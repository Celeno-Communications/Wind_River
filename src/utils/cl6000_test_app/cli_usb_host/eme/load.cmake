# Included by top-level CMakeLists.txt to do settings, find packages, visit all
# modules selected by usecase and recursively their prerequisites etc.

# use for debug only:
#message(STATUS "Included: eme/load.cmake")

set(CPACK_PACKAGE_NAME UsbStack)
set(CPACK_PACKAGE_VENDOR "emsys Embedded Systems GmbH")
set(CPACK_PACKAGE_VERSION_MAJOR 17)
set(CPACK_PACKAGE_VERSION_MINOR 2)
set(CPACK_PACKAGE_VERSION_PATCH 0)
set(CPACK_GENERATOR "")
set(CPACK_SOURCE_GENERATOR "TBZ2")
set(CPACK_SOURCE_STRIP_FILES "ON") # ??
set(CMAKE_ECLIPSE_VERSION "4.2 Juno")
include(CPack)
include(CTest)

include(CMakePrintHelpers)

#init used global variables
SET(TRACE  "" CACHE INTERNAL "filter for eme tracing, allowed: modules dependencies")
SET(_dependency_graph  "" CACHE INTERNAL "store module dependencies for later use")
SET(WATCH "" CACHE INTERNAL "track changes of this variable")
SET(FILES_FOR_LATE_INCLUSION "" CACHE INTERNAL "")

# use our find scripts before default find scripts
set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/eme/cmake/Modules")

# find(UnixCommands) # tar
find_package(Cygwin) # CYGWIN_FOUND, CYGWIN_INSTALL_PATH
if (CYGWIN)
  set(CMAKE_PREFIX_PATH "c:/cygwin/usr;c:/cygwin") # windows native cmake needs these prefixes
endif()

if (NOT ( "${WATCH}" STREQUAL ""))
    variable_watch(${WATCH})
endif()
#find_package(Boost)
#find_package(CxxTest)
#find_package(GTest)
#find_package(Subversion)
#find_package(Git)
find_package(Python COMPONENTS Interpreter)

# testing targets
enable_testing()
add_custom_target(check_apps)

set(CHECK_TARGET_PROCESSES "20" CACHE STRING "Number of parallel processes when executing unit tests through 'check' target")

if (WIN32)
  set(CHECK_TARGET_BASE_COMMAND
    ${CMAKE_CTEST_COMMAND};
    --test-action;test; # generates XML report
    --parallel;${CHECK_TARGET_PROCESSES}; # alias for -j ...
    --output-on-failure; # show test executable's output only if it exited with error (!= 0)
    --no-label-summary; # less verbose summary
    --no-compress-output # do not compress/encode test output with gzip/base64 in XML reports
  )
else()
set(CHECK_TARGET_BASE_COMMAND
  EMSYS_CHECK=1; # dummy argument (cmake quotes the first argument, which would mess our options up)
  ASAN_OPTIONS=suppressions='${CMAKE_SOURCE_DIR}/suppressions_asan.txt':$$ASAN_OPTIONS;
  LSAN_OPTIONS=suppressions='${CMAKE_SOURCE_DIR}/suppressions_lsan.txt':print_suppressions=0:allocator_may_return_null=1:$$LSAN_OPTIONS;
  TSAN_OPTIONS=suppressions='${CMAKE_SOURCE_DIR}/suppressions_tsan.txt':second_deadlock_stack=1:allocator_may_return_null=1:$$TSAN_OPTIONS;
  UBSAN_OPTIONS=suppressions='${CMAKE_SOURCE_DIR}/suppressions_ubsan.txt':print_stacktrace=1:$$UBSAN_OPTIONS;
  MSAN_OPTIONS=poison_in_dtor=1:$$MSAN_OPTIONS;
  ${CMAKE_CTEST_COMMAND};
  --test-action;test; # generates XML report
  --parallel;${CHECK_TARGET_PROCESSES}; # alias for -j ...
  --output-on-failure; # show test executable's output only if it exited with error (!= 0)
  --no-label-summary; # less verbose summary
  --no-compress-output # do not compress/encode test output with gzip/base64 in XML reports
)
endif()

add_custom_target(apps)

# we would prefer to use VERBATIM here, but we need to pass environment variables, so we depend
# on a shell instance
add_custom_target(check       COMMAND ${CHECK_TARGET_BASE_COMMAND};-LE;"^XFAIL$$")
add_custom_target(check_xfail COMMAND ${CHECK_TARGET_BASE_COMMAND};-L;"^XFAIL$$")
add_custom_target(check_all   COMMAND ${CHECK_TARGET_BASE_COMMAND})
add_dependencies(check check_apps)
add_dependencies(check_all check_apps)

# target for all usecase libs
add_custom_target(all_libs)

# target for module dependency graphic generation
add_custom_target(dependency-graph.svg
                  COMMAND dot -T svg dependency-graph.dot -o dependency-graph.svg
)

# This is still ignored by MSVC Generator.
# http://www.cmake.org/Bug/view.php?id=5811
if (CMAKE_CONFIGURATION_TYPES) # I.e.: real IDE
  list(APPEND CMAKE_CONFIGURATION_TYPES Coverage)
  list(REMOVE_DUPLICATES CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_CONFIGURATION_TYPES "${CMAKE_CONFIGURATION_TYPES}" CACHE STRING
      "Semicolon separated list of supported configuration types." FORCE)
endif()

# include usecase files
if(USECASE)
  set(USECASE ${USECASE} CACHE STRING "selected usecase")
  include(${USECASE} RESULT_VARIABLE result)
  if(result)
    message(STATUS "Usecase file: ${USECASE}")
  endif()
endif()

# include configure headers generated by cmake
include_directories(${PROJECT_BINARY_DIR})
add_definitions(-DHAVE_CMAKE_CONFIGURE)

# include all */eme/options.cmake
file(GLOB opt_files RELATIVE ${PROJECT_SOURCE_DIR} "*/eme/options.cmake")
list(SORT opt_files)
foreach(o ${opt_files})
  include(${o})
endforeach()

#if CMAKE_TOOLCHAIN_FILE was not set to one of our toolchain file EME_TOOLSET_PATH should not be set
include(${EME_TOOLSET_PATH}/toolconfig.cmake OPTIONAL)

# include */eme/module.cmake of all selected modules
# and all their prerequisites
# and append */inc to list of include pathes
set(ALL_MODULES_LIST CACHE INTERNAL "")
eme_trace("selected modules:" "modules")
eme_print_list(MODULES "modules")
set(ALL_MODULES) # list of all usecase modules
while(MODULES)
  list(GET MODULES 0 module)
  list(FIND ALL_MODULES ${module} index)
  if(index EQUAL -1)
    include(${module}/eme/module.cmake)
    list(APPEND ALL_MODULES ${module})
  endif()
  list(REMOVE_AT MODULES 0)
endwhile()

# write all modules to cache
set(ALL_MODULES_LIST ${ALL_MODULES} CACHE INTERNAL "")

# add subdirectories of all visited modules
eme_trace("visiting modules:" "modules")
eme_print_list(ALL_MODULES "modules")
set(ALL_TESTS CACHE INTERNAL "")
set(ALL_TEST_SOURCES CACHE INTERNAL "")
set(ALL_LIB_SOURCES CACHE INTERNAL "")
set(ALL_HEADERS CACHE INTERNAL "")
foreach(m ${ALL_MODULES})
  add_subdirectory(${m})
  file(GLOB_RECURSE module_headers ${m}/inc/**.h*)
  list(APPEND ALL_HEADERS ${module_headers})
endforeach()

# Variable MODERN_ALL_LIBRARIES
# Use case:
#  source delivery targets
# visual studio project generator
# lint
include(EmeAllLibraries)
eme_get_targets_from_directory(targets "${PROJECT_SOURCE_DIR}")
set(MODERN_ALL_LIBRARIES)
foreach(tgt ${targets})
    get_target_property(target_type ${tgt} TYPE)
    if(target_type MATCHES "STATIC_LIBRARY")
      list(APPEND MODERN_ALL_LIBRARIES ${tgt})
    endif()
endforeach()


if(CMAKE_CXX_COMPILER)
  #add dummy target with all headers to see them with QtCreator
  add_library(dummy_headers EXCLUDE_FROM_ALL ${ALL_HEADERS} eme/empty.cpp)
endif()

# Include files registered for late inclusion. This optional files
# may define additional targets wich need to be declared after all modules
# CMakeLists.txt have been parsed.
foreach(f ${FILES_FOR_LATE_INCLUSION})
  include(${f})
endforeach()



#create lint target
if(EME_EXECUTE_LINT)
  include(EmeAllLibraries)
  include("${PROJECT_SOURCE_DIR}/eme/toolset/lint/toolconfig.cmake")
  include(EmeAllLibraries)
  eme_get_target_includes_from_directory(ALL_INCLUDE_DIRS "${PROJECT_SOURCE_DIR}")
  #get_property(LINT_INCLUDE_DIRS TARGET emcpp_lint PROPERTY INCLUDE_DIRECTORIES)  
  #message(status "#### LINT ALL  [${ALL_INCLUDE_DIRS}]")
  #message(status "#### LINT lint [${LINT_INCLUDE_DIRS}]")
  eme_add_lint_includes("${ALL_INCLUDE_DIRS}")
  eme_add_lint_sources()
endif()

# Write module dependencies
STRING(REGEX REPLACE ";" "\n" _content "${_dependency_graph}")
set(_content "digraph{\n${_content}}")
file(GENERATE OUTPUT "${PROJECT_SOURCE_DIR}/dependency-graph.dot"
              CONTENT "${_content}"
)

#foreach(s ${ALL_LIB_SOURCES})
#  message("<ClCompile Include=\"..\\..\\" ${s} "\" />")
#endforeach()
