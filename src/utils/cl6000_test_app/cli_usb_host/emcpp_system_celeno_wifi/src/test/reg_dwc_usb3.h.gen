// clang-format off

#ifndef __REG_DWC_usb3_H_
#define __REG_DWC_usb3_H_

#include <stdint.h>
#include "_reg_dwc_usb3.h.gen"
#if 0 // emsys: only available on target
#include "compiler.h"
#include "arch.h"
#include "reg_access.h"
#endif


#define DBG_FILEID __REG_DWC_usb3__H__FILEID__

#define REG_DWC_usb3_COUNT 50

/**
* Block definition

* Block name            DWC_usb3_block_gbl
* Block description     USB 3.0 Global Register Block
* Block baseAddress     0xc100
* Block Range           0x600
* Block width           32
* Number of registers   43
*/


/**
* \@brief GSBUSCFG0 register definition
* Global SoC Bus Configuration Register 0

This register configures system bus DMA options for the master bus, which may be configured as AHB, AXI, or Native. Options include burst length and cache type (bufferable/posted, cacheable/snoop, and so on). The application can program this register upon power-on, or a change in mode of operation after the DMA engine is halted.

xHCI Register Power-On Value:

If you are using a standard xHCI host driver, make sure to set the register's power-on value during coreConsultant configuration (DWC_USB3_GSBUSCFG0_INIT parameter) because the standard xHCI driver does not access this register.

For more details on this register, refer to the following sections:
 - "Usage of Global SoC Bus Configuration Register 0 (GSBUSCFG0)" section in the Programming Guide
 - "System Bus Interface" section in the Databook
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          INCRBRSTENA                             0x0
*    1          INCR4BRSTENA                            0x1
*    2          INCR8BRSTENA                            0x0
*    3          INCR16BRSTENA                           0x0
*    4          INCR32BRSTENA                           0x0
*    5          INCR64BRSTENA                           0x0
*    6          INCR128BRSTENA                          0x0
*    7          INCR256BRSTENA                          0x0
*    08:09       reserved_9_8                            0x0
*    10         DESBIGEND                               0x0
*    11         DATBIGEND                               0x0
*    12:15      reserved_15_12                          0x0
*    16:19      DESWRREQINFO                            0x0
*    20:23      DATWRREQINFO                            0x0
*    24:27      DESRDREQINFO                            0x0
*    28:31      DATRDREQINFO                            0x0
* </pre>
*/
#define DWC_usb3_GSBUSCFG0_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C100)
#define DWC_usb3_GSBUSCFG0_OFFSET      0x0000C100
#define DWC_usb3_GSBUSCFG0_INDEX       0x3040
__INLINE uint32_t dwc_usb3_gsbuscfg0_get(void)
{
       return REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
}

__INLINE void dwc_usb3_gsbuscfg0_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR,value);
}
// field definitions
#define DWC_usb3_GSBUSCFG0_INCRBRSTENA_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_GSBUSCFG0_INCRBRSTENA_POS     0
#define DWC_usb3_GSBUSCFG0_INCR4BRSTENA_BIT     ((uint32_t)0x00000002)
#define DWC_usb3_GSBUSCFG0_INCR4BRSTENA_POS     1
#define DWC_usb3_GSBUSCFG0_INCR8BRSTENA_BIT     ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG0_INCR8BRSTENA_POS     2
#define DWC_usb3_GSBUSCFG0_INCR16BRSTENA_BIT     ((uint32_t)0x00000008)
#define DWC_usb3_GSBUSCFG0_INCR16BRSTENA_POS     3
#define DWC_usb3_GSBUSCFG0_INCR32BRSTENA_BIT     ((uint32_t)0x00000010)
#define DWC_usb3_GSBUSCFG0_INCR32BRSTENA_POS     4
#define DWC_usb3_GSBUSCFG0_INCR64BRSTENA_BIT     ((uint32_t)0x00000020)
#define DWC_usb3_GSBUSCFG0_INCR64BRSTENA_POS     5
#define DWC_usb3_GSBUSCFG0_INCR128BRSTENA_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_GSBUSCFG0_INCR128BRSTENA_POS     6
#define DWC_usb3_GSBUSCFG0_INCR256BRSTENA_BIT     ((uint32_t)0x00000080)
#define DWC_usb3_GSBUSCFG0_INCR256BRSTENA_POS     7
#define DWC_usb3_GSBUSCFG0_reserved_9_8_MASK    ((uint32_t)0x00000300)
#define DWC_usb3_GSBUSCFG0_reserved_9_8_LSB     8
#define DWC_usb3_GSBUSCFG0_reserved_9_8_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GSBUSCFG0_DESBIGEND_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GSBUSCFG0_DESBIGEND_POS     10
#define DWC_usb3_GSBUSCFG0_DATBIGEND_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GSBUSCFG0_DATBIGEND_POS     11
#define DWC_usb3_GSBUSCFG0_reserved_15_12_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GSBUSCFG0_reserved_15_12_LSB     12
#define DWC_usb3_GSBUSCFG0_reserved_15_12_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG0_DESWRREQINFO_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GSBUSCFG0_DESWRREQINFO_LSB     16
#define DWC_usb3_GSBUSCFG0_DESWRREQINFO_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG0_DATWRREQINFO_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GSBUSCFG0_DATWRREQINFO_LSB     20
#define DWC_usb3_GSBUSCFG0_DATWRREQINFO_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG0_DESRDREQINFO_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GSBUSCFG0_DESRDREQINFO_LSB     24
#define DWC_usb3_GSBUSCFG0_DESRDREQINFO_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG0_DATRDREQINFO_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GSBUSCFG0_DATRDREQINFO_LSB     28
#define DWC_usb3_GSBUSCFG0_DATRDREQINFO_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GSBUSCFG0_INCRBRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR4BRSTENA_RST     0x1
#define DWC_usb3_GSBUSCFG0_INCR8BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR16BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR32BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR64BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR128BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_INCR256BRSTENA_RST     0x0
#define DWC_usb3_GSBUSCFG0_reserved_9_8_RST     0x0
#define DWC_usb3_GSBUSCFG0_DESBIGEND_RST     0x0
#define DWC_usb3_GSBUSCFG0_DATBIGEND_RST     0x0
#define DWC_usb3_GSBUSCFG0_reserved_15_12_RST     0x0
#define DWC_usb3_GSBUSCFG0_DESWRREQINFO_RST     0x0
#define DWC_usb3_GSBUSCFG0_DATWRREQINFO_RST     0x0
#define DWC_usb3_GSBUSCFG0_DESRDREQINFO_RST     0x0
#define DWC_usb3_GSBUSCFG0_DATRDREQINFO_RST     0x0

__INLINE void dwc_usb3_gsbuscfg0_pack(uint8_t incrbrstena,uint8_t incr4brstena,uint8_t incr8brstena,uint8_t incr16brstena,uint8_t incr32brstena,uint8_t incr64brstena,uint8_t incr128brstena,uint8_t incr256brstena,uint8_t reserved98,uint8_t desbigend,uint8_t datbigend,uint8_t reserved1512,uint8_t deswrreqinfo,uint8_t datwrreqinfo,uint8_t desrdreqinfo,uint8_t datrdreqinfo)
{
       ASSERT_ERR((((uint32_t)incrbrstena << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)incr4brstena << 1) & ~((uint32_t)0x00000002)) == 0);
       ASSERT_ERR((((uint32_t)incr8brstena << 2) & ~((uint32_t)0x00000004)) == 0);
       ASSERT_ERR((((uint32_t)incr16brstena << 3) & ~((uint32_t)0x00000008)) == 0);
       ASSERT_ERR((((uint32_t)incr32brstena << 4) & ~((uint32_t)0x00000010)) == 0);
       ASSERT_ERR((((uint32_t)incr64brstena << 5) & ~((uint32_t)0x00000020)) == 0);
       ASSERT_ERR((((uint32_t)incr128brstena << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)incr256brstena << 7) & ~((uint32_t)0x00000080)) == 0);
       ASSERT_ERR((((uint32_t)reserved98 << 8) & ~((uint32_t)0x00000300)) == 0);
       ASSERT_ERR((((uint32_t)desbigend << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)datbigend << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)reserved1512 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)deswrreqinfo << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)datwrreqinfo << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)desrdreqinfo << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)datrdreqinfo << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, ((uint32_t)incrbrstena << 0) |((uint32_t)incr4brstena << 1) |((uint32_t)incr8brstena << 2) |((uint32_t)incr16brstena << 3) |((uint32_t)incr32brstena << 4) |((uint32_t)incr64brstena << 5) |((uint32_t)incr128brstena << 6) |((uint32_t)incr256brstena << 7) |((uint32_t)reserved98 << 8) |((uint32_t)desbigend << 10) |((uint32_t)datbigend << 11) |((uint32_t)reserved1512 << 12) |((uint32_t)deswrreqinfo << 16) |((uint32_t)datwrreqinfo << 20) |((uint32_t)desrdreqinfo << 24) |((uint32_t)datrdreqinfo << 28));
}

__INLINE void dwc_usb3_gsbuscfg0_unpack(uint8_t* incrbrstena,uint8_t* incr4brstena,uint8_t* incr8brstena,uint8_t* incr16brstena,uint8_t* incr32brstena,uint8_t* incr64brstena,uint8_t* incr128brstena,uint8_t* incr256brstena,uint8_t* reserved98,uint8_t* desbigend,uint8_t* datbigend,uint8_t* reserved1512,uint8_t* deswrreqinfo,uint8_t* datwrreqinfo,uint8_t* desrdreqinfo,uint8_t* datrdreqinfo)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);

       *incrbrstena = (localVal & ((uint32_t)0x00000001)) >> 0;
       *incr4brstena = (localVal & ((uint32_t)0x00000002)) >> 1;
       *incr8brstena = (localVal & ((uint32_t)0x00000004)) >> 2;
       *incr16brstena = (localVal & ((uint32_t)0x00000008)) >> 3;
       *incr32brstena = (localVal & ((uint32_t)0x00000010)) >> 4;
       *incr64brstena = (localVal & ((uint32_t)0x00000020)) >> 5;
       *incr128brstena = (localVal & ((uint32_t)0x00000040)) >> 6;
       *incr256brstena = (localVal & ((uint32_t)0x00000080)) >> 7;
       *reserved98 = (localVal & ((uint32_t)0x00000300)) >> 8;
       *desbigend = (localVal & ((uint32_t)0x00000400)) >> 10;
       *datbigend = (localVal & ((uint32_t)0x00000800)) >> 11;
       *reserved1512 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *deswrreqinfo = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *datwrreqinfo = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *desrdreqinfo = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *datrdreqinfo = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incrbrstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void  dwc_usb3_gsbuscfg0_incrbrstena_setf(uint8_t  incrbrstena)
{
       ASSERT_ERR((((uint32_t)incrbrstena << 0) & ~((uint32_t)0x00000001)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)incrbrstena <<0));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr4brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr4brstena_setf(uint8_t  incr4brstena)
{
       ASSERT_ERR((((uint32_t)incr4brstena << 1) & ~((uint32_t)0x00000002)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)incr4brstena <<1));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr8brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr8brstena_setf(uint8_t  incr8brstena)
{
       ASSERT_ERR((((uint32_t)incr8brstena << 2) & ~((uint32_t)0x00000004)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)incr8brstena <<2));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr16brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr16brstena_setf(uint8_t  incr16brstena)
{
       ASSERT_ERR((((uint32_t)incr16brstena << 3) & ~((uint32_t)0x00000008)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)incr16brstena <<3));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr32brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr32brstena_setf(uint8_t  incr32brstena)
{
       ASSERT_ERR((((uint32_t)incr32brstena << 4) & ~((uint32_t)0x00000010)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)incr32brstena <<4));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr64brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr64brstena_setf(uint8_t  incr64brstena)
{
       ASSERT_ERR((((uint32_t)incr64brstena << 5) & ~((uint32_t)0x00000020)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)incr64brstena <<5));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr128brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr128brstena_setf(uint8_t  incr128brstena)
{
       ASSERT_ERR((((uint32_t)incr128brstena << 6) & ~((uint32_t)0x00000040)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)incr128brstena <<6));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_incr256brstena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void  dwc_usb3_gsbuscfg0_incr256brstena_setf(uint8_t  incr256brstena)
{
       ASSERT_ERR((((uint32_t)incr256brstena << 7) & ~((uint32_t)0x00000080)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)incr256brstena <<7));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_reserved_9_8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000300)) >> 8);
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_desbigend_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void  dwc_usb3_gsbuscfg0_desbigend_setf(uint8_t  desbigend)
{
       ASSERT_ERR((((uint32_t)desbigend << 10) & ~((uint32_t)0x00000400)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)desbigend <<10));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_datbigend_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void  dwc_usb3_gsbuscfg0_datbigend_setf(uint8_t  datbigend)
{
       ASSERT_ERR((((uint32_t)datbigend << 11) & ~((uint32_t)0x00000800)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)datbigend <<11));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_reserved_15_12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_deswrreqinfo_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gsbuscfg0_deswrreqinfo_setf(uint8_t  deswrreqinfo)
{
       ASSERT_ERR((((uint32_t)deswrreqinfo << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)deswrreqinfo <<16));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_datwrreqinfo_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gsbuscfg0_datwrreqinfo_setf(uint8_t  datwrreqinfo)
{
       ASSERT_ERR((((uint32_t)datwrreqinfo << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)datwrreqinfo <<20));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_desrdreqinfo_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gsbuscfg0_desrdreqinfo_setf(uint8_t  desrdreqinfo)
{
       ASSERT_ERR((((uint32_t)desrdreqinfo << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)desrdreqinfo <<24));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg0_datrdreqinfo_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void  dwc_usb3_gsbuscfg0_datrdreqinfo_setf(uint8_t  datrdreqinfo)
{
       ASSERT_ERR((((uint32_t)datrdreqinfo << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG0_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG0_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)datrdreqinfo <<28));
}
/**
* \@brief GSBUSCFG1 register definition
* Global SoC Bus Configuration Register 1

xHCI Register Power-On Value:

If you are using a standard xHCI host driver, make sure to set the register's power-on value during coreConsultant configuration (DWC_USB3_GSBUSCFG1_INIT parameter) because the standard xHCI driver does not access this register.

For more details on this register, refer to "System Bus Interface" section in the Databook.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:07       reserved_7_0                            0x0
*    08:11      PipeTransLimit                          0x7
*    12         EN1KPAGE                                0x0
*    13:31      reserved_31_13                          0x0
* </pre>
*/
#define DWC_usb3_GSBUSCFG1_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C104)
#define DWC_usb3_GSBUSCFG1_OFFSET      0x0000C104
#define DWC_usb3_GSBUSCFG1_INDEX       0x3041
__INLINE uint32_t dwc_usb3_gsbuscfg1_get(void)
{
       return REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);
}

__INLINE void dwc_usb3_gsbuscfg1_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GSBUSCFG1_ADDR,value);
}
// field definitions
#define DWC_usb3_GSBUSCFG1_reserved_7_0_MASK    ((uint32_t)0x000000FF)
#define DWC_usb3_GSBUSCFG1_reserved_7_0_LSB     0
#define DWC_usb3_GSBUSCFG1_reserved_7_0_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GSBUSCFG1_PipeTransLimit_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GSBUSCFG1_PipeTransLimit_LSB     8
#define DWC_usb3_GSBUSCFG1_PipeTransLimit_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GSBUSCFG1_EN1KPAGE_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GSBUSCFG1_EN1KPAGE_POS     12
#define DWC_usb3_GSBUSCFG1_reserved_31_13_MASK    ((uint32_t)0xFFFFE000)
#define DWC_usb3_GSBUSCFG1_reserved_31_13_LSB     13
#define DWC_usb3_GSBUSCFG1_reserved_31_13_WIDTH   ((uint32_t)0x00000013)

#define DWC_usb3_GSBUSCFG1_reserved_7_0_RST     0x0
#define DWC_usb3_GSBUSCFG1_PipeTransLimit_RST     0x7
#define DWC_usb3_GSBUSCFG1_EN1KPAGE_RST     0x0
#define DWC_usb3_GSBUSCFG1_reserved_31_13_RST     0x0

__INLINE void dwc_usb3_gsbuscfg1_pack(uint8_t reserved70,uint8_t pipetranslimit,uint8_t en1kpage,uint32_t reserved3113)
{
       ASSERT_ERR((((uint32_t)reserved70 << 0) & ~((uint32_t)0x000000FF)) == 0);
       ASSERT_ERR((((uint32_t)pipetranslimit << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)en1kpage << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3113 << 13) & ~((uint32_t)0xFFFFE000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG1_ADDR, ((uint32_t)reserved70 << 0) |((uint32_t)pipetranslimit << 8) |((uint32_t)en1kpage << 12) |((uint32_t)reserved3113 << 13));
}

__INLINE void dwc_usb3_gsbuscfg1_unpack(uint8_t* reserved70,uint8_t* pipetranslimit,uint8_t* en1kpage,uint32_t* reserved3113)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);

       *reserved70 = (localVal & ((uint32_t)0x000000FF)) >> 0;
       *pipetranslimit = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *en1kpage = (localVal & ((uint32_t)0x00001000)) >> 12;
       *reserved3113 = (localVal & ((uint32_t)0xFFFFE000)) >> 13;
}
__INLINE uint8_t  dwc_usb3_gsbuscfg1_reserved_7_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);
       return ((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gsbuscfg1_pipetranslimit_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gsbuscfg1_pipetranslimit_setf(uint8_t  pipetranslimit)
{
       ASSERT_ERR((((uint32_t)pipetranslimit << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG1_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)pipetranslimit <<8));
}
__INLINE uint8_t  dwc_usb3_gsbuscfg1_en1kpage_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void  dwc_usb3_gsbuscfg1_en1kpage_setf(uint8_t  en1kpage)
{
       ASSERT_ERR((((uint32_t)en1kpage << 12) & ~((uint32_t)0x00001000)) == 0);
       REG_PL_WR(DWC_usb3_GSBUSCFG1_ADDR, (REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)en1kpage <<12));
}
__INLINE uint32_t  dwc_usb3_gsbuscfg1_reserved_31_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSBUSCFG1_ADDR);
       return ((localVal & ((uint32_t)0xFFFFE000)) >> 13);
}
/**
* \@brief GTXTHRCFG register definition
* Global Tx Threshold Control Register

For more information on
 - Using this register, refer to "Packet Threshold and Burst Features for High Latency Systems" section in the Databook.
 - Selecting values for the fields of this register, see the "TX/RX Data FIFO Sizes and TX/RX Threshold Control Register Settings" section in the User Guide.
Note:
 - GTXTHRCFG register is not applicable for Debug Target.
 - GTXTHRCFG register is not applicable in USB 2.0-only mode.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:10      reserved_10_0                           0x0
*    11:13      reserved_13_11                          0x0
*    14         reserved_14                             0x0
*    15         reserved_15                             0x0
*    16:23      UsbMaxTxBurstSize                       0x0
*    24:27      UsbTxPktCnt                             0x0
*    28         reserved_28                             0x0
*    29         UsbTxPktCntSel                          0x0
*    30         reserved_30                             0x0
*    31         reserved_31                             0x0
* </pre>
*/
#define DWC_usb3_GTXTHRCFG_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C108)
#define DWC_usb3_GTXTHRCFG_OFFSET      0x0000C108
#define DWC_usb3_GTXTHRCFG_INDEX       0x3042
__INLINE uint32_t dwc_usb3_gtxthrcfg_get(void)
{
       return REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
}

__INLINE void dwc_usb3_gtxthrcfg_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GTXTHRCFG_ADDR,value);
}
// field definitions
#define DWC_usb3_GTXTHRCFG_reserved_10_0_MASK    ((uint32_t)0x000007FF)
#define DWC_usb3_GTXTHRCFG_reserved_10_0_LSB     0
#define DWC_usb3_GTXTHRCFG_reserved_10_0_WIDTH   ((uint32_t)0x0000000B)
#define DWC_usb3_GTXTHRCFG_reserved_13_11_MASK    ((uint32_t)0x00003800)
#define DWC_usb3_GTXTHRCFG_reserved_13_11_LSB     11
#define DWC_usb3_GTXTHRCFG_reserved_13_11_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GTXTHRCFG_reserved_14_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_GTXTHRCFG_reserved_14_POS     14
#define DWC_usb3_GTXTHRCFG_reserved_15_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GTXTHRCFG_reserved_15_POS     15
#define DWC_usb3_GTXTHRCFG_UsbMaxTxBurstSize_MASK    ((uint32_t)0x00FF0000)
#define DWC_usb3_GTXTHRCFG_UsbMaxTxBurstSize_LSB     16
#define DWC_usb3_GTXTHRCFG_UsbMaxTxBurstSize_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GTXTHRCFG_UsbTxPktCnt_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GTXTHRCFG_UsbTxPktCnt_LSB     24
#define DWC_usb3_GTXTHRCFG_UsbTxPktCnt_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GTXTHRCFG_reserved_28_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_GTXTHRCFG_reserved_28_POS     28
#define DWC_usb3_GTXTHRCFG_UsbTxPktCntSel_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_GTXTHRCFG_UsbTxPktCntSel_POS     29
#define DWC_usb3_GTXTHRCFG_reserved_30_BIT     ((uint32_t)0x40000000)
#define DWC_usb3_GTXTHRCFG_reserved_30_POS     30
#define DWC_usb3_GTXTHRCFG_reserved_31_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GTXTHRCFG_reserved_31_POS     31

#define DWC_usb3_GTXTHRCFG_reserved_10_0_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_13_11_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_14_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_15_RST     0x0
#define DWC_usb3_GTXTHRCFG_UsbMaxTxBurstSize_RST     0x0
#define DWC_usb3_GTXTHRCFG_UsbTxPktCnt_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_28_RST     0x0
#define DWC_usb3_GTXTHRCFG_UsbTxPktCntSel_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_30_RST     0x0
#define DWC_usb3_GTXTHRCFG_reserved_31_RST     0x0

__INLINE void dwc_usb3_gtxthrcfg_pack(uint16_t reserved100,uint8_t reserved1311,uint8_t reserved14,uint8_t reserved15,uint8_t usbmaxtxburstsize,uint8_t usbtxpktcnt,uint8_t reserved28,uint8_t usbtxpktcntsel,uint8_t reserved30,uint8_t reserved31)
{
       ASSERT_ERR((((uint32_t)reserved100 << 0) & ~((uint32_t)0x000007FF)) == 0);
       ASSERT_ERR((((uint32_t)reserved1311 << 11) & ~((uint32_t)0x00003800)) == 0);
       ASSERT_ERR((((uint32_t)reserved14 << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)reserved15 << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)usbmaxtxburstsize << 16) & ~((uint32_t)0x00FF0000)) == 0);
       ASSERT_ERR((((uint32_t)usbtxpktcnt << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved28 << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)usbtxpktcntsel << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved30 << 30) & ~((uint32_t)0x40000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved31 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GTXTHRCFG_ADDR, ((uint32_t)reserved100 << 0) |((uint32_t)reserved1311 << 11) |((uint32_t)reserved14 << 14) |((uint32_t)reserved15 << 15) |((uint32_t)usbmaxtxburstsize << 16) |((uint32_t)usbtxpktcnt << 24) |((uint32_t)reserved28 << 28) |((uint32_t)usbtxpktcntsel << 29) |((uint32_t)reserved30 << 30) |((uint32_t)reserved31 << 31));
}

__INLINE void dwc_usb3_gtxthrcfg_unpack(uint16_t* reserved100,uint8_t* reserved1311,uint8_t* reserved14,uint8_t* reserved15,uint8_t* usbmaxtxburstsize,uint8_t* usbtxpktcnt,uint8_t* reserved28,uint8_t* usbtxpktcntsel,uint8_t* reserved30,uint8_t* reserved31)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);

       *reserved100 = (localVal & ((uint32_t)0x000007FF)) >> 0;
       *reserved1311 = (localVal & ((uint32_t)0x00003800)) >> 11;
       *reserved14 = (localVal & ((uint32_t)0x00004000)) >> 14;
       *reserved15 = (localVal & ((uint32_t)0x00008000)) >> 15;
       *usbmaxtxburstsize = (localVal & ((uint32_t)0x00FF0000)) >> 16;
       *usbtxpktcnt = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *reserved28 = (localVal & ((uint32_t)0x10000000)) >> 28;
       *usbtxpktcntsel = (localVal & ((uint32_t)0x20000000)) >> 29;
       *reserved30 = (localVal & ((uint32_t)0x40000000)) >> 30;
       *reserved31 = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint16_t  dwc_usb3_gtxthrcfg_reserved_10_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x000007FF)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_13_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00003800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_14_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_usbmaxtxburstsize_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void  dwc_usb3_gtxthrcfg_usbmaxtxburstsize_setf(uint8_t  usbmaxtxburstsize)
{
       ASSERT_ERR((((uint32_t)usbmaxtxburstsize << 16) & ~((uint32_t)0x00FF0000)) == 0);
       REG_PL_WR(DWC_usb3_GTXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)usbmaxtxburstsize <<16));
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_usbtxpktcnt_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gtxthrcfg_usbtxpktcnt_setf(uint8_t  usbtxpktcnt)
{
       ASSERT_ERR((((uint32_t)usbtxpktcnt << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GTXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)usbtxpktcnt <<24));
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_usbtxpktcntsel_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void  dwc_usb3_gtxthrcfg_usbtxpktcntsel_setf(uint8_t  usbtxpktcntsel)
{
       ASSERT_ERR((((uint32_t)usbtxpktcntsel << 29) & ~((uint32_t)0x20000000)) == 0);
       REG_PL_WR(DWC_usb3_GTXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)usbtxpktcntsel <<29));
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_30_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE uint8_t  dwc_usb3_gtxthrcfg_reserved_31_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
/**
* \@brief GRXTHRCFG register definition
* Global Rx Threshold Control Register

In a normal case, a Tx burst starts as soon as one packet is prefetched; an Rx burst starts as soon as 1-packet space is available. This works well as long as the system bus is faster than the USB 3.0 bus (a 1024-bytes packet takes ~2.2 microseconds on the USB bus in SS mode). 

If the system bus latency is larger than 2.2 microseconds to access a 1024-byte packet, then starting a burst on 1-packet condition leads to an early abort of the burst causing unnecessary performance reduction.  

To avoid underrun and overrun during the burst, in a high-latency bus system (like USB), threshold and burst size control is provided through GTXTHRCFG and GRXTHRCFG registers. Bit [29] of the GTXTHRCFG and GRXTHRCFG registers enables this feature.

For more information on
 - Using this register, refer to "Packet Threshold and Burst Features for High Latency Systems" section in the Databook.
 - Selecting values for the fields of this register, see the "TX/RX Data FIFO Sizes and TX/RX Threshold Control Register Settings" section in the User Guide.
Note:
 - GRXTHRCFG register is not applicable for Debug Target.
 - There is an issue when ACK TP with NumP=0 followed by ACK TP with NumP=1 without ERDY TP sent by the device controller during a burst bulk OUT transfer. This may cause third-party USB 3.0 host controllers to keep waiting for the ERDY TP.
The USB 3.0 specification states that "When an endpoint is not in a flow control condition, it shall not send an ERDY TP unless the endpoint is a Bulk endpoint that supports streams." In this case, after the device sent the ACK TP (nump=1), the endpoint was not in the flow control, so it did not send an ERDY.
The device would have sent ERDY if the next OUT packet was not received. When the next OUT packet was received, at that time there was enough buffer space to accept it, so the device accepted the packet by informing host that it is not no longer in the flow control. The Host should wait for the responses for all the OUT packets to return and then decide if the endpoint is still in flow control or not.
The USB 3.1 specification supersedes all the USB 3.0 specification. The errata states that "If the host continues, or resumes, transactions to an endpoint, the endpoint shall re-evaluate its flow control state and respond appropriately." However, there are no ECNs on the USB 3.0 for this issue.
To work around this issue, the Global Rx Threshold mode must be disable by setting GRXTHRCFG.UsbRxPktCntSel=0. Instead, software can program the DCFG.NUMP mode (where fixed NUMP is transmitted always) instead of the RX threshold based nump mode to prevent the device from sending ACK TP with NumP=0. The NUMP in the ACK TP is the minimum value of (DCFG.NUMP, bMaxBurstSize) for each endpoint.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:12      ResvISOCOUTSpc                          0x0
*    13:14      reserved_14_13                          0x0
*    15         reserved_15                             0x0
*    16:18      reserved_18_16                          0x0
*    19:23      UsbMaxRxBurstSize                       0x0
*    24:27      UsbRxPktCnt                             0x0
*    28         reserved_28                             0x0
*    29         UsbRxPktCntSel                          0x0
*    30:31      reserved_31_30                          0x0
* </pre>
*/
#define DWC_usb3_GRXTHRCFG_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C10C)
#define DWC_usb3_GRXTHRCFG_OFFSET      0x0000C10C
#define DWC_usb3_GRXTHRCFG_INDEX       0x3043
__INLINE uint32_t dwc_usb3_grxthrcfg_get(void)
{
       return REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
}

__INLINE void dwc_usb3_grxthrcfg_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR,value);
}
// field definitions
#define DWC_usb3_GRXTHRCFG_ResvISOCOUTSpc_MASK    ((uint32_t)0x00001FFF)
#define DWC_usb3_GRXTHRCFG_ResvISOCOUTSpc_LSB     0
#define DWC_usb3_GRXTHRCFG_ResvISOCOUTSpc_WIDTH   ((uint32_t)0x0000000D)
#define DWC_usb3_GRXTHRCFG_reserved_14_13_MASK    ((uint32_t)0x00006000)
#define DWC_usb3_GRXTHRCFG_reserved_14_13_LSB     13
#define DWC_usb3_GRXTHRCFG_reserved_14_13_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GRXTHRCFG_reserved_15_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GRXTHRCFG_reserved_15_POS     15
#define DWC_usb3_GRXTHRCFG_reserved_18_16_MASK    ((uint32_t)0x00070000)
#define DWC_usb3_GRXTHRCFG_reserved_18_16_LSB     16
#define DWC_usb3_GRXTHRCFG_reserved_18_16_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GRXTHRCFG_UsbMaxRxBurstSize_MASK    ((uint32_t)0x00F80000)
#define DWC_usb3_GRXTHRCFG_UsbMaxRxBurstSize_LSB     19
#define DWC_usb3_GRXTHRCFG_UsbMaxRxBurstSize_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_GRXTHRCFG_UsbRxPktCnt_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GRXTHRCFG_UsbRxPktCnt_LSB     24
#define DWC_usb3_GRXTHRCFG_UsbRxPktCnt_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GRXTHRCFG_reserved_28_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_GRXTHRCFG_reserved_28_POS     28
#define DWC_usb3_GRXTHRCFG_UsbRxPktCntSel_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_GRXTHRCFG_UsbRxPktCntSel_POS     29
#define DWC_usb3_GRXTHRCFG_reserved_31_30_MASK    ((uint32_t)0xC0000000)
#define DWC_usb3_GRXTHRCFG_reserved_31_30_LSB     30
#define DWC_usb3_GRXTHRCFG_reserved_31_30_WIDTH   ((uint32_t)0x00000002)

#define DWC_usb3_GRXTHRCFG_ResvISOCOUTSpc_RST     0x0
#define DWC_usb3_GRXTHRCFG_reserved_14_13_RST     0x0
#define DWC_usb3_GRXTHRCFG_reserved_15_RST     0x0
#define DWC_usb3_GRXTHRCFG_reserved_18_16_RST     0x0
#define DWC_usb3_GRXTHRCFG_UsbMaxRxBurstSize_RST     0x0
#define DWC_usb3_GRXTHRCFG_UsbRxPktCnt_RST     0x0
#define DWC_usb3_GRXTHRCFG_reserved_28_RST     0x0
#define DWC_usb3_GRXTHRCFG_UsbRxPktCntSel_RST     0x0
#define DWC_usb3_GRXTHRCFG_reserved_31_30_RST     0x0

__INLINE void dwc_usb3_grxthrcfg_pack(uint16_t resvisocoutspc,uint8_t reserved1413,uint8_t reserved15,uint8_t reserved1816,uint8_t usbmaxrxburstsize,uint8_t usbrxpktcnt,uint8_t reserved28,uint8_t usbrxpktcntsel,uint8_t reserved3130)
{
       ASSERT_ERR((((uint32_t)resvisocoutspc << 0) & ~((uint32_t)0x00001FFF)) == 0);
       ASSERT_ERR((((uint32_t)reserved1413 << 13) & ~((uint32_t)0x00006000)) == 0);
       ASSERT_ERR((((uint32_t)reserved15 << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)reserved1816 << 16) & ~((uint32_t)0x00070000)) == 0);
       ASSERT_ERR((((uint32_t)usbmaxrxburstsize << 19) & ~((uint32_t)0x00F80000)) == 0);
       ASSERT_ERR((((uint32_t)usbrxpktcnt << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved28 << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)usbrxpktcntsel << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3130 << 30) & ~((uint32_t)0xC0000000)) == 0);
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR, ((uint32_t)resvisocoutspc << 0) |((uint32_t)reserved1413 << 13) |((uint32_t)reserved15 << 15) |((uint32_t)reserved1816 << 16) |((uint32_t)usbmaxrxburstsize << 19) |((uint32_t)usbrxpktcnt << 24) |((uint32_t)reserved28 << 28) |((uint32_t)usbrxpktcntsel << 29) |((uint32_t)reserved3130 << 30));
}

__INLINE void dwc_usb3_grxthrcfg_unpack(uint16_t* resvisocoutspc,uint8_t* reserved1413,uint8_t* reserved15,uint8_t* reserved1816,uint8_t* usbmaxrxburstsize,uint8_t* usbrxpktcnt,uint8_t* reserved28,uint8_t* usbrxpktcntsel,uint8_t* reserved3130)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);

       *resvisocoutspc = (localVal & ((uint32_t)0x00001FFF)) >> 0;
       *reserved1413 = (localVal & ((uint32_t)0x00006000)) >> 13;
       *reserved15 = (localVal & ((uint32_t)0x00008000)) >> 15;
       *reserved1816 = (localVal & ((uint32_t)0x00070000)) >> 16;
       *usbmaxrxburstsize = (localVal & ((uint32_t)0x00F80000)) >> 19;
       *usbrxpktcnt = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *reserved28 = (localVal & ((uint32_t)0x10000000)) >> 28;
       *usbrxpktcntsel = (localVal & ((uint32_t)0x20000000)) >> 29;
       *reserved3130 = (localVal & ((uint32_t)0xC0000000)) >> 30;
}
__INLINE uint16_t  dwc_usb3_grxthrcfg_resvisocoutspc_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00001FFF)) >> 0);
}
__INLINE void  dwc_usb3_grxthrcfg_resvisocoutspc_setf(uint16_t  resvisocoutspc)
{
       ASSERT_ERR((((uint32_t)resvisocoutspc << 0) & ~((uint32_t)0x00001FFF)) == 0);
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR) & ~((uint32_t)0x00001FFF)) | ((uint32_t)resvisocoutspc <<0));
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_reserved_14_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00006000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_reserved_15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_reserved_18_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00070000)) >> 16);
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_usbmaxrxburstsize_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x00F80000)) >> 19);
}
__INLINE void  dwc_usb3_grxthrcfg_usbmaxrxburstsize_setf(uint8_t  usbmaxrxburstsize)
{
       ASSERT_ERR((((uint32_t)usbmaxrxburstsize << 19) & ~((uint32_t)0x00F80000)) == 0);
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR) & ~((uint32_t)0x00F80000)) | ((uint32_t)usbmaxrxburstsize <<19));
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_usbrxpktcnt_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_grxthrcfg_usbrxpktcnt_setf(uint8_t  usbrxpktcnt)
{
       ASSERT_ERR((((uint32_t)usbrxpktcnt << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)usbrxpktcnt <<24));
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_reserved_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_usbrxpktcntsel_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void  dwc_usb3_grxthrcfg_usbrxpktcntsel_setf(uint8_t  usbrxpktcntsel)
{
       ASSERT_ERR((((uint32_t)usbrxpktcntsel << 29) & ~((uint32_t)0x20000000)) == 0);
       REG_PL_WR(DWC_usb3_GRXTHRCFG_ADDR, (REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)usbrxpktcntsel <<29));
}
__INLINE uint8_t  dwc_usb3_grxthrcfg_reserved_31_30_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GRXTHRCFG_ADDR);
       return ((localVal & ((uint32_t)0xC0000000)) >> 30);
}
/**
* \@brief GCTL register definition
* Global Core Control Register

Refer to <workspace>/src/DWC_usb3_params.v for details on `DWC_USB3_GCTL_INIT.

Note: 

When Hibernation is not enabled, you can write any value to GblHibernationEn. It always returns 0 when read.

<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          DSBLCLKGTNG                             0x0
*    1          GblHibernationEn                        0x0
*    2          U2EXIT_LFPS                             0x1
*    3          DISSCRAMBLE                             0x0
*    04:05       SCALEDOWN                               0x0
*    06:07       RAMCLKSEL                               0x0
*    8          DEBUGATTACH                             0x0
*    9          U1U2TimerScale                          0x0
*    10         SOFITPSYNC                              0x0
*    11         CORESOFTRESET                           0x0
*    12:13      PRTCAPDIR                               0x2
*    14:15      FRMSCLDWN                               0x0
*    16         U2RSTECN                                0x1
*    17         BYPSSETADDR                             0x0
*    18         MASTERFILTBYPASS                        0x0
*    19:31      PWRDNSCALE                              0x618
* </pre>
*/
#define DWC_usb3_GCTL_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C110)
#define DWC_usb3_GCTL_OFFSET      0x0000C110
#define DWC_usb3_GCTL_INDEX       0x3044
__INLINE uint32_t dwc_usb3_gctl_get(void)
{
       return REG_PL_RD(DWC_usb3_GCTL_ADDR);
}

__INLINE void dwc_usb3_gctl_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GCTL_ADDR,value);
}
// field definitions
#define DWC_usb3_GCTL_DSBLCLKGTNG_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_GCTL_DSBLCLKGTNG_POS     0
#define DWC_usb3_GCTL_GblHibernationEn_BIT     ((uint32_t)0x00000002)
#define DWC_usb3_GCTL_GblHibernationEn_POS     1
#define DWC_usb3_GCTL_U2EXIT_LFPS_BIT     ((uint32_t)0x00000004)
#define DWC_usb3_GCTL_U2EXIT_LFPS_POS     2
#define DWC_usb3_GCTL_DISSCRAMBLE_BIT     ((uint32_t)0x00000008)
#define DWC_usb3_GCTL_DISSCRAMBLE_POS     3
#define DWC_usb3_GCTL_SCALEDOWN_MASK    ((uint32_t)0x00000030)
#define DWC_usb3_GCTL_SCALEDOWN_LSB     4
#define DWC_usb3_GCTL_SCALEDOWN_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GCTL_RAMCLKSEL_MASK    ((uint32_t)0x000000C0)
#define DWC_usb3_GCTL_RAMCLKSEL_LSB     6
#define DWC_usb3_GCTL_RAMCLKSEL_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GCTL_DEBUGATTACH_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_GCTL_DEBUGATTACH_POS     8
#define DWC_usb3_GCTL_U1U2TimerScale_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_GCTL_U1U2TimerScale_POS     9
#define DWC_usb3_GCTL_SOFITPSYNC_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GCTL_SOFITPSYNC_POS     10
#define DWC_usb3_GCTL_CORESOFTRESET_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GCTL_CORESOFTRESET_POS     11
#define DWC_usb3_GCTL_PRTCAPDIR_MASK    ((uint32_t)0x00003000)
#define DWC_usb3_GCTL_PRTCAPDIR_LSB     12
#define DWC_usb3_GCTL_PRTCAPDIR_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GCTL_FRMSCLDWN_MASK    ((uint32_t)0x0000C000)
#define DWC_usb3_GCTL_FRMSCLDWN_LSB     14
#define DWC_usb3_GCTL_FRMSCLDWN_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GCTL_U2RSTECN_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_GCTL_U2RSTECN_POS     16
#define DWC_usb3_GCTL_BYPSSETADDR_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_GCTL_BYPSSETADDR_POS     17
#define DWC_usb3_GCTL_MASTERFILTBYPASS_BIT     ((uint32_t)0x00040000)
#define DWC_usb3_GCTL_MASTERFILTBYPASS_POS     18
#define DWC_usb3_GCTL_PWRDNSCALE_MASK    ((uint32_t)0xFFF80000)
#define DWC_usb3_GCTL_PWRDNSCALE_LSB     19
#define DWC_usb3_GCTL_PWRDNSCALE_WIDTH   ((uint32_t)0x0000000D)

#define DWC_usb3_GCTL_DSBLCLKGTNG_RST     0x0
#define DWC_usb3_GCTL_GblHibernationEn_RST     0x0
#define DWC_usb3_GCTL_U2EXIT_LFPS_RST     0x1
#define DWC_usb3_GCTL_DISSCRAMBLE_RST     0x0
#define DWC_usb3_GCTL_SCALEDOWN_RST     0x0
#define DWC_usb3_GCTL_RAMCLKSEL_RST     0x0
#define DWC_usb3_GCTL_DEBUGATTACH_RST     0x0
#define DWC_usb3_GCTL_U1U2TimerScale_RST     0x0
#define DWC_usb3_GCTL_SOFITPSYNC_RST     0x0
#define DWC_usb3_GCTL_CORESOFTRESET_RST     0x0
#define DWC_usb3_GCTL_PRTCAPDIR_RST     0x2
#define DWC_usb3_GCTL_FRMSCLDWN_RST     0x0
#define DWC_usb3_GCTL_U2RSTECN_RST     0x1
#define DWC_usb3_GCTL_BYPSSETADDR_RST     0x0
#define DWC_usb3_GCTL_MASTERFILTBYPASS_RST     0x0
#define DWC_usb3_GCTL_PWRDNSCALE_RST     0x618

__INLINE void dwc_usb3_gctl_pack(uint8_t dsblclkgtng,uint8_t gblhibernationen,uint8_t u2exitlfps,uint8_t disscramble,uint8_t scaledown,uint8_t ramclksel,uint8_t debugattach,uint8_t u1u2timerscale,uint8_t sofitpsync,uint8_t coresoftreset,uint8_t prtcapdir,uint8_t frmscldwn,uint8_t u2rstecn,uint8_t bypssetaddr,uint8_t masterfiltbypass,uint16_t pwrdnscale)
{
       ASSERT_ERR((((uint32_t)dsblclkgtng << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)gblhibernationen << 1) & ~((uint32_t)0x00000002)) == 0);
       ASSERT_ERR((((uint32_t)u2exitlfps << 2) & ~((uint32_t)0x00000004)) == 0);
       ASSERT_ERR((((uint32_t)disscramble << 3) & ~((uint32_t)0x00000008)) == 0);
       ASSERT_ERR((((uint32_t)scaledown << 4) & ~((uint32_t)0x00000030)) == 0);
       ASSERT_ERR((((uint32_t)ramclksel << 6) & ~((uint32_t)0x000000C0)) == 0);
       ASSERT_ERR((((uint32_t)debugattach << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)u1u2timerscale << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)sofitpsync << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)coresoftreset << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)prtcapdir << 12) & ~((uint32_t)0x00003000)) == 0);
       ASSERT_ERR((((uint32_t)frmscldwn << 14) & ~((uint32_t)0x0000C000)) == 0);
       ASSERT_ERR((((uint32_t)u2rstecn << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)bypssetaddr << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)masterfiltbypass << 18) & ~((uint32_t)0x00040000)) == 0);
       ASSERT_ERR((((uint32_t)pwrdnscale << 19) & ~((uint32_t)0xFFF80000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, ((uint32_t)dsblclkgtng << 0) |((uint32_t)gblhibernationen << 1) |((uint32_t)u2exitlfps << 2) |((uint32_t)disscramble << 3) |((uint32_t)scaledown << 4) |((uint32_t)ramclksel << 6) |((uint32_t)debugattach << 8) |((uint32_t)u1u2timerscale << 9) |((uint32_t)sofitpsync << 10) |((uint32_t)coresoftreset << 11) |((uint32_t)prtcapdir << 12) |((uint32_t)frmscldwn << 14) |((uint32_t)u2rstecn << 16) |((uint32_t)bypssetaddr << 17) |((uint32_t)masterfiltbypass << 18) |((uint32_t)pwrdnscale << 19));
}

__INLINE void dwc_usb3_gctl_unpack(uint8_t* dsblclkgtng,uint8_t* gblhibernationen,uint8_t* u2exitlfps,uint8_t* disscramble,uint8_t* scaledown,uint8_t* ramclksel,uint8_t* debugattach,uint8_t* u1u2timerscale,uint8_t* sofitpsync,uint8_t* coresoftreset,uint8_t* prtcapdir,uint8_t* frmscldwn,uint8_t* u2rstecn,uint8_t* bypssetaddr,uint8_t* masterfiltbypass,uint16_t* pwrdnscale)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);

       *dsblclkgtng = (localVal & ((uint32_t)0x00000001)) >> 0;
       *gblhibernationen = (localVal & ((uint32_t)0x00000002)) >> 1;
       *u2exitlfps = (localVal & ((uint32_t)0x00000004)) >> 2;
       *disscramble = (localVal & ((uint32_t)0x00000008)) >> 3;
       *scaledown = (localVal & ((uint32_t)0x00000030)) >> 4;
       *ramclksel = (localVal & ((uint32_t)0x000000C0)) >> 6;
       *debugattach = (localVal & ((uint32_t)0x00000100)) >> 8;
       *u1u2timerscale = (localVal & ((uint32_t)0x00000200)) >> 9;
       *sofitpsync = (localVal & ((uint32_t)0x00000400)) >> 10;
       *coresoftreset = (localVal & ((uint32_t)0x00000800)) >> 11;
       *prtcapdir = (localVal & ((uint32_t)0x00003000)) >> 12;
       *frmscldwn = (localVal & ((uint32_t)0x0000C000)) >> 14;
       *u2rstecn = (localVal & ((uint32_t)0x00010000)) >> 16;
       *bypssetaddr = (localVal & ((uint32_t)0x00020000)) >> 17;
       *masterfiltbypass = (localVal & ((uint32_t)0x00040000)) >> 18;
       *pwrdnscale = (localVal & ((uint32_t)0xFFF80000)) >> 19;
}
__INLINE uint8_t  dwc_usb3_gctl_dsblclkgtng_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void  dwc_usb3_gctl_dsblclkgtng_setf(uint8_t  dsblclkgtng)
{
       ASSERT_ERR((((uint32_t)dsblclkgtng << 0) & ~((uint32_t)0x00000001)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dsblclkgtng <<0));
}
__INLINE uint8_t  dwc_usb3_gctl_gblhibernationen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE uint8_t  dwc_usb3_gctl_u2exit_lfps_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void  dwc_usb3_gctl_u2exit_lfps_setf(uint8_t  u2exitlfps)
{
       ASSERT_ERR((((uint32_t)u2exitlfps << 2) & ~((uint32_t)0x00000004)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)u2exitlfps <<2));
}
__INLINE uint8_t  dwc_usb3_gctl_disscramble_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void  dwc_usb3_gctl_disscramble_setf(uint8_t  disscramble)
{
       ASSERT_ERR((((uint32_t)disscramble << 3) & ~((uint32_t)0x00000008)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)disscramble <<3));
}
__INLINE uint8_t  dwc_usb3_gctl_scaledown_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000030)) >> 4);
}
__INLINE void  dwc_usb3_gctl_scaledown_setf(uint8_t  scaledown)
{
       ASSERT_ERR((((uint32_t)scaledown << 4) & ~((uint32_t)0x00000030)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000030)) | ((uint32_t)scaledown <<4));
}
__INLINE uint8_t  dwc_usb3_gctl_ramclksel_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x000000C0)) >> 6);
}
__INLINE void  dwc_usb3_gctl_ramclksel_setf(uint8_t  ramclksel)
{
       ASSERT_ERR((((uint32_t)ramclksel << 6) & ~((uint32_t)0x000000C0)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x000000C0)) | ((uint32_t)ramclksel <<6));
}
__INLINE uint8_t  dwc_usb3_gctl_debugattach_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void  dwc_usb3_gctl_debugattach_setf(uint8_t  debugattach)
{
       ASSERT_ERR((((uint32_t)debugattach << 8) & ~((uint32_t)0x00000100)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)debugattach <<8));
}
__INLINE uint8_t  dwc_usb3_gctl_u1u2timerscale_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void  dwc_usb3_gctl_u1u2timerscale_setf(uint8_t  u1u2timerscale)
{
       ASSERT_ERR((((uint32_t)u1u2timerscale << 9) & ~((uint32_t)0x00000200)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)u1u2timerscale <<9));
}
__INLINE uint8_t  dwc_usb3_gctl_sofitpsync_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void  dwc_usb3_gctl_sofitpsync_setf(uint8_t  sofitpsync)
{
       ASSERT_ERR((((uint32_t)sofitpsync << 10) & ~((uint32_t)0x00000400)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)sofitpsync <<10));
}
__INLINE uint8_t  dwc_usb3_gctl_coresoftreset_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void  dwc_usb3_gctl_coresoftreset_setf(uint8_t  coresoftreset)
{
       ASSERT_ERR((((uint32_t)coresoftreset << 11) & ~((uint32_t)0x00000800)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)coresoftreset <<11));
}
__INLINE uint8_t  dwc_usb3_gctl_prtcapdir_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00003000)) >> 12);
}
__INLINE void  dwc_usb3_gctl_prtcapdir_setf(uint8_t  prtcapdir)
{
       ASSERT_ERR((((uint32_t)prtcapdir << 12) & ~((uint32_t)0x00003000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00003000)) | ((uint32_t)prtcapdir <<12));
}
__INLINE uint8_t  dwc_usb3_gctl_frmscldwn_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x0000C000)) >> 14);
}
__INLINE void  dwc_usb3_gctl_frmscldwn_setf(uint8_t  frmscldwn)
{
       ASSERT_ERR((((uint32_t)frmscldwn << 14) & ~((uint32_t)0x0000C000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x0000C000)) | ((uint32_t)frmscldwn <<14));
}
__INLINE uint8_t  dwc_usb3_gctl_u2rstecn_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void  dwc_usb3_gctl_u2rstecn_setf(uint8_t  u2rstecn)
{
       ASSERT_ERR((((uint32_t)u2rstecn << 16) & ~((uint32_t)0x00010000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)u2rstecn <<16));
}
__INLINE uint8_t  dwc_usb3_gctl_bypssetaddr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void  dwc_usb3_gctl_bypssetaddr_setf(uint8_t  bypssetaddr)
{
       ASSERT_ERR((((uint32_t)bypssetaddr << 17) & ~((uint32_t)0x00020000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)bypssetaddr <<17));
}
__INLINE uint8_t  dwc_usb3_gctl_masterfiltbypass_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void  dwc_usb3_gctl_masterfiltbypass_setf(uint8_t  masterfiltbypass)
{
       ASSERT_ERR((((uint32_t)masterfiltbypass << 18) & ~((uint32_t)0x00040000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)masterfiltbypass <<18));
}
__INLINE uint16_t  dwc_usb3_gctl_pwrdnscale_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GCTL_ADDR);
       return ((localVal & ((uint32_t)0xFFF80000)) >> 19);
}
__INLINE void  dwc_usb3_gctl_pwrdnscale_setf(uint16_t  pwrdnscale)
{
       ASSERT_ERR((((uint32_t)pwrdnscale << 19) & ~((uint32_t)0xFFF80000)) == 0);
       REG_PL_WR(DWC_usb3_GCTL_ADDR, (REG_PL_RD(DWC_usb3_GCTL_ADDR) & ~((uint32_t)0xFFF80000)) | ((uint32_t)pwrdnscale <<19));
}
/**
* \@brief GPMSTS register definition
* Global Power Management Status Register

This debug register gives information on which event caused the hibernation exit. It provides internal status and state machine information, and is for Synopsys use only for debugging purposes.

This register is not applicable in USB 2.0-only mode.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:09       U2Wakeup                                0x0
*    10:11      reserved_10_11                          0x0
*    12:16      U3Wakeup                                0x0
*    17:27      reserved_27_17                          0x0
*    28:31      PortSel                                 0x0
* </pre>
*/
#define DWC_usb3_GPMSTS_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C114)
#define DWC_usb3_GPMSTS_OFFSET      0x0000C114
#define DWC_usb3_GPMSTS_INDEX       0x3045
__INLINE uint32_t dwc_usb3_gpmsts_get(void)
{
       return REG_PL_RD(DWC_usb3_GPMSTS_ADDR);
}

__INLINE void dwc_usb3_gpmsts_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPMSTS_ADDR,value);
}
// field definitions
#define DWC_usb3_GPMSTS_U2Wakeup_MASK    ((uint32_t)0x000003FF)
#define DWC_usb3_GPMSTS_U2Wakeup_LSB     0
#define DWC_usb3_GPMSTS_U2Wakeup_WIDTH   ((uint32_t)0x0000000A)
#define DWC_usb3_GPMSTS_reserved_10_11_MASK    ((uint32_t)0x00000C00)
#define DWC_usb3_GPMSTS_reserved_10_11_LSB     10
#define DWC_usb3_GPMSTS_reserved_10_11_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GPMSTS_U3Wakeup_MASK    ((uint32_t)0x0001F000)
#define DWC_usb3_GPMSTS_U3Wakeup_LSB     12
#define DWC_usb3_GPMSTS_U3Wakeup_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_GPMSTS_reserved_27_17_MASK    ((uint32_t)0x0FFE0000)
#define DWC_usb3_GPMSTS_reserved_27_17_LSB     17
#define DWC_usb3_GPMSTS_reserved_27_17_WIDTH   ((uint32_t)0x0000000B)
#define DWC_usb3_GPMSTS_PortSel_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPMSTS_PortSel_LSB     28
#define DWC_usb3_GPMSTS_PortSel_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPMSTS_U2Wakeup_RST     0x0
#define DWC_usb3_GPMSTS_reserved_10_11_RST     0x0
#define DWC_usb3_GPMSTS_U3Wakeup_RST     0x0
#define DWC_usb3_GPMSTS_reserved_27_17_RST     0x0
#define DWC_usb3_GPMSTS_PortSel_RST     0x0

__INLINE void dwc_usb3_gpmsts_pack(uint16_t u2wakeup,uint8_t reserved1011,uint8_t u3wakeup,uint16_t reserved2717,uint8_t portsel)
{
       ASSERT_ERR((((uint32_t)u2wakeup << 0) & ~((uint32_t)0x000003FF)) == 0);
       ASSERT_ERR((((uint32_t)reserved1011 << 10) & ~((uint32_t)0x00000C00)) == 0);
       ASSERT_ERR((((uint32_t)u3wakeup << 12) & ~((uint32_t)0x0001F000)) == 0);
       ASSERT_ERR((((uint32_t)reserved2717 << 17) & ~((uint32_t)0x0FFE0000)) == 0);
       ASSERT_ERR((((uint32_t)portsel << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPMSTS_ADDR, ((uint32_t)u2wakeup << 0) |((uint32_t)reserved1011 << 10) |((uint32_t)u3wakeup << 12) |((uint32_t)reserved2717 << 17) |((uint32_t)portsel << 28));
}

__INLINE void dwc_usb3_gpmsts_unpack(uint16_t* u2wakeup,uint8_t* reserved1011,uint8_t* u3wakeup,uint16_t* reserved2717,uint8_t* portsel)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPMSTS_ADDR);

       *u2wakeup = (localVal & ((uint32_t)0x000003FF)) >> 0;
       *reserved1011 = (localVal & ((uint32_t)0x00000C00)) >> 10;
       *u3wakeup = (localVal & ((uint32_t)0x0001F000)) >> 12;
       *reserved2717 = (localVal & ((uint32_t)0x0FFE0000)) >> 17;
       *portsel = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint16_t  dwc_usb3_gpmsts_u2wakeup_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPMSTS_ADDR);
       return ((localVal & ((uint32_t)0x000003FF)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gpmsts_reserved_10_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPMSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE uint8_t  dwc_usb3_gpmsts_u3wakeup_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPMSTS_ADDR);
       return ((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE uint16_t  dwc_usb3_gpmsts_reserved_27_17_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPMSTS_ADDR);
       return ((localVal & ((uint32_t)0x0FFE0000)) >> 17);
}
__INLINE void  dwc_usb3_gpmsts_portsel_setf(uint8_t  portsel)
{
       ASSERT_ERR((((uint32_t)portsel << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPMSTS_ADDR, (REG_PL_RD(DWC_usb3_GPMSTS_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)portsel <<28));
}
/**
* \@brief GSTS register definition
* Global Status Register
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:01       CURMOD                                  0x0
*    02:03       reserved_3_2                            0x0
*    4          BUSERRADDRVLD                           0x0
*    5          CSRTimeout                              0x0
*    6          Device_IP                               0x0
*    7          Host_IP                                 0x0
*    8          ADP_IP                                  0x0
*    9          BC_IP                                   0x0
*    10         OTG_IP                                  0x0
*    11         SSIC_IP                                 0x0
*    12:19      reserved_19_12                          0x0
*    20:31      CBELT                                   0x0
* </pre>
*/
#define DWC_usb3_GSTS_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C118)
#define DWC_usb3_GSTS_OFFSET      0x0000C118
#define DWC_usb3_GSTS_INDEX       0x3046
__INLINE uint32_t dwc_usb3_gsts_get(void)
{
       return REG_PL_RD(DWC_usb3_GSTS_ADDR);
}

__INLINE void dwc_usb3_gsts_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GSTS_ADDR,value);
}
// field definitions
#define DWC_usb3_GSTS_CURMOD_MASK    ((uint32_t)0x00000003)
#define DWC_usb3_GSTS_CURMOD_LSB     0
#define DWC_usb3_GSTS_CURMOD_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GSTS_reserved_3_2_MASK    ((uint32_t)0x0000000C)
#define DWC_usb3_GSTS_reserved_3_2_LSB     2
#define DWC_usb3_GSTS_reserved_3_2_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GSTS_BUSERRADDRVLD_BIT     ((uint32_t)0x00000010)
#define DWC_usb3_GSTS_BUSERRADDRVLD_POS     4
#define DWC_usb3_GSTS_CSRTimeout_BIT     ((uint32_t)0x00000020)
#define DWC_usb3_GSTS_CSRTimeout_POS     5
#define DWC_usb3_GSTS_Device_IP_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_GSTS_Device_IP_POS     6
#define DWC_usb3_GSTS_Host_IP_BIT     ((uint32_t)0x00000080)
#define DWC_usb3_GSTS_Host_IP_POS     7
#define DWC_usb3_GSTS_ADP_IP_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_GSTS_ADP_IP_POS     8
#define DWC_usb3_GSTS_BC_IP_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_GSTS_BC_IP_POS     9
#define DWC_usb3_GSTS_OTG_IP_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GSTS_OTG_IP_POS     10
#define DWC_usb3_GSTS_SSIC_IP_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GSTS_SSIC_IP_POS     11
#define DWC_usb3_GSTS_reserved_19_12_MASK    ((uint32_t)0x000FF000)
#define DWC_usb3_GSTS_reserved_19_12_LSB     12
#define DWC_usb3_GSTS_reserved_19_12_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GSTS_CBELT_MASK    ((uint32_t)0xFFF00000)
#define DWC_usb3_GSTS_CBELT_LSB     20
#define DWC_usb3_GSTS_CBELT_WIDTH   ((uint32_t)0x0000000C)

#define DWC_usb3_GSTS_CURMOD_RST     0x0
#define DWC_usb3_GSTS_reserved_3_2_RST     0x0
#define DWC_usb3_GSTS_BUSERRADDRVLD_RST     0x0
#define DWC_usb3_GSTS_CSRTimeout_RST     0x0
#define DWC_usb3_GSTS_Device_IP_RST     0x0
#define DWC_usb3_GSTS_Host_IP_RST     0x0
#define DWC_usb3_GSTS_ADP_IP_RST     0x0
#define DWC_usb3_GSTS_BC_IP_RST     0x0
#define DWC_usb3_GSTS_OTG_IP_RST     0x0
#define DWC_usb3_GSTS_SSIC_IP_RST     0x0
#define DWC_usb3_GSTS_reserved_19_12_RST     0x0
#define DWC_usb3_GSTS_CBELT_RST     0x0

__INLINE void dwc_usb3_gsts_pack(uint8_t curmod,uint8_t reserved32,uint8_t buserraddrvld,uint8_t csrtimeout,uint8_t deviceip,uint8_t hostip,uint8_t adpip,uint8_t bcip,uint8_t otgip,uint8_t ssicip,uint8_t reserved1912,uint16_t cbelt)
{
       ASSERT_ERR((((uint32_t)curmod << 0) & ~((uint32_t)0x00000003)) == 0);
       ASSERT_ERR((((uint32_t)reserved32 << 2) & ~((uint32_t)0x0000000C)) == 0);
       ASSERT_ERR((((uint32_t)buserraddrvld << 4) & ~((uint32_t)0x00000010)) == 0);
       ASSERT_ERR((((uint32_t)csrtimeout << 5) & ~((uint32_t)0x00000020)) == 0);
       ASSERT_ERR((((uint32_t)deviceip << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)hostip << 7) & ~((uint32_t)0x00000080)) == 0);
       ASSERT_ERR((((uint32_t)adpip << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)bcip << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)otgip << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)ssicip << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)reserved1912 << 12) & ~((uint32_t)0x000FF000)) == 0);
       ASSERT_ERR((((uint32_t)cbelt << 20) & ~((uint32_t)0xFFF00000)) == 0);
       REG_PL_WR(DWC_usb3_GSTS_ADDR, ((uint32_t)curmod << 0) |((uint32_t)reserved32 << 2) |((uint32_t)buserraddrvld << 4) |((uint32_t)csrtimeout << 5) |((uint32_t)deviceip << 6) |((uint32_t)hostip << 7) |((uint32_t)adpip << 8) |((uint32_t)bcip << 9) |((uint32_t)otgip << 10) |((uint32_t)ssicip << 11) |((uint32_t)reserved1912 << 12) |((uint32_t)cbelt << 20));
}

__INLINE void dwc_usb3_gsts_unpack(uint8_t* curmod,uint8_t* reserved32,uint8_t* buserraddrvld,uint8_t* csrtimeout,uint8_t* deviceip,uint8_t* hostip,uint8_t* adpip,uint8_t* bcip,uint8_t* otgip,uint8_t* ssicip,uint8_t* reserved1912,uint16_t* cbelt)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);

       *curmod = (localVal & ((uint32_t)0x00000003)) >> 0;
       *reserved32 = (localVal & ((uint32_t)0x0000000C)) >> 2;
       *buserraddrvld = (localVal & ((uint32_t)0x00000010)) >> 4;
       *csrtimeout = (localVal & ((uint32_t)0x00000020)) >> 5;
       *deviceip = (localVal & ((uint32_t)0x00000040)) >> 6;
       *hostip = (localVal & ((uint32_t)0x00000080)) >> 7;
       *adpip = (localVal & ((uint32_t)0x00000100)) >> 8;
       *bcip = (localVal & ((uint32_t)0x00000200)) >> 9;
       *otgip = (localVal & ((uint32_t)0x00000400)) >> 10;
       *ssicip = (localVal & ((uint32_t)0x00000800)) >> 11;
       *reserved1912 = (localVal & ((uint32_t)0x000FF000)) >> 12;
       *cbelt = (localVal & ((uint32_t)0xFFF00000)) >> 20;
}
__INLINE uint8_t  dwc_usb3_gsts_curmod_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000003)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gsts_reserved_3_2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x0000000C)) >> 2);
}
__INLINE uint8_t  dwc_usb3_gsts_buserraddrvld_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void  dwc_usb3_gsts_buserraddrvld_setf(uint8_t  buserraddrvld)
{
       ASSERT_ERR((((uint32_t)buserraddrvld << 4) & ~((uint32_t)0x00000010)) == 0);
       REG_PL_WR(DWC_usb3_GSTS_ADDR, (REG_PL_RD(DWC_usb3_GSTS_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)buserraddrvld <<4));
}
__INLINE uint8_t  dwc_usb3_gsts_csrtimeout_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void  dwc_usb3_gsts_csrtimeout_setf(uint8_t  csrtimeout)
{
       ASSERT_ERR((((uint32_t)csrtimeout << 5) & ~((uint32_t)0x00000020)) == 0);
       REG_PL_WR(DWC_usb3_GSTS_ADDR, (REG_PL_RD(DWC_usb3_GSTS_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)csrtimeout <<5));
}
__INLINE uint8_t  dwc_usb3_gsts_device_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t  dwc_usb3_gsts_host_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t  dwc_usb3_gsts_adp_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE uint8_t  dwc_usb3_gsts_bc_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t  dwc_usb3_gsts_otg_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t  dwc_usb3_gsts_ssic_ip_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_gsts_reserved_19_12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t  dwc_usb3_gsts_cbelt_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSTS_ADDR);
       return ((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
/**
* \@brief GUCTL1 register definition
* Global User Control Register 1
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          LOA_FILTER_EN                           0x0
*    1          OVRLD_L1_SUSP_COM                       0x1
*    2          HC_PARCHK_DISABLE                       0x0
*    3          HC_ERRATA_ENABLE                        0x1
*    04:07       L1_SUSP_THRLD_FOR_HOST                  0x8
*    8          L1_SUSP_THRLD_EN_FOR_HOST               0x1
*    9          DEV_HS_NYET_BULK_SPR                    0x0
*    10         RESUME_OPMODE_HS_HOST                   0x0
*    11         DisRefClkGtng                           0x1
*    12         DisUSB2RefClkGtng                       0x1
*    13:14      reserved_14_13                          0x0
*    15         PARKMODE_DISABLE_FSLS                   0x0
*    16         PARKMODE_DISABLE_HS                     0x0
*    17         PARKMODE_DISABLE_SS                     0x0
*    18         NAK_PER_ENH_HS                          0x1
*    19         NAK_PER_ENH_FS                          0x0
*    20         DEV_LSP_TAIL_LOCK_DIS                   0x0
*    21:23      IP_GAP_ADD_ON                           0x0
*    24         DEV_L1_EXIT_BY_HW                       0x0
*    25         P3_IN_U2                                0x0
*    26         DEV_FORCE_20_CLK_FOR_30_CLK             0x0
*    27         DEV_TRB_OUT_SPR_IND                     0x0
*    28         TX_IPGAP_LINECHECK_DIS                  0x0
*    29         FILTER_SE0_FSLS_EOP                     0x0
*    30         DS_RXDET_MAX_TOUT_CTRL                  0x0
*    31         DEV_DECOUPLE_L1L2_EVT                   0x0
* </pre>
*/
#define DWC_usb3_GUCTL1_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C11C)
#define DWC_usb3_GUCTL1_OFFSET      0x0000C11C
#define DWC_usb3_GUCTL1_INDEX       0x3047
__INLINE uint32_t dwc_usb3_guctl1_get(void)
{
       return REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
}

__INLINE void dwc_usb3_guctl1_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR,value);
}
// field definitions
#define DWC_usb3_GUCTL1_LOA_FILTER_EN_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_GUCTL1_LOA_FILTER_EN_POS     0
#define DWC_usb3_GUCTL1_OVRLD_L1_SUSP_COM_BIT     ((uint32_t)0x00000002)
#define DWC_usb3_GUCTL1_OVRLD_L1_SUSP_COM_POS     1
#define DWC_usb3_GUCTL1_HC_PARCHK_DISABLE_BIT     ((uint32_t)0x00000004)
#define DWC_usb3_GUCTL1_HC_PARCHK_DISABLE_POS     2
#define DWC_usb3_GUCTL1_HC_ERRATA_ENABLE_BIT     ((uint32_t)0x00000008)
#define DWC_usb3_GUCTL1_HC_ERRATA_ENABLE_POS     3
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_LSB     4
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_EN_FOR_HOST_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_EN_FOR_HOST_POS     8
#define DWC_usb3_GUCTL1_DEV_HS_NYET_BULK_SPR_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_GUCTL1_DEV_HS_NYET_BULK_SPR_POS     9
#define DWC_usb3_GUCTL1_RESUME_OPMODE_HS_HOST_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GUCTL1_RESUME_OPMODE_HS_HOST_POS     10
#define DWC_usb3_GUCTL1_DisRefClkGtng_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GUCTL1_DisRefClkGtng_POS     11
#define DWC_usb3_GUCTL1_DisUSB2RefClkGtng_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GUCTL1_DisUSB2RefClkGtng_POS     12
#define DWC_usb3_GUCTL1_reserved_14_13_MASK    ((uint32_t)0x00006000)
#define DWC_usb3_GUCTL1_reserved_14_13_LSB     13
#define DWC_usb3_GUCTL1_reserved_14_13_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_FSLS_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_FSLS_POS     15
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_HS_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_HS_POS     16
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_SS_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_SS_POS     17
#define DWC_usb3_GUCTL1_NAK_PER_ENH_HS_BIT     ((uint32_t)0x00040000)
#define DWC_usb3_GUCTL1_NAK_PER_ENH_HS_POS     18
#define DWC_usb3_GUCTL1_NAK_PER_ENH_FS_BIT     ((uint32_t)0x00080000)
#define DWC_usb3_GUCTL1_NAK_PER_ENH_FS_POS     19
#define DWC_usb3_GUCTL1_DEV_LSP_TAIL_LOCK_DIS_BIT     ((uint32_t)0x00100000)
#define DWC_usb3_GUCTL1_DEV_LSP_TAIL_LOCK_DIS_POS     20
#define DWC_usb3_GUCTL1_IP_GAP_ADD_ON_MASK    ((uint32_t)0x00E00000)
#define DWC_usb3_GUCTL1_IP_GAP_ADD_ON_LSB     21
#define DWC_usb3_GUCTL1_IP_GAP_ADD_ON_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GUCTL1_DEV_L1_EXIT_BY_HW_BIT     ((uint32_t)0x01000000)
#define DWC_usb3_GUCTL1_DEV_L1_EXIT_BY_HW_POS     24
#define DWC_usb3_GUCTL1_P3_IN_U2_BIT     ((uint32_t)0x02000000)
#define DWC_usb3_GUCTL1_P3_IN_U2_POS     25
#define DWC_usb3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK_BIT     ((uint32_t)0x04000000)
#define DWC_usb3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK_POS     26
#define DWC_usb3_GUCTL1_DEV_TRB_OUT_SPR_IND_BIT     ((uint32_t)0x08000000)
#define DWC_usb3_GUCTL1_DEV_TRB_OUT_SPR_IND_POS     27
#define DWC_usb3_GUCTL1_TX_IPGAP_LINECHECK_DIS_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_GUCTL1_TX_IPGAP_LINECHECK_DIS_POS     28
#define DWC_usb3_GUCTL1_FILTER_SE0_FSLS_EOP_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_GUCTL1_FILTER_SE0_FSLS_EOP_POS     29
#define DWC_usb3_GUCTL1_DS_RXDET_MAX_TOUT_CTRL_BIT     ((uint32_t)0x40000000)
#define DWC_usb3_GUCTL1_DS_RXDET_MAX_TOUT_CTRL_POS     30
#define DWC_usb3_GUCTL1_DEV_DECOUPLE_L1L2_EVT_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GUCTL1_DEV_DECOUPLE_L1L2_EVT_POS     31

#define DWC_usb3_GUCTL1_LOA_FILTER_EN_RST     0x0
#define DWC_usb3_GUCTL1_OVRLD_L1_SUSP_COM_RST     0x1
#define DWC_usb3_GUCTL1_HC_PARCHK_DISABLE_RST     0x0
#define DWC_usb3_GUCTL1_HC_ERRATA_ENABLE_RST     0x1
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_FOR_HOST_RST     0x8
#define DWC_usb3_GUCTL1_L1_SUSP_THRLD_EN_FOR_HOST_RST     0x1
#define DWC_usb3_GUCTL1_DEV_HS_NYET_BULK_SPR_RST     0x0
#define DWC_usb3_GUCTL1_RESUME_OPMODE_HS_HOST_RST     0x0
#define DWC_usb3_GUCTL1_DisRefClkGtng_RST     0x1
#define DWC_usb3_GUCTL1_DisUSB2RefClkGtng_RST     0x1
#define DWC_usb3_GUCTL1_reserved_14_13_RST     0x0
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_FSLS_RST     0x0
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_HS_RST     0x0
#define DWC_usb3_GUCTL1_PARKMODE_DISABLE_SS_RST     0x0
#define DWC_usb3_GUCTL1_NAK_PER_ENH_HS_RST     0x1
#define DWC_usb3_GUCTL1_NAK_PER_ENH_FS_RST     0x0
#define DWC_usb3_GUCTL1_DEV_LSP_TAIL_LOCK_DIS_RST     0x0
#define DWC_usb3_GUCTL1_IP_GAP_ADD_ON_RST     0x0
#define DWC_usb3_GUCTL1_DEV_L1_EXIT_BY_HW_RST     0x0
#define DWC_usb3_GUCTL1_P3_IN_U2_RST     0x0
#define DWC_usb3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK_RST     0x0
#define DWC_usb3_GUCTL1_DEV_TRB_OUT_SPR_IND_RST     0x0
#define DWC_usb3_GUCTL1_TX_IPGAP_LINECHECK_DIS_RST     0x0
#define DWC_usb3_GUCTL1_FILTER_SE0_FSLS_EOP_RST     0x0
#define DWC_usb3_GUCTL1_DS_RXDET_MAX_TOUT_CTRL_RST     0x0
#define DWC_usb3_GUCTL1_DEV_DECOUPLE_L1L2_EVT_RST     0x0

__INLINE void dwc_usb3_guctl1_pack(uint8_t loafilteren,uint8_t ovrldl1suspcom,uint8_t hcparchkdisable,uint8_t hcerrataenable,uint8_t l1suspthrldforhost,uint8_t l1suspthrldenforhost,uint8_t devhsnyetbulkspr,uint8_t resumeopmodehshost,uint8_t disrefclkgtng,uint8_t disusb2refclkgtng,uint8_t reserved1413,uint8_t parkmodedisablefsls,uint8_t parkmodedisablehs,uint8_t parkmodedisabless,uint8_t nakperenhhs,uint8_t nakperenhfs,uint8_t devlsptaillockdis,uint8_t ipgapaddon,uint8_t devl1exitbyhw,uint8_t p3inu2,uint8_t devforce20clkfor30clk,uint8_t devtrboutsprind,uint8_t txipgaplinecheckdis,uint8_t filterse0fslseop,uint8_t dsrxdetmaxtoutctrl,uint8_t devdecouplel1l2evt)
{
       ASSERT_ERR((((uint32_t)loafilteren << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)ovrldl1suspcom << 1) & ~((uint32_t)0x00000002)) == 0);
       ASSERT_ERR((((uint32_t)hcparchkdisable << 2) & ~((uint32_t)0x00000004)) == 0);
       ASSERT_ERR((((uint32_t)hcerrataenable << 3) & ~((uint32_t)0x00000008)) == 0);
       ASSERT_ERR((((uint32_t)l1suspthrldforhost << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)l1suspthrldenforhost << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)devhsnyetbulkspr << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)resumeopmodehshost << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)disrefclkgtng << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)disusb2refclkgtng << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)reserved1413 << 13) & ~((uint32_t)0x00006000)) == 0);
       ASSERT_ERR((((uint32_t)parkmodedisablefsls << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)parkmodedisablehs << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)parkmodedisabless << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)nakperenhhs << 18) & ~((uint32_t)0x00040000)) == 0);
       ASSERT_ERR((((uint32_t)nakperenhfs << 19) & ~((uint32_t)0x00080000)) == 0);
       ASSERT_ERR((((uint32_t)devlsptaillockdis << 20) & ~((uint32_t)0x00100000)) == 0);
       ASSERT_ERR((((uint32_t)ipgapaddon << 21) & ~((uint32_t)0x00E00000)) == 0);
       ASSERT_ERR((((uint32_t)devl1exitbyhw << 24) & ~((uint32_t)0x01000000)) == 0);
       ASSERT_ERR((((uint32_t)p3inu2 << 25) & ~((uint32_t)0x02000000)) == 0);
       ASSERT_ERR((((uint32_t)devforce20clkfor30clk << 26) & ~((uint32_t)0x04000000)) == 0);
       ASSERT_ERR((((uint32_t)devtrboutsprind << 27) & ~((uint32_t)0x08000000)) == 0);
       ASSERT_ERR((((uint32_t)txipgaplinecheckdis << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)filterse0fslseop << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)dsrxdetmaxtoutctrl << 30) & ~((uint32_t)0x40000000)) == 0);
       ASSERT_ERR((((uint32_t)devdecouplel1l2evt << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, ((uint32_t)loafilteren << 0) |((uint32_t)ovrldl1suspcom << 1) |((uint32_t)hcparchkdisable << 2) |((uint32_t)hcerrataenable << 3) |((uint32_t)l1suspthrldforhost << 4) |((uint32_t)l1suspthrldenforhost << 8) |((uint32_t)devhsnyetbulkspr << 9) |((uint32_t)resumeopmodehshost << 10) |((uint32_t)disrefclkgtng << 11) |((uint32_t)disusb2refclkgtng << 12) |((uint32_t)reserved1413 << 13) |((uint32_t)parkmodedisablefsls << 15) |((uint32_t)parkmodedisablehs << 16) |((uint32_t)parkmodedisabless << 17) |((uint32_t)nakperenhhs << 18) |((uint32_t)nakperenhfs << 19) |((uint32_t)devlsptaillockdis << 20) |((uint32_t)ipgapaddon << 21) |((uint32_t)devl1exitbyhw << 24) |((uint32_t)p3inu2 << 25) |((uint32_t)devforce20clkfor30clk << 26) |((uint32_t)devtrboutsprind << 27) |((uint32_t)txipgaplinecheckdis << 28) |((uint32_t)filterse0fslseop << 29) |((uint32_t)dsrxdetmaxtoutctrl << 30) |((uint32_t)devdecouplel1l2evt << 31));
}

__INLINE void dwc_usb3_guctl1_unpack(uint8_t* loafilteren,uint8_t* ovrldl1suspcom,uint8_t* hcparchkdisable,uint8_t* hcerrataenable,uint8_t* l1suspthrldforhost,uint8_t* l1suspthrldenforhost,uint8_t* devhsnyetbulkspr,uint8_t* resumeopmodehshost,uint8_t* disrefclkgtng,uint8_t* disusb2refclkgtng,uint8_t* reserved1413,uint8_t* parkmodedisablefsls,uint8_t* parkmodedisablehs,uint8_t* parkmodedisabless,uint8_t* nakperenhhs,uint8_t* nakperenhfs,uint8_t* devlsptaillockdis,uint8_t* ipgapaddon,uint8_t* devl1exitbyhw,uint8_t* p3inu2,uint8_t* devforce20clkfor30clk,uint8_t* devtrboutsprind,uint8_t* txipgaplinecheckdis,uint8_t* filterse0fslseop,uint8_t* dsrxdetmaxtoutctrl,uint8_t* devdecouplel1l2evt)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);

       *loafilteren = (localVal & ((uint32_t)0x00000001)) >> 0;
       *ovrldl1suspcom = (localVal & ((uint32_t)0x00000002)) >> 1;
       *hcparchkdisable = (localVal & ((uint32_t)0x00000004)) >> 2;
       *hcerrataenable = (localVal & ((uint32_t)0x00000008)) >> 3;
       *l1suspthrldforhost = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *l1suspthrldenforhost = (localVal & ((uint32_t)0x00000100)) >> 8;
       *devhsnyetbulkspr = (localVal & ((uint32_t)0x00000200)) >> 9;
       *resumeopmodehshost = (localVal & ((uint32_t)0x00000400)) >> 10;
       *disrefclkgtng = (localVal & ((uint32_t)0x00000800)) >> 11;
       *disusb2refclkgtng = (localVal & ((uint32_t)0x00001000)) >> 12;
       *reserved1413 = (localVal & ((uint32_t)0x00006000)) >> 13;
       *parkmodedisablefsls = (localVal & ((uint32_t)0x00008000)) >> 15;
       *parkmodedisablehs = (localVal & ((uint32_t)0x00010000)) >> 16;
       *parkmodedisabless = (localVal & ((uint32_t)0x00020000)) >> 17;
       *nakperenhhs = (localVal & ((uint32_t)0x00040000)) >> 18;
       *nakperenhfs = (localVal & ((uint32_t)0x00080000)) >> 19;
       *devlsptaillockdis = (localVal & ((uint32_t)0x00100000)) >> 20;
       *ipgapaddon = (localVal & ((uint32_t)0x00E00000)) >> 21;
       *devl1exitbyhw = (localVal & ((uint32_t)0x01000000)) >> 24;
       *p3inu2 = (localVal & ((uint32_t)0x02000000)) >> 25;
       *devforce20clkfor30clk = (localVal & ((uint32_t)0x04000000)) >> 26;
       *devtrboutsprind = (localVal & ((uint32_t)0x08000000)) >> 27;
       *txipgaplinecheckdis = (localVal & ((uint32_t)0x10000000)) >> 28;
       *filterse0fslseop = (localVal & ((uint32_t)0x20000000)) >> 29;
       *dsrxdetmaxtoutctrl = (localVal & ((uint32_t)0x40000000)) >> 30;
       *devdecouplel1l2evt = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_guctl1_loa_filter_en_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void  dwc_usb3_guctl1_loa_filter_en_setf(uint8_t  loafilteren)
{
       ASSERT_ERR((((uint32_t)loafilteren << 0) & ~((uint32_t)0x00000001)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)loafilteren <<0));
}
__INLINE uint8_t  dwc_usb3_guctl1_ovrld_l1_susp_com_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void  dwc_usb3_guctl1_ovrld_l1_susp_com_setf(uint8_t  ovrldl1suspcom)
{
       ASSERT_ERR((((uint32_t)ovrldl1suspcom << 1) & ~((uint32_t)0x00000002)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)ovrldl1suspcom <<1));
}
__INLINE uint8_t  dwc_usb3_guctl1_hc_parchk_disable_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void  dwc_usb3_guctl1_hc_parchk_disable_setf(uint8_t  hcparchkdisable)
{
       ASSERT_ERR((((uint32_t)hcparchkdisable << 2) & ~((uint32_t)0x00000004)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)hcparchkdisable <<2));
}
__INLINE uint8_t  dwc_usb3_guctl1_hc_errata_enable_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void  dwc_usb3_guctl1_hc_errata_enable_setf(uint8_t  hcerrataenable)
{
       ASSERT_ERR((((uint32_t)hcerrataenable << 3) & ~((uint32_t)0x00000008)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)hcerrataenable <<3));
}
__INLINE uint8_t  dwc_usb3_guctl1_l1_susp_thrld_for_host_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_guctl1_l1_susp_thrld_for_host_setf(uint8_t  l1suspthrldforhost)
{
       ASSERT_ERR((((uint32_t)l1suspthrldforhost << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)l1suspthrldforhost <<4));
}
__INLINE uint8_t  dwc_usb3_guctl1_l1_susp_thrld_en_for_host_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void  dwc_usb3_guctl1_l1_susp_thrld_en_for_host_setf(uint8_t  l1suspthrldenforhost)
{
       ASSERT_ERR((((uint32_t)l1suspthrldenforhost << 8) & ~((uint32_t)0x00000100)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)l1suspthrldenforhost <<8));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_hs_nyet_bulk_spr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void  dwc_usb3_guctl1_dev_hs_nyet_bulk_spr_setf(uint8_t  devhsnyetbulkspr)
{
       ASSERT_ERR((((uint32_t)devhsnyetbulkspr << 9) & ~((uint32_t)0x00000200)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)devhsnyetbulkspr <<9));
}
__INLINE uint8_t  dwc_usb3_guctl1_resume_opmode_hs_host_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void  dwc_usb3_guctl1_resume_opmode_hs_host_setf(uint8_t  resumeopmodehshost)
{
       ASSERT_ERR((((uint32_t)resumeopmodehshost << 10) & ~((uint32_t)0x00000400)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)resumeopmodehshost <<10));
}
__INLINE uint8_t  dwc_usb3_guctl1_disrefclkgtng_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_guctl1_disusb2refclkgtng_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_guctl1_reserved_14_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00006000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_guctl1_parkmode_disable_fsls_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void  dwc_usb3_guctl1_parkmode_disable_fsls_setf(uint8_t  parkmodedisablefsls)
{
       ASSERT_ERR((((uint32_t)parkmodedisablefsls << 15) & ~((uint32_t)0x00008000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)parkmodedisablefsls <<15));
}
__INLINE uint8_t  dwc_usb3_guctl1_parkmode_disable_hs_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void  dwc_usb3_guctl1_parkmode_disable_hs_setf(uint8_t  parkmodedisablehs)
{
       ASSERT_ERR((((uint32_t)parkmodedisablehs << 16) & ~((uint32_t)0x00010000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)parkmodedisablehs <<16));
}
__INLINE uint8_t  dwc_usb3_guctl1_parkmode_disable_ss_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void  dwc_usb3_guctl1_parkmode_disable_ss_setf(uint8_t  parkmodedisabless)
{
       ASSERT_ERR((((uint32_t)parkmodedisabless << 17) & ~((uint32_t)0x00020000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)parkmodedisabless <<17));
}
__INLINE uint8_t  dwc_usb3_guctl1_nak_per_enh_hs_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void  dwc_usb3_guctl1_nak_per_enh_hs_setf(uint8_t  nakperenhhs)
{
       ASSERT_ERR((((uint32_t)nakperenhhs << 18) & ~((uint32_t)0x00040000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)nakperenhhs <<18));
}
__INLINE uint8_t  dwc_usb3_guctl1_nak_per_enh_fs_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void  dwc_usb3_guctl1_nak_per_enh_fs_setf(uint8_t  nakperenhfs)
{
       ASSERT_ERR((((uint32_t)nakperenhfs << 19) & ~((uint32_t)0x00080000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)nakperenhfs <<19));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_lsp_tail_lock_dis_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void  dwc_usb3_guctl1_dev_lsp_tail_lock_dis_setf(uint8_t  devlsptaillockdis)
{
       ASSERT_ERR((((uint32_t)devlsptaillockdis << 20) & ~((uint32_t)0x00100000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)devlsptaillockdis <<20));
}
__INLINE uint8_t  dwc_usb3_guctl1_ip_gap_add_on_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void  dwc_usb3_guctl1_ip_gap_add_on_setf(uint8_t  ipgapaddon)
{
       ASSERT_ERR((((uint32_t)ipgapaddon << 21) & ~((uint32_t)0x00E00000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)ipgapaddon <<21));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_l1_exit_by_hw_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void  dwc_usb3_guctl1_dev_l1_exit_by_hw_setf(uint8_t  devl1exitbyhw)
{
       ASSERT_ERR((((uint32_t)devl1exitbyhw << 24) & ~((uint32_t)0x01000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)devl1exitbyhw <<24));
}
__INLINE uint8_t  dwc_usb3_guctl1_p3_in_u2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void  dwc_usb3_guctl1_p3_in_u2_setf(uint8_t  p3inu2)
{
       ASSERT_ERR((((uint32_t)p3inu2 << 25) & ~((uint32_t)0x02000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)p3inu2 <<25));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_force_20_clk_for_30_clk_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void  dwc_usb3_guctl1_dev_force_20_clk_for_30_clk_setf(uint8_t  devforce20clkfor30clk)
{
       ASSERT_ERR((((uint32_t)devforce20clkfor30clk << 26) & ~((uint32_t)0x04000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)devforce20clkfor30clk <<26));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_trb_out_spr_ind_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void  dwc_usb3_guctl1_dev_trb_out_spr_ind_setf(uint8_t  devtrboutsprind)
{
       ASSERT_ERR((((uint32_t)devtrboutsprind << 27) & ~((uint32_t)0x08000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)devtrboutsprind <<27));
}
__INLINE uint8_t  dwc_usb3_guctl1_tx_ipgap_linecheck_dis_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void  dwc_usb3_guctl1_tx_ipgap_linecheck_dis_setf(uint8_t  txipgaplinecheckdis)
{
       ASSERT_ERR((((uint32_t)txipgaplinecheckdis << 28) & ~((uint32_t)0x10000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)txipgaplinecheckdis <<28));
}
__INLINE uint8_t  dwc_usb3_guctl1_filter_se0_fsls_eop_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void  dwc_usb3_guctl1_filter_se0_fsls_eop_setf(uint8_t  filterse0fslseop)
{
       ASSERT_ERR((((uint32_t)filterse0fslseop << 29) & ~((uint32_t)0x20000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)filterse0fslseop <<29));
}
__INLINE uint8_t  dwc_usb3_guctl1_ds_rxdet_max_tout_ctrl_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void  dwc_usb3_guctl1_ds_rxdet_max_tout_ctrl_setf(uint8_t  dsrxdetmaxtoutctrl)
{
       ASSERT_ERR((((uint32_t)dsrxdetmaxtoutctrl << 30) & ~((uint32_t)0x40000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)dsrxdetmaxtoutctrl <<30));
}
__INLINE uint8_t  dwc_usb3_guctl1_dev_decouple_l1l2_evt_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL1_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void  dwc_usb3_guctl1_dev_decouple_l1l2_evt_setf(uint8_t  devdecouplel1l2evt)
{
       ASSERT_ERR((((uint32_t)devdecouplel1l2evt << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL1_ADDR, (REG_PL_RD(DWC_usb3_GUCTL1_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)devdecouplel1l2evt <<31));
}
/**
* \@brief GSNPSID register definition
* Global Synopsys ID Register

This is a read-only register that contains the release number of the controller.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      SYNOPSYSID                              0x5533330b
* </pre>
*/
#define DWC_usb3_GSNPSID_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C120)
#define DWC_usb3_GSNPSID_OFFSET      0x0000C120
#define DWC_usb3_GSNPSID_INDEX       0x3048
__INLINE uint32_t dwc_usb3_gsnpsid_get(void)
{
       return REG_PL_RD(DWC_usb3_GSNPSID_ADDR);
}

__INLINE void dwc_usb3_gsnpsid_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GSNPSID_ADDR,value);
}
// field definitions
#define DWC_usb3_GSNPSID_SYNOPSYSID_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GSNPSID_SYNOPSYSID_LSB     0
#define DWC_usb3_GSNPSID_SYNOPSYSID_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GSNPSID_SYNOPSYSID_RST     0x5533330b

__INLINE void dwc_usb3_gsnpsid_pack(uint32_t synopsysid)
{
       ASSERT_ERR((((uint32_t)synopsysid << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GSNPSID_ADDR, ((uint32_t)synopsysid << 0));
}

__INLINE void dwc_usb3_gsnpsid_unpack(uint32_t* synopsysid)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSNPSID_ADDR);

       *synopsysid = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gsnpsid_synopsysid_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GSNPSID_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GGPIO register definition
* Global General Purpose Input/Output Register

The application can use this register for general purpose input and output ports or for debugging.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:15      GPI                                     0x0
*    16:31      GPO                                     0x0
* </pre>
*/
#define DWC_usb3_GGPIO_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C124)
#define DWC_usb3_GGPIO_OFFSET      0x0000C124
#define DWC_usb3_GGPIO_INDEX       0x3049
__INLINE uint32_t dwc_usb3_ggpio_get(void)
{
       return REG_PL_RD(DWC_usb3_GGPIO_ADDR);
}

__INLINE void dwc_usb3_ggpio_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GGPIO_ADDR,value);
}
// field definitions
#define DWC_usb3_GGPIO_GPI_MASK    ((uint32_t)0x0000FFFF)
#define DWC_usb3_GGPIO_GPI_LSB     0
#define DWC_usb3_GGPIO_GPI_WIDTH   ((uint32_t)0x00000010)
#define DWC_usb3_GGPIO_GPO_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_GGPIO_GPO_LSB     16
#define DWC_usb3_GGPIO_GPO_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_GGPIO_GPI_RST     0x0
#define DWC_usb3_GGPIO_GPO_RST     0x0

__INLINE void dwc_usb3_ggpio_pack(uint16_t gpi,uint16_t gpo)
{
       ASSERT_ERR((((uint32_t)gpi << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       ASSERT_ERR((((uint32_t)gpo << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GGPIO_ADDR, ((uint32_t)gpi << 0) |((uint32_t)gpo << 16));
}

__INLINE void dwc_usb3_ggpio_unpack(uint16_t* gpi,uint16_t* gpo)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GGPIO_ADDR);

       *gpi = (localVal & ((uint32_t)0x0000FFFF)) >> 0;
       *gpo = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint16_t  dwc_usb3_ggpio_gpi_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GGPIO_ADDR);
       return ((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE uint16_t  dwc_usb3_ggpio_gpo_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GGPIO_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void  dwc_usb3_ggpio_gpo_setf(uint16_t  gpo)
{
       ASSERT_ERR((((uint32_t)gpo << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GGPIO_ADDR, (REG_PL_RD(DWC_usb3_GGPIO_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)gpo <<16));
}
/**
* \@brief GUID register definition
* Global User ID Register

This is a read/write register containing the User ID. The power-on value for this register is specified as the User Identification Register. Power-on value during coreConsultant configuration (parameter DWC_USB3_USERID). This register can be used in the following ways:
 - To store the version or revision of your system;
 - To store hardware configurations that are outside the controller;
 - As a scratch register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      USERID                                  0xcafecafe
* </pre>
*/
#define DWC_usb3_GUID_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C128)
#define DWC_usb3_GUID_OFFSET      0x0000C128
#define DWC_usb3_GUID_INDEX       0x304a
__INLINE uint32_t dwc_usb3_guid_get(void)
{
       return REG_PL_RD(DWC_usb3_GUID_ADDR);
}

__INLINE void dwc_usb3_guid_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GUID_ADDR,value);
}
// field definitions
#define DWC_usb3_GUID_USERID_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GUID_USERID_LSB     0
#define DWC_usb3_GUID_USERID_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GUID_USERID_RST     0xcafecafe

__INLINE void dwc_usb3_guid_pack(uint32_t userid)
{
       ASSERT_ERR((((uint32_t)userid << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GUID_ADDR, ((uint32_t)userid << 0));
}

__INLINE void dwc_usb3_guid_unpack(uint32_t* userid)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUID_ADDR);

       *userid = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_guid_userid_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUID_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
__INLINE void  dwc_usb3_guid_userid_setf(uint32_t  userid)
{
       ASSERT_ERR((((uint32_t)userid << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GUID_ADDR, (REG_PL_RD(DWC_usb3_GUID_ADDR) & ~((uint32_t)0xFFFFFFFF)) | ((uint32_t)userid <<0));
}
/**
* \@brief GUCTL register definition
* Global User Control Register:  

This register provides a few options for the software to control the controller behavior in the Host mode. Most of the options are used to improve host inter-operability with different devices.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:08       DTFT                                    0x10
*    09:10      DTCT                                    0x0
*    11         InsrtExtrFSBODI                         0x0
*    12         ExtCapSupptEN                           0x0
*    13         EnOverlapChk                            0x0
*    14         USBHstInAutoRetryEn                     0x0
*    15         reserved_15                             0x0
*    16         ResBwHSEPS                              0x0
*    17         SprsCtrlTransEn                         0x0
*    18:20      reserved_20_18                          0x0
*    21         NoExtrDl                                0x0
*    22:31      REFCLKPER                               0x8
* </pre>
*/
#define DWC_usb3_GUCTL_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C12C)
#define DWC_usb3_GUCTL_OFFSET      0x0000C12C
#define DWC_usb3_GUCTL_INDEX       0x304b
__INLINE uint32_t dwc_usb3_guctl_get(void)
{
       return REG_PL_RD(DWC_usb3_GUCTL_ADDR);
}

__INLINE void dwc_usb3_guctl_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GUCTL_ADDR,value);
}
// field definitions
#define DWC_usb3_GUCTL_DTFT_MASK    ((uint32_t)0x000001FF)
#define DWC_usb3_GUCTL_DTFT_LSB     0
#define DWC_usb3_GUCTL_DTFT_WIDTH   ((uint32_t)0x00000009)
#define DWC_usb3_GUCTL_DTCT_MASK    ((uint32_t)0x00000600)
#define DWC_usb3_GUCTL_DTCT_LSB     9
#define DWC_usb3_GUCTL_DTCT_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GUCTL_InsrtExtrFSBODI_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GUCTL_InsrtExtrFSBODI_POS     11
#define DWC_usb3_GUCTL_ExtCapSupptEN_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GUCTL_ExtCapSupptEN_POS     12
#define DWC_usb3_GUCTL_EnOverlapChk_BIT     ((uint32_t)0x00002000)
#define DWC_usb3_GUCTL_EnOverlapChk_POS     13
#define DWC_usb3_GUCTL_USBHstInAutoRetryEn_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_GUCTL_USBHstInAutoRetryEn_POS     14
#define DWC_usb3_GUCTL_reserved_15_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GUCTL_reserved_15_POS     15
#define DWC_usb3_GUCTL_ResBwHSEPS_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_GUCTL_ResBwHSEPS_POS     16
#define DWC_usb3_GUCTL_SprsCtrlTransEn_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_GUCTL_SprsCtrlTransEn_POS     17
#define DWC_usb3_GUCTL_reserved_20_18_MASK    ((uint32_t)0x001C0000)
#define DWC_usb3_GUCTL_reserved_20_18_LSB     18
#define DWC_usb3_GUCTL_reserved_20_18_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GUCTL_NoExtrDl_BIT     ((uint32_t)0x00200000)
#define DWC_usb3_GUCTL_NoExtrDl_POS     21
#define DWC_usb3_GUCTL_REFCLKPER_MASK    ((uint32_t)0xFFC00000)
#define DWC_usb3_GUCTL_REFCLKPER_LSB     22
#define DWC_usb3_GUCTL_REFCLKPER_WIDTH   ((uint32_t)0x0000000A)

#define DWC_usb3_GUCTL_DTFT_RST     0x10
#define DWC_usb3_GUCTL_DTCT_RST     0x0
#define DWC_usb3_GUCTL_InsrtExtrFSBODI_RST     0x0
#define DWC_usb3_GUCTL_ExtCapSupptEN_RST     0x0
#define DWC_usb3_GUCTL_EnOverlapChk_RST     0x0
#define DWC_usb3_GUCTL_USBHstInAutoRetryEn_RST     0x0
#define DWC_usb3_GUCTL_reserved_15_RST     0x0
#define DWC_usb3_GUCTL_ResBwHSEPS_RST     0x0
#define DWC_usb3_GUCTL_SprsCtrlTransEn_RST     0x0
#define DWC_usb3_GUCTL_reserved_20_18_RST     0x0
#define DWC_usb3_GUCTL_NoExtrDl_RST     0x0
#define DWC_usb3_GUCTL_REFCLKPER_RST     0x8

__INLINE void dwc_usb3_guctl_pack(uint16_t dtft,uint8_t dtct,uint8_t insrtextrfsbodi,uint8_t extcapsuppten,uint8_t enoverlapchk,uint8_t usbhstinautoretryen,uint8_t reserved15,uint8_t resbwhseps,uint8_t sprsctrltransen,uint8_t reserved2018,uint8_t noextrdl,uint16_t refclkper)
{
       ASSERT_ERR((((uint32_t)dtft << 0) & ~((uint32_t)0x000001FF)) == 0);
       ASSERT_ERR((((uint32_t)dtct << 9) & ~((uint32_t)0x00000600)) == 0);
       ASSERT_ERR((((uint32_t)insrtextrfsbodi << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)extcapsuppten << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)enoverlapchk << 13) & ~((uint32_t)0x00002000)) == 0);
       ASSERT_ERR((((uint32_t)usbhstinautoretryen << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)reserved15 << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)resbwhseps << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)sprsctrltransen << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)reserved2018 << 18) & ~((uint32_t)0x001C0000)) == 0);
       ASSERT_ERR((((uint32_t)noextrdl << 21) & ~((uint32_t)0x00200000)) == 0);
       ASSERT_ERR((((uint32_t)refclkper << 22) & ~((uint32_t)0xFFC00000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, ((uint32_t)dtft << 0) |((uint32_t)dtct << 9) |((uint32_t)insrtextrfsbodi << 11) |((uint32_t)extcapsuppten << 12) |((uint32_t)enoverlapchk << 13) |((uint32_t)usbhstinautoretryen << 14) |((uint32_t)reserved15 << 15) |((uint32_t)resbwhseps << 16) |((uint32_t)sprsctrltransen << 17) |((uint32_t)reserved2018 << 18) |((uint32_t)noextrdl << 21) |((uint32_t)refclkper << 22));
}

__INLINE void dwc_usb3_guctl_unpack(uint16_t* dtft,uint8_t* dtct,uint8_t* insrtextrfsbodi,uint8_t* extcapsuppten,uint8_t* enoverlapchk,uint8_t* usbhstinautoretryen,uint8_t* reserved15,uint8_t* resbwhseps,uint8_t* sprsctrltransen,uint8_t* reserved2018,uint8_t* noextrdl,uint16_t* refclkper)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);

       *dtft = (localVal & ((uint32_t)0x000001FF)) >> 0;
       *dtct = (localVal & ((uint32_t)0x00000600)) >> 9;
       *insrtextrfsbodi = (localVal & ((uint32_t)0x00000800)) >> 11;
       *extcapsuppten = (localVal & ((uint32_t)0x00001000)) >> 12;
       *enoverlapchk = (localVal & ((uint32_t)0x00002000)) >> 13;
       *usbhstinautoretryen = (localVal & ((uint32_t)0x00004000)) >> 14;
       *reserved15 = (localVal & ((uint32_t)0x00008000)) >> 15;
       *resbwhseps = (localVal & ((uint32_t)0x00010000)) >> 16;
       *sprsctrltransen = (localVal & ((uint32_t)0x00020000)) >> 17;
       *reserved2018 = (localVal & ((uint32_t)0x001C0000)) >> 18;
       *noextrdl = (localVal & ((uint32_t)0x00200000)) >> 21;
       *refclkper = (localVal & ((uint32_t)0xFFC00000)) >> 22;
}
__INLINE uint16_t  dwc_usb3_guctl_dtft_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x000001FF)) >> 0);
}
__INLINE void  dwc_usb3_guctl_dtft_setf(uint16_t  dtft)
{
       ASSERT_ERR((((uint32_t)dtft << 0) & ~((uint32_t)0x000001FF)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x000001FF)) | ((uint32_t)dtft <<0));
}
__INLINE uint8_t  dwc_usb3_guctl_dtct_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE void  dwc_usb3_guctl_dtct_setf(uint8_t  dtct)
{
       ASSERT_ERR((((uint32_t)dtct << 9) & ~((uint32_t)0x00000600)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00000600)) | ((uint32_t)dtct <<9));
}
__INLINE uint8_t  dwc_usb3_guctl_insrtextrfsbodi_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void  dwc_usb3_guctl_insrtextrfsbodi_setf(uint8_t  insrtextrfsbodi)
{
       ASSERT_ERR((((uint32_t)insrtextrfsbodi << 11) & ~((uint32_t)0x00000800)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)insrtextrfsbodi <<11));
}
__INLINE uint8_t  dwc_usb3_guctl_extcapsuppten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void  dwc_usb3_guctl_extcapsuppten_setf(uint8_t  extcapsuppten)
{
       ASSERT_ERR((((uint32_t)extcapsuppten << 12) & ~((uint32_t)0x00001000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)extcapsuppten <<12));
}
__INLINE uint8_t  dwc_usb3_guctl_enoverlapchk_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void  dwc_usb3_guctl_enoverlapchk_setf(uint8_t  enoverlapchk)
{
       ASSERT_ERR((((uint32_t)enoverlapchk << 13) & ~((uint32_t)0x00002000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)enoverlapchk <<13));
}
__INLINE uint8_t  dwc_usb3_guctl_usbhstinautoretryen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void  dwc_usb3_guctl_usbhstinautoretryen_setf(uint8_t  usbhstinautoretryen)
{
       ASSERT_ERR((((uint32_t)usbhstinautoretryen << 14) & ~((uint32_t)0x00004000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)usbhstinautoretryen <<14));
}
__INLINE uint8_t  dwc_usb3_guctl_reserved_15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_guctl_resbwhseps_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void  dwc_usb3_guctl_resbwhseps_setf(uint8_t  resbwhseps)
{
       ASSERT_ERR((((uint32_t)resbwhseps << 16) & ~((uint32_t)0x00010000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)resbwhseps <<16));
}
__INLINE uint8_t  dwc_usb3_guctl_sprsctrltransen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void  dwc_usb3_guctl_sprsctrltransen_setf(uint8_t  sprsctrltransen)
{
       ASSERT_ERR((((uint32_t)sprsctrltransen << 17) & ~((uint32_t)0x00020000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)sprsctrltransen <<17));
}
__INLINE uint8_t  dwc_usb3_guctl_reserved_20_18_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x001C0000)) >> 18);
}
__INLINE uint8_t  dwc_usb3_guctl_noextrdl_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void  dwc_usb3_guctl_noextrdl_setf(uint8_t  noextrdl)
{
       ASSERT_ERR((((uint32_t)noextrdl << 21) & ~((uint32_t)0x00200000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)noextrdl <<21));
}
__INLINE uint16_t  dwc_usb3_guctl_refclkper_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL_ADDR);
       return ((localVal & ((uint32_t)0xFFC00000)) >> 22);
}
__INLINE void  dwc_usb3_guctl_refclkper_setf(uint16_t  refclkper)
{
       ASSERT_ERR((((uint32_t)refclkper << 22) & ~((uint32_t)0xFFC00000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL_ADDR, (REG_PL_RD(DWC_usb3_GUCTL_ADDR) & ~((uint32_t)0xFFC00000)) | ((uint32_t)refclkper <<22));
}
/**
* \@brief GBUSERRADDRLO register definition
* Gobal SoC Bus Error Address Register - Low

This is an alternate register for the GBUSERRADDR register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      BUSERRADDR                              0x0
* </pre>
*/
#define DWC_usb3_GBUSERRADDRLO_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C130)
#define DWC_usb3_GBUSERRADDRLO_OFFSET      0x0000C130
#define DWC_usb3_GBUSERRADDRLO_INDEX       0x304c
__INLINE uint32_t dwc_usb3_gbuserraddrlo_get(void)
{
       return REG_PL_RD(DWC_usb3_GBUSERRADDRLO_ADDR);
}

__INLINE void dwc_usb3_gbuserraddrlo_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GBUSERRADDRLO_ADDR,value);
}
// field definitions
#define DWC_usb3_GBUSERRADDRLO_BUSERRADDR_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GBUSERRADDRLO_BUSERRADDR_LSB     0
#define DWC_usb3_GBUSERRADDRLO_BUSERRADDR_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GBUSERRADDRLO_BUSERRADDR_RST     0x0

__INLINE void dwc_usb3_gbuserraddrlo_pack(uint32_t buserraddr)
{
       ASSERT_ERR((((uint32_t)buserraddr << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GBUSERRADDRLO_ADDR, ((uint32_t)buserraddr << 0));
}

__INLINE void dwc_usb3_gbuserraddrlo_unpack(uint32_t* buserraddr)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GBUSERRADDRLO_ADDR);

       *buserraddr = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gbuserraddrlo_buserraddr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GBUSERRADDRLO_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GBUSERRADDRHI register definition
* Gobal SoC Bus Error Address Register - High

This is an alternate register for the GBUSERRADDR register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      BUSERRADDR                              0x0
* </pre>
*/
#define DWC_usb3_GBUSERRADDRHI_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C134)
#define DWC_usb3_GBUSERRADDRHI_OFFSET      0x0000C134
#define DWC_usb3_GBUSERRADDRHI_INDEX       0x304d
__INLINE uint32_t dwc_usb3_gbuserraddrhi_get(void)
{
       return REG_PL_RD(DWC_usb3_GBUSERRADDRHI_ADDR);
}

__INLINE void dwc_usb3_gbuserraddrhi_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GBUSERRADDRHI_ADDR,value);
}
// field definitions
#define DWC_usb3_GBUSERRADDRHI_BUSERRADDR_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GBUSERRADDRHI_BUSERRADDR_LSB     0
#define DWC_usb3_GBUSERRADDRHI_BUSERRADDR_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GBUSERRADDRHI_BUSERRADDR_RST     0x0

__INLINE void dwc_usb3_gbuserraddrhi_pack(uint32_t buserraddr)
{
       ASSERT_ERR((((uint32_t)buserraddr << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GBUSERRADDRHI_ADDR, ((uint32_t)buserraddr << 0));
}

__INLINE void dwc_usb3_gbuserraddrhi_unpack(uint32_t* buserraddr)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GBUSERRADDRHI_ADDR);

       *buserraddr = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gbuserraddrhi_buserraddr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GBUSERRADDRHI_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GPRTBIMAPLO register definition
* Global SS Port to Bus Instance Mapping Register - Low

This is an alternate register for the GPRTBIMAP register.

Register fields are read-write with respect to number of port instantiated. writeAsRead constraint is added to limit side effects for unused fields. 

For a configuration with number of USB 3.0 ports same as number of SS Bus Instances, do not remap during debug session. If you remap for some reason, then the debug host must be connected to a port which has a dedicated SS Bus Instance.

For example, if DWC_USB3_NUM_U3_ROOT_PORTS =3 and DWC_USB3_NUM_SS_USB_INSTANCES=3, and software maps the first SS port to the first SS BI and the second/third port to the second BI, then the debug host can be connected to the first port only.

Note: For reset values, refer to the corresponding values in the GPRTBIMAP register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM1                                  0x0
*    04:07       BINUM2                                  0x0
*    08:11      BINUM3                                  0x0
*    12:15      BINUM4                                  0x0
*    16:19      BINUM5                                  0x0
*    20:23      BINUM6                                  0x0
*    24:27      BINUM7                                  0x0
*    28:31      BINUM8                                  0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAPLO_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C138)
#define DWC_usb3_GPRTBIMAPLO_OFFSET      0x0000C138
#define DWC_usb3_GPRTBIMAPLO_INDEX       0x304e
__INLINE uint32_t dwc_usb3_gprtbimaplo_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
}

__INLINE void dwc_usb3_gprtbimaplo_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAPLO_BINUM1_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAPLO_BINUM1_LSB     0
#define DWC_usb3_GPRTBIMAPLO_BINUM1_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM2_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAPLO_BINUM2_LSB     4
#define DWC_usb3_GPRTBIMAPLO_BINUM2_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM3_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAPLO_BINUM3_LSB     8
#define DWC_usb3_GPRTBIMAPLO_BINUM3_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM4_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAPLO_BINUM4_LSB     12
#define DWC_usb3_GPRTBIMAPLO_BINUM4_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM5_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAPLO_BINUM5_LSB     16
#define DWC_usb3_GPRTBIMAPLO_BINUM5_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM6_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAPLO_BINUM6_LSB     20
#define DWC_usb3_GPRTBIMAPLO_BINUM6_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM7_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAPLO_BINUM7_LSB     24
#define DWC_usb3_GPRTBIMAPLO_BINUM7_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPLO_BINUM8_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAPLO_BINUM8_LSB     28
#define DWC_usb3_GPRTBIMAPLO_BINUM8_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAPLO_BINUM1_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM2_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM3_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM4_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM5_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM6_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM7_RST     0x0
#define DWC_usb3_GPRTBIMAPLO_BINUM8_RST     0x0

__INLINE void dwc_usb3_gprtbimaplo_pack(uint8_t binum1,uint8_t binum2,uint8_t binum3,uint8_t binum4,uint8_t binum5,uint8_t binum6,uint8_t binum7,uint8_t binum8)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, ((uint32_t)binum1 << 0) |((uint32_t)binum2 << 4) |((uint32_t)binum3 << 8) |((uint32_t)binum4 << 12) |((uint32_t)binum5 << 16) |((uint32_t)binum6 << 20) |((uint32_t)binum7 << 24) |((uint32_t)binum8 << 28));
}

__INLINE void dwc_usb3_gprtbimaplo_unpack(uint8_t* binum1,uint8_t* binum2,uint8_t* binum3,uint8_t* binum4,uint8_t* binum5,uint8_t* binum6,uint8_t* binum7,uint8_t* binum8)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);

       *binum1 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum2 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum3 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum4 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum5 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum6 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum7 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *binum8 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum1_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum1_setf(uint8_t  binum1)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum1 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum2_setf(uint8_t  binum2)
{
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum2 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum3_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum3_setf(uint8_t  binum3)
{
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum3 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum4_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum4_setf(uint8_t  binum4)
{
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum4 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum5_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum5_setf(uint8_t  binum5)
{
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum5 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum6_setf(uint8_t  binum6)
{
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum6 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum7_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum7_setf(uint8_t  binum7)
{
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum7 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimaplo_binum8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void  dwc_usb3_gprtbimaplo_binum8_setf(uint8_t  binum8)
{
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPLO_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)binum8 <<28));
}
/**
* \@brief GPRTBIMAPHI register definition
* Global SS Port to Bus Instance Mapping Register - High

This is an alternate register for the GPRTBIMAP register.

For a configuration with number of USB 3.0 ports same as number of SS Bus Instances, do not remap during debug session. If you remap for some reason, then the debug host must be connected to a port which has a dedicated SS Bus Instance.

For example, if DWC_USB3_NUM_U3_ROOT_PORTS =3 and DWC_USB3_NUM_SS_USB_INSTANCES=3, and software maps the first SS port to the first SS BI and the second/third port to the second BI, then the debug host can be connected to the first port only.

Note: For reset values, refer to the corresponding values in the GPRTBIMAP register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM9                                  0x0
*    04:07       BINUM10                                 0x0
*    08:11      BINUM11                                 0x0
*    12:15      BINUM12                                 0x0
*    16:19      BINUM13                                 0x0
*    20:23      BINUM14                                 0x0
*    24:27      BINUM15                                 0x0
*    28:31      reserved_31_28                          0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAPHI_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C13C)
#define DWC_usb3_GPRTBIMAPHI_OFFSET      0x0000C13C
#define DWC_usb3_GPRTBIMAPHI_INDEX       0x304f
__INLINE uint32_t dwc_usb3_gprtbimaphi_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
}

__INLINE void dwc_usb3_gprtbimaphi_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAPHI_BINUM9_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAPHI_BINUM9_LSB     0
#define DWC_usb3_GPRTBIMAPHI_BINUM9_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM10_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAPHI_BINUM10_LSB     4
#define DWC_usb3_GPRTBIMAPHI_BINUM10_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM11_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAPHI_BINUM11_LSB     8
#define DWC_usb3_GPRTBIMAPHI_BINUM11_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM12_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAPHI_BINUM12_LSB     12
#define DWC_usb3_GPRTBIMAPHI_BINUM12_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM13_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAPHI_BINUM13_LSB     16
#define DWC_usb3_GPRTBIMAPHI_BINUM13_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM14_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAPHI_BINUM14_LSB     20
#define DWC_usb3_GPRTBIMAPHI_BINUM14_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_BINUM15_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAPHI_BINUM15_LSB     24
#define DWC_usb3_GPRTBIMAPHI_BINUM15_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAPHI_reserved_31_28_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAPHI_reserved_31_28_LSB     28
#define DWC_usb3_GPRTBIMAPHI_reserved_31_28_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAPHI_BINUM9_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM10_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM11_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM12_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM13_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM14_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_BINUM15_RST     0x0
#define DWC_usb3_GPRTBIMAPHI_reserved_31_28_RST     0x0

__INLINE void dwc_usb3_gprtbimaphi_pack(uint8_t binum9,uint8_t binum10,uint8_t binum11,uint8_t binum12,uint8_t binum13,uint8_t binum14,uint8_t binum15,uint8_t reserved3128)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3128 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, ((uint32_t)binum9 << 0) |((uint32_t)binum10 << 4) |((uint32_t)binum11 << 8) |((uint32_t)binum12 << 12) |((uint32_t)binum13 << 16) |((uint32_t)binum14 << 20) |((uint32_t)binum15 << 24) |((uint32_t)reserved3128 << 28));
}

__INLINE void dwc_usb3_gprtbimaphi_unpack(uint8_t* binum9,uint8_t* binum10,uint8_t* binum11,uint8_t* binum12,uint8_t* binum13,uint8_t* binum14,uint8_t* binum15,uint8_t* reserved3128)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);

       *binum9 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum10 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum11 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum12 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum13 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum14 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum15 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *reserved3128 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum9_setf(uint8_t  binum9)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum9 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum10_setf(uint8_t  binum10)
{
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum10 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum11_setf(uint8_t  binum11)
{
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum11 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum12_setf(uint8_t  binum12)
{
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum12 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum13_setf(uint8_t  binum13)
{
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum13 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum14_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum14_setf(uint8_t  binum14)
{
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum14 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_binum15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimaphi_binum15_setf(uint8_t  binum15)
{
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAPHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum15 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimaphi_reserved_31_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAPHI_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
/**
* \@brief GHWPARAMS0 register definition
* Global Hardware Parameters Register 0

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:02       ghwparams0_2_0                          0x0
*    03:05       ghwparams0_5_3                          0x1
*    06:07       ghwparams0_7_6                          0x1
*    08:15      ghwparams0_15_8                         0x20
*    16:23      ghwparams0_23_16                        0x20
*    24:31      ghwparams0_31_24                        0x20
* </pre>
*/
#define DWC_usb3_GHWPARAMS0_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C140)
#define DWC_usb3_GHWPARAMS0_OFFSET      0x0000C140
#define DWC_usb3_GHWPARAMS0_INDEX       0x3050
__INLINE uint32_t dwc_usb3_ghwparams0_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
}

__INLINE void dwc_usb3_ghwparams0_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS0_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS0_ghwparams0_2_0_MASK    ((uint32_t)0x00000007)
#define DWC_usb3_GHWPARAMS0_ghwparams0_2_0_LSB     0
#define DWC_usb3_GHWPARAMS0_ghwparams0_2_0_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS0_ghwparams0_5_3_MASK    ((uint32_t)0x00000038)
#define DWC_usb3_GHWPARAMS0_ghwparams0_5_3_LSB     3
#define DWC_usb3_GHWPARAMS0_ghwparams0_5_3_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS0_ghwparams0_7_6_MASK    ((uint32_t)0x000000C0)
#define DWC_usb3_GHWPARAMS0_ghwparams0_7_6_LSB     6
#define DWC_usb3_GHWPARAMS0_ghwparams0_7_6_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS0_ghwparams0_15_8_MASK    ((uint32_t)0x0000FF00)
#define DWC_usb3_GHWPARAMS0_ghwparams0_15_8_LSB     8
#define DWC_usb3_GHWPARAMS0_ghwparams0_15_8_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GHWPARAMS0_ghwparams0_23_16_MASK    ((uint32_t)0x00FF0000)
#define DWC_usb3_GHWPARAMS0_ghwparams0_23_16_LSB     16
#define DWC_usb3_GHWPARAMS0_ghwparams0_23_16_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GHWPARAMS0_ghwparams0_31_24_MASK    ((uint32_t)0xFF000000)
#define DWC_usb3_GHWPARAMS0_ghwparams0_31_24_LSB     24
#define DWC_usb3_GHWPARAMS0_ghwparams0_31_24_WIDTH   ((uint32_t)0x00000008)

#define DWC_usb3_GHWPARAMS0_ghwparams0_2_0_RST     0x0
#define DWC_usb3_GHWPARAMS0_ghwparams0_5_3_RST     0x1
#define DWC_usb3_GHWPARAMS0_ghwparams0_7_6_RST     0x1
#define DWC_usb3_GHWPARAMS0_ghwparams0_15_8_RST     0x20
#define DWC_usb3_GHWPARAMS0_ghwparams0_23_16_RST     0x20
#define DWC_usb3_GHWPARAMS0_ghwparams0_31_24_RST     0x20

__INLINE void dwc_usb3_ghwparams0_pack(uint8_t ghwparams020,uint8_t ghwparams053,uint8_t ghwparams076,uint8_t ghwparams0158,uint8_t ghwparams02316,uint8_t ghwparams03124)
{
       ASSERT_ERR((((uint32_t)ghwparams020 << 0) & ~((uint32_t)0x00000007)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams053 << 3) & ~((uint32_t)0x00000038)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams076 << 6) & ~((uint32_t)0x000000C0)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams0158 << 8) & ~((uint32_t)0x0000FF00)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams02316 << 16) & ~((uint32_t)0x00FF0000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams03124 << 24) & ~((uint32_t)0xFF000000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS0_ADDR, ((uint32_t)ghwparams020 << 0) |((uint32_t)ghwparams053 << 3) |((uint32_t)ghwparams076 << 6) |((uint32_t)ghwparams0158 << 8) |((uint32_t)ghwparams02316 << 16) |((uint32_t)ghwparams03124 << 24));
}

__INLINE void dwc_usb3_ghwparams0_unpack(uint8_t* ghwparams020,uint8_t* ghwparams053,uint8_t* ghwparams076,uint8_t* ghwparams0158,uint8_t* ghwparams02316,uint8_t* ghwparams03124)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);

       *ghwparams020 = (localVal & ((uint32_t)0x00000007)) >> 0;
       *ghwparams053 = (localVal & ((uint32_t)0x00000038)) >> 3;
       *ghwparams076 = (localVal & ((uint32_t)0x000000C0)) >> 6;
       *ghwparams0158 = (localVal & ((uint32_t)0x0000FF00)) >> 8;
       *ghwparams02316 = (localVal & ((uint32_t)0x00FF0000)) >> 16;
       *ghwparams03124 = (localVal & ((uint32_t)0xFF000000)) >> 24;
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_2_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_5_3_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0x00000038)) >> 3);
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_7_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0x000000C0)) >> 6);
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_15_8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_23_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t  dwc_usb3_ghwparams0_ghwparams0_31_24_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS0_ADDR);
       return ((localVal & ((uint32_t)0xFF000000)) >> 24);
}
/**
* \@brief GHWPARAMS1 register definition
* Global Hardware Parameters Register 1

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:02       ghwparams1_2_0                          0x3
*    03:05       ghwparams1_5_3                          0x7
*    06:08       ghwparams1_8_6                          0x4
*    09:11      ghwparams1_11_9                         0x4
*    12:14      ghwparams1_14_12                        0x4
*    15:20      ghwparams1_20_15                        0x1
*    21:22      ghwparams1_22_21                        0x3
*    23         ghwparams1_23                           0x0
*    24:25      ghwparams1_25_24                        0x1
*    26         ghwparams1_26                           0x0
*    27         ghwparams1_27                           0x0
*    28         ghwparams1_28                           0x0
*    29         ghwparams1_29                           0x0
*    30         ghwparams1_30                           0x0
*    31         ghwparams1_31                           0x0
* </pre>
*/
#define DWC_usb3_GHWPARAMS1_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C144)
#define DWC_usb3_GHWPARAMS1_OFFSET      0x0000C144
#define DWC_usb3_GHWPARAMS1_INDEX       0x3051
__INLINE uint32_t dwc_usb3_ghwparams1_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
}

__INLINE void dwc_usb3_ghwparams1_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS1_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS1_ghwparams1_2_0_MASK    ((uint32_t)0x00000007)
#define DWC_usb3_GHWPARAMS1_ghwparams1_2_0_LSB     0
#define DWC_usb3_GHWPARAMS1_ghwparams1_2_0_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS1_ghwparams1_5_3_MASK    ((uint32_t)0x00000038)
#define DWC_usb3_GHWPARAMS1_ghwparams1_5_3_LSB     3
#define DWC_usb3_GHWPARAMS1_ghwparams1_5_3_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS1_ghwparams1_8_6_MASK    ((uint32_t)0x000001C0)
#define DWC_usb3_GHWPARAMS1_ghwparams1_8_6_LSB     6
#define DWC_usb3_GHWPARAMS1_ghwparams1_8_6_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS1_ghwparams1_11_9_MASK    ((uint32_t)0x00000E00)
#define DWC_usb3_GHWPARAMS1_ghwparams1_11_9_LSB     9
#define DWC_usb3_GHWPARAMS1_ghwparams1_11_9_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS1_ghwparams1_14_12_MASK    ((uint32_t)0x00007000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_14_12_LSB     12
#define DWC_usb3_GHWPARAMS1_ghwparams1_14_12_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS1_ghwparams1_20_15_MASK    ((uint32_t)0x001F8000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_20_15_LSB     15
#define DWC_usb3_GHWPARAMS1_ghwparams1_20_15_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS1_ghwparams1_22_21_MASK    ((uint32_t)0x00600000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_22_21_LSB     21
#define DWC_usb3_GHWPARAMS1_ghwparams1_22_21_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS1_ghwparams1_23_BIT     ((uint32_t)0x00800000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_23_POS     23
#define DWC_usb3_GHWPARAMS1_ghwparams1_25_24_MASK    ((uint32_t)0x03000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_25_24_LSB     24
#define DWC_usb3_GHWPARAMS1_ghwparams1_25_24_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS1_ghwparams1_26_BIT     ((uint32_t)0x04000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_26_POS     26
#define DWC_usb3_GHWPARAMS1_ghwparams1_27_BIT     ((uint32_t)0x08000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_27_POS     27
#define DWC_usb3_GHWPARAMS1_ghwparams1_28_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_28_POS     28
#define DWC_usb3_GHWPARAMS1_ghwparams1_29_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_29_POS     29
#define DWC_usb3_GHWPARAMS1_ghwparams1_30_BIT     ((uint32_t)0x40000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_30_POS     30
#define DWC_usb3_GHWPARAMS1_ghwparams1_31_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GHWPARAMS1_ghwparams1_31_POS     31

#define DWC_usb3_GHWPARAMS1_ghwparams1_2_0_RST     0x3
#define DWC_usb3_GHWPARAMS1_ghwparams1_5_3_RST     0x7
#define DWC_usb3_GHWPARAMS1_ghwparams1_8_6_RST     0x4
#define DWC_usb3_GHWPARAMS1_ghwparams1_11_9_RST     0x4
#define DWC_usb3_GHWPARAMS1_ghwparams1_14_12_RST     0x4
#define DWC_usb3_GHWPARAMS1_ghwparams1_20_15_RST     0x1
#define DWC_usb3_GHWPARAMS1_ghwparams1_22_21_RST     0x3
#define DWC_usb3_GHWPARAMS1_ghwparams1_23_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_25_24_RST     0x1
#define DWC_usb3_GHWPARAMS1_ghwparams1_26_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_27_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_28_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_29_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_30_RST     0x0
#define DWC_usb3_GHWPARAMS1_ghwparams1_31_RST     0x0

__INLINE void dwc_usb3_ghwparams1_pack(uint8_t ghwparams120,uint8_t ghwparams153,uint8_t ghwparams186,uint8_t ghwparams1119,uint8_t ghwparams11412,uint8_t ghwparams12015,uint8_t ghwparams12221,uint8_t ghwparams123,uint8_t ghwparams12524,uint8_t ghwparams126,uint8_t ghwparams127,uint8_t ghwparams128,uint8_t ghwparams129,uint8_t ghwparams130,uint8_t ghwparams131)
{
       ASSERT_ERR((((uint32_t)ghwparams120 << 0) & ~((uint32_t)0x00000007)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams153 << 3) & ~((uint32_t)0x00000038)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams186 << 6) & ~((uint32_t)0x000001C0)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams1119 << 9) & ~((uint32_t)0x00000E00)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams11412 << 12) & ~((uint32_t)0x00007000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams12015 << 15) & ~((uint32_t)0x001F8000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams12221 << 21) & ~((uint32_t)0x00600000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams123 << 23) & ~((uint32_t)0x00800000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams12524 << 24) & ~((uint32_t)0x03000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams126 << 26) & ~((uint32_t)0x04000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams127 << 27) & ~((uint32_t)0x08000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams128 << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams129 << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams130 << 30) & ~((uint32_t)0x40000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams131 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS1_ADDR, ((uint32_t)ghwparams120 << 0) |((uint32_t)ghwparams153 << 3) |((uint32_t)ghwparams186 << 6) |((uint32_t)ghwparams1119 << 9) |((uint32_t)ghwparams11412 << 12) |((uint32_t)ghwparams12015 << 15) |((uint32_t)ghwparams12221 << 21) |((uint32_t)ghwparams123 << 23) |((uint32_t)ghwparams12524 << 24) |((uint32_t)ghwparams126 << 26) |((uint32_t)ghwparams127 << 27) |((uint32_t)ghwparams128 << 28) |((uint32_t)ghwparams129 << 29) |((uint32_t)ghwparams130 << 30) |((uint32_t)ghwparams131 << 31));
}

__INLINE void dwc_usb3_ghwparams1_unpack(uint8_t* ghwparams120,uint8_t* ghwparams153,uint8_t* ghwparams186,uint8_t* ghwparams1119,uint8_t* ghwparams11412,uint8_t* ghwparams12015,uint8_t* ghwparams12221,uint8_t* ghwparams123,uint8_t* ghwparams12524,uint8_t* ghwparams126,uint8_t* ghwparams127,uint8_t* ghwparams128,uint8_t* ghwparams129,uint8_t* ghwparams130,uint8_t* ghwparams131)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);

       *ghwparams120 = (localVal & ((uint32_t)0x00000007)) >> 0;
       *ghwparams153 = (localVal & ((uint32_t)0x00000038)) >> 3;
       *ghwparams186 = (localVal & ((uint32_t)0x000001C0)) >> 6;
       *ghwparams1119 = (localVal & ((uint32_t)0x00000E00)) >> 9;
       *ghwparams11412 = (localVal & ((uint32_t)0x00007000)) >> 12;
       *ghwparams12015 = (localVal & ((uint32_t)0x001F8000)) >> 15;
       *ghwparams12221 = (localVal & ((uint32_t)0x00600000)) >> 21;
       *ghwparams123 = (localVal & ((uint32_t)0x00800000)) >> 23;
       *ghwparams12524 = (localVal & ((uint32_t)0x03000000)) >> 24;
       *ghwparams126 = (localVal & ((uint32_t)0x04000000)) >> 26;
       *ghwparams127 = (localVal & ((uint32_t)0x08000000)) >> 27;
       *ghwparams128 = (localVal & ((uint32_t)0x10000000)) >> 28;
       *ghwparams129 = (localVal & ((uint32_t)0x20000000)) >> 29;
       *ghwparams130 = (localVal & ((uint32_t)0x40000000)) >> 30;
       *ghwparams131 = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_2_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_5_3_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00000038)) >> 3);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_8_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x000001C0)) >> 6);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_11_9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00000E00)) >> 9);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_14_12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00007000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_20_15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x001F8000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_22_21_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00600000)) >> 21);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_23_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_25_24_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_26_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_27_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_29_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_30_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE uint8_t  dwc_usb3_ghwparams1_ghwparams1_31_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS1_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
/**
* \@brief GHWPARAMS2 register definition
* Global Hardware Parameters Register 2

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      ghwparams2_31_0                         0xcafecafe
* </pre>
*/
#define DWC_usb3_GHWPARAMS2_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C148)
#define DWC_usb3_GHWPARAMS2_OFFSET      0x0000C148
#define DWC_usb3_GHWPARAMS2_INDEX       0x3052
__INLINE uint32_t dwc_usb3_ghwparams2_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS2_ADDR);
}

__INLINE void dwc_usb3_ghwparams2_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS2_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS2_ghwparams2_31_0_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GHWPARAMS2_ghwparams2_31_0_LSB     0
#define DWC_usb3_GHWPARAMS2_ghwparams2_31_0_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GHWPARAMS2_ghwparams2_31_0_RST     0xcafecafe

__INLINE void dwc_usb3_ghwparams2_pack(uint32_t ghwparams2310)
{
       ASSERT_ERR((((uint32_t)ghwparams2310 << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS2_ADDR, ((uint32_t)ghwparams2310 << 0));
}

__INLINE void dwc_usb3_ghwparams2_unpack(uint32_t* ghwparams2310)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS2_ADDR);

       *ghwparams2310 = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_ghwparams2_ghwparams2_31_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS2_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GHWPARAMS3 register definition
* Global Hardware Parameters Register 3

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:01       ghwparams3_1_0                          0x1
*    02:03       ghwparams3_3_2                          0x1
*    04:05       ghwparams3_5_4                          0x0
*    06:07       ghwparams3_7_6                          0x2
*    08:09       ghwparams3_9_8                          0x0
*    10         ghwparams3_10                           0x0
*    11         ghwparams3_11                           0x0
*    12:17      ghwparams3_17_12                        0x20
*    18:22      ghwparams3_22_18                        0x10
*    23:30      ghwparams3_30_23                        0x20
*    31         ghwparams3_31                           0x0
* </pre>
*/
#define DWC_usb3_GHWPARAMS3_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C14C)
#define DWC_usb3_GHWPARAMS3_OFFSET      0x0000C14C
#define DWC_usb3_GHWPARAMS3_INDEX       0x3053
__INLINE uint32_t dwc_usb3_ghwparams3_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
}

__INLINE void dwc_usb3_ghwparams3_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS3_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS3_ghwparams3_1_0_MASK    ((uint32_t)0x00000003)
#define DWC_usb3_GHWPARAMS3_ghwparams3_1_0_LSB     0
#define DWC_usb3_GHWPARAMS3_ghwparams3_1_0_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS3_ghwparams3_3_2_MASK    ((uint32_t)0x0000000C)
#define DWC_usb3_GHWPARAMS3_ghwparams3_3_2_LSB     2
#define DWC_usb3_GHWPARAMS3_ghwparams3_3_2_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS3_ghwparams3_5_4_MASK    ((uint32_t)0x00000030)
#define DWC_usb3_GHWPARAMS3_ghwparams3_5_4_LSB     4
#define DWC_usb3_GHWPARAMS3_ghwparams3_5_4_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS3_ghwparams3_7_6_MASK    ((uint32_t)0x000000C0)
#define DWC_usb3_GHWPARAMS3_ghwparams3_7_6_LSB     6
#define DWC_usb3_GHWPARAMS3_ghwparams3_7_6_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS3_ghwparams3_9_8_MASK    ((uint32_t)0x00000300)
#define DWC_usb3_GHWPARAMS3_ghwparams3_9_8_LSB     8
#define DWC_usb3_GHWPARAMS3_ghwparams3_9_8_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS3_ghwparams3_10_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GHWPARAMS3_ghwparams3_10_POS     10
#define DWC_usb3_GHWPARAMS3_ghwparams3_11_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GHWPARAMS3_ghwparams3_11_POS     11
#define DWC_usb3_GHWPARAMS3_ghwparams3_17_12_MASK    ((uint32_t)0x0003F000)
#define DWC_usb3_GHWPARAMS3_ghwparams3_17_12_LSB     12
#define DWC_usb3_GHWPARAMS3_ghwparams3_17_12_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS3_ghwparams3_22_18_MASK    ((uint32_t)0x007C0000)
#define DWC_usb3_GHWPARAMS3_ghwparams3_22_18_LSB     18
#define DWC_usb3_GHWPARAMS3_ghwparams3_22_18_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_GHWPARAMS3_ghwparams3_30_23_MASK    ((uint32_t)0x7F800000)
#define DWC_usb3_GHWPARAMS3_ghwparams3_30_23_LSB     23
#define DWC_usb3_GHWPARAMS3_ghwparams3_30_23_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GHWPARAMS3_ghwparams3_31_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GHWPARAMS3_ghwparams3_31_POS     31

#define DWC_usb3_GHWPARAMS3_ghwparams3_1_0_RST     0x1
#define DWC_usb3_GHWPARAMS3_ghwparams3_3_2_RST     0x1
#define DWC_usb3_GHWPARAMS3_ghwparams3_5_4_RST     0x0
#define DWC_usb3_GHWPARAMS3_ghwparams3_7_6_RST     0x2
#define DWC_usb3_GHWPARAMS3_ghwparams3_9_8_RST     0x0
#define DWC_usb3_GHWPARAMS3_ghwparams3_10_RST     0x0
#define DWC_usb3_GHWPARAMS3_ghwparams3_11_RST     0x0
#define DWC_usb3_GHWPARAMS3_ghwparams3_17_12_RST     0x20
#define DWC_usb3_GHWPARAMS3_ghwparams3_22_18_RST     0x10
#define DWC_usb3_GHWPARAMS3_ghwparams3_30_23_RST     0x20
#define DWC_usb3_GHWPARAMS3_ghwparams3_31_RST     0x0

__INLINE void dwc_usb3_ghwparams3_pack(uint8_t ghwparams310,uint8_t ghwparams332,uint8_t ghwparams354,uint8_t ghwparams376,uint8_t ghwparams398,uint8_t ghwparams311,uint8_t ghwparams31712,uint8_t ghwparams32218,uint8_t ghwparams33023,uint8_t ghwparams331)
{
       ASSERT_ERR((((uint32_t)ghwparams310 << 0) & ~((uint32_t)0x00000003)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams332 << 2) & ~((uint32_t)0x0000000C)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams354 << 4) & ~((uint32_t)0x00000030)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams376 << 6) & ~((uint32_t)0x000000C0)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams398 << 8) & ~((uint32_t)0x00000300)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams310 << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams311 << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams31712 << 12) & ~((uint32_t)0x0003F000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams32218 << 18) & ~((uint32_t)0x007C0000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams33023 << 23) & ~((uint32_t)0x7F800000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams331 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS3_ADDR, ((uint32_t)ghwparams310 << 0) |((uint32_t)ghwparams332 << 2) |((uint32_t)ghwparams354 << 4) |((uint32_t)ghwparams376 << 6) |((uint32_t)ghwparams398 << 8) |((uint32_t)ghwparams310 << 10) |((uint32_t)ghwparams311 << 11) |((uint32_t)ghwparams31712 << 12) |((uint32_t)ghwparams32218 << 18) |((uint32_t)ghwparams33023 << 23) |((uint32_t)ghwparams331 << 31));
}

__INLINE void dwc_usb3_ghwparams3_unpack(uint8_t* ghwparams310,uint8_t* ghwparams332,uint8_t* ghwparams354,uint8_t* ghwparams376,uint8_t* ghwparams398,uint8_t* ghwparams311,uint8_t* ghwparams31712,uint8_t* ghwparams32218,uint8_t* ghwparams33023,uint8_t* ghwparams331)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);

       *ghwparams310 = (localVal & ((uint32_t)0x00000003)) >> 0;
       *ghwparams332 = (localVal & ((uint32_t)0x0000000C)) >> 2;
       *ghwparams354 = (localVal & ((uint32_t)0x00000030)) >> 4;
       *ghwparams376 = (localVal & ((uint32_t)0x000000C0)) >> 6;
       *ghwparams398 = (localVal & ((uint32_t)0x00000300)) >> 8;
       *ghwparams310 = (localVal & ((uint32_t)0x00000400)) >> 10;
       *ghwparams311 = (localVal & ((uint32_t)0x00000800)) >> 11;
       *ghwparams31712 = (localVal & ((uint32_t)0x0003F000)) >> 12;
       *ghwparams32218 = (localVal & ((uint32_t)0x007C0000)) >> 18;
       *ghwparams33023 = (localVal & ((uint32_t)0x7F800000)) >> 23;
       *ghwparams331 = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_1_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x00000003)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_3_2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x0000000C)) >> 2);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_5_4_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x00000030)) >> 4);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_7_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x000000C0)) >> 6);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_9_8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x00000300)) >> 8);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_17_12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x0003F000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_22_18_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x007C0000)) >> 18);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_30_23_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x7F800000)) >> 23);
}
__INLINE uint8_t  dwc_usb3_ghwparams3_ghwparams3_31_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS3_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
/**
* \@brief GHWPARAMS4 register definition
* Global Hardware Parameters Register 4

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:05       ghwparams4_5_0                          0x18
*    6          ghwparams4_6                            0x0
*    07:08       ghwparams4_8_7                          0x0
*    09:10      ghwparams4_10_9                         0x0
*    11         ghwparams4_11                           0x0
*    12         ghwparams4_12                           0x0
*    13:16      ghwparams4_16_13                        0x1
*    17:20      ghwparams4_20_17                        0x1
*    21         ghwparams4_21                           0x0
*    22         ghwparams4_22                           0x0
*    23         ghwparams4_23                           0x1
*    24:27      ghwparams4_27_24                        0x7
*    28:31      ghwparams4_31_28                        0x4
* </pre>
*/
#define DWC_usb3_GHWPARAMS4_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C150)
#define DWC_usb3_GHWPARAMS4_OFFSET      0x0000C150
#define DWC_usb3_GHWPARAMS4_INDEX       0x3054
__INLINE uint32_t dwc_usb3_ghwparams4_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
}

__INLINE void dwc_usb3_ghwparams4_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS4_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS4_ghwparams4_5_0_MASK    ((uint32_t)0x0000003F)
#define DWC_usb3_GHWPARAMS4_ghwparams4_5_0_LSB     0
#define DWC_usb3_GHWPARAMS4_ghwparams4_5_0_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS4_ghwparams4_6_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_GHWPARAMS4_ghwparams4_6_POS     6
#define DWC_usb3_GHWPARAMS4_ghwparams4_8_7_MASK    ((uint32_t)0x00000180)
#define DWC_usb3_GHWPARAMS4_ghwparams4_8_7_LSB     7
#define DWC_usb3_GHWPARAMS4_ghwparams4_8_7_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS4_ghwparams4_10_9_MASK    ((uint32_t)0x00000600)
#define DWC_usb3_GHWPARAMS4_ghwparams4_10_9_LSB     9
#define DWC_usb3_GHWPARAMS4_ghwparams4_10_9_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS4_ghwparams4_11_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GHWPARAMS4_ghwparams4_11_POS     11
#define DWC_usb3_GHWPARAMS4_ghwparams4_12_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_12_POS     12
#define DWC_usb3_GHWPARAMS4_ghwparams4_16_13_MASK    ((uint32_t)0x0001E000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_16_13_LSB     13
#define DWC_usb3_GHWPARAMS4_ghwparams4_16_13_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GHWPARAMS4_ghwparams4_20_17_MASK    ((uint32_t)0x001E0000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_20_17_LSB     17
#define DWC_usb3_GHWPARAMS4_ghwparams4_20_17_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GHWPARAMS4_ghwparams4_21_BIT     ((uint32_t)0x00200000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_21_POS     21
#define DWC_usb3_GHWPARAMS4_ghwparams4_22_BIT     ((uint32_t)0x00400000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_22_POS     22
#define DWC_usb3_GHWPARAMS4_ghwparams4_23_BIT     ((uint32_t)0x00800000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_23_POS     23
#define DWC_usb3_GHWPARAMS4_ghwparams4_27_24_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_27_24_LSB     24
#define DWC_usb3_GHWPARAMS4_ghwparams4_27_24_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GHWPARAMS4_ghwparams4_31_28_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GHWPARAMS4_ghwparams4_31_28_LSB     28
#define DWC_usb3_GHWPARAMS4_ghwparams4_31_28_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GHWPARAMS4_ghwparams4_5_0_RST     0x18
#define DWC_usb3_GHWPARAMS4_ghwparams4_6_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_8_7_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_10_9_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_11_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_12_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_16_13_RST     0x1
#define DWC_usb3_GHWPARAMS4_ghwparams4_20_17_RST     0x1
#define DWC_usb3_GHWPARAMS4_ghwparams4_21_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_22_RST     0x0
#define DWC_usb3_GHWPARAMS4_ghwparams4_23_RST     0x1
#define DWC_usb3_GHWPARAMS4_ghwparams4_27_24_RST     0x7
#define DWC_usb3_GHWPARAMS4_ghwparams4_31_28_RST     0x4

__INLINE void dwc_usb3_ghwparams4_pack(uint8_t ghwparams450,uint8_t ghwparams46,uint8_t ghwparams487,uint8_t ghwparams4109,uint8_t ghwparams411,uint8_t ghwparams412,uint8_t ghwparams41613,uint8_t ghwparams42017,uint8_t ghwparams421,uint8_t ghwparams422,uint8_t ghwparams423,uint8_t ghwparams42724,uint8_t ghwparams43128)
{
       ASSERT_ERR((((uint32_t)ghwparams450 << 0) & ~((uint32_t)0x0000003F)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams46 << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams487 << 7) & ~((uint32_t)0x00000180)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams4109 << 9) & ~((uint32_t)0x00000600)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams411 << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams412 << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams41613 << 13) & ~((uint32_t)0x0001E000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams42017 << 17) & ~((uint32_t)0x001E0000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams421 << 21) & ~((uint32_t)0x00200000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams422 << 22) & ~((uint32_t)0x00400000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams423 << 23) & ~((uint32_t)0x00800000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams42724 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams43128 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS4_ADDR, ((uint32_t)ghwparams450 << 0) |((uint32_t)ghwparams46 << 6) |((uint32_t)ghwparams487 << 7) |((uint32_t)ghwparams4109 << 9) |((uint32_t)ghwparams411 << 11) |((uint32_t)ghwparams412 << 12) |((uint32_t)ghwparams41613 << 13) |((uint32_t)ghwparams42017 << 17) |((uint32_t)ghwparams421 << 21) |((uint32_t)ghwparams422 << 22) |((uint32_t)ghwparams423 << 23) |((uint32_t)ghwparams42724 << 24) |((uint32_t)ghwparams43128 << 28));
}

__INLINE void dwc_usb3_ghwparams4_unpack(uint8_t* ghwparams450,uint8_t* ghwparams46,uint8_t* ghwparams487,uint8_t* ghwparams4109,uint8_t* ghwparams411,uint8_t* ghwparams412,uint8_t* ghwparams41613,uint8_t* ghwparams42017,uint8_t* ghwparams421,uint8_t* ghwparams422,uint8_t* ghwparams423,uint8_t* ghwparams42724,uint8_t* ghwparams43128)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);

       *ghwparams450 = (localVal & ((uint32_t)0x0000003F)) >> 0;
       *ghwparams46 = (localVal & ((uint32_t)0x00000040)) >> 6;
       *ghwparams487 = (localVal & ((uint32_t)0x00000180)) >> 7;
       *ghwparams4109 = (localVal & ((uint32_t)0x00000600)) >> 9;
       *ghwparams411 = (localVal & ((uint32_t)0x00000800)) >> 11;
       *ghwparams412 = (localVal & ((uint32_t)0x00001000)) >> 12;
       *ghwparams41613 = (localVal & ((uint32_t)0x0001E000)) >> 13;
       *ghwparams42017 = (localVal & ((uint32_t)0x001E0000)) >> 17;
       *ghwparams421 = (localVal & ((uint32_t)0x00200000)) >> 21;
       *ghwparams422 = (localVal & ((uint32_t)0x00400000)) >> 22;
       *ghwparams423 = (localVal & ((uint32_t)0x00800000)) >> 23;
       *ghwparams42724 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *ghwparams43128 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_5_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x0000003F)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_8_7_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00000180)) >> 7);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_10_9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_16_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x0001E000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_20_17_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x001E0000)) >> 17);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_21_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_22_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_23_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_27_24_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE uint8_t  dwc_usb3_ghwparams4_ghwparams4_31_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS4_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
/**
* \@brief GHWPARAMS5 register definition
* Global Hardware Parameters Register 5

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       ghwparams5_3_0                          0x8
*    04:09       ghwparams5_9_4                          0x10
*    10:15      ghwparams5_15_10                        0x10
*    16:21      ghwparams5_21_16                        0x20
*    22:27      ghwparams5_27_22                        0x10
*    28:31      ghwparams5_31_28                        0x0
* </pre>
*/
#define DWC_usb3_GHWPARAMS5_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C154)
#define DWC_usb3_GHWPARAMS5_OFFSET      0x0000C154
#define DWC_usb3_GHWPARAMS5_INDEX       0x3055
__INLINE uint32_t dwc_usb3_ghwparams5_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
}

__INLINE void dwc_usb3_ghwparams5_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS5_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS5_ghwparams5_3_0_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GHWPARAMS5_ghwparams5_3_0_LSB     0
#define DWC_usb3_GHWPARAMS5_ghwparams5_3_0_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GHWPARAMS5_ghwparams5_9_4_MASK    ((uint32_t)0x000003F0)
#define DWC_usb3_GHWPARAMS5_ghwparams5_9_4_LSB     4
#define DWC_usb3_GHWPARAMS5_ghwparams5_9_4_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS5_ghwparams5_15_10_MASK    ((uint32_t)0x0000FC00)
#define DWC_usb3_GHWPARAMS5_ghwparams5_15_10_LSB     10
#define DWC_usb3_GHWPARAMS5_ghwparams5_15_10_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS5_ghwparams5_21_16_MASK    ((uint32_t)0x003F0000)
#define DWC_usb3_GHWPARAMS5_ghwparams5_21_16_LSB     16
#define DWC_usb3_GHWPARAMS5_ghwparams5_21_16_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS5_ghwparams5_27_22_MASK    ((uint32_t)0x0FC00000)
#define DWC_usb3_GHWPARAMS5_ghwparams5_27_22_LSB     22
#define DWC_usb3_GHWPARAMS5_ghwparams5_27_22_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS5_ghwparams5_31_28_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GHWPARAMS5_ghwparams5_31_28_LSB     28
#define DWC_usb3_GHWPARAMS5_ghwparams5_31_28_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GHWPARAMS5_ghwparams5_3_0_RST     0x8
#define DWC_usb3_GHWPARAMS5_ghwparams5_9_4_RST     0x10
#define DWC_usb3_GHWPARAMS5_ghwparams5_15_10_RST     0x10
#define DWC_usb3_GHWPARAMS5_ghwparams5_21_16_RST     0x20
#define DWC_usb3_GHWPARAMS5_ghwparams5_27_22_RST     0x10
#define DWC_usb3_GHWPARAMS5_ghwparams5_31_28_RST     0x0

__INLINE void dwc_usb3_ghwparams5_pack(uint8_t ghwparams530,uint8_t ghwparams594,uint8_t ghwparams51510,uint8_t ghwparams52116,uint8_t ghwparams52722,uint8_t ghwparams53128)
{
       ASSERT_ERR((((uint32_t)ghwparams530 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams594 << 4) & ~((uint32_t)0x000003F0)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams51510 << 10) & ~((uint32_t)0x0000FC00)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams52116 << 16) & ~((uint32_t)0x003F0000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams52722 << 22) & ~((uint32_t)0x0FC00000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams53128 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS5_ADDR, ((uint32_t)ghwparams530 << 0) |((uint32_t)ghwparams594 << 4) |((uint32_t)ghwparams51510 << 10) |((uint32_t)ghwparams52116 << 16) |((uint32_t)ghwparams52722 << 22) |((uint32_t)ghwparams53128 << 28));
}

__INLINE void dwc_usb3_ghwparams5_unpack(uint8_t* ghwparams530,uint8_t* ghwparams594,uint8_t* ghwparams51510,uint8_t* ghwparams52116,uint8_t* ghwparams52722,uint8_t* ghwparams53128)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);

       *ghwparams530 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *ghwparams594 = (localVal & ((uint32_t)0x000003F0)) >> 4;
       *ghwparams51510 = (localVal & ((uint32_t)0x0000FC00)) >> 10;
       *ghwparams52116 = (localVal & ((uint32_t)0x003F0000)) >> 16;
       *ghwparams52722 = (localVal & ((uint32_t)0x0FC00000)) >> 22;
       *ghwparams53128 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_3_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_9_4_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0x000003F0)) >> 4);
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_15_10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0x0000FC00)) >> 10);
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_21_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_27_22_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0x0FC00000)) >> 22);
}
__INLINE uint8_t  dwc_usb3_ghwparams5_ghwparams5_31_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS5_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
/**
* \@brief GHWPARAMS6 register definition
* Global Hardware Parameters Register 6

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:05       ghwparams6_5_0                          0x20
*    6          ghwparams6_6                            0x0
*    7          ghwparams6_7                            0x0
*    08:09       ghwparams6_9_8                          0x0
*    10         SRPSupport                              0x0
*    11         HNPSupport                              0x0
*    12         ADPSupport                              0x0
*    13         OTG_SS_Support                          0x0
*    14         BCSupport                               0x0
*    15         BusFltrsSupport                         0x0
*    16:31      ghwparams6_31_16                        0xf8c
* </pre>
*/
#define DWC_usb3_GHWPARAMS6_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C158)
#define DWC_usb3_GHWPARAMS6_OFFSET      0x0000C158
#define DWC_usb3_GHWPARAMS6_INDEX       0x3056
__INLINE uint32_t dwc_usb3_ghwparams6_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
}

__INLINE void dwc_usb3_ghwparams6_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS6_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS6_ghwparams6_5_0_MASK    ((uint32_t)0x0000003F)
#define DWC_usb3_GHWPARAMS6_ghwparams6_5_0_LSB     0
#define DWC_usb3_GHWPARAMS6_ghwparams6_5_0_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GHWPARAMS6_ghwparams6_6_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_GHWPARAMS6_ghwparams6_6_POS     6
#define DWC_usb3_GHWPARAMS6_ghwparams6_7_BIT     ((uint32_t)0x00000080)
#define DWC_usb3_GHWPARAMS6_ghwparams6_7_POS     7
#define DWC_usb3_GHWPARAMS6_ghwparams6_9_8_MASK    ((uint32_t)0x00000300)
#define DWC_usb3_GHWPARAMS6_ghwparams6_9_8_LSB     8
#define DWC_usb3_GHWPARAMS6_ghwparams6_9_8_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GHWPARAMS6_SRPSupport_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_GHWPARAMS6_SRPSupport_POS     10
#define DWC_usb3_GHWPARAMS6_HNPSupport_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GHWPARAMS6_HNPSupport_POS     11
#define DWC_usb3_GHWPARAMS6_ADPSupport_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GHWPARAMS6_ADPSupport_POS     12
#define DWC_usb3_GHWPARAMS6_OTG_SS_Support_BIT     ((uint32_t)0x00002000)
#define DWC_usb3_GHWPARAMS6_OTG_SS_Support_POS     13
#define DWC_usb3_GHWPARAMS6_BCSupport_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_GHWPARAMS6_BCSupport_POS     14
#define DWC_usb3_GHWPARAMS6_BusFltrsSupport_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GHWPARAMS6_BusFltrsSupport_POS     15
#define DWC_usb3_GHWPARAMS6_ghwparams6_31_16_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_GHWPARAMS6_ghwparams6_31_16_LSB     16
#define DWC_usb3_GHWPARAMS6_ghwparams6_31_16_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_GHWPARAMS6_ghwparams6_5_0_RST     0x20
#define DWC_usb3_GHWPARAMS6_ghwparams6_6_RST     0x0
#define DWC_usb3_GHWPARAMS6_ghwparams6_7_RST     0x0
#define DWC_usb3_GHWPARAMS6_ghwparams6_9_8_RST     0x0
#define DWC_usb3_GHWPARAMS6_SRPSupport_RST     0x0
#define DWC_usb3_GHWPARAMS6_HNPSupport_RST     0x0
#define DWC_usb3_GHWPARAMS6_ADPSupport_RST     0x0
#define DWC_usb3_GHWPARAMS6_OTG_SS_Support_RST     0x0
#define DWC_usb3_GHWPARAMS6_BCSupport_RST     0x0
#define DWC_usb3_GHWPARAMS6_BusFltrsSupport_RST     0x0
#define DWC_usb3_GHWPARAMS6_ghwparams6_31_16_RST     0xf8c

__INLINE void dwc_usb3_ghwparams6_pack(uint8_t ghwparams650,uint8_t ghwparams66,uint8_t ghwparams67,uint8_t ghwparams698,uint8_t srpsupport,uint8_t hnpsupport,uint8_t adpsupport,uint8_t otgsssupport,uint8_t bcsupport,uint8_t busfltrssupport,uint16_t ghwparams63116)
{
       ASSERT_ERR((((uint32_t)ghwparams650 << 0) & ~((uint32_t)0x0000003F)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams66 << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams67 << 7) & ~((uint32_t)0x00000080)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams698 << 8) & ~((uint32_t)0x00000300)) == 0);
       ASSERT_ERR((((uint32_t)srpsupport << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)hnpsupport << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)adpsupport << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)otgsssupport << 13) & ~((uint32_t)0x00002000)) == 0);
       ASSERT_ERR((((uint32_t)bcsupport << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)busfltrssupport << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams63116 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS6_ADDR, ((uint32_t)ghwparams650 << 0) |((uint32_t)ghwparams66 << 6) |((uint32_t)ghwparams67 << 7) |((uint32_t)ghwparams698 << 8) |((uint32_t)srpsupport << 10) |((uint32_t)hnpsupport << 11) |((uint32_t)adpsupport << 12) |((uint32_t)otgsssupport << 13) |((uint32_t)bcsupport << 14) |((uint32_t)busfltrssupport << 15) |((uint32_t)ghwparams63116 << 16));
}

__INLINE void dwc_usb3_ghwparams6_unpack(uint8_t* ghwparams650,uint8_t* ghwparams66,uint8_t* ghwparams67,uint8_t* ghwparams698,uint8_t* srpsupport,uint8_t* hnpsupport,uint8_t* adpsupport,uint8_t* otgsssupport,uint8_t* bcsupport,uint8_t* busfltrssupport,uint16_t* ghwparams63116)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);

       *ghwparams650 = (localVal & ((uint32_t)0x0000003F)) >> 0;
       *ghwparams66 = (localVal & ((uint32_t)0x00000040)) >> 6;
       *ghwparams67 = (localVal & ((uint32_t)0x00000080)) >> 7;
       *ghwparams698 = (localVal & ((uint32_t)0x00000300)) >> 8;
       *srpsupport = (localVal & ((uint32_t)0x00000400)) >> 10;
       *hnpsupport = (localVal & ((uint32_t)0x00000800)) >> 11;
       *adpsupport = (localVal & ((uint32_t)0x00001000)) >> 12;
       *otgsssupport = (localVal & ((uint32_t)0x00002000)) >> 13;
       *bcsupport = (localVal & ((uint32_t)0x00004000)) >> 14;
       *busfltrssupport = (localVal & ((uint32_t)0x00008000)) >> 15;
       *ghwparams63116 = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint8_t  dwc_usb3_ghwparams6_ghwparams6_5_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x0000003F)) >> 0);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_ghwparams6_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_ghwparams6_7_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_ghwparams6_9_8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00000300)) >> 8);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_srpsupport_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_hnpsupport_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_adpsupport_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_otg_ss_support_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_bcsupport_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE uint8_t  dwc_usb3_ghwparams6_busfltrssupport_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint16_t  dwc_usb3_ghwparams6_ghwparams6_31_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS6_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
/**
* \@brief GHWPARAMS7 register definition
* Global Hardware Parameters Register 7

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:15      ghwparams7_15_0                         0x26b7
*    16:31      ghwparams7_31_16                        0x30a
* </pre>
*/
#define DWC_usb3_GHWPARAMS7_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C15C)
#define DWC_usb3_GHWPARAMS7_OFFSET      0x0000C15C
#define DWC_usb3_GHWPARAMS7_INDEX       0x3057
__INLINE uint32_t dwc_usb3_ghwparams7_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS7_ADDR);
}

__INLINE void dwc_usb3_ghwparams7_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS7_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS7_ghwparams7_15_0_MASK    ((uint32_t)0x0000FFFF)
#define DWC_usb3_GHWPARAMS7_ghwparams7_15_0_LSB     0
#define DWC_usb3_GHWPARAMS7_ghwparams7_15_0_WIDTH   ((uint32_t)0x00000010)
#define DWC_usb3_GHWPARAMS7_ghwparams7_31_16_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_GHWPARAMS7_ghwparams7_31_16_LSB     16
#define DWC_usb3_GHWPARAMS7_ghwparams7_31_16_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_GHWPARAMS7_ghwparams7_15_0_RST     0x26b7
#define DWC_usb3_GHWPARAMS7_ghwparams7_31_16_RST     0x30a

__INLINE void dwc_usb3_ghwparams7_pack(uint16_t ghwparams7150,uint16_t ghwparams73116)
{
       ASSERT_ERR((((uint32_t)ghwparams7150 << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       ASSERT_ERR((((uint32_t)ghwparams73116 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS7_ADDR, ((uint32_t)ghwparams7150 << 0) |((uint32_t)ghwparams73116 << 16));
}

__INLINE void dwc_usb3_ghwparams7_unpack(uint16_t* ghwparams7150,uint16_t* ghwparams73116)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS7_ADDR);

       *ghwparams7150 = (localVal & ((uint32_t)0x0000FFFF)) >> 0;
       *ghwparams73116 = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint16_t  dwc_usb3_ghwparams7_ghwparams7_15_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS7_ADDR);
       return ((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE uint16_t  dwc_usb3_ghwparams7_ghwparams7_31_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS7_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
/**
* \@brief GDBGFIFOSPACE register definition
* Global Debug Queue/FIFO Space Available Register

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:08       FIFO_QUEUE_SELECT                       0x0
*    09:15      reserved_15_9                           0x0
*    16:31      SPACE_AVAILABLE                         0x82
* </pre>
*/
#define DWC_usb3_GDBGFIFOSPACE_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C160)
#define DWC_usb3_GDBGFIFOSPACE_OFFSET      0x0000C160
#define DWC_usb3_GDBGFIFOSPACE_INDEX       0x3058
__INLINE uint32_t dwc_usb3_gdbgfifospace_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR);
}

__INLINE void dwc_usb3_gdbgfifospace_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGFIFOSPACE_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_MASK    ((uint32_t)0x000001FF)
#define DWC_usb3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_LSB     0
#define DWC_usb3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_WIDTH   ((uint32_t)0x00000009)
#define DWC_usb3_GDBGFIFOSPACE_reserved_15_9_MASK    ((uint32_t)0x0000FE00)
#define DWC_usb3_GDBGFIFOSPACE_reserved_15_9_LSB     9
#define DWC_usb3_GDBGFIFOSPACE_reserved_15_9_WIDTH   ((uint32_t)0x00000007)
#define DWC_usb3_GDBGFIFOSPACE_SPACE_AVAILABLE_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_GDBGFIFOSPACE_SPACE_AVAILABLE_LSB     16
#define DWC_usb3_GDBGFIFOSPACE_SPACE_AVAILABLE_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_GDBGFIFOSPACE_FIFO_QUEUE_SELECT_RST     0x0
#define DWC_usb3_GDBGFIFOSPACE_reserved_15_9_RST     0x0
#define DWC_usb3_GDBGFIFOSPACE_SPACE_AVAILABLE_RST     0x82

__INLINE void dwc_usb3_gdbgfifospace_pack(uint16_t fifoqueueselect,uint8_t reserved159,uint16_t spaceavailable)
{
       ASSERT_ERR((((uint32_t)fifoqueueselect << 0) & ~((uint32_t)0x000001FF)) == 0);
       ASSERT_ERR((((uint32_t)reserved159 << 9) & ~((uint32_t)0x0000FE00)) == 0);
       ASSERT_ERR((((uint32_t)spaceavailable << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GDBGFIFOSPACE_ADDR, ((uint32_t)fifoqueueselect << 0) |((uint32_t)reserved159 << 9) |((uint32_t)spaceavailable << 16));
}

__INLINE void dwc_usb3_gdbgfifospace_unpack(uint16_t* fifoqueueselect,uint8_t* reserved159,uint16_t* spaceavailable)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR);

       *fifoqueueselect = (localVal & ((uint32_t)0x000001FF)) >> 0;
       *reserved159 = (localVal & ((uint32_t)0x0000FE00)) >> 9;
       *spaceavailable = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint16_t  dwc_usb3_gdbgfifospace_fifo_queue_select_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR);
       return ((localVal & ((uint32_t)0x000001FF)) >> 0);
}
__INLINE void  dwc_usb3_gdbgfifospace_fifo_queue_select_setf(uint16_t  fifoqueueselect)
{
       ASSERT_ERR((((uint32_t)fifoqueueselect << 0) & ~((uint32_t)0x000001FF)) == 0);
       REG_PL_WR(DWC_usb3_GDBGFIFOSPACE_ADDR, (REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR) & ~((uint32_t)0x000001FF)) | ((uint32_t)fifoqueueselect <<0));
}
__INLINE uint8_t  dwc_usb3_gdbgfifospace_reserved_15_9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR);
       return ((localVal & ((uint32_t)0x0000FE00)) >> 9);
}
__INLINE uint16_t  dwc_usb3_gdbgfifospace_space_available_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGFIFOSPACE_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
/**
* \@brief GDBGLTSSM register definition
* Global Debug LTSSM Register

In multi-port host configuration, the port-number is defined by Port-Select[3:0] field in the GDBGFIFOSPACE register.  

Note: 
 - GDBGLTSSM register is not applicable for USB 2.0-only mode.
 - Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          TXONESZEROS                             0x0
*    1          RXTERMINATION                           0x0
*    2          TXSWING                                 0x0
*    03:05       LTDBClkState                            0x0
*    06:07       TXDEEMPHASIS                            0x1
*    8          RXEQTRAIN                               0x0
*    09:10      POWERDOWN                               0x2
*    11:13      LTDBPhyCmdState                         0x0
*    14         TxDetRxLoopback                         0x0
*    15         RXPOLARITY                              0x0
*    16         TXELECLDLE                              0x1
*    17         ELASTICBUFFERMODE                       0x0
*    18:21      LTDBSUBSTATE                            0x0
*    22:25      LTDBLINKSTATE                           0x4
*    26         LTDBTIMEOUT                             0x0
*    27         PRTDIRECTION                            0x0
*    28         X3_DS_HOST_SHUTDOWN                     0x0
*    29         X3_XS_SWAPPING                          0x0
*    30         RxElecidle                              0x1
*    31         reserved_31_31                          0x0
* </pre>
*/
#define DWC_usb3_GDBGLTSSM_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C164)
#define DWC_usb3_GDBGLTSSM_OFFSET      0x0000C164
#define DWC_usb3_GDBGLTSSM_INDEX       0x3059
__INLINE uint32_t dwc_usb3_gdbgltssm_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
}

__INLINE void dwc_usb3_gdbgltssm_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGLTSSM_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGLTSSM_TXONESZEROS_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_GDBGLTSSM_TXONESZEROS_POS     0
#define DWC_usb3_GDBGLTSSM_RXTERMINATION_BIT     ((uint32_t)0x00000002)
#define DWC_usb3_GDBGLTSSM_RXTERMINATION_POS     1
#define DWC_usb3_GDBGLTSSM_TXSWING_BIT     ((uint32_t)0x00000004)
#define DWC_usb3_GDBGLTSSM_TXSWING_POS     2
#define DWC_usb3_GDBGLTSSM_LTDBClkState_MASK    ((uint32_t)0x00000038)
#define DWC_usb3_GDBGLTSSM_LTDBClkState_LSB     3
#define DWC_usb3_GDBGLTSSM_LTDBClkState_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GDBGLTSSM_TXDEEMPHASIS_MASK    ((uint32_t)0x000000C0)
#define DWC_usb3_GDBGLTSSM_TXDEEMPHASIS_LSB     6
#define DWC_usb3_GDBGLTSSM_TXDEEMPHASIS_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GDBGLTSSM_RXEQTRAIN_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_GDBGLTSSM_RXEQTRAIN_POS     8
#define DWC_usb3_GDBGLTSSM_POWERDOWN_MASK    ((uint32_t)0x00000600)
#define DWC_usb3_GDBGLTSSM_POWERDOWN_LSB     9
#define DWC_usb3_GDBGLTSSM_POWERDOWN_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GDBGLTSSM_LTDBPhyCmdState_MASK    ((uint32_t)0x00003800)
#define DWC_usb3_GDBGLTSSM_LTDBPhyCmdState_LSB     11
#define DWC_usb3_GDBGLTSSM_LTDBPhyCmdState_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_GDBGLTSSM_TxDetRxLoopback_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_GDBGLTSSM_TxDetRxLoopback_POS     14
#define DWC_usb3_GDBGLTSSM_RXPOLARITY_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_GDBGLTSSM_RXPOLARITY_POS     15
#define DWC_usb3_GDBGLTSSM_TXELECLDLE_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_GDBGLTSSM_TXELECLDLE_POS     16
#define DWC_usb3_GDBGLTSSM_ELASTICBUFFERMODE_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_GDBGLTSSM_ELASTICBUFFERMODE_POS     17
#define DWC_usb3_GDBGLTSSM_LTDBSUBSTATE_MASK    ((uint32_t)0x003C0000)
#define DWC_usb3_GDBGLTSSM_LTDBSUBSTATE_LSB     18
#define DWC_usb3_GDBGLTSSM_LTDBSUBSTATE_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GDBGLTSSM_LTDBLINKSTATE_MASK    ((uint32_t)0x03C00000)
#define DWC_usb3_GDBGLTSSM_LTDBLINKSTATE_LSB     22
#define DWC_usb3_GDBGLTSSM_LTDBLINKSTATE_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GDBGLTSSM_LTDBTIMEOUT_BIT     ((uint32_t)0x04000000)
#define DWC_usb3_GDBGLTSSM_LTDBTIMEOUT_POS     26
#define DWC_usb3_GDBGLTSSM_PRTDIRECTION_BIT     ((uint32_t)0x08000000)
#define DWC_usb3_GDBGLTSSM_PRTDIRECTION_POS     27
#define DWC_usb3_GDBGLTSSM_X3_DS_HOST_SHUTDOWN_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_GDBGLTSSM_X3_DS_HOST_SHUTDOWN_POS     28
#define DWC_usb3_GDBGLTSSM_X3_XS_SWAPPING_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_GDBGLTSSM_X3_XS_SWAPPING_POS     29
#define DWC_usb3_GDBGLTSSM_RxElecidle_BIT     ((uint32_t)0x40000000)
#define DWC_usb3_GDBGLTSSM_RxElecidle_POS     30
#define DWC_usb3_GDBGLTSSM_reserved_31_31_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GDBGLTSSM_reserved_31_31_POS     31

#define DWC_usb3_GDBGLTSSM_TXONESZEROS_RST     0x0
#define DWC_usb3_GDBGLTSSM_RXTERMINATION_RST     0x0
#define DWC_usb3_GDBGLTSSM_TXSWING_RST     0x0
#define DWC_usb3_GDBGLTSSM_LTDBClkState_RST     0x0
#define DWC_usb3_GDBGLTSSM_TXDEEMPHASIS_RST     0x1
#define DWC_usb3_GDBGLTSSM_RXEQTRAIN_RST     0x0
#define DWC_usb3_GDBGLTSSM_POWERDOWN_RST     0x2
#define DWC_usb3_GDBGLTSSM_LTDBPhyCmdState_RST     0x0
#define DWC_usb3_GDBGLTSSM_TxDetRxLoopback_RST     0x0
#define DWC_usb3_GDBGLTSSM_RXPOLARITY_RST     0x0
#define DWC_usb3_GDBGLTSSM_TXELECLDLE_RST     0x1
#define DWC_usb3_GDBGLTSSM_ELASTICBUFFERMODE_RST     0x0
#define DWC_usb3_GDBGLTSSM_LTDBSUBSTATE_RST     0x0
#define DWC_usb3_GDBGLTSSM_LTDBLINKSTATE_RST     0x4
#define DWC_usb3_GDBGLTSSM_LTDBTIMEOUT_RST     0x0
#define DWC_usb3_GDBGLTSSM_PRTDIRECTION_RST     0x0
#define DWC_usb3_GDBGLTSSM_X3_DS_HOST_SHUTDOWN_RST     0x0
#define DWC_usb3_GDBGLTSSM_X3_XS_SWAPPING_RST     0x0
#define DWC_usb3_GDBGLTSSM_RxElecidle_RST     0x1
#define DWC_usb3_GDBGLTSSM_reserved_31_31_RST     0x0

__INLINE void dwc_usb3_gdbgltssm_pack(uint8_t txoneszeros,uint8_t rxtermination,uint8_t txswing,uint8_t ltdbclkstate,uint8_t txdeemphasis,uint8_t rxeqtrain,uint8_t powerdown,uint8_t ltdbphycmdstate,uint8_t txdetrxloopback,uint8_t rxpolarity,uint8_t txelecldle,uint8_t elasticbuffermode,uint8_t ltdbsubstate,uint8_t ltdblinkstate,uint8_t ltdbtimeout,uint8_t prtdirection,uint8_t x3dshostshutdown,uint8_t x3xsswapping,uint8_t rxelecidle,uint8_t reserved3131)
{
       ASSERT_ERR((((uint32_t)txoneszeros << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)rxtermination << 1) & ~((uint32_t)0x00000002)) == 0);
       ASSERT_ERR((((uint32_t)txswing << 2) & ~((uint32_t)0x00000004)) == 0);
       ASSERT_ERR((((uint32_t)ltdbclkstate << 3) & ~((uint32_t)0x00000038)) == 0);
       ASSERT_ERR((((uint32_t)txdeemphasis << 6) & ~((uint32_t)0x000000C0)) == 0);
       ASSERT_ERR((((uint32_t)rxeqtrain << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)powerdown << 9) & ~((uint32_t)0x00000600)) == 0);
       ASSERT_ERR((((uint32_t)ltdbphycmdstate << 11) & ~((uint32_t)0x00003800)) == 0);
       ASSERT_ERR((((uint32_t)txdetrxloopback << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)rxpolarity << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)txelecldle << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)elasticbuffermode << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)ltdbsubstate << 18) & ~((uint32_t)0x003C0000)) == 0);
       ASSERT_ERR((((uint32_t)ltdblinkstate << 22) & ~((uint32_t)0x03C00000)) == 0);
       ASSERT_ERR((((uint32_t)ltdbtimeout << 26) & ~((uint32_t)0x04000000)) == 0);
       ASSERT_ERR((((uint32_t)prtdirection << 27) & ~((uint32_t)0x08000000)) == 0);
       ASSERT_ERR((((uint32_t)x3dshostshutdown << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)x3xsswapping << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)rxelecidle << 30) & ~((uint32_t)0x40000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3131 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLTSSM_ADDR, ((uint32_t)txoneszeros << 0) |((uint32_t)rxtermination << 1) |((uint32_t)txswing << 2) |((uint32_t)ltdbclkstate << 3) |((uint32_t)txdeemphasis << 6) |((uint32_t)rxeqtrain << 8) |((uint32_t)powerdown << 9) |((uint32_t)ltdbphycmdstate << 11) |((uint32_t)txdetrxloopback << 14) |((uint32_t)rxpolarity << 15) |((uint32_t)txelecldle << 16) |((uint32_t)elasticbuffermode << 17) |((uint32_t)ltdbsubstate << 18) |((uint32_t)ltdblinkstate << 22) |((uint32_t)ltdbtimeout << 26) |((uint32_t)prtdirection << 27) |((uint32_t)x3dshostshutdown << 28) |((uint32_t)x3xsswapping << 29) |((uint32_t)rxelecidle << 30) |((uint32_t)reserved3131 << 31));
}

__INLINE void dwc_usb3_gdbgltssm_unpack(uint8_t* txoneszeros,uint8_t* rxtermination,uint8_t* txswing,uint8_t* ltdbclkstate,uint8_t* txdeemphasis,uint8_t* rxeqtrain,uint8_t* powerdown,uint8_t* ltdbphycmdstate,uint8_t* txdetrxloopback,uint8_t* rxpolarity,uint8_t* txelecldle,uint8_t* elasticbuffermode,uint8_t* ltdbsubstate,uint8_t* ltdblinkstate,uint8_t* ltdbtimeout,uint8_t* prtdirection,uint8_t* x3dshostshutdown,uint8_t* x3xsswapping,uint8_t* rxelecidle,uint8_t* reserved3131)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);

       *txoneszeros = (localVal & ((uint32_t)0x00000001)) >> 0;
       *rxtermination = (localVal & ((uint32_t)0x00000002)) >> 1;
       *txswing = (localVal & ((uint32_t)0x00000004)) >> 2;
       *ltdbclkstate = (localVal & ((uint32_t)0x00000038)) >> 3;
       *txdeemphasis = (localVal & ((uint32_t)0x000000C0)) >> 6;
       *rxeqtrain = (localVal & ((uint32_t)0x00000100)) >> 8;
       *powerdown = (localVal & ((uint32_t)0x00000600)) >> 9;
       *ltdbphycmdstate = (localVal & ((uint32_t)0x00003800)) >> 11;
       *txdetrxloopback = (localVal & ((uint32_t)0x00004000)) >> 14;
       *rxpolarity = (localVal & ((uint32_t)0x00008000)) >> 15;
       *txelecldle = (localVal & ((uint32_t)0x00010000)) >> 16;
       *elasticbuffermode = (localVal & ((uint32_t)0x00020000)) >> 17;
       *ltdbsubstate = (localVal & ((uint32_t)0x003C0000)) >> 18;
       *ltdblinkstate = (localVal & ((uint32_t)0x03C00000)) >> 22;
       *ltdbtimeout = (localVal & ((uint32_t)0x04000000)) >> 26;
       *prtdirection = (localVal & ((uint32_t)0x08000000)) >> 27;
       *x3dshostshutdown = (localVal & ((uint32_t)0x10000000)) >> 28;
       *x3xsswapping = (localVal & ((uint32_t)0x20000000)) >> 29;
       *rxelecidle = (localVal & ((uint32_t)0x40000000)) >> 30;
       *reserved3131 = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_txoneszeros_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_rxtermination_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_txswing_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_ltdbclkstate_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000038)) >> 3);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_txdeemphasis_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x000000C0)) >> 6);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_rxeqtrain_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_powerdown_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_ltdbphycmdstate_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00003800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_txdetrxloopback_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_rxpolarity_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_txelecldle_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_elasticbuffermode_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_ltdbsubstate_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x003C0000)) >> 18);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_ltdblinkstate_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x03C00000)) >> 22);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_ltdbtimeout_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_prtdirection_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_x3_ds_host_shutdown_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_x3_xs_swapping_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_rxelecidle_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE uint8_t  dwc_usb3_gdbgltssm_reserved_31_31_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLTSSM_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
/**
* \@brief GDBGLNMCC register definition
* Global Debug LNMCC Register

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:08       LNMCC_BERC                              0x0
*    09:31      reserved_31_9                           0x0
* </pre>
*/
#define DWC_usb3_GDBGLNMCC_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C168)
#define DWC_usb3_GDBGLNMCC_OFFSET      0x0000C168
#define DWC_usb3_GDBGLNMCC_INDEX       0x305a
__INLINE uint32_t dwc_usb3_gdbglnmcc_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGLNMCC_ADDR);
}

__INLINE void dwc_usb3_gdbglnmcc_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGLNMCC_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGLNMCC_LNMCC_BERC_MASK    ((uint32_t)0x000001FF)
#define DWC_usb3_GDBGLNMCC_LNMCC_BERC_LSB     0
#define DWC_usb3_GDBGLNMCC_LNMCC_BERC_WIDTH   ((uint32_t)0x00000009)
#define DWC_usb3_GDBGLNMCC_reserved_31_9_MASK    ((uint32_t)0xFFFFFE00)
#define DWC_usb3_GDBGLNMCC_reserved_31_9_LSB     9
#define DWC_usb3_GDBGLNMCC_reserved_31_9_WIDTH   ((uint32_t)0x00000017)

#define DWC_usb3_GDBGLNMCC_LNMCC_BERC_RST     0x0
#define DWC_usb3_GDBGLNMCC_reserved_31_9_RST     0x0

__INLINE void dwc_usb3_gdbglnmcc_pack(uint16_t lnmccberc,uint32_t reserved319)
{
       ASSERT_ERR((((uint32_t)lnmccberc << 0) & ~((uint32_t)0x000001FF)) == 0);
       ASSERT_ERR((((uint32_t)reserved319 << 9) & ~((uint32_t)0xFFFFFE00)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLNMCC_ADDR, ((uint32_t)lnmccberc << 0) |((uint32_t)reserved319 << 9));
}

__INLINE void dwc_usb3_gdbglnmcc_unpack(uint16_t* lnmccberc,uint32_t* reserved319)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLNMCC_ADDR);

       *lnmccberc = (localVal & ((uint32_t)0x000001FF)) >> 0;
       *reserved319 = (localVal & ((uint32_t)0xFFFFFE00)) >> 9;
}
__INLINE uint16_t  dwc_usb3_gdbglnmcc_lnmcc_berc_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLNMCC_ADDR);
       return ((localVal & ((uint32_t)0x000001FF)) >> 0);
}
__INLINE uint32_t  dwc_usb3_gdbglnmcc_reserved_31_9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLNMCC_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFE00)) >> 9);
}
/**
* \@brief GDBGBMU register definition
* Global Debug BMU Register

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BMU_CCU                                 0x0
*    04:07       BMU_DCU                                 0x0
*    08:31      BMU_BCU                                 0x0
* </pre>
*/
#define DWC_usb3_GDBGBMU_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C16C)
#define DWC_usb3_GDBGBMU_OFFSET      0x0000C16C
#define DWC_usb3_GDBGBMU_INDEX       0x305b
__INLINE uint32_t dwc_usb3_gdbgbmu_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGBMU_ADDR);
}

__INLINE void dwc_usb3_gdbgbmu_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGBMU_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGBMU_BMU_CCU_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GDBGBMU_BMU_CCU_LSB     0
#define DWC_usb3_GDBGBMU_BMU_CCU_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GDBGBMU_BMU_DCU_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GDBGBMU_BMU_DCU_LSB     4
#define DWC_usb3_GDBGBMU_BMU_DCU_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GDBGBMU_BMU_BCU_MASK    ((uint32_t)0xFFFFFF00)
#define DWC_usb3_GDBGBMU_BMU_BCU_LSB     8
#define DWC_usb3_GDBGBMU_BMU_BCU_WIDTH   ((uint32_t)0x00000018)

#define DWC_usb3_GDBGBMU_BMU_CCU_RST     0x0
#define DWC_usb3_GDBGBMU_BMU_DCU_RST     0x0
#define DWC_usb3_GDBGBMU_BMU_BCU_RST     0x0

__INLINE void dwc_usb3_gdbgbmu_pack(uint8_t bmuccu,uint8_t bmudcu,uint32_t bmubcu)
{
       ASSERT_ERR((((uint32_t)bmuccu << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)bmudcu << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)bmubcu << 8) & ~((uint32_t)0xFFFFFF00)) == 0);
       REG_PL_WR(DWC_usb3_GDBGBMU_ADDR, ((uint32_t)bmuccu << 0) |((uint32_t)bmudcu << 4) |((uint32_t)bmubcu << 8));
}

__INLINE void dwc_usb3_gdbgbmu_unpack(uint8_t* bmuccu,uint8_t* bmudcu,uint32_t* bmubcu)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGBMU_ADDR);

       *bmuccu = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *bmudcu = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *bmubcu = (localVal & ((uint32_t)0xFFFFFF00)) >> 8;
}
__INLINE uint8_t  dwc_usb3_gdbgbmu_bmu_ccu_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGBMU_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE uint8_t  dwc_usb3_gdbgbmu_bmu_dcu_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGBMU_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE uint32_t  dwc_usb3_gdbgbmu_bmu_bcu_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGBMU_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFF00)) >> 8);
}
/**
* \@brief GDBGLSPMUX_HST register definition
* Global Debug LSP MUX Register - Host

This register is for internal use only.

If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during controller configuration, then the default values readout is X (Undefined).

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:13      HOSTSELECT                              0x0
*    14:15      reserved_15_14                          0x0
*    16:23      logic_analyzer_trace                    0x3f
*    24:31      reserved_31_24                          0x0
* </pre>
*/
#define DWC_usb3_GDBGLSPMUX_HST_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C170)
#define DWC_usb3_GDBGLSPMUX_HST_OFFSET      0x0000C170
#define DWC_usb3_GDBGLSPMUX_HST_INDEX       0x305c
__INLINE uint32_t dwc_usb3_gdbglspmux_hst_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);
}

__INLINE void dwc_usb3_gdbglspmux_hst_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGLSPMUX_HST_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGLSPMUX_HST_HOSTSELECT_MASK    ((uint32_t)0x00003FFF)
#define DWC_usb3_GDBGLSPMUX_HST_HOSTSELECT_LSB     0
#define DWC_usb3_GDBGLSPMUX_HST_HOSTSELECT_WIDTH   ((uint32_t)0x0000000E)
#define DWC_usb3_GDBGLSPMUX_HST_reserved_15_14_MASK    ((uint32_t)0x0000C000)
#define DWC_usb3_GDBGLSPMUX_HST_reserved_15_14_LSB     14
#define DWC_usb3_GDBGLSPMUX_HST_reserved_15_14_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_GDBGLSPMUX_HST_logic_analyzer_trace_MASK    ((uint32_t)0x00FF0000)
#define DWC_usb3_GDBGLSPMUX_HST_logic_analyzer_trace_LSB     16
#define DWC_usb3_GDBGLSPMUX_HST_logic_analyzer_trace_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_GDBGLSPMUX_HST_reserved_31_24_MASK    ((uint32_t)0xFF000000)
#define DWC_usb3_GDBGLSPMUX_HST_reserved_31_24_LSB     24
#define DWC_usb3_GDBGLSPMUX_HST_reserved_31_24_WIDTH   ((uint32_t)0x00000008)

#define DWC_usb3_GDBGLSPMUX_HST_HOSTSELECT_RST     0x0
#define DWC_usb3_GDBGLSPMUX_HST_reserved_15_14_RST     0x0
#define DWC_usb3_GDBGLSPMUX_HST_logic_analyzer_trace_RST     0x3f
#define DWC_usb3_GDBGLSPMUX_HST_reserved_31_24_RST     0x0

__INLINE void dwc_usb3_gdbglspmux_hst_pack(uint16_t hostselect,uint8_t reserved1514,uint8_t logicanalyzertrace,uint8_t reserved3124)
{
       ASSERT_ERR((((uint32_t)hostselect << 0) & ~((uint32_t)0x00003FFF)) == 0);
       ASSERT_ERR((((uint32_t)reserved1514 << 14) & ~((uint32_t)0x0000C000)) == 0);
       ASSERT_ERR((((uint32_t)logicanalyzertrace << 16) & ~((uint32_t)0x00FF0000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3124 << 24) & ~((uint32_t)0xFF000000)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLSPMUX_HST_ADDR, ((uint32_t)hostselect << 0) |((uint32_t)reserved1514 << 14) |((uint32_t)logicanalyzertrace << 16) |((uint32_t)reserved3124 << 24));
}

__INLINE void dwc_usb3_gdbglspmux_hst_unpack(uint16_t* hostselect,uint8_t* reserved1514,uint8_t* logicanalyzertrace,uint8_t* reserved3124)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);

       *hostselect = (localVal & ((uint32_t)0x00003FFF)) >> 0;
       *reserved1514 = (localVal & ((uint32_t)0x0000C000)) >> 14;
       *logicanalyzertrace = (localVal & ((uint32_t)0x00FF0000)) >> 16;
       *reserved3124 = (localVal & ((uint32_t)0xFF000000)) >> 24;
}
__INLINE uint16_t  dwc_usb3_gdbglspmux_hst_hostselect_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);
       return ((localVal & ((uint32_t)0x00003FFF)) >> 0);
}
__INLINE void  dwc_usb3_gdbglspmux_hst_hostselect_setf(uint16_t  hostselect)
{
       ASSERT_ERR((((uint32_t)hostselect << 0) & ~((uint32_t)0x00003FFF)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLSPMUX_HST_ADDR, (REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR) & ~((uint32_t)0x00003FFF)) | ((uint32_t)hostselect <<0));
}
__INLINE uint8_t  dwc_usb3_gdbglspmux_hst_reserved_15_14_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);
       return ((localVal & ((uint32_t)0x0000C000)) >> 14);
}
__INLINE uint8_t  dwc_usb3_gdbglspmux_hst_logic_analyzer_trace_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);
       return ((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void  dwc_usb3_gdbglspmux_hst_logic_analyzer_trace_setf(uint8_t  logicanalyzertrace)
{
       ASSERT_ERR((((uint32_t)logicanalyzertrace << 16) & ~((uint32_t)0x00FF0000)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLSPMUX_HST_ADDR, (REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)logicanalyzertrace <<16));
}
__INLINE uint8_t  dwc_usb3_gdbglspmux_hst_reserved_31_24_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSPMUX_HST_ADDR);
       return ((localVal & ((uint32_t)0xFF000000)) >> 24);
}
/**
* \@brief GDBGLSP register definition
* Global Debug LSP Register

This register is for internal debug purposes only.

This register is for internal use only.

If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during controller configuration, then the default values readout is X (Undefined).

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      LSPDEBUG                                0x0
* </pre>
*/
#define DWC_usb3_GDBGLSP_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C174)
#define DWC_usb3_GDBGLSP_OFFSET      0x0000C174
#define DWC_usb3_GDBGLSP_INDEX       0x305d
__INLINE uint32_t dwc_usb3_gdbglsp_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGLSP_ADDR);
}

__INLINE void dwc_usb3_gdbglsp_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGLSP_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGLSP_LSPDEBUG_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GDBGLSP_LSPDEBUG_LSB     0
#define DWC_usb3_GDBGLSP_LSPDEBUG_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GDBGLSP_LSPDEBUG_RST     0x0

__INLINE void dwc_usb3_gdbglsp_pack(uint32_t lspdebug)
{
       ASSERT_ERR((((uint32_t)lspdebug << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GDBGLSP_ADDR, ((uint32_t)lspdebug << 0));
}

__INLINE void dwc_usb3_gdbglsp_unpack(uint32_t* lspdebug)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSP_ADDR);

       *lspdebug = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gdbglsp_lspdebug_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGLSP_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GDBGEPINFO0 register definition
* Global Debug Endpoint Information Register 0

This register is for internal use only.

If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during controller configuration, then the default values readout is X (Undefined).

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      EPDEBUG                                 0x0
* </pre>
*/
#define DWC_usb3_GDBGEPINFO0_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C178)
#define DWC_usb3_GDBGEPINFO0_OFFSET      0x0000C178
#define DWC_usb3_GDBGEPINFO0_INDEX       0x305e
__INLINE uint32_t dwc_usb3_gdbgepinfo0_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGEPINFO0_ADDR);
}

__INLINE void dwc_usb3_gdbgepinfo0_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGEPINFO0_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGEPINFO0_EPDEBUG_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GDBGEPINFO0_EPDEBUG_LSB     0
#define DWC_usb3_GDBGEPINFO0_EPDEBUG_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GDBGEPINFO0_EPDEBUG_RST     0x0

__INLINE void dwc_usb3_gdbgepinfo0_pack(uint32_t epdebug)
{
       ASSERT_ERR((((uint32_t)epdebug << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GDBGEPINFO0_ADDR, ((uint32_t)epdebug << 0));
}

__INLINE void dwc_usb3_gdbgepinfo0_unpack(uint32_t* epdebug)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGEPINFO0_ADDR);

       *epdebug = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gdbgepinfo0_epdebug_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGEPINFO0_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GDBGEPINFO1 register definition
* Global Debug Endpoint Information Register 1

This register is for internal use only.

If DWC_USB3_PRESERVE_LOGIC_ANALYZER_SELECT is enabled during controller configuration, then the default values readout is X (Undefined).

Bit Bash test should not be done on this debug register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      EPDEBUG                                 0x800000
* </pre>
*/
#define DWC_usb3_GDBGEPINFO1_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C17C)
#define DWC_usb3_GDBGEPINFO1_OFFSET      0x0000C17C
#define DWC_usb3_GDBGEPINFO1_INDEX       0x305f
__INLINE uint32_t dwc_usb3_gdbgepinfo1_get(void)
{
       return REG_PL_RD(DWC_usb3_GDBGEPINFO1_ADDR);
}

__INLINE void dwc_usb3_gdbgepinfo1_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GDBGEPINFO1_ADDR,value);
}
// field definitions
#define DWC_usb3_GDBGEPINFO1_EPDEBUG_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GDBGEPINFO1_EPDEBUG_LSB     0
#define DWC_usb3_GDBGEPINFO1_EPDEBUG_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GDBGEPINFO1_EPDEBUG_RST     0x800000

__INLINE void dwc_usb3_gdbgepinfo1_pack(uint32_t epdebug)
{
       ASSERT_ERR((((uint32_t)epdebug << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GDBGEPINFO1_ADDR, ((uint32_t)epdebug << 0));
}

__INLINE void dwc_usb3_gdbgepinfo1_unpack(uint32_t* epdebug)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGEPINFO1_ADDR);

       *epdebug = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_gdbgepinfo1_epdebug_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GDBGEPINFO1_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GPRTBIMAP_HSLO register definition
* Global High-Speed Port to Bus Instance Mapping Register - Low

This is an alternate register for the GPRTBIMAP_HS register.

 - Register fields are read-write with respect to number of port instantiated. writeAsRead constraint is added to limit side effects for unused fields. 

Note: For reset values, refer to the corresponding values in the GPRTBIMAP_HS register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM1                                  0x0
*    04:07       BINUM2                                  0x0
*    08:11      BINUM3                                  0x0
*    12:15      BINUM4                                  0x0
*    16:19      BINUM5                                  0x0
*    20:23      BINUM6                                  0x0
*    24:27      BINUM7                                  0x0
*    28:31      BINUM8                                  0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAP_HSLO_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C180)
#define DWC_usb3_GPRTBIMAP_HSLO_OFFSET      0x0000C180
#define DWC_usb3_GPRTBIMAP_HSLO_INDEX       0x3060
__INLINE uint32_t dwc_usb3_gprtbimap_hslo_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
}

__INLINE void dwc_usb3_gprtbimap_hslo_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM1_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM1_LSB     0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM1_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM2_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM2_LSB     4
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM2_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM3_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM3_LSB     8
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM3_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM4_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM4_LSB     12
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM4_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM5_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM5_LSB     16
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM5_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM6_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM6_LSB     20
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM6_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM7_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM7_LSB     24
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM7_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM8_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM8_LSB     28
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM8_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAP_HSLO_BINUM1_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM2_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM3_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM4_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM5_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM6_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM7_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSLO_BINUM8_RST     0x0

__INLINE void dwc_usb3_gprtbimap_hslo_pack(uint8_t binum1,uint8_t binum2,uint8_t binum3,uint8_t binum4,uint8_t binum5,uint8_t binum6,uint8_t binum7,uint8_t binum8)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, ((uint32_t)binum1 << 0) |((uint32_t)binum2 << 4) |((uint32_t)binum3 << 8) |((uint32_t)binum4 << 12) |((uint32_t)binum5 << 16) |((uint32_t)binum6 << 20) |((uint32_t)binum7 << 24) |((uint32_t)binum8 << 28));
}

__INLINE void dwc_usb3_gprtbimap_hslo_unpack(uint8_t* binum1,uint8_t* binum2,uint8_t* binum3,uint8_t* binum4,uint8_t* binum5,uint8_t* binum6,uint8_t* binum7,uint8_t* binum8)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);

       *binum1 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum2 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum3 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum4 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum5 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum6 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum7 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *binum8 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum1_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum1_setf(uint8_t  binum1)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum1 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum2_setf(uint8_t  binum2)
{
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum2 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum3_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum3_setf(uint8_t  binum3)
{
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum3 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum4_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum4_setf(uint8_t  binum4)
{
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum4 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum5_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum5_setf(uint8_t  binum5)
{
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum5 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum6_setf(uint8_t  binum6)
{
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum6 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum7_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum7_setf(uint8_t  binum7)
{
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum7 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hslo_binum8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void  dwc_usb3_gprtbimap_hslo_binum8_setf(uint8_t  binum8)
{
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSLO_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)binum8 <<28));
}
/**
* \@brief GPRTBIMAP_HSHI register definition
* Global High-Speed Port to Bus Instance Mapping Register - High

This is an alternate register for the GPRTBIMAP_HS register.

 - Register fields are read-write with respect to number of port instantiated. writeAsRead constraint is added to limit side effects for unused fields. 

Note: For reset values, refer to the corresponding values in the GPRTBIMAP register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM9                                  0x0
*    04:07       BINUM10                                 0x0
*    08:11      BINUM11                                 0x0
*    12:15      BINUM12                                 0x0
*    16:19      BINUM13                                 0x0
*    20:23      BINUM14                                 0x0
*    24:27      BINUM15                                 0x0
*    28:31      reserved_31_28                          0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAP_HSHI_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C184)
#define DWC_usb3_GPRTBIMAP_HSHI_OFFSET      0x0000C184
#define DWC_usb3_GPRTBIMAP_HSHI_INDEX       0x3061
__INLINE uint32_t dwc_usb3_gprtbimap_hshi_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
}

__INLINE void dwc_usb3_gprtbimap_hshi_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM9_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM9_LSB     0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM9_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM10_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM10_LSB     4
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM10_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM11_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM11_LSB     8
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM11_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM12_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM12_LSB     12
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM12_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM13_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM13_LSB     16
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM13_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM14_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM14_LSB     20
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM14_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM15_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM15_LSB     24
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM15_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_HSHI_reserved_31_28_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAP_HSHI_reserved_31_28_LSB     28
#define DWC_usb3_GPRTBIMAP_HSHI_reserved_31_28_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAP_HSHI_BINUM9_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM10_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM11_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM12_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM13_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM14_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_BINUM15_RST     0x0
#define DWC_usb3_GPRTBIMAP_HSHI_reserved_31_28_RST     0x0

__INLINE void dwc_usb3_gprtbimap_hshi_pack(uint8_t binum9,uint8_t binum10,uint8_t binum11,uint8_t binum12,uint8_t binum13,uint8_t binum14,uint8_t binum15,uint8_t reserved3128)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3128 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, ((uint32_t)binum9 << 0) |((uint32_t)binum10 << 4) |((uint32_t)binum11 << 8) |((uint32_t)binum12 << 12) |((uint32_t)binum13 << 16) |((uint32_t)binum14 << 20) |((uint32_t)binum15 << 24) |((uint32_t)reserved3128 << 28));
}

__INLINE void dwc_usb3_gprtbimap_hshi_unpack(uint8_t* binum9,uint8_t* binum10,uint8_t* binum11,uint8_t* binum12,uint8_t* binum13,uint8_t* binum14,uint8_t* binum15,uint8_t* reserved3128)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);

       *binum9 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum10 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum11 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum12 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum13 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum14 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum15 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *reserved3128 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum9_setf(uint8_t  binum9)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum9 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum10_setf(uint8_t  binum10)
{
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum10 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum11_setf(uint8_t  binum11)
{
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum11 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum12_setf(uint8_t  binum12)
{
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum12 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum13_setf(uint8_t  binum13)
{
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum13 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum14_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum14_setf(uint8_t  binum14)
{
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum14 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_binum15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimap_hshi_binum15_setf(uint8_t  binum15)
{
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_HSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum15 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_hshi_reserved_31_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_HSHI_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
/**
* \@brief GPRTBIMAP_FSLO register definition
* Global Full-Speed Port to Bus Instance Mapping Register - Low

This is an alternate register for the GPRTBIMAP_FS register.

 - Register fields are read-write with respect to number of port instantiated. writeAsRead constraint is added to limit side effects for unused fields. 

Note: For reset values, refer to the corresponding values in the GPRTBIMAP_FS register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM1                                  0x0
*    04:07       BINUM2                                  0x0
*    08:11      BINUM3                                  0x0
*    12:15      BINUM4                                  0x0
*    16:19      BINUM5                                  0x0
*    20:23      BINUM6                                  0x0
*    24:27      BINUM7                                  0x0
*    28:31      BINUM8                                  0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAP_FSLO_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C188)
#define DWC_usb3_GPRTBIMAP_FSLO_OFFSET      0x0000C188
#define DWC_usb3_GPRTBIMAP_FSLO_INDEX       0x3062
__INLINE uint32_t dwc_usb3_gprtbimap_fslo_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
}

__INLINE void dwc_usb3_gprtbimap_fslo_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM1_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM1_LSB     0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM1_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM2_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM2_LSB     4
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM2_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM3_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM3_LSB     8
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM3_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM4_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM4_LSB     12
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM4_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM5_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM5_LSB     16
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM5_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM6_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM6_LSB     20
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM6_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM7_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM7_LSB     24
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM7_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM8_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM8_LSB     28
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM8_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAP_FSLO_BINUM1_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM2_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM3_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM4_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM5_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM6_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM7_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSLO_BINUM8_RST     0x0

__INLINE void dwc_usb3_gprtbimap_fslo_pack(uint8_t binum1,uint8_t binum2,uint8_t binum3,uint8_t binum4,uint8_t binum5,uint8_t binum6,uint8_t binum7,uint8_t binum8)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, ((uint32_t)binum1 << 0) |((uint32_t)binum2 << 4) |((uint32_t)binum3 << 8) |((uint32_t)binum4 << 12) |((uint32_t)binum5 << 16) |((uint32_t)binum6 << 20) |((uint32_t)binum7 << 24) |((uint32_t)binum8 << 28));
}

__INLINE void dwc_usb3_gprtbimap_fslo_unpack(uint8_t* binum1,uint8_t* binum2,uint8_t* binum3,uint8_t* binum4,uint8_t* binum5,uint8_t* binum6,uint8_t* binum7,uint8_t* binum8)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);

       *binum1 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum2 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum3 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum4 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum5 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum6 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum7 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *binum8 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum1_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum1_setf(uint8_t  binum1)
{
       ASSERT_ERR((((uint32_t)binum1 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum1 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum2_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum2_setf(uint8_t  binum2)
{
       ASSERT_ERR((((uint32_t)binum2 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum2 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum3_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum3_setf(uint8_t  binum3)
{
       ASSERT_ERR((((uint32_t)binum3 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum3 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum4_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum4_setf(uint8_t  binum4)
{
       ASSERT_ERR((((uint32_t)binum4 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum4 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum5_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum5_setf(uint8_t  binum5)
{
       ASSERT_ERR((((uint32_t)binum5 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum5 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum6_setf(uint8_t  binum6)
{
       ASSERT_ERR((((uint32_t)binum6 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum6 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum7_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum7_setf(uint8_t  binum7)
{
       ASSERT_ERR((((uint32_t)binum7 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum7 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fslo_binum8_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void  dwc_usb3_gprtbimap_fslo_binum8_setf(uint8_t  binum8)
{
       ASSERT_ERR((((uint32_t)binum8 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSLO_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSLO_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)binum8 <<28));
}
/**
* \@brief GPRTBIMAP_FSHI register definition
* Global Full-Speed Port to Bus Instance Mapping Register - High

This is an alternate register for the GPRTBIMAP_FS register.

 - Register fields are read-write with respect to number of port instantiated. writeAsRead constraint is added to limit side effects for unused fields. 

Note: For reset values, refer to the corresponding values in the GPRTBIMAP_FS register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:03       BINUM9                                  0x0
*    04:07       BINUM10                                 0x0
*    08:11      BINUM11                                 0x0
*    12:15      BINUM12                                 0x0
*    16:19      BINUM13                                 0x0
*    20:23      BINUM14                                 0x0
*    24:27      BINUM15                                 0x0
*    28:31      reserved_31_28                          0x0
* </pre>
*/
#define DWC_usb3_GPRTBIMAP_FSHI_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C18C)
#define DWC_usb3_GPRTBIMAP_FSHI_OFFSET      0x0000C18C
#define DWC_usb3_GPRTBIMAP_FSHI_INDEX       0x3063
__INLINE uint32_t dwc_usb3_gprtbimap_fshi_get(void)
{
       return REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
}

__INLINE void dwc_usb3_gprtbimap_fshi_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR,value);
}
// field definitions
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM9_MASK    ((uint32_t)0x0000000F)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM9_LSB     0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM9_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM10_MASK    ((uint32_t)0x000000F0)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM10_LSB     4
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM10_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM11_MASK    ((uint32_t)0x00000F00)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM11_LSB     8
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM11_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM12_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM12_LSB     12
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM12_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM13_MASK    ((uint32_t)0x000F0000)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM13_LSB     16
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM13_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM14_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM14_LSB     20
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM14_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM15_MASK    ((uint32_t)0x0F000000)
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM15_LSB     24
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM15_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GPRTBIMAP_FSHI_reserved_31_28_MASK    ((uint32_t)0xF0000000)
#define DWC_usb3_GPRTBIMAP_FSHI_reserved_31_28_LSB     28
#define DWC_usb3_GPRTBIMAP_FSHI_reserved_31_28_WIDTH   ((uint32_t)0x00000004)

#define DWC_usb3_GPRTBIMAP_FSHI_BINUM9_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM10_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM11_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM12_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM13_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM14_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_BINUM15_RST     0x0
#define DWC_usb3_GPRTBIMAP_FSHI_reserved_31_28_RST     0x0

__INLINE void dwc_usb3_gprtbimap_fshi_pack(uint8_t binum9,uint8_t binum10,uint8_t binum11,uint8_t binum12,uint8_t binum13,uint8_t binum14,uint8_t binum15,uint8_t reserved3128)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3128 << 28) & ~((uint32_t)0xF0000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, ((uint32_t)binum9 << 0) |((uint32_t)binum10 << 4) |((uint32_t)binum11 << 8) |((uint32_t)binum12 << 12) |((uint32_t)binum13 << 16) |((uint32_t)binum14 << 20) |((uint32_t)binum15 << 24) |((uint32_t)reserved3128 << 28));
}

__INLINE void dwc_usb3_gprtbimap_fshi_unpack(uint8_t* binum9,uint8_t* binum10,uint8_t* binum11,uint8_t* binum12,uint8_t* binum13,uint8_t* binum14,uint8_t* binum15,uint8_t* reserved3128)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);

       *binum9 = (localVal & ((uint32_t)0x0000000F)) >> 0;
       *binum10 = (localVal & ((uint32_t)0x000000F0)) >> 4;
       *binum11 = (localVal & ((uint32_t)0x00000F00)) >> 8;
       *binum12 = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *binum13 = (localVal & ((uint32_t)0x000F0000)) >> 16;
       *binum14 = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *binum15 = (localVal & ((uint32_t)0x0F000000)) >> 24;
       *reserved3128 = (localVal & ((uint32_t)0xF0000000)) >> 28;
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum9_setf(uint8_t  binum9)
{
       ASSERT_ERR((((uint32_t)binum9 << 0) & ~((uint32_t)0x0000000F)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)binum9 <<0));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum10_setf(uint8_t  binum10)
{
       ASSERT_ERR((((uint32_t)binum10 << 4) & ~((uint32_t)0x000000F0)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)binum10 <<4));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum11_setf(uint8_t  binum11)
{
       ASSERT_ERR((((uint32_t)binum11 << 8) & ~((uint32_t)0x00000F00)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)binum11 <<8));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum12_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum12_setf(uint8_t  binum12)
{
       ASSERT_ERR((((uint32_t)binum12 << 12) & ~((uint32_t)0x0000F000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)binum12 <<12));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum13_setf(uint8_t  binum13)
{
       ASSERT_ERR((((uint32_t)binum13 << 16) & ~((uint32_t)0x000F0000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)binum13 <<16));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum14_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum14_setf(uint8_t  binum14)
{
       ASSERT_ERR((((uint32_t)binum14 << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)binum14 <<20));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_binum15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0x0F000000)) >> 24);
}
__INLINE void  dwc_usb3_gprtbimap_fshi_binum15_setf(uint8_t  binum15)
{
       ASSERT_ERR((((uint32_t)binum15 << 24) & ~((uint32_t)0x0F000000)) == 0);
       REG_PL_WR(DWC_usb3_GPRTBIMAP_FSHI_ADDR, (REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR) & ~((uint32_t)0x0F000000)) | ((uint32_t)binum15 <<24));
}
__INLINE uint8_t  dwc_usb3_gprtbimap_fshi_reserved_31_28_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GPRTBIMAP_FSHI_ADDR);
       return ((localVal & ((uint32_t)0xF0000000)) >> 28);
}
/**
* \@brief Reserved_94 register definition
* Future Reserved Register at offset 0x94
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      reserved_31_0                           0x0
* </pre>
*/
#define DWC_usb3_Reserved_94_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C194)
#define DWC_usb3_Reserved_94_OFFSET      0x0000C194
#define DWC_usb3_Reserved_94_INDEX       0x3065
__INLINE uint32_t dwc_usb3_reserved_94_get(void)
{
       return REG_PL_RD(DWC_usb3_Reserved_94_ADDR);
}

__INLINE void dwc_usb3_reserved_94_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_Reserved_94_ADDR,value);
}
// field definitions
#define DWC_usb3_Reserved_94_reserved_31_0_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_Reserved_94_reserved_31_0_LSB     0
#define DWC_usb3_Reserved_94_reserved_31_0_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_Reserved_94_reserved_31_0_RST     0x0

__INLINE void dwc_usb3_reserved_94_pack(uint32_t reserved310)
{
       ASSERT_ERR((((uint32_t)reserved310 << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_Reserved_94_ADDR, ((uint32_t)reserved310 << 0));
}

__INLINE void dwc_usb3_reserved_94_unpack(uint32_t* reserved310)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_Reserved_94_ADDR);

       *reserved310 = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_reserved_94_reserved_31_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_Reserved_94_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief Reserved_98 register definition
* Future Reserved Register at offset 0x98
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      reserved_31_0                           0x0
* </pre>
*/
#define DWC_usb3_Reserved_98_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C198)
#define DWC_usb3_Reserved_98_OFFSET      0x0000C198
#define DWC_usb3_Reserved_98_INDEX       0x3066
__INLINE uint32_t dwc_usb3_reserved_98_get(void)
{
       return REG_PL_RD(DWC_usb3_Reserved_98_ADDR);
}

__INLINE void dwc_usb3_reserved_98_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_Reserved_98_ADDR,value);
}
// field definitions
#define DWC_usb3_Reserved_98_reserved_31_0_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_Reserved_98_reserved_31_0_LSB     0
#define DWC_usb3_Reserved_98_reserved_31_0_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_Reserved_98_reserved_31_0_RST     0x0

__INLINE void dwc_usb3_reserved_98_pack(uint32_t reserved310)
{
       ASSERT_ERR((((uint32_t)reserved310 << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_Reserved_98_ADDR, ((uint32_t)reserved310 << 0));
}

__INLINE void dwc_usb3_reserved_98_unpack(uint32_t* reserved310)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_Reserved_98_ADDR);

       *reserved310 = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_reserved_98_reserved_31_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_Reserved_98_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GUCTL2 register definition
* Global User Control Register 2:  

This register provides a few options for the software to control the controller behavior in the Host and device mode. Most of the options are used to improve inter-operability with different hosts and devices.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:04       TxPingDuration                          0xd
*    05:10      RxPingDuration                          0x20
*    11         DisableCFC                              0x0
*    12         EnableEpCacheEvict                      0x0
*    13         reserved_13                             0x0
*    14         Rst_actbitlater                         0x0
*    15:18      NOLOWPWRDUR                             0x0
*    19:25      EN_HP_PM_TIMER                          0x33
*    26:31      reserved_31_26                          0x0
* </pre>
*/
#define DWC_usb3_GUCTL2_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C19C)
#define DWC_usb3_GUCTL2_OFFSET      0x0000C19C
#define DWC_usb3_GUCTL2_INDEX       0x3067
__INLINE uint32_t dwc_usb3_guctl2_get(void)
{
       return REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
}

__INLINE void dwc_usb3_guctl2_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR,value);
}
// field definitions
#define DWC_usb3_GUCTL2_TxPingDuration_MASK    ((uint32_t)0x0000001F)
#define DWC_usb3_GUCTL2_TxPingDuration_LSB     0
#define DWC_usb3_GUCTL2_TxPingDuration_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_GUCTL2_RxPingDuration_MASK    ((uint32_t)0x000007E0)
#define DWC_usb3_GUCTL2_RxPingDuration_LSB     5
#define DWC_usb3_GUCTL2_RxPingDuration_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GUCTL2_DisableCFC_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_GUCTL2_DisableCFC_POS     11
#define DWC_usb3_GUCTL2_EnableEpCacheEvict_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_GUCTL2_EnableEpCacheEvict_POS     12
#define DWC_usb3_GUCTL2_reserved_13_BIT     ((uint32_t)0x00002000)
#define DWC_usb3_GUCTL2_reserved_13_POS     13
#define DWC_usb3_GUCTL2_Rst_actbitlater_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_GUCTL2_Rst_actbitlater_POS     14
#define DWC_usb3_GUCTL2_NOLOWPWRDUR_MASK    ((uint32_t)0x00078000)
#define DWC_usb3_GUCTL2_NOLOWPWRDUR_LSB     15
#define DWC_usb3_GUCTL2_NOLOWPWRDUR_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_GUCTL2_EN_HP_PM_TIMER_MASK    ((uint32_t)0x03F80000)
#define DWC_usb3_GUCTL2_EN_HP_PM_TIMER_LSB     19
#define DWC_usb3_GUCTL2_EN_HP_PM_TIMER_WIDTH   ((uint32_t)0x00000007)
#define DWC_usb3_GUCTL2_reserved_31_26_MASK    ((uint32_t)0xFC000000)
#define DWC_usb3_GUCTL2_reserved_31_26_LSB     26
#define DWC_usb3_GUCTL2_reserved_31_26_WIDTH   ((uint32_t)0x00000006)

#define DWC_usb3_GUCTL2_TxPingDuration_RST     0xd
#define DWC_usb3_GUCTL2_RxPingDuration_RST     0x20
#define DWC_usb3_GUCTL2_DisableCFC_RST     0x0
#define DWC_usb3_GUCTL2_EnableEpCacheEvict_RST     0x0
#define DWC_usb3_GUCTL2_reserved_13_RST     0x0
#define DWC_usb3_GUCTL2_Rst_actbitlater_RST     0x0
#define DWC_usb3_GUCTL2_NOLOWPWRDUR_RST     0x0
#define DWC_usb3_GUCTL2_EN_HP_PM_TIMER_RST     0x33
#define DWC_usb3_GUCTL2_reserved_31_26_RST     0x0

__INLINE void dwc_usb3_guctl2_pack(uint8_t txpingduration,uint8_t rxpingduration,uint8_t disablecfc,uint8_t enableepcacheevict,uint8_t reserved13,uint8_t rstactbitlater,uint8_t nolowpwrdur,uint8_t enhppmtimer,uint8_t reserved3126)
{
       ASSERT_ERR((((uint32_t)txpingduration << 0) & ~((uint32_t)0x0000001F)) == 0);
       ASSERT_ERR((((uint32_t)rxpingduration << 5) & ~((uint32_t)0x000007E0)) == 0);
       ASSERT_ERR((((uint32_t)disablecfc << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)enableepcacheevict << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)reserved13 << 13) & ~((uint32_t)0x00002000)) == 0);
       ASSERT_ERR((((uint32_t)rstactbitlater << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)nolowpwrdur << 15) & ~((uint32_t)0x00078000)) == 0);
       ASSERT_ERR((((uint32_t)enhppmtimer << 19) & ~((uint32_t)0x03F80000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3126 << 26) & ~((uint32_t)0xFC000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, ((uint32_t)txpingduration << 0) |((uint32_t)rxpingduration << 5) |((uint32_t)disablecfc << 11) |((uint32_t)enableepcacheevict << 12) |((uint32_t)reserved13 << 13) |((uint32_t)rstactbitlater << 14) |((uint32_t)nolowpwrdur << 15) |((uint32_t)enhppmtimer << 19) |((uint32_t)reserved3126 << 26));
}

__INLINE void dwc_usb3_guctl2_unpack(uint8_t* txpingduration,uint8_t* rxpingduration,uint8_t* disablecfc,uint8_t* enableepcacheevict,uint8_t* reserved13,uint8_t* rstactbitlater,uint8_t* nolowpwrdur,uint8_t* enhppmtimer,uint8_t* reserved3126)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);

       *txpingduration = (localVal & ((uint32_t)0x0000001F)) >> 0;
       *rxpingduration = (localVal & ((uint32_t)0x000007E0)) >> 5;
       *disablecfc = (localVal & ((uint32_t)0x00000800)) >> 11;
       *enableepcacheevict = (localVal & ((uint32_t)0x00001000)) >> 12;
       *reserved13 = (localVal & ((uint32_t)0x00002000)) >> 13;
       *rstactbitlater = (localVal & ((uint32_t)0x00004000)) >> 14;
       *nolowpwrdur = (localVal & ((uint32_t)0x00078000)) >> 15;
       *enhppmtimer = (localVal & ((uint32_t)0x03F80000)) >> 19;
       *reserved3126 = (localVal & ((uint32_t)0xFC000000)) >> 26;
}
__INLINE uint8_t  dwc_usb3_guctl2_txpingduration_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void  dwc_usb3_guctl2_txpingduration_setf(uint8_t  txpingduration)
{
       ASSERT_ERR((((uint32_t)txpingduration << 0) & ~((uint32_t)0x0000001F)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)txpingduration <<0));
}
__INLINE uint8_t  dwc_usb3_guctl2_rxpingduration_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x000007E0)) >> 5);
}
__INLINE void  dwc_usb3_guctl2_rxpingduration_setf(uint8_t  rxpingduration)
{
       ASSERT_ERR((((uint32_t)rxpingduration << 5) & ~((uint32_t)0x000007E0)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x000007E0)) | ((uint32_t)rxpingduration <<5));
}
__INLINE uint8_t  dwc_usb3_guctl2_disablecfc_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void  dwc_usb3_guctl2_disablecfc_setf(uint8_t  disablecfc)
{
       ASSERT_ERR((((uint32_t)disablecfc << 11) & ~((uint32_t)0x00000800)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)disablecfc <<11));
}
__INLINE uint8_t  dwc_usb3_guctl2_enableepcacheevict_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void  dwc_usb3_guctl2_enableepcacheevict_setf(uint8_t  enableepcacheevict)
{
       ASSERT_ERR((((uint32_t)enableepcacheevict << 12) & ~((uint32_t)0x00001000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)enableepcacheevict <<12));
}
__INLINE uint8_t  dwc_usb3_guctl2_reserved_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_guctl2_rst_actbitlater_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void  dwc_usb3_guctl2_rst_actbitlater_setf(uint8_t  rstactbitlater)
{
       ASSERT_ERR((((uint32_t)rstactbitlater << 14) & ~((uint32_t)0x00004000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)rstactbitlater <<14));
}
__INLINE uint8_t  dwc_usb3_guctl2_nolowpwrdur_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x00078000)) >> 15);
}
__INLINE void  dwc_usb3_guctl2_nolowpwrdur_setf(uint8_t  nolowpwrdur)
{
       ASSERT_ERR((((uint32_t)nolowpwrdur << 15) & ~((uint32_t)0x00078000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x00078000)) | ((uint32_t)nolowpwrdur <<15));
}
__INLINE uint8_t  dwc_usb3_guctl2_en_hp_pm_timer_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0x03F80000)) >> 19);
}
__INLINE void  dwc_usb3_guctl2_en_hp_pm_timer_setf(uint8_t  enhppmtimer)
{
       ASSERT_ERR((((uint32_t)enhppmtimer << 19) & ~((uint32_t)0x03F80000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0x03F80000)) | ((uint32_t)enhppmtimer <<19));
}
__INLINE uint8_t  dwc_usb3_guctl2_reserved_31_26_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL2_ADDR);
       return ((localVal & ((uint32_t)0xFC000000)) >> 26);
}
__INLINE void  dwc_usb3_guctl2_reserved_31_26_setf(uint8_t  reserved3126)
{
       ASSERT_ERR((((uint32_t)reserved3126 << 26) & ~((uint32_t)0xFC000000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL2_ADDR, (REG_PL_RD(DWC_usb3_GUCTL2_ADDR) & ~((uint32_t)0xFC000000)) | ((uint32_t)reserved3126 <<26));
}
/**
* \@brief GHWPARAMS8 register definition
* Global Hardware Parameters Register 8

This register contains the hardware configuration options that you can select in the coreConsultant GUI.  

For a description of each parameter, refer to the "Parameter Descriptions" chapter in the Databook. This information is also available in coreConsultant by right-clicking the parameter label and selecting "What's This" or by clicking the Help tab.  

Note: 

Some of the global hardware parameters are not currently modifiable in coreConsultant. These settings are in the  <workspace>/src/DWC_usb3_params.v file; you must not change them.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      ghwparams8_32_0                         0xf8c
* </pre>
*/
#define DWC_usb3_GHWPARAMS8_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C600)
#define DWC_usb3_GHWPARAMS8_OFFSET      0x0000C600
#define DWC_usb3_GHWPARAMS8_INDEX       0x3180
__INLINE uint32_t dwc_usb3_ghwparams8_get(void)
{
       return REG_PL_RD(DWC_usb3_GHWPARAMS8_ADDR);
}

__INLINE void dwc_usb3_ghwparams8_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GHWPARAMS8_ADDR,value);
}
// field definitions
#define DWC_usb3_GHWPARAMS8_ghwparams8_32_0_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_GHWPARAMS8_ghwparams8_32_0_LSB     0
#define DWC_usb3_GHWPARAMS8_ghwparams8_32_0_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_GHWPARAMS8_ghwparams8_32_0_RST     0xf8c

__INLINE void dwc_usb3_ghwparams8_pack(uint32_t ghwparams8320)
{
       ASSERT_ERR((((uint32_t)ghwparams8320 << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_GHWPARAMS8_ADDR, ((uint32_t)ghwparams8320 << 0));
}

__INLINE void dwc_usb3_ghwparams8_unpack(uint32_t* ghwparams8320)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS8_ADDR);

       *ghwparams8320 = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_ghwparams8_ghwparams8_32_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GHWPARAMS8_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
/**
* \@brief GUCTL3 register definition
* Global User Control Register 3

This register provides a few options for the software to control the controller behavior in the Host mode. Most of the options are used to improve host inter-operability with different devices.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:15      reserved_15_0                           0x0
*    16         Sch_Ping_early                          0x1
*    17:31      reserved_31_17                          0x0
* </pre>
*/
#define DWC_usb3_GUCTL3_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C60C)
#define DWC_usb3_GUCTL3_OFFSET      0x0000C60C
#define DWC_usb3_GUCTL3_INDEX       0x3183
__INLINE uint32_t dwc_usb3_guctl3_get(void)
{
       return REG_PL_RD(DWC_usb3_GUCTL3_ADDR);
}

__INLINE void dwc_usb3_guctl3_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GUCTL3_ADDR,value);
}
// field definitions
#define DWC_usb3_GUCTL3_reserved_15_0_MASK    ((uint32_t)0x0000FFFF)
#define DWC_usb3_GUCTL3_reserved_15_0_LSB     0
#define DWC_usb3_GUCTL3_reserved_15_0_WIDTH   ((uint32_t)0x00000010)
#define DWC_usb3_GUCTL3_Sch_Ping_early_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_GUCTL3_Sch_Ping_early_POS     16
#define DWC_usb3_GUCTL3_reserved_31_17_MASK    ((uint32_t)0xFFFE0000)
#define DWC_usb3_GUCTL3_reserved_31_17_LSB     17
#define DWC_usb3_GUCTL3_reserved_31_17_WIDTH   ((uint32_t)0x0000000F)

#define DWC_usb3_GUCTL3_reserved_15_0_RST     0x0
#define DWC_usb3_GUCTL3_Sch_Ping_early_RST     0x1
#define DWC_usb3_GUCTL3_reserved_31_17_RST     0x0

__INLINE void dwc_usb3_guctl3_pack(uint16_t reserved150,uint8_t schpingearly,uint16_t reserved3117)
{
       ASSERT_ERR((((uint32_t)reserved150 << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       ASSERT_ERR((((uint32_t)schpingearly << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3117 << 17) & ~((uint32_t)0xFFFE0000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL3_ADDR, ((uint32_t)reserved150 << 0) |((uint32_t)schpingearly << 16) |((uint32_t)reserved3117 << 17));
}

__INLINE void dwc_usb3_guctl3_unpack(uint16_t* reserved150,uint8_t* schpingearly,uint16_t* reserved3117)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL3_ADDR);

       *reserved150 = (localVal & ((uint32_t)0x0000FFFF)) >> 0;
       *schpingearly = (localVal & ((uint32_t)0x00010000)) >> 16;
       *reserved3117 = (localVal & ((uint32_t)0xFFFE0000)) >> 17;
}
__INLINE uint16_t  dwc_usb3_guctl3_reserved_15_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL3_ADDR);
       return ((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void  dwc_usb3_guctl3_reserved_15_0_setf(uint16_t  reserved150)
{
       ASSERT_ERR((((uint32_t)reserved150 << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL3_ADDR, (REG_PL_RD(DWC_usb3_GUCTL3_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)reserved150 <<0));
}
__INLINE uint8_t  dwc_usb3_guctl3_sch_ping_early_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL3_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void  dwc_usb3_guctl3_sch_ping_early_setf(uint8_t  schpingearly)
{
       ASSERT_ERR((((uint32_t)schpingearly << 16) & ~((uint32_t)0x00010000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL3_ADDR, (REG_PL_RD(DWC_usb3_GUCTL3_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)schpingearly <<16));
}
__INLINE uint16_t  dwc_usb3_guctl3_reserved_31_17_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GUCTL3_ADDR);
       return ((localVal & ((uint32_t)0xFFFE0000)) >> 17);
}
__INLINE void  dwc_usb3_guctl3_reserved_31_17_setf(uint16_t  reserved3117)
{
       ASSERT_ERR((((uint32_t)reserved3117 << 17) & ~((uint32_t)0xFFFE0000)) == 0);
       REG_PL_WR(DWC_usb3_GUCTL3_ADDR, (REG_PL_RD(DWC_usb3_GUCTL3_ADDR) & ~((uint32_t)0xFFFE0000)) | ((uint32_t)reserved3117 <<17));
}
/**
* \@brief GTXFIFOPRIDEV register definition
* Global Device TX FIFO DMA Priority Register

This register specifies the relative DMA priority level among the Device TXFIFOs (one per IN endpoint). Each register bit[n] controls the priority (1: high, 0: low) of each TXFIFO[n]. When multiple TXFIFOs compete for DMA service at a given time (that is, multiple TXQs contain TX DMA requests and their corresponding TXFIFOs have space available), the TX DMA arbiter grants access on a packet-basis in the following manner:
 - 1. High-priority TXFIFOs are granted access using round-robin arbitration
 - 2. Low-priority TXFIFOs are granted access using round-robin arbitration only after the high-priority TXFIFOs have no further processing to do (that is, either the TXQs are empty or the corresponding TXFIFOs are full).
For scatter-gather packets, the arbiter grants successive DMA requests to the same FIFO until the entire packet is completed.

When configuring periodic IN endpoints, software must set register bit[n]=1, where n is the TXFIFO assignment. This ensures that the DMA for isochronous or interrupt IN endpoints are prioritized over bulk or control IN endpoints.

This register is present only when the controller is configured to operate in the device mode (includes DRD mode). The register size corresponds to the number of Device IN endpoints.

Note
 - Since the device mode uses only one RXFIFO, there is no Device RXFIFO DMA Priority Register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:15      gtxfifopridev                           0x0
*    16:31      reserved_31_n                           0x0
* </pre>
*/
#define DWC_usb3_GTXFIFOPRIDEV_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C610)
#define DWC_usb3_GTXFIFOPRIDEV_OFFSET      0x0000C610
#define DWC_usb3_GTXFIFOPRIDEV_INDEX       0x3184
__INLINE uint32_t dwc_usb3_gtxfifopridev_get(void)
{
       return REG_PL_RD(DWC_usb3_GTXFIFOPRIDEV_ADDR);
}

__INLINE void dwc_usb3_gtxfifopridev_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GTXFIFOPRIDEV_ADDR,value);
}
// field definitions
#define DWC_usb3_GTXFIFOPRIDEV_gtxfifopridev_MASK    ((uint32_t)0x0000FFFF)
#define DWC_usb3_GTXFIFOPRIDEV_gtxfifopridev_LSB     0
#define DWC_usb3_GTXFIFOPRIDEV_gtxfifopridev_WIDTH   ((uint32_t)0x00000010)
#define DWC_usb3_GTXFIFOPRIDEV_reserved_31_n_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_GTXFIFOPRIDEV_reserved_31_n_LSB     16
#define DWC_usb3_GTXFIFOPRIDEV_reserved_31_n_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_GTXFIFOPRIDEV_gtxfifopridev_RST     0x0
#define DWC_usb3_GTXFIFOPRIDEV_reserved_31_n_RST     0x0

__INLINE void dwc_usb3_gtxfifopridev_pack(uint16_t gtxfifopridev,uint16_t reserved31n)
{
       ASSERT_ERR((((uint32_t)gtxfifopridev << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       ASSERT_ERR((((uint32_t)reserved31n << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_GTXFIFOPRIDEV_ADDR, ((uint32_t)gtxfifopridev << 0) |((uint32_t)reserved31n << 16));
}

__INLINE void dwc_usb3_gtxfifopridev_unpack(uint16_t* gtxfifopridev,uint16_t* reserved31n)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXFIFOPRIDEV_ADDR);

       *gtxfifopridev = (localVal & ((uint32_t)0x0000FFFF)) >> 0;
       *reserved31n = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint16_t  dwc_usb3_gtxfifopridev_gtxfifopridev_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXFIFOPRIDEV_ADDR);
       return ((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void  dwc_usb3_gtxfifopridev_gtxfifopridev_setf(uint16_t  gtxfifopridev)
{
       ASSERT_ERR((((uint32_t)gtxfifopridev << 0) & ~((uint32_t)0x0000FFFF)) == 0);
       REG_PL_WR(DWC_usb3_GTXFIFOPRIDEV_ADDR, (REG_PL_RD(DWC_usb3_GTXFIFOPRIDEV_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)gtxfifopridev <<0));
}
__INLINE uint16_t  dwc_usb3_gtxfifopridev_reserved_31_n_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GTXFIFOPRIDEV_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
/**
* \@brief GFLADJ register definition
* Global Frame Length Adjustment Register

This register provides options for the software to control the controller behavior with respect to SOF (Start of Frame) and ITP (Isochronous Timestamp Packet) timers and frame timer functionality. It provides an option to override the fladj_30mhz_reg sideband signal. In addition, it enables running SOF or ITP frame timer counters completely from the ref_clk. This facilitates hardware LPM in host mode with the SOF or ITP counters being run from the ref_clk signal.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:05       GFLADJ_30MHZ                            0x0
*    6          reserved_6                              0x0
*    7          GFLADJ_30MHZ_SDBND_SEL                  0x0
*    08:21      GFLADJ_REFCLK_FLADJ                     0x0
*    22         reserved_22                             0x0
*    23         GFLADJ_REFCLK_LPM_SEL                   0x0
*    24:30      GFLADJ_REFCLK_240MHZ_DECR               0x0
*    31         GFLADJ_REFCLK_240MHZDECR_PLS1           0x0
* </pre>
*/
#define DWC_usb3_GFLADJ_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C630)
#define DWC_usb3_GFLADJ_OFFSET      0x0000C630
#define DWC_usb3_GFLADJ_INDEX       0x318c
__INLINE uint32_t dwc_usb3_gfladj_get(void)
{
       return REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
}

__INLINE void dwc_usb3_gfladj_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR,value);
}
// field definitions
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_MASK    ((uint32_t)0x0000003F)
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_LSB     0
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_WIDTH   ((uint32_t)0x00000006)
#define DWC_usb3_GFLADJ_reserved_6_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_GFLADJ_reserved_6_POS     6
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_SDBND_SEL_BIT     ((uint32_t)0x00000080)
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_SDBND_SEL_POS     7
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_FLADJ_MASK    ((uint32_t)0x003FFF00)
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_FLADJ_LSB     8
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_FLADJ_WIDTH   ((uint32_t)0x0000000E)
#define DWC_usb3_GFLADJ_reserved_22_BIT     ((uint32_t)0x00400000)
#define DWC_usb3_GFLADJ_reserved_22_POS     22
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_LPM_SEL_BIT     ((uint32_t)0x00800000)
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_LPM_SEL_POS     23
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_MASK    ((uint32_t)0x7F000000)
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_LSB     24
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_WIDTH   ((uint32_t)0x00000007)
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZDECR_PLS1_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZDECR_PLS1_POS     31

#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_RST     0x0
#define DWC_usb3_GFLADJ_reserved_6_RST     0x0
#define DWC_usb3_GFLADJ_GFLADJ_30MHZ_SDBND_SEL_RST     0x0
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_FLADJ_RST     0x0
#define DWC_usb3_GFLADJ_reserved_22_RST     0x0
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_LPM_SEL_RST     0x0
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZ_DECR_RST     0x0
#define DWC_usb3_GFLADJ_GFLADJ_REFCLK_240MHZDECR_PLS1_RST     0x0

__INLINE void dwc_usb3_gfladj_pack(uint8_t gfladj30mhz,uint8_t reserved6,uint8_t gfladj30mhzsdbndsel,uint16_t gfladjrefclkfladj,uint8_t reserved22,uint8_t gfladjrefclklpmsel,uint8_t gfladjrefclk240mhzdecr,uint8_t gfladjrefclk240mhzdecrpls1)
{
       ASSERT_ERR((((uint32_t)gfladj30mhz << 0) & ~((uint32_t)0x0000003F)) == 0);
       ASSERT_ERR((((uint32_t)reserved6 << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)gfladj30mhzsdbndsel << 7) & ~((uint32_t)0x00000080)) == 0);
       ASSERT_ERR((((uint32_t)gfladjrefclkfladj << 8) & ~((uint32_t)0x003FFF00)) == 0);
       ASSERT_ERR((((uint32_t)reserved22 << 22) & ~((uint32_t)0x00400000)) == 0);
       ASSERT_ERR((((uint32_t)gfladjrefclklpmsel << 23) & ~((uint32_t)0x00800000)) == 0);
       ASSERT_ERR((((uint32_t)gfladjrefclk240mhzdecr << 24) & ~((uint32_t)0x7F000000)) == 0);
       ASSERT_ERR((((uint32_t)gfladjrefclk240mhzdecrpls1 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, ((uint32_t)gfladj30mhz << 0) |((uint32_t)reserved6 << 6) |((uint32_t)gfladj30mhzsdbndsel << 7) |((uint32_t)gfladjrefclkfladj << 8) |((uint32_t)reserved22 << 22) |((uint32_t)gfladjrefclklpmsel << 23) |((uint32_t)gfladjrefclk240mhzdecr << 24) |((uint32_t)gfladjrefclk240mhzdecrpls1 << 31));
}

__INLINE void dwc_usb3_gfladj_unpack(uint8_t* gfladj30mhz,uint8_t* reserved6,uint8_t* gfladj30mhzsdbndsel,uint16_t* gfladjrefclkfladj,uint8_t* reserved22,uint8_t* gfladjrefclklpmsel,uint8_t* gfladjrefclk240mhzdecr,uint8_t* gfladjrefclk240mhzdecrpls1)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);

       *gfladj30mhz = (localVal & ((uint32_t)0x0000003F)) >> 0;
       *reserved6 = (localVal & ((uint32_t)0x00000040)) >> 6;
       *gfladj30mhzsdbndsel = (localVal & ((uint32_t)0x00000080)) >> 7;
       *gfladjrefclkfladj = (localVal & ((uint32_t)0x003FFF00)) >> 8;
       *reserved22 = (localVal & ((uint32_t)0x00400000)) >> 22;
       *gfladjrefclklpmsel = (localVal & ((uint32_t)0x00800000)) >> 23;
       *gfladjrefclk240mhzdecr = (localVal & ((uint32_t)0x7F000000)) >> 24;
       *gfladjrefclk240mhzdecrpls1 = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_gfladj_gfladj_30mhz_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x0000003F)) >> 0);
}
__INLINE void  dwc_usb3_gfladj_gfladj_30mhz_setf(uint8_t  gfladj30mhz)
{
       ASSERT_ERR((((uint32_t)gfladj30mhz << 0) & ~((uint32_t)0x0000003F)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x0000003F)) | ((uint32_t)gfladj30mhz <<0));
}
__INLINE uint8_t  dwc_usb3_gfladj_reserved_6_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t  dwc_usb3_gfladj_gfladj_30mhz_sdbnd_sel_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void  dwc_usb3_gfladj_gfladj_30mhz_sdbnd_sel_setf(uint8_t  gfladj30mhzsdbndsel)
{
       ASSERT_ERR((((uint32_t)gfladj30mhzsdbndsel << 7) & ~((uint32_t)0x00000080)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)gfladj30mhzsdbndsel <<7));
}
__INLINE uint16_t  dwc_usb3_gfladj_gfladj_refclk_fladj_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x003FFF00)) >> 8);
}
__INLINE void  dwc_usb3_gfladj_gfladj_refclk_fladj_setf(uint16_t  gfladjrefclkfladj)
{
       ASSERT_ERR((((uint32_t)gfladjrefclkfladj << 8) & ~((uint32_t)0x003FFF00)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x003FFF00)) | ((uint32_t)gfladjrefclkfladj <<8));
}
__INLINE uint8_t  dwc_usb3_gfladj_reserved_22_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE uint8_t  dwc_usb3_gfladj_gfladj_refclk_lpm_sel_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void  dwc_usb3_gfladj_gfladj_refclk_lpm_sel_setf(uint8_t  gfladjrefclklpmsel)
{
       ASSERT_ERR((((uint32_t)gfladjrefclklpmsel << 23) & ~((uint32_t)0x00800000)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)gfladjrefclklpmsel <<23));
}
__INLINE uint8_t  dwc_usb3_gfladj_gfladj_refclk_240mhz_decr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x7F000000)) >> 24);
}
__INLINE void  dwc_usb3_gfladj_gfladj_refclk_240mhz_decr_setf(uint8_t  gfladjrefclk240mhzdecr)
{
       ASSERT_ERR((((uint32_t)gfladjrefclk240mhzdecr << 24) & ~((uint32_t)0x7F000000)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x7F000000)) | ((uint32_t)gfladjrefclk240mhzdecr <<24));
}
__INLINE uint8_t  dwc_usb3_gfladj_gfladj_refclk_240mhzdecr_pls1_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_GFLADJ_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void  dwc_usb3_gfladj_gfladj_refclk_240mhzdecr_pls1_setf(uint8_t  gfladjrefclk240mhzdecrpls1)
{
       ASSERT_ERR((((uint32_t)gfladjrefclk240mhzdecrpls1 << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_GFLADJ_ADDR, (REG_PL_RD(DWC_usb3_GFLADJ_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)gfladjrefclk240mhzdecrpls1 <<31));
}
/**
* Block definition

* Block name            DWC_usb3_block_dev
* Block description     USB 3.0 Device Register Block
* Block baseAddress     0xc700
* Block Range           0x400
* Block width           32
* Number of registers   7
*/


/**
* \@brief DCFG register definition
* Device Configuration Register. 

This register configures the controller in Device mode after power-on or after certain control commands or enumeration. Do not make changes to this register after initial programming.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:02       DEVSPD                                  0x4
*    03:09       DEVADDR                                 0x0
*    10:11      reserved_10_11                          0x2
*    12:16      INTRNUM                                 0x0
*    17:21      NUMP                                    0x4
*    22         LPMCAP                                  0x0
*    23         IgnStrmPP                               0x0
*    24         reserved_24                             0x0
*    25:31      reserved_31_25                          0x0
* </pre>
*/
#define DWC_usb3_DCFG_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C700)
#define DWC_usb3_DCFG_OFFSET      0x0000C700
#define DWC_usb3_DCFG_INDEX       0x31c0
__INLINE uint32_t dwc_usb3_dcfg_get(void)
{
       return REG_PL_RD(DWC_usb3_DCFG_ADDR);
}

__INLINE void dwc_usb3_dcfg_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DCFG_ADDR,value);
}
// field definitions
#define DWC_usb3_DCFG_DEVSPD_MASK    ((uint32_t)0x00000007)
#define DWC_usb3_DCFG_DEVSPD_LSB     0
#define DWC_usb3_DCFG_DEVSPD_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_DCFG_DEVADDR_MASK    ((uint32_t)0x000003F8)
#define DWC_usb3_DCFG_DEVADDR_LSB     3
#define DWC_usb3_DCFG_DEVADDR_WIDTH   ((uint32_t)0x00000007)
#define DWC_usb3_DCFG_reserved_10_11_MASK    ((uint32_t)0x00000C00)
#define DWC_usb3_DCFG_reserved_10_11_LSB     10
#define DWC_usb3_DCFG_reserved_10_11_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_DCFG_INTRNUM_MASK    ((uint32_t)0x0001F000)
#define DWC_usb3_DCFG_INTRNUM_LSB     12
#define DWC_usb3_DCFG_INTRNUM_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_DCFG_NUMP_MASK    ((uint32_t)0x003E0000)
#define DWC_usb3_DCFG_NUMP_LSB     17
#define DWC_usb3_DCFG_NUMP_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_DCFG_LPMCAP_BIT     ((uint32_t)0x00400000)
#define DWC_usb3_DCFG_LPMCAP_POS     22
#define DWC_usb3_DCFG_IgnStrmPP_BIT     ((uint32_t)0x00800000)
#define DWC_usb3_DCFG_IgnStrmPP_POS     23
#define DWC_usb3_DCFG_reserved_24_BIT     ((uint32_t)0x01000000)
#define DWC_usb3_DCFG_reserved_24_POS     24
#define DWC_usb3_DCFG_reserved_31_25_MASK    ((uint32_t)0xFE000000)
#define DWC_usb3_DCFG_reserved_31_25_LSB     25
#define DWC_usb3_DCFG_reserved_31_25_WIDTH   ((uint32_t)0x00000007)

#define DWC_usb3_DCFG_DEVSPD_RST     0x4
#define DWC_usb3_DCFG_DEVADDR_RST     0x0
#define DWC_usb3_DCFG_reserved_10_11_RST     0x2
#define DWC_usb3_DCFG_INTRNUM_RST     0x0
#define DWC_usb3_DCFG_NUMP_RST     0x4
#define DWC_usb3_DCFG_LPMCAP_RST     0x0
#define DWC_usb3_DCFG_IgnStrmPP_RST     0x0
#define DWC_usb3_DCFG_reserved_24_RST     0x0
#define DWC_usb3_DCFG_reserved_31_25_RST     0x0

__INLINE void dwc_usb3_dcfg_pack(uint8_t devspd,uint8_t devaddr,uint8_t reserved1011,uint8_t intrnum,uint8_t nump,uint8_t lpmcap,uint8_t ignstrmpp,uint8_t reserved24,uint8_t reserved3125)
{
       ASSERT_ERR((((uint32_t)devspd << 0) & ~((uint32_t)0x00000007)) == 0);
       ASSERT_ERR((((uint32_t)devaddr << 3) & ~((uint32_t)0x000003F8)) == 0);
       ASSERT_ERR((((uint32_t)reserved1011 << 10) & ~((uint32_t)0x00000C00)) == 0);
       ASSERT_ERR((((uint32_t)intrnum << 12) & ~((uint32_t)0x0001F000)) == 0);
       ASSERT_ERR((((uint32_t)nump << 17) & ~((uint32_t)0x003E0000)) == 0);
       ASSERT_ERR((((uint32_t)lpmcap << 22) & ~((uint32_t)0x00400000)) == 0);
       ASSERT_ERR((((uint32_t)ignstrmpp << 23) & ~((uint32_t)0x00800000)) == 0);
       ASSERT_ERR((((uint32_t)reserved24 << 24) & ~((uint32_t)0x01000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3125 << 25) & ~((uint32_t)0xFE000000)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, ((uint32_t)devspd << 0) |((uint32_t)devaddr << 3) |((uint32_t)reserved1011 << 10) |((uint32_t)intrnum << 12) |((uint32_t)nump << 17) |((uint32_t)lpmcap << 22) |((uint32_t)ignstrmpp << 23) |((uint32_t)reserved24 << 24) |((uint32_t)reserved3125 << 25));
}

__INLINE void dwc_usb3_dcfg_unpack(uint8_t* devspd,uint8_t* devaddr,uint8_t* reserved1011,uint8_t* intrnum,uint8_t* nump,uint8_t* lpmcap,uint8_t* ignstrmpp,uint8_t* reserved24,uint8_t* reserved3125)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);

       *devspd = (localVal & ((uint32_t)0x00000007)) >> 0;
       *devaddr = (localVal & ((uint32_t)0x000003F8)) >> 3;
       *reserved1011 = (localVal & ((uint32_t)0x00000C00)) >> 10;
       *intrnum = (localVal & ((uint32_t)0x0001F000)) >> 12;
       *nump = (localVal & ((uint32_t)0x003E0000)) >> 17;
       *lpmcap = (localVal & ((uint32_t)0x00400000)) >> 22;
       *ignstrmpp = (localVal & ((uint32_t)0x00800000)) >> 23;
       *reserved24 = (localVal & ((uint32_t)0x01000000)) >> 24;
       *reserved3125 = (localVal & ((uint32_t)0xFE000000)) >> 25;
}
__INLINE uint8_t  dwc_usb3_dcfg_devspd_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE void  dwc_usb3_dcfg_devspd_setf(uint8_t  devspd)
{
       ASSERT_ERR((((uint32_t)devspd << 0) & ~((uint32_t)0x00000007)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x00000007)) | ((uint32_t)devspd <<0));
}
__INLINE uint8_t  dwc_usb3_dcfg_devaddr_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x000003F8)) >> 3);
}
__INLINE void  dwc_usb3_dcfg_devaddr_setf(uint8_t  devaddr)
{
       ASSERT_ERR((((uint32_t)devaddr << 3) & ~((uint32_t)0x000003F8)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x000003F8)) | ((uint32_t)devaddr <<3));
}
__INLINE uint8_t  dwc_usb3_dcfg_reserved_10_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE uint8_t  dwc_usb3_dcfg_intrnum_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void  dwc_usb3_dcfg_intrnum_setf(uint8_t  intrnum)
{
       ASSERT_ERR((((uint32_t)intrnum << 12) & ~((uint32_t)0x0001F000)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)intrnum <<12));
}
__INLINE uint8_t  dwc_usb3_dcfg_nump_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x003E0000)) >> 17);
}
__INLINE void  dwc_usb3_dcfg_nump_setf(uint8_t  nump)
{
       ASSERT_ERR((((uint32_t)nump << 17) & ~((uint32_t)0x003E0000)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x003E0000)) | ((uint32_t)nump <<17));
}
__INLINE uint8_t  dwc_usb3_dcfg_lpmcap_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void  dwc_usb3_dcfg_lpmcap_setf(uint8_t  lpmcap)
{
       ASSERT_ERR((((uint32_t)lpmcap << 22) & ~((uint32_t)0x00400000)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)lpmcap <<22));
}
__INLINE uint8_t  dwc_usb3_dcfg_ignstrmpp_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void  dwc_usb3_dcfg_ignstrmpp_setf(uint8_t  ignstrmpp)
{
       ASSERT_ERR((((uint32_t)ignstrmpp << 23) & ~((uint32_t)0x00800000)) == 0);
       REG_PL_WR(DWC_usb3_DCFG_ADDR, (REG_PL_RD(DWC_usb3_DCFG_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)ignstrmpp <<23));
}
__INLINE uint8_t  dwc_usb3_dcfg_reserved_24_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE uint8_t  dwc_usb3_dcfg_reserved_31_25_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCFG_ADDR);
       return ((localVal & ((uint32_t)0xFE000000)) >> 25);
}
/**
* \@brief DCTL register definition
* Device Control Register

Note:

When Hibernation is not enabled using GCTL.GblHibernationEn field,
 - you can write any value to CSS, CRS, L1HibernationEn, and KeepConnect fields
 - L1HibernationEn, and KeepConnect fields always return 0 when read in this hibernation-disabled state
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          reserved_0                              0x0
*    01:04       TSTCTL                                  0x0
*    05:08       ULSTCHNGREQ                             0x0
*    9          ACCEPTU1ENA                             0x0
*    10         INITU1ENA                               0x0
*    11         ACCEPTU2ENA                             0x0
*    12         INITU2ENA                               0x0
*    13:15      reserved_15_13                          0x0
*    16         CSS                                     0x0
*    17         CRS                                     0x0
*    18         L1HibernationEn                         0x0
*    19         KeepConnect                             0x0
*    20:23      LPM_NYET_thres                          0xf
*    24:28      HIRDTHRES                               0x0
*    29         reserved_29                             0x0
*    30         CSFTRST                                 0x0
*    31         RUN_STOP                                0x0
* </pre>
*/
#define DWC_usb3_DCTL_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C704)
#define DWC_usb3_DCTL_OFFSET      0x0000C704
#define DWC_usb3_DCTL_INDEX       0x31c1
__INLINE uint32_t dwc_usb3_dctl_get(void)
{
       return REG_PL_RD(DWC_usb3_DCTL_ADDR);
}

__INLINE void dwc_usb3_dctl_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DCTL_ADDR,value);
}
// field definitions
#define DWC_usb3_DCTL_reserved_0_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_DCTL_reserved_0_POS     0
#define DWC_usb3_DCTL_TSTCTL_MASK    ((uint32_t)0x0000001E)
#define DWC_usb3_DCTL_TSTCTL_LSB     1
#define DWC_usb3_DCTL_TSTCTL_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_DCTL_ULSTCHNGREQ_MASK    ((uint32_t)0x000001E0)
#define DWC_usb3_DCTL_ULSTCHNGREQ_LSB     5
#define DWC_usb3_DCTL_ULSTCHNGREQ_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_DCTL_ACCEPTU1ENA_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_DCTL_ACCEPTU1ENA_POS     9
#define DWC_usb3_DCTL_INITU1ENA_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_DCTL_INITU1ENA_POS     10
#define DWC_usb3_DCTL_ACCEPTU2ENA_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_DCTL_ACCEPTU2ENA_POS     11
#define DWC_usb3_DCTL_INITU2ENA_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_DCTL_INITU2ENA_POS     12
#define DWC_usb3_DCTL_reserved_15_13_MASK    ((uint32_t)0x0000E000)
#define DWC_usb3_DCTL_reserved_15_13_LSB     13
#define DWC_usb3_DCTL_reserved_15_13_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_DCTL_CSS_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_DCTL_CSS_POS     16
#define DWC_usb3_DCTL_CRS_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_DCTL_CRS_POS     17
#define DWC_usb3_DCTL_L1HibernationEn_BIT     ((uint32_t)0x00040000)
#define DWC_usb3_DCTL_L1HibernationEn_POS     18
#define DWC_usb3_DCTL_KeepConnect_BIT     ((uint32_t)0x00080000)
#define DWC_usb3_DCTL_KeepConnect_POS     19
#define DWC_usb3_DCTL_LPM_NYET_thres_MASK    ((uint32_t)0x00F00000)
#define DWC_usb3_DCTL_LPM_NYET_thres_LSB     20
#define DWC_usb3_DCTL_LPM_NYET_thres_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_DCTL_HIRDTHRES_MASK    ((uint32_t)0x1F000000)
#define DWC_usb3_DCTL_HIRDTHRES_LSB     24
#define DWC_usb3_DCTL_HIRDTHRES_WIDTH   ((uint32_t)0x00000005)
#define DWC_usb3_DCTL_reserved_29_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_DCTL_reserved_29_POS     29
#define DWC_usb3_DCTL_CSFTRST_BIT     ((uint32_t)0x40000000)
#define DWC_usb3_DCTL_CSFTRST_POS     30
#define DWC_usb3_DCTL_RUN_STOP_BIT     ((uint32_t)0x80000000)
#define DWC_usb3_DCTL_RUN_STOP_POS     31

#define DWC_usb3_DCTL_reserved_0_RST     0x0
#define DWC_usb3_DCTL_TSTCTL_RST     0x0
#define DWC_usb3_DCTL_ULSTCHNGREQ_RST     0x0
#define DWC_usb3_DCTL_ACCEPTU1ENA_RST     0x0
#define DWC_usb3_DCTL_INITU1ENA_RST     0x0
#define DWC_usb3_DCTL_ACCEPTU2ENA_RST     0x0
#define DWC_usb3_DCTL_INITU2ENA_RST     0x0
#define DWC_usb3_DCTL_reserved_15_13_RST     0x0
#define DWC_usb3_DCTL_CSS_RST     0x0
#define DWC_usb3_DCTL_CRS_RST     0x0
#define DWC_usb3_DCTL_L1HibernationEn_RST     0x0
#define DWC_usb3_DCTL_KeepConnect_RST     0x0
#define DWC_usb3_DCTL_LPM_NYET_thres_RST     0xf
#define DWC_usb3_DCTL_HIRDTHRES_RST     0x0
#define DWC_usb3_DCTL_reserved_29_RST     0x0
#define DWC_usb3_DCTL_CSFTRST_RST     0x0
#define DWC_usb3_DCTL_RUN_STOP_RST     0x0

__INLINE void dwc_usb3_dctl_pack(uint8_t reserved0,uint8_t tstctl,uint8_t ulstchngreq,uint8_t acceptu1ena,uint8_t initu1ena,uint8_t acceptu2ena,uint8_t initu2ena,uint8_t reserved1513,uint8_t css,uint8_t crs,uint8_t l1hibernationen,uint8_t keepconnect,uint8_t lpmnyetthres,uint8_t hirdthres,uint8_t reserved29,uint8_t csftrst,uint8_t runstop)
{
       ASSERT_ERR((((uint32_t)reserved0 << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)tstctl << 1) & ~((uint32_t)0x0000001E)) == 0);
       ASSERT_ERR((((uint32_t)ulstchngreq << 5) & ~((uint32_t)0x000001E0)) == 0);
       ASSERT_ERR((((uint32_t)acceptu1ena << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)initu1ena << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)acceptu2ena << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)initu2ena << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)reserved1513 << 13) & ~((uint32_t)0x0000E000)) == 0);
       ASSERT_ERR((((uint32_t)css << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)crs << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)l1hibernationen << 18) & ~((uint32_t)0x00040000)) == 0);
       ASSERT_ERR((((uint32_t)keepconnect << 19) & ~((uint32_t)0x00080000)) == 0);
       ASSERT_ERR((((uint32_t)lpmnyetthres << 20) & ~((uint32_t)0x00F00000)) == 0);
       ASSERT_ERR((((uint32_t)hirdthres << 24) & ~((uint32_t)0x1F000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved29 << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)csftrst << 30) & ~((uint32_t)0x40000000)) == 0);
       ASSERT_ERR((((uint32_t)runstop << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, ((uint32_t)reserved0 << 0) |((uint32_t)tstctl << 1) |((uint32_t)ulstchngreq << 5) |((uint32_t)acceptu1ena << 9) |((uint32_t)initu1ena << 10) |((uint32_t)acceptu2ena << 11) |((uint32_t)initu2ena << 12) |((uint32_t)reserved1513 << 13) |((uint32_t)css << 16) |((uint32_t)crs << 17) |((uint32_t)l1hibernationen << 18) |((uint32_t)keepconnect << 19) |((uint32_t)lpmnyetthres << 20) |((uint32_t)hirdthres << 24) |((uint32_t)reserved29 << 29) |((uint32_t)csftrst << 30) |((uint32_t)runstop << 31));
}

__INLINE void dwc_usb3_dctl_unpack(uint8_t* reserved0,uint8_t* tstctl,uint8_t* ulstchngreq,uint8_t* acceptu1ena,uint8_t* initu1ena,uint8_t* acceptu2ena,uint8_t* initu2ena,uint8_t* reserved1513,uint8_t* css,uint8_t* crs,uint8_t* l1hibernationen,uint8_t* keepconnect,uint8_t* lpmnyetthres,uint8_t* hirdthres,uint8_t* reserved29,uint8_t* csftrst,uint8_t* runstop)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);

       *reserved0 = (localVal & ((uint32_t)0x00000001)) >> 0;
       *tstctl = (localVal & ((uint32_t)0x0000001E)) >> 1;
       *ulstchngreq = (localVal & ((uint32_t)0x000001E0)) >> 5;
       *acceptu1ena = (localVal & ((uint32_t)0x00000200)) >> 9;
       *initu1ena = (localVal & ((uint32_t)0x00000400)) >> 10;
       *acceptu2ena = (localVal & ((uint32_t)0x00000800)) >> 11;
       *initu2ena = (localVal & ((uint32_t)0x00001000)) >> 12;
       *reserved1513 = (localVal & ((uint32_t)0x0000E000)) >> 13;
       *css = (localVal & ((uint32_t)0x00010000)) >> 16;
       *crs = (localVal & ((uint32_t)0x00020000)) >> 17;
       *l1hibernationen = (localVal & ((uint32_t)0x00040000)) >> 18;
       *keepconnect = (localVal & ((uint32_t)0x00080000)) >> 19;
       *lpmnyetthres = (localVal & ((uint32_t)0x00F00000)) >> 20;
       *hirdthres = (localVal & ((uint32_t)0x1F000000)) >> 24;
       *reserved29 = (localVal & ((uint32_t)0x20000000)) >> 29;
       *csftrst = (localVal & ((uint32_t)0x40000000)) >> 30;
       *runstop = (localVal & ((uint32_t)0x80000000)) >> 31;
}
__INLINE uint8_t  dwc_usb3_dctl_reserved_0_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE uint8_t  dwc_usb3_dctl_tstctl_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x0000001E)) >> 1);
}
__INLINE void  dwc_usb3_dctl_tstctl_setf(uint8_t  tstctl)
{
       ASSERT_ERR((((uint32_t)tstctl << 1) & ~((uint32_t)0x0000001E)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x0000001E)) | ((uint32_t)tstctl <<1));
}
__INLINE void  dwc_usb3_dctl_ulstchngreq_setf(uint8_t  ulstchngreq)
{
       ASSERT_ERR((((uint32_t)ulstchngreq << 5) & ~((uint32_t)0x000001E0)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x000001E0)) | ((uint32_t)ulstchngreq <<5));
}
__INLINE uint8_t  dwc_usb3_dctl_acceptu1ena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void  dwc_usb3_dctl_acceptu1ena_setf(uint8_t  acceptu1ena)
{
       ASSERT_ERR((((uint32_t)acceptu1ena << 9) & ~((uint32_t)0x00000200)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)acceptu1ena <<9));
}
__INLINE uint8_t  dwc_usb3_dctl_initu1ena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void  dwc_usb3_dctl_initu1ena_setf(uint8_t  initu1ena)
{
       ASSERT_ERR((((uint32_t)initu1ena << 10) & ~((uint32_t)0x00000400)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)initu1ena <<10));
}
__INLINE uint8_t  dwc_usb3_dctl_acceptu2ena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void  dwc_usb3_dctl_acceptu2ena_setf(uint8_t  acceptu2ena)
{
       ASSERT_ERR((((uint32_t)acceptu2ena << 11) & ~((uint32_t)0x00000800)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)acceptu2ena <<11));
}
__INLINE uint8_t  dwc_usb3_dctl_initu2ena_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void  dwc_usb3_dctl_initu2ena_setf(uint8_t  initu2ena)
{
       ASSERT_ERR((((uint32_t)initu2ena << 12) & ~((uint32_t)0x00001000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)initu2ena <<12));
}
__INLINE uint8_t  dwc_usb3_dctl_reserved_15_13_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x0000E000)) >> 13);
}
__INLINE uint8_t  dwc_usb3_dctl_css_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void  dwc_usb3_dctl_css_setf(uint8_t  css)
{
       ASSERT_ERR((((uint32_t)css << 16) & ~((uint32_t)0x00010000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)css <<16));
}
__INLINE uint8_t  dwc_usb3_dctl_crs_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void  dwc_usb3_dctl_crs_setf(uint8_t  crs)
{
       ASSERT_ERR((((uint32_t)crs << 17) & ~((uint32_t)0x00020000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)crs <<17));
}
__INLINE uint8_t  dwc_usb3_dctl_l1hibernationen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void  dwc_usb3_dctl_l1hibernationen_setf(uint8_t  l1hibernationen)
{
       ASSERT_ERR((((uint32_t)l1hibernationen << 18) & ~((uint32_t)0x00040000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)l1hibernationen <<18));
}
__INLINE uint8_t  dwc_usb3_dctl_keepconnect_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void  dwc_usb3_dctl_keepconnect_setf(uint8_t  keepconnect)
{
       ASSERT_ERR((((uint32_t)keepconnect << 19) & ~((uint32_t)0x00080000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)keepconnect <<19));
}
__INLINE uint8_t  dwc_usb3_dctl_lpm_nyet_thres_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE void  dwc_usb3_dctl_lpm_nyet_thres_setf(uint8_t  lpmnyetthres)
{
       ASSERT_ERR((((uint32_t)lpmnyetthres << 20) & ~((uint32_t)0x00F00000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x00F00000)) | ((uint32_t)lpmnyetthres <<20));
}
__INLINE uint8_t  dwc_usb3_dctl_hirdthres_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x1F000000)) >> 24);
}
__INLINE void  dwc_usb3_dctl_hirdthres_setf(uint8_t  hirdthres)
{
       ASSERT_ERR((((uint32_t)hirdthres << 24) & ~((uint32_t)0x1F000000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x1F000000)) | ((uint32_t)hirdthres <<24));
}
__INLINE uint8_t  dwc_usb3_dctl_reserved_29_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE uint8_t  dwc_usb3_dctl_csftrst_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void  dwc_usb3_dctl_csftrst_setf(uint8_t  csftrst)
{
       ASSERT_ERR((((uint32_t)csftrst << 30) & ~((uint32_t)0x40000000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)csftrst <<30));
}
__INLINE uint8_t  dwc_usb3_dctl_run_stop_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DCTL_ADDR);
       return ((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void  dwc_usb3_dctl_run_stop_setf(uint8_t  runstop)
{
       ASSERT_ERR((((uint32_t)runstop << 31) & ~((uint32_t)0x80000000)) == 0);
       REG_PL_WR(DWC_usb3_DCTL_ADDR, (REG_PL_RD(DWC_usb3_DCTL_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)runstop <<31));
}
/**
* \@brief DEVTEN register definition
* Device Event Enable Register

This register controls the generation of device-specific events (see "Event Buffer Content for Device-Specific Events (DEVT)" section). If an enable bit is set to 0, the event will not be generated.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    0          DISSCONNEVTEN                           0x0
*    1          USBRSTEVTEN                             0x0
*    2          CONNECTDONEEVTEN                        0x0
*    3          ULSTCNGEN                               0x0
*    4          WKUPEVTEN                               0x0
*    5          HibernationReqEvtEn                     0x0
*    6          U3L2L1SuspEn                            0x0
*    7          SOFTEVTEN                               0x0
*    8          L1SUSPEN                                0x0
*    9          ERRTICERREVTEN                          0x0
*    10         reserved_10                             0x0
*    11         reserved_11                             0x0
*    12         VENDEVTSTRCVDEN                         0x0
*    14         L1WKUPEVTEN                             0x0
*    15         reserved_15                             0x0
*    16         ECCERREN                                0x0
*    17:31      reserved_31_17                          0x0
* </pre>
*/
#define DWC_usb3_DEVTEN_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C708)
#define DWC_usb3_DEVTEN_OFFSET      0x0000C708
#define DWC_usb3_DEVTEN_INDEX       0x31c2
__INLINE uint32_t dwc_usb3_devten_get(void)
{
       return REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
}

__INLINE void dwc_usb3_devten_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR,value);
}
// field definitions
#define DWC_usb3_DEVTEN_DISSCONNEVTEN_BIT     ((uint32_t)0x00000001)
#define DWC_usb3_DEVTEN_DISSCONNEVTEN_POS     0
#define DWC_usb3_DEVTEN_USBRSTEVTEN_BIT     ((uint32_t)0x00000002)
#define DWC_usb3_DEVTEN_USBRSTEVTEN_POS     1
#define DWC_usb3_DEVTEN_CONNECTDONEEVTEN_BIT     ((uint32_t)0x00000004)
#define DWC_usb3_DEVTEN_CONNECTDONEEVTEN_POS     2
#define DWC_usb3_DEVTEN_ULSTCNGEN_BIT     ((uint32_t)0x00000008)
#define DWC_usb3_DEVTEN_ULSTCNGEN_POS     3
#define DWC_usb3_DEVTEN_WKUPEVTEN_BIT     ((uint32_t)0x00000010)
#define DWC_usb3_DEVTEN_WKUPEVTEN_POS     4
#define DWC_usb3_DEVTEN_HibernationReqEvtEn_BIT     ((uint32_t)0x00000020)
#define DWC_usb3_DEVTEN_HibernationReqEvtEn_POS     5
#define DWC_usb3_DEVTEN_U3L2L1SuspEn_BIT     ((uint32_t)0x00000040)
#define DWC_usb3_DEVTEN_U3L2L1SuspEn_POS     6
#define DWC_usb3_DEVTEN_SOFTEVTEN_BIT     ((uint32_t)0x00000080)
#define DWC_usb3_DEVTEN_SOFTEVTEN_POS     7
#define DWC_usb3_DEVTEN_L1SUSPEN_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_DEVTEN_L1SUSPEN_POS     8
#define DWC_usb3_DEVTEN_ERRTICERREVTEN_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_DEVTEN_ERRTICERREVTEN_POS     9
#define DWC_usb3_DEVTEN_reserved_10_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_DEVTEN_reserved_10_POS     10
#define DWC_usb3_DEVTEN_reserved_11_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_DEVTEN_reserved_11_POS     11
#define DWC_usb3_DEVTEN_VENDEVTSTRCVDEN_BIT     ((uint32_t)0x00001000)
#define DWC_usb3_DEVTEN_VENDEVTSTRCVDEN_POS     12
#define DWC_usb3_DEVTEN_L1WKUPEVTEN_BIT     ((uint32_t)0x00004000)
#define DWC_usb3_DEVTEN_L1WKUPEVTEN_POS     14
#define DWC_usb3_DEVTEN_reserved_15_BIT     ((uint32_t)0x00008000)
#define DWC_usb3_DEVTEN_reserved_15_POS     15
#define DWC_usb3_DEVTEN_ECCERREN_BIT     ((uint32_t)0x00010000)
#define DWC_usb3_DEVTEN_ECCERREN_POS     16
#define DWC_usb3_DEVTEN_reserved_31_17_MASK    ((uint32_t)0xFFFE0000)
#define DWC_usb3_DEVTEN_reserved_31_17_LSB     17
#define DWC_usb3_DEVTEN_reserved_31_17_WIDTH   ((uint32_t)0x0000000F)

#define DWC_usb3_DEVTEN_DISSCONNEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_USBRSTEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_CONNECTDONEEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_ULSTCNGEN_RST     0x0
#define DWC_usb3_DEVTEN_WKUPEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_HibernationReqEvtEn_RST     0x0
#define DWC_usb3_DEVTEN_U3L2L1SuspEn_RST     0x0
#define DWC_usb3_DEVTEN_SOFTEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_L1SUSPEN_RST     0x0
#define DWC_usb3_DEVTEN_ERRTICERREVTEN_RST     0x0
#define DWC_usb3_DEVTEN_reserved_10_RST     0x0
#define DWC_usb3_DEVTEN_reserved_11_RST     0x0
#define DWC_usb3_DEVTEN_VENDEVTSTRCVDEN_RST     0x0
#define DWC_usb3_DEVTEN_L1WKUPEVTEN_RST     0x0
#define DWC_usb3_DEVTEN_reserved_15_RST     0x0
#define DWC_usb3_DEVTEN_ECCERREN_RST     0x0
#define DWC_usb3_DEVTEN_reserved_31_17_RST     0x0

__INLINE void dwc_usb3_devten_pack(uint8_t dissconnevten,uint8_t usbrstevten,uint8_t connectdoneevten,uint8_t ulstcngen,uint8_t wkupevten,uint8_t hibernationreqevten,uint8_t u3l2l1suspen,uint8_t softevten,uint8_t l1suspen,uint8_t errticerrevten,uint8_t reserved10,uint8_t reserved11,uint8_t vendevtstrcvden,uint8_t l1wkupevten,uint8_t reserved15,uint8_t eccerren,uint16_t reserved3117)
{
       ASSERT_ERR((((uint32_t)dissconnevten << 0) & ~((uint32_t)0x00000001)) == 0);
       ASSERT_ERR((((uint32_t)usbrstevten << 1) & ~((uint32_t)0x00000002)) == 0);
       ASSERT_ERR((((uint32_t)connectdoneevten << 2) & ~((uint32_t)0x00000004)) == 0);
       ASSERT_ERR((((uint32_t)ulstcngen << 3) & ~((uint32_t)0x00000008)) == 0);
       ASSERT_ERR((((uint32_t)wkupevten << 4) & ~((uint32_t)0x00000010)) == 0);
       ASSERT_ERR((((uint32_t)hibernationreqevten << 5) & ~((uint32_t)0x00000020)) == 0);
       ASSERT_ERR((((uint32_t)u3l2l1suspen << 6) & ~((uint32_t)0x00000040)) == 0);
       ASSERT_ERR((((uint32_t)softevten << 7) & ~((uint32_t)0x00000080)) == 0);
       ASSERT_ERR((((uint32_t)l1suspen << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)errticerrevten << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)reserved10 << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)reserved11 << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)vendevtstrcvden << 12) & ~((uint32_t)0x00001000)) == 0);
       ASSERT_ERR((((uint32_t)l1wkupevten << 14) & ~((uint32_t)0x00004000)) == 0);
       ASSERT_ERR((((uint32_t)reserved15 << 15) & ~((uint32_t)0x00008000)) == 0);
       ASSERT_ERR((((uint32_t)eccerren << 16) & ~((uint32_t)0x00010000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3117 << 17) & ~((uint32_t)0xFFFE0000)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, ((uint32_t)dissconnevten << 0) |((uint32_t)usbrstevten << 1) |((uint32_t)connectdoneevten << 2) |((uint32_t)ulstcngen << 3) |((uint32_t)wkupevten << 4) |((uint32_t)hibernationreqevten << 5) |((uint32_t)u3l2l1suspen << 6) |((uint32_t)softevten << 7) |((uint32_t)l1suspen << 8) |((uint32_t)errticerrevten << 9) |((uint32_t)reserved10 << 10) |((uint32_t)reserved11 << 11) |((uint32_t)vendevtstrcvden << 12) |((uint32_t)l1wkupevten << 14) |((uint32_t)reserved15 << 15) |((uint32_t)eccerren << 16) |((uint32_t)reserved3117 << 17));
}

__INLINE void dwc_usb3_devten_unpack(uint8_t* dissconnevten,uint8_t* usbrstevten,uint8_t* connectdoneevten,uint8_t* ulstcngen,uint8_t* wkupevten,uint8_t* hibernationreqevten,uint8_t* u3l2l1suspen,uint8_t* softevten,uint8_t* l1suspen,uint8_t* errticerrevten,uint8_t* reserved10,uint8_t* reserved11,uint8_t* vendevtstrcvden,uint8_t* l1wkupevten,uint8_t* reserved15,uint8_t* eccerren,uint16_t* reserved3117)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);

       *dissconnevten = (localVal & ((uint32_t)0x00000001)) >> 0;
       *usbrstevten = (localVal & ((uint32_t)0x00000002)) >> 1;
       *connectdoneevten = (localVal & ((uint32_t)0x00000004)) >> 2;
       *ulstcngen = (localVal & ((uint32_t)0x00000008)) >> 3;
       *wkupevten = (localVal & ((uint32_t)0x00000010)) >> 4;
       *hibernationreqevten = (localVal & ((uint32_t)0x00000020)) >> 5;
       *u3l2l1suspen = (localVal & ((uint32_t)0x00000040)) >> 6;
       *softevten = (localVal & ((uint32_t)0x00000080)) >> 7;
       *l1suspen = (localVal & ((uint32_t)0x00000100)) >> 8;
       *errticerrevten = (localVal & ((uint32_t)0x00000200)) >> 9;
       *reserved10 = (localVal & ((uint32_t)0x00000400)) >> 10;
       *reserved11 = (localVal & ((uint32_t)0x00000800)) >> 11;
       *vendevtstrcvden = (localVal & ((uint32_t)0x00001000)) >> 12;
       *l1wkupevten = (localVal & ((uint32_t)0x00004000)) >> 14;
       *reserved15 = (localVal & ((uint32_t)0x00008000)) >> 15;
       *eccerren = (localVal & ((uint32_t)0x00010000)) >> 16;
       *reserved3117 = (localVal & ((uint32_t)0xFFFE0000)) >> 17;
}
__INLINE uint8_t  dwc_usb3_devten_dissconnevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void  dwc_usb3_devten_dissconnevten_setf(uint8_t  dissconnevten)
{
       ASSERT_ERR((((uint32_t)dissconnevten << 0) & ~((uint32_t)0x00000001)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dissconnevten <<0));
}
__INLINE uint8_t  dwc_usb3_devten_usbrstevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void  dwc_usb3_devten_usbrstevten_setf(uint8_t  usbrstevten)
{
       ASSERT_ERR((((uint32_t)usbrstevten << 1) & ~((uint32_t)0x00000002)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)usbrstevten <<1));
}
__INLINE uint8_t  dwc_usb3_devten_connectdoneevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void  dwc_usb3_devten_connectdoneevten_setf(uint8_t  connectdoneevten)
{
       ASSERT_ERR((((uint32_t)connectdoneevten << 2) & ~((uint32_t)0x00000004)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)connectdoneevten <<2));
}
__INLINE uint8_t  dwc_usb3_devten_ulstcngen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void  dwc_usb3_devten_ulstcngen_setf(uint8_t  ulstcngen)
{
       ASSERT_ERR((((uint32_t)ulstcngen << 3) & ~((uint32_t)0x00000008)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)ulstcngen <<3));
}
__INLINE uint8_t  dwc_usb3_devten_wkupevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void  dwc_usb3_devten_wkupevten_setf(uint8_t  wkupevten)
{
       ASSERT_ERR((((uint32_t)wkupevten << 4) & ~((uint32_t)0x00000010)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)wkupevten <<4));
}
__INLINE uint8_t  dwc_usb3_devten_hibernationreqevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void  dwc_usb3_devten_hibernationreqevten_setf(uint8_t  hibernationreqevten)
{
       ASSERT_ERR((((uint32_t)hibernationreqevten << 5) & ~((uint32_t)0x00000020)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)hibernationreqevten <<5));
}
__INLINE uint8_t  dwc_usb3_devten_u3l2l1suspen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void  dwc_usb3_devten_u3l2l1suspen_setf(uint8_t  u3l2l1suspen)
{
       ASSERT_ERR((((uint32_t)u3l2l1suspen << 6) & ~((uint32_t)0x00000040)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)u3l2l1suspen <<6));
}
__INLINE uint8_t  dwc_usb3_devten_softevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void  dwc_usb3_devten_softevten_setf(uint8_t  softevten)
{
       ASSERT_ERR((((uint32_t)softevten << 7) & ~((uint32_t)0x00000080)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)softevten <<7));
}
__INLINE uint8_t  dwc_usb3_devten_l1suspen_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void  dwc_usb3_devten_l1suspen_setf(uint8_t  l1suspen)
{
       ASSERT_ERR((((uint32_t)l1suspen << 8) & ~((uint32_t)0x00000100)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)l1suspen <<8));
}
__INLINE uint8_t  dwc_usb3_devten_errticerrevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void  dwc_usb3_devten_errticerrevten_setf(uint8_t  errticerrevten)
{
       ASSERT_ERR((((uint32_t)errticerrevten << 9) & ~((uint32_t)0x00000200)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)errticerrevten <<9));
}
__INLINE uint8_t  dwc_usb3_devten_reserved_10_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t  dwc_usb3_devten_reserved_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_devten_vendevtstrcvden_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void  dwc_usb3_devten_vendevtstrcvden_setf(uint8_t  vendevtstrcvden)
{
       ASSERT_ERR((((uint32_t)vendevtstrcvden << 12) & ~((uint32_t)0x00001000)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)vendevtstrcvden <<12));
}
__INLINE uint8_t  dwc_usb3_devten_l1wkupevten_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void  dwc_usb3_devten_l1wkupevten_setf(uint8_t  l1wkupevten)
{
       ASSERT_ERR((((uint32_t)l1wkupevten << 14) & ~((uint32_t)0x00004000)) == 0);
       REG_PL_WR(DWC_usb3_DEVTEN_ADDR, (REG_PL_RD(DWC_usb3_DEVTEN_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)l1wkupevten <<14));
}
__INLINE uint8_t  dwc_usb3_devten_reserved_15_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t  dwc_usb3_devten_eccerren_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint16_t  dwc_usb3_devten_reserved_31_17_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DEVTEN_ADDR);
       return ((localVal & ((uint32_t)0xFFFE0000)) >> 17);
}
/**
* \@brief DSTS register definition
* Device Status Register

This register indicates the status of the device controller with respect to USB-related events.

Note:

When Hibernation is not enabled, RSS and SSS fields always return 0 when read.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:02       CONNECTSPD                              0x4
*    03:16      SOFFN                                   0x0
*    17         RXFIFOEMPTY                             0x1
*    18:21      USBLNKST                                0x4
*    22         DEVCTRLHLT                              0x1
*    23         COREIDLE                                0x1
*    24         SSS                                     0x0
*    25         RSS                                     0x0
*    26:27      reserved_27_26                          0x0
*    28         SRE                                     0x0
*    29         DCNRD                                   0x0
*    30:31      reserved_31_30                          0x0
* </pre>
*/
#define DWC_usb3_DSTS_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C70C)
#define DWC_usb3_DSTS_OFFSET      0x0000C70C
#define DWC_usb3_DSTS_INDEX       0x31c3
__INLINE uint32_t dwc_usb3_dsts_get(void)
{
       return REG_PL_RD(DWC_usb3_DSTS_ADDR);
}

__INLINE void dwc_usb3_dsts_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DSTS_ADDR,value);
}
// field definitions
#define DWC_usb3_DSTS_CONNECTSPD_MASK    ((uint32_t)0x00000007)
#define DWC_usb3_DSTS_CONNECTSPD_LSB     0
#define DWC_usb3_DSTS_CONNECTSPD_WIDTH   ((uint32_t)0x00000003)
#define DWC_usb3_DSTS_SOFFN_MASK    ((uint32_t)0x0001FFF8)
#define DWC_usb3_DSTS_SOFFN_LSB     3
#define DWC_usb3_DSTS_SOFFN_WIDTH   ((uint32_t)0x0000000E)
#define DWC_usb3_DSTS_RXFIFOEMPTY_BIT     ((uint32_t)0x00020000)
#define DWC_usb3_DSTS_RXFIFOEMPTY_POS     17
#define DWC_usb3_DSTS_USBLNKST_MASK    ((uint32_t)0x003C0000)
#define DWC_usb3_DSTS_USBLNKST_LSB     18
#define DWC_usb3_DSTS_USBLNKST_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_DSTS_DEVCTRLHLT_BIT     ((uint32_t)0x00400000)
#define DWC_usb3_DSTS_DEVCTRLHLT_POS     22
#define DWC_usb3_DSTS_COREIDLE_BIT     ((uint32_t)0x00800000)
#define DWC_usb3_DSTS_COREIDLE_POS     23
#define DWC_usb3_DSTS_SSS_BIT     ((uint32_t)0x01000000)
#define DWC_usb3_DSTS_SSS_POS     24
#define DWC_usb3_DSTS_RSS_BIT     ((uint32_t)0x02000000)
#define DWC_usb3_DSTS_RSS_POS     25
#define DWC_usb3_DSTS_reserved_27_26_MASK    ((uint32_t)0x0C000000)
#define DWC_usb3_DSTS_reserved_27_26_LSB     26
#define DWC_usb3_DSTS_reserved_27_26_WIDTH   ((uint32_t)0x00000002)
#define DWC_usb3_DSTS_SRE_BIT     ((uint32_t)0x10000000)
#define DWC_usb3_DSTS_SRE_POS     28
#define DWC_usb3_DSTS_DCNRD_BIT     ((uint32_t)0x20000000)
#define DWC_usb3_DSTS_DCNRD_POS     29
#define DWC_usb3_DSTS_reserved_31_30_MASK    ((uint32_t)0xC0000000)
#define DWC_usb3_DSTS_reserved_31_30_LSB     30
#define DWC_usb3_DSTS_reserved_31_30_WIDTH   ((uint32_t)0x00000002)

#define DWC_usb3_DSTS_CONNECTSPD_RST     0x4
#define DWC_usb3_DSTS_SOFFN_RST     0x0
#define DWC_usb3_DSTS_RXFIFOEMPTY_RST     0x1
#define DWC_usb3_DSTS_USBLNKST_RST     0x4
#define DWC_usb3_DSTS_DEVCTRLHLT_RST     0x1
#define DWC_usb3_DSTS_COREIDLE_RST     0x1
#define DWC_usb3_DSTS_SSS_RST     0x0
#define DWC_usb3_DSTS_RSS_RST     0x0
#define DWC_usb3_DSTS_reserved_27_26_RST     0x0
#define DWC_usb3_DSTS_SRE_RST     0x0
#define DWC_usb3_DSTS_DCNRD_RST     0x0
#define DWC_usb3_DSTS_reserved_31_30_RST     0x0

__INLINE void dwc_usb3_dsts_pack(uint8_t connectspd,uint16_t soffn,uint8_t rxfifoempty,uint8_t usblnkst,uint8_t devctrlhlt,uint8_t coreidle,uint8_t sss,uint8_t rss,uint8_t reserved2726,uint8_t sre,uint8_t dcnrd,uint8_t reserved3130)
{
       ASSERT_ERR((((uint32_t)connectspd << 0) & ~((uint32_t)0x00000007)) == 0);
       ASSERT_ERR((((uint32_t)soffn << 3) & ~((uint32_t)0x0001FFF8)) == 0);
       ASSERT_ERR((((uint32_t)rxfifoempty << 17) & ~((uint32_t)0x00020000)) == 0);
       ASSERT_ERR((((uint32_t)usblnkst << 18) & ~((uint32_t)0x003C0000)) == 0);
       ASSERT_ERR((((uint32_t)devctrlhlt << 22) & ~((uint32_t)0x00400000)) == 0);
       ASSERT_ERR((((uint32_t)coreidle << 23) & ~((uint32_t)0x00800000)) == 0);
       ASSERT_ERR((((uint32_t)sss << 24) & ~((uint32_t)0x01000000)) == 0);
       ASSERT_ERR((((uint32_t)rss << 25) & ~((uint32_t)0x02000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved2726 << 26) & ~((uint32_t)0x0C000000)) == 0);
       ASSERT_ERR((((uint32_t)sre << 28) & ~((uint32_t)0x10000000)) == 0);
       ASSERT_ERR((((uint32_t)dcnrd << 29) & ~((uint32_t)0x20000000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3130 << 30) & ~((uint32_t)0xC0000000)) == 0);
       REG_PL_WR(DWC_usb3_DSTS_ADDR, ((uint32_t)connectspd << 0) |((uint32_t)soffn << 3) |((uint32_t)rxfifoempty << 17) |((uint32_t)usblnkst << 18) |((uint32_t)devctrlhlt << 22) |((uint32_t)coreidle << 23) |((uint32_t)sss << 24) |((uint32_t)rss << 25) |((uint32_t)reserved2726 << 26) |((uint32_t)sre << 28) |((uint32_t)dcnrd << 29) |((uint32_t)reserved3130 << 30));
}

__INLINE void dwc_usb3_dsts_unpack(uint8_t* connectspd,uint16_t* soffn,uint8_t* rxfifoempty,uint8_t* usblnkst,uint8_t* devctrlhlt,uint8_t* coreidle,uint8_t* sss,uint8_t* rss,uint8_t* reserved2726,uint8_t* sre,uint8_t* dcnrd,uint8_t* reserved3130)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);

       *connectspd = (localVal & ((uint32_t)0x00000007)) >> 0;
       *soffn = (localVal & ((uint32_t)0x0001FFF8)) >> 3;
       *rxfifoempty = (localVal & ((uint32_t)0x00020000)) >> 17;
       *usblnkst = (localVal & ((uint32_t)0x003C0000)) >> 18;
       *devctrlhlt = (localVal & ((uint32_t)0x00400000)) >> 22;
       *coreidle = (localVal & ((uint32_t)0x00800000)) >> 23;
       *sss = (localVal & ((uint32_t)0x01000000)) >> 24;
       *rss = (localVal & ((uint32_t)0x02000000)) >> 25;
       *reserved2726 = (localVal & ((uint32_t)0x0C000000)) >> 26;
       *sre = (localVal & ((uint32_t)0x10000000)) >> 28;
       *dcnrd = (localVal & ((uint32_t)0x20000000)) >> 29;
       *reserved3130 = (localVal & ((uint32_t)0xC0000000)) >> 30;
}
__INLINE uint8_t  dwc_usb3_dsts_connectspd_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE uint16_t  dwc_usb3_dsts_soffn_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x0001FFF8)) >> 3);
}
__INLINE uint8_t  dwc_usb3_dsts_rxfifoempty_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE uint8_t  dwc_usb3_dsts_usblnkst_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x003C0000)) >> 18);
}
__INLINE uint8_t  dwc_usb3_dsts_devctrlhlt_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE uint8_t  dwc_usb3_dsts_coreidle_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t  dwc_usb3_dsts_sss_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE uint8_t  dwc_usb3_dsts_rss_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE uint8_t  dwc_usb3_dsts_reserved_27_26_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE uint8_t  dwc_usb3_dsts_sre_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void  dwc_usb3_dsts_sre_setf(uint8_t  sre)
{
       ASSERT_ERR((((uint32_t)sre << 28) & ~((uint32_t)0x10000000)) == 0);
       REG_PL_WR(DWC_usb3_DSTS_ADDR, (REG_PL_RD(DWC_usb3_DSTS_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)sre <<28));
}
__INLINE uint8_t  dwc_usb3_dsts_dcnrd_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE uint8_t  dwc_usb3_dsts_reserved_31_30_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DSTS_ADDR);
       return ((localVal & ((uint32_t)0xC0000000)) >> 30);
}
/**
* \@brief DGCMDPAR register definition
* Device Generic Command Parameter Register

This register indicates the device command parameter. This must be programmed before or along with the device command. The available device commands are listed in DGCMD register.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      PARAMETER                               0x0
* </pre>
*/
#define DWC_usb3_DGCMDPAR_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C710)
#define DWC_usb3_DGCMDPAR_OFFSET      0x0000C710
#define DWC_usb3_DGCMDPAR_INDEX       0x31c4
__INLINE uint32_t dwc_usb3_dgcmdpar_get(void)
{
       return REG_PL_RD(DWC_usb3_DGCMDPAR_ADDR);
}

__INLINE void dwc_usb3_dgcmdpar_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DGCMDPAR_ADDR,value);
}
// field definitions
#define DWC_usb3_DGCMDPAR_PARAMETER_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_DGCMDPAR_PARAMETER_LSB     0
#define DWC_usb3_DGCMDPAR_PARAMETER_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_DGCMDPAR_PARAMETER_RST     0x0

__INLINE void dwc_usb3_dgcmdpar_pack(uint32_t parameter)
{
       ASSERT_ERR((((uint32_t)parameter << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_DGCMDPAR_ADDR, ((uint32_t)parameter << 0));
}

__INLINE void dwc_usb3_dgcmdpar_unpack(uint32_t* parameter)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMDPAR_ADDR);

       *parameter = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_dgcmdpar_parameter_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMDPAR_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
__INLINE void  dwc_usb3_dgcmdpar_parameter_setf(uint32_t  parameter)
{
       ASSERT_ERR((((uint32_t)parameter << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_DGCMDPAR_ADDR, (REG_PL_RD(DWC_usb3_DGCMDPAR_ADDR) & ~((uint32_t)0xFFFFFFFF)) | ((uint32_t)parameter <<0));
}
/**
* \@brief DGCMD register definition
* Device Generic Command Register

This register enables software to program the controller using a single generic command interface to send link management packets and notifications. This register contains command, control, and status fields relevant to the current generic command, while the DGCMDPAR register provides the command parameter.

<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:07       CMDTYP                                  0x0
*    8          CMDIOC                                  0x0
*    9          reserved_9                              0x0
*    10         CMDACT                                  0x0
*    11         reserved_11                             0x0
*    12:15      CMDSTATUS                               0x0
*    16:31      reserved_31_16                          0x0
* </pre>
*/
#define DWC_usb3_DGCMD_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C714)
#define DWC_usb3_DGCMD_OFFSET      0x0000C714
#define DWC_usb3_DGCMD_INDEX       0x31c5
__INLINE uint32_t dwc_usb3_dgcmd_get(void)
{
       return REG_PL_RD(DWC_usb3_DGCMD_ADDR);
}

__INLINE void dwc_usb3_dgcmd_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DGCMD_ADDR,value);
}
// field definitions
#define DWC_usb3_DGCMD_CMDTYP_MASK    ((uint32_t)0x000000FF)
#define DWC_usb3_DGCMD_CMDTYP_LSB     0
#define DWC_usb3_DGCMD_CMDTYP_WIDTH   ((uint32_t)0x00000008)
#define DWC_usb3_DGCMD_CMDIOC_BIT     ((uint32_t)0x00000100)
#define DWC_usb3_DGCMD_CMDIOC_POS     8
#define DWC_usb3_DGCMD_reserved_9_BIT     ((uint32_t)0x00000200)
#define DWC_usb3_DGCMD_reserved_9_POS     9
#define DWC_usb3_DGCMD_CMDACT_BIT     ((uint32_t)0x00000400)
#define DWC_usb3_DGCMD_CMDACT_POS     10
#define DWC_usb3_DGCMD_reserved_11_BIT     ((uint32_t)0x00000800)
#define DWC_usb3_DGCMD_reserved_11_POS     11
#define DWC_usb3_DGCMD_CMDSTATUS_MASK    ((uint32_t)0x0000F000)
#define DWC_usb3_DGCMD_CMDSTATUS_LSB     12
#define DWC_usb3_DGCMD_CMDSTATUS_WIDTH   ((uint32_t)0x00000004)
#define DWC_usb3_DGCMD_reserved_31_16_MASK    ((uint32_t)0xFFFF0000)
#define DWC_usb3_DGCMD_reserved_31_16_LSB     16
#define DWC_usb3_DGCMD_reserved_31_16_WIDTH   ((uint32_t)0x00000010)

#define DWC_usb3_DGCMD_CMDTYP_RST     0x0
#define DWC_usb3_DGCMD_CMDIOC_RST     0x0
#define DWC_usb3_DGCMD_reserved_9_RST     0x0
#define DWC_usb3_DGCMD_CMDACT_RST     0x0
#define DWC_usb3_DGCMD_reserved_11_RST     0x0
#define DWC_usb3_DGCMD_CMDSTATUS_RST     0x0
#define DWC_usb3_DGCMD_reserved_31_16_RST     0x0

__INLINE void dwc_usb3_dgcmd_pack(uint8_t cmdtyp,uint8_t cmdioc,uint8_t reserved9,uint8_t cmdact,uint8_t reserved11,uint8_t cmdstatus,uint16_t reserved3116)
{
       ASSERT_ERR((((uint32_t)cmdtyp << 0) & ~((uint32_t)0x000000FF)) == 0);
       ASSERT_ERR((((uint32_t)cmdioc << 8) & ~((uint32_t)0x00000100)) == 0);
       ASSERT_ERR((((uint32_t)reserved9 << 9) & ~((uint32_t)0x00000200)) == 0);
       ASSERT_ERR((((uint32_t)cmdact << 10) & ~((uint32_t)0x00000400)) == 0);
       ASSERT_ERR((((uint32_t)reserved11 << 11) & ~((uint32_t)0x00000800)) == 0);
       ASSERT_ERR((((uint32_t)cmdstatus << 12) & ~((uint32_t)0x0000F000)) == 0);
       ASSERT_ERR((((uint32_t)reserved3116 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
       REG_PL_WR(DWC_usb3_DGCMD_ADDR, ((uint32_t)cmdtyp << 0) |((uint32_t)cmdioc << 8) |((uint32_t)reserved9 << 9) |((uint32_t)cmdact << 10) |((uint32_t)reserved11 << 11) |((uint32_t)cmdstatus << 12) |((uint32_t)reserved3116 << 16));
}

__INLINE void dwc_usb3_dgcmd_unpack(uint8_t* cmdtyp,uint8_t* cmdioc,uint8_t* reserved9,uint8_t* cmdact,uint8_t* reserved11,uint8_t* cmdstatus,uint16_t* reserved3116)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);

       *cmdtyp = (localVal & ((uint32_t)0x000000FF)) >> 0;
       *cmdioc = (localVal & ((uint32_t)0x00000100)) >> 8;
       *reserved9 = (localVal & ((uint32_t)0x00000200)) >> 9;
       *cmdact = (localVal & ((uint32_t)0x00000400)) >> 10;
       *reserved11 = (localVal & ((uint32_t)0x00000800)) >> 11;
       *cmdstatus = (localVal & ((uint32_t)0x0000F000)) >> 12;
       *reserved3116 = (localVal & ((uint32_t)0xFFFF0000)) >> 16;
}
__INLINE uint8_t  dwc_usb3_dgcmd_cmdtyp_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void  dwc_usb3_dgcmd_cmdtyp_setf(uint8_t  cmdtyp)
{
       ASSERT_ERR((((uint32_t)cmdtyp << 0) & ~((uint32_t)0x000000FF)) == 0);
       REG_PL_WR(DWC_usb3_DGCMD_ADDR, (REG_PL_RD(DWC_usb3_DGCMD_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)cmdtyp <<0));
}
__INLINE uint8_t  dwc_usb3_dgcmd_cmdioc_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void  dwc_usb3_dgcmd_cmdioc_setf(uint8_t  cmdioc)
{
       ASSERT_ERR((((uint32_t)cmdioc << 8) & ~((uint32_t)0x00000100)) == 0);
       REG_PL_WR(DWC_usb3_DGCMD_ADDR, (REG_PL_RD(DWC_usb3_DGCMD_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)cmdioc <<8));
}
__INLINE uint8_t  dwc_usb3_dgcmd_reserved_9_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t  dwc_usb3_dgcmd_cmdact_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void  dwc_usb3_dgcmd_cmdact_setf(uint8_t  cmdact)
{
       ASSERT_ERR((((uint32_t)cmdact << 10) & ~((uint32_t)0x00000400)) == 0);
       REG_PL_WR(DWC_usb3_DGCMD_ADDR, (REG_PL_RD(DWC_usb3_DGCMD_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)cmdact <<10));
}
__INLINE uint8_t  dwc_usb3_dgcmd_reserved_11_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t  dwc_usb3_dgcmd_cmdstatus_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE uint16_t  dwc_usb3_dgcmd_reserved_31_16_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DGCMD_ADDR);
       return ((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
/**
* \@brief DALEPENA register definition
* Device Active USB Endpoint Enable Register. 

This register indicates whether a USB endpoint is active in a given configuration or interface.
<pre>/
*    Bits       Field Name                         Reset Value
*   -------    -------------                      ------------------
*    00:31      USBACTEP                                0x0
* </pre>
*/
#define DWC_usb3_DALEPENA_ADDR        (REG_DWC_usb3_BASE_ADDR+0x0000C720)
#define DWC_usb3_DALEPENA_OFFSET      0x0000C720
#define DWC_usb3_DALEPENA_INDEX       0x31c8
__INLINE uint32_t dwc_usb3_dalepena_get(void)
{
       return REG_PL_RD(DWC_usb3_DALEPENA_ADDR);
}

__INLINE void dwc_usb3_dalepena_set(uint32_t value)
{
       REG_PL_WR(DWC_usb3_DALEPENA_ADDR,value);
}
// field definitions
#define DWC_usb3_DALEPENA_USBACTEP_MASK    ((uint32_t)0xFFFFFFFF)
#define DWC_usb3_DALEPENA_USBACTEP_LSB     0
#define DWC_usb3_DALEPENA_USBACTEP_WIDTH   ((uint32_t)0x00000020)

#define DWC_usb3_DALEPENA_USBACTEP_RST     0x0

__INLINE void dwc_usb3_dalepena_pack(uint32_t usbactep)
{
       ASSERT_ERR((((uint32_t)usbactep << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_DALEPENA_ADDR, ((uint32_t)usbactep << 0));
}

__INLINE void dwc_usb3_dalepena_unpack(uint32_t* usbactep)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DALEPENA_ADDR);

       *usbactep = (localVal & ((uint32_t)0xFFFFFFFF)) >> 0;
}
__INLINE uint32_t  dwc_usb3_dalepena_usbactep_getf(void)
{
       uint32_t localVal = REG_PL_RD(DWC_usb3_DALEPENA_ADDR);
       return ((localVal & ((uint32_t)0xFFFFFFFF)) >> 0);
}
__INLINE void  dwc_usb3_dalepena_usbactep_setf(uint32_t  usbactep)
{
       ASSERT_ERR((((uint32_t)usbactep << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
       REG_PL_WR(DWC_usb3_DALEPENA_ADDR, (REG_PL_RD(DWC_usb3_DALEPENA_ADDR) & ~((uint32_t)0xFFFFFFFF)) | ((uint32_t)usbactep <<0));
}
/**
* Block definition

* Block name            DWC_usb3_block_link
* Block description     USB 3.0 Link Register Block
* Block baseAddress     0xd000
* Block Range           0x800
* Block width           32
* Number of registers   0
*/


/**
* Block definition

* Block name            DWC_usb3_block_debug
* Block description     USB 3.0 Debug Register Block
* Block baseAddress     0xd800
* Block Range           0x200
* Block width           32
* Number of registers   0
*/


/**
* Block definition

* Block name            DWC_usb3_block_int_RAM0
* Block description     USB3 internal RAM0 Register Block

For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.

* Block baseAddress     0x40000
* Block Range           0x40000
* Block width           32
* Number of registers   0
*/


/**
* Block definition

* Block name            DWC_usb3_block_int_RAM1
* Block description     USB3 internal RAM1 Register Block

For a description of this standard USB register field, see the eXtensible Host Controller Interface for Universal Serial Bus (USB) Specification 3.0.

* Block baseAddress     0x80000
* Block Range           0x40000
* Block width           32
* Number of registers   0
*/


/**
* Block definition

* Block name            DWC_usb3_block_int_RAM2
* Block description     USB3 internal RAM2 Register Block
* Block baseAddress     0xc0000
* Block Range           0x40000
* Block width           32
* Number of registers   0
*/

#endif

// clang-format on
