#ifndef _REG_PCIE_EP_H_
#define _REG_PCIE_EP_H_

#include <stdint.h>
#include "_reg_pcie_ep.h"
#include "compiler.h"
#include "arch.h"
#include "reg_access.h"

#define DBG_FILEID __REG_PCIE_EP__H__FILEID__

#define REG_PCIE_EP_COUNT  324


/**
 * @brief DEVICE_ID_VENDOR_ID_REG register definition
 *  This register holds the device ID, next offset pointer for RCRB mode and vendor ID. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 PCI_TYPE0_DEVICE_ID       0x6000
 *    15:00 PCI_TYPE0_VENDOR_ID       0x1d69
 * </pre>
 */
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000000)
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_OFFSET      0x00000000
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_INDEX       0x00000000
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_RESET       0x60001D69

__INLINE uint32_t  pcie_ep_device_id_vendor_id_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR);
}

__INLINE void pcie_ep_device_id_vendor_id_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_DEVICE_ID_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_DEVICE_ID_LSB    16
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_DEVICE_ID_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_VENDOR_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_VENDOR_ID_LSB    0
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_VENDOR_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_DEVICE_ID_RST    0x6000
#define PCIE_EP_DEVICE_ID_VENDOR_ID_REG_PCI_TYPE_0_VENDOR_ID_RST    0x1d69

__INLINE void pcie_ep_device_id_vendor_id_reg_pack(uint16_t pci_type0_device_id, uint16_t pci_type0_vendor_id)
{
	ASSERT_ERR((((uint32_t)pci_type0_device_id << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_vendor_id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR,  ((uint32_t)pci_type0_device_id << 16) |((uint32_t)pci_type0_vendor_id << 0));
}

__INLINE void pcie_ep_device_id_vendor_id_reg_unpack(uint16_t* pci_type0_device_id, uint16_t* pci_type0_vendor_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR);

	*pci_type0_device_id = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*pci_type0_vendor_id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_device_id_vendor_id_reg_pci_type_0_device_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_device_id_vendor_id_reg_pci_type_0_device_id_setf(uint16_t pcitype0deviceid)
{
	ASSERT_ERR((((uint32_t)pcitype0deviceid << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)pcitype0deviceid <<16));
}
__INLINE uint16_t pcie_ep_device_id_vendor_id_reg_pci_type_0_vendor_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_device_id_vendor_id_reg_pci_type_0_vendor_id_setf(uint16_t pcitype0vendorid)
{
	ASSERT_ERR((((uint32_t)pcitype0vendorid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_ID_VENDOR_ID_REG_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)pcitype0vendorid <<0));
}

/**
 * @brief STATUS_COMMAND_REG register definition
 *  This register provides the status and controls the behavior of a function. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    DETECTED_PARITY_ERR       0              
 *    30    SIGNALED_SYS_ERR          0              
 *    29    RCVD_MASTER_ABORT         0              
 *    28    RCVD_TARGET_ABORT         0              
 *    27    SIGNALED_TARGET_ABORT     0              
 *    26:25 DEV_SEL_TIMING            0x0
 *    24    MASTER_DPE                0              
 *    23    FAST_B2_B_CAP             0              
 *    22    RSVDP_22                  0              
 *    21    FAST_66_MHZ_CAP           0              
 *    20    CAP_LIST                  1              
 *    19    INT_STATUS                0              
 *    18:17 RSVDP_17                  0x0
 *    15:11 PCI_TYPE_RESERV           0x0
 *    10    PCI_TYPE0_INT_EN          0              
 *    09    RSVDP_9                   0              
 *    08    PCI_TYPE0_SERREN          0              
 *    07    PCI_TYPE_IDSEL_STEPPING   0              
 *    06    PCI_TYPE0_PARITY_ERR_EN   0              
 *    05    PCI_TYPE_VGA_PALETTE_SNOOP 0              
 *    04    PCI_TYPE_MWI_ENABLE       0              
 *    03    PCI_TYPE0_SPECIAL_CYCLE_OPERATION 0              
 *    02    PCI_TYPE0_BUS_MASTER_EN   0              
 *    01    PCI_TYPE0_MEM_SPACE_EN    0              
 *    00    PCI_TYPE0_IO_EN           0              
 * </pre>
 */
#define PCIE_EP_STATUS_COMMAND_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000004)
#define PCIE_EP_STATUS_COMMAND_REG_OFFSET      0x00000004
#define PCIE_EP_STATUS_COMMAND_REG_INDEX       0x00000001
#define PCIE_EP_STATUS_COMMAND_REG_RESET       0x00100000

__INLINE uint32_t  pcie_ep_status_command_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
}

__INLINE void pcie_ep_status_command_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_STATUS_COMMAND_REG_DETECTED_PARITY_ERR_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_STATUS_COMMAND_REG_DETECTED_PARITY_ERR_POS    31
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_SYS_ERR_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_SYS_ERR_POS    30
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_MASTER_ABORT_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_MASTER_ABORT_POS    29
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_TARGET_ABORT_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_TARGET_ABORT_POS    28
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_TARGET_ABORT_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_TARGET_ABORT_POS    27
#define PCIE_EP_STATUS_COMMAND_REG_DEV_SEL_TIMING_MASK    ((uint32_t)0x06000000)
#define PCIE_EP_STATUS_COMMAND_REG_DEV_SEL_TIMING_LSB    25
#define PCIE_EP_STATUS_COMMAND_REG_DEV_SEL_TIMING_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_STATUS_COMMAND_REG_MASTER_DPE_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_STATUS_COMMAND_REG_MASTER_DPE_POS    24
#define PCIE_EP_STATUS_COMMAND_REG_FAST_B_2_B_CAP_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_STATUS_COMMAND_REG_FAST_B_2_B_CAP_POS    23
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_22_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_22_POS    22
#define PCIE_EP_STATUS_COMMAND_REG_FAST_66_MHZ_CAP_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_STATUS_COMMAND_REG_FAST_66_MHZ_CAP_POS    21
#define PCIE_EP_STATUS_COMMAND_REG_CAP_LIST_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_STATUS_COMMAND_REG_CAP_LIST_POS    20
#define PCIE_EP_STATUS_COMMAND_REG_INT_STATUS_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_STATUS_COMMAND_REG_INT_STATUS_POS    19
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_17_MASK    ((uint32_t)0x00060000)
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_17_LSB    17
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_17_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_RESERV_MASK    ((uint32_t)0x0000F800)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_RESERV_LSB    11
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_RESERV_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_INT_EN_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_INT_EN_POS    10
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_9_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_9_POS    9
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SERREN_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SERREN_POS    8
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_IDSEL_STEPPING_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_IDSEL_STEPPING_POS    7
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_PARITY_ERR_EN_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_PARITY_ERR_EN_POS    6
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_VGA_PALETTE_SNOOP_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_VGA_PALETTE_SNOOP_POS    5
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_MWI_ENABLE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_MWI_ENABLE_POS    4
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SPECIAL_CYCLE_OPERATION_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SPECIAL_CYCLE_OPERATION_POS    3
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_BUS_MASTER_EN_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_BUS_MASTER_EN_POS    2
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_MEM_SPACE_EN_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_MEM_SPACE_EN_POS    1
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_IO_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_IO_EN_POS    0

#define PCIE_EP_STATUS_COMMAND_REG_DETECTED_PARITY_ERR_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_SYS_ERR_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_MASTER_ABORT_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_RCVD_TARGET_ABORT_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_SIGNALED_TARGET_ABORT_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_DEV_SEL_TIMING_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_MASTER_DPE_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_FAST_B_2_B_CAP_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_22_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_FAST_66_MHZ_CAP_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_CAP_LIST_RST    0x1
#define PCIE_EP_STATUS_COMMAND_REG_INT_STATUS_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_17_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_RESERV_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_INT_EN_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_RSVDP_9_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SERREN_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_IDSEL_STEPPING_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_PARITY_ERR_EN_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_VGA_PALETTE_SNOOP_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_MWI_ENABLE_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_SPECIAL_CYCLE_OPERATION_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_BUS_MASTER_EN_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_MEM_SPACE_EN_RST    0x0
#define PCIE_EP_STATUS_COMMAND_REG_PCI_TYPE_0_IO_EN_RST    0x0

__INLINE void pcie_ep_status_command_reg_pack(uint8_t detected_parity_err, uint8_t signaled_sys_err, uint8_t rcvd_master_abort, uint8_t rcvd_target_abort, uint8_t signaled_target_abort, uint8_t dev_sel_timing, uint8_t master_dpe, uint8_t fast_b2_b_cap, uint8_t rsvdp_22, uint8_t fast_66_mhz_cap, uint8_t cap_list, uint8_t int_status, uint8_t rsvdp_17, uint8_t pci_type_reserv, uint8_t pci_type0_int_en, uint8_t rsvdp_9, uint8_t pci_type0_serren, uint8_t pci_type_idsel_stepping, uint8_t pci_type0_parity_err_en, uint8_t pci_type_vga_palette_snoop, uint8_t pci_type_mwi_enable, uint8_t pci_type0_special_cycle_operation, uint8_t pci_type0_bus_master_en, uint8_t pci_type0_mem_space_en, uint8_t pci_type0_io_en)
{
	ASSERT_ERR((((uint32_t)detected_parity_err << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)signaled_sys_err << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)rcvd_master_abort << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)rcvd_target_abort << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)signaled_target_abort << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)dev_sel_timing << 25) & ~((uint32_t)0x06000000)) == 0);
	ASSERT_ERR((((uint32_t)master_dpe << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)fast_b2_b_cap << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_22 << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)fast_66_mhz_cap << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)cap_list << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)int_status << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_17 << 17) & ~((uint32_t)0x00060000)) == 0);
	ASSERT_ERR((((uint32_t)pci_type_reserv << 11) & ~((uint32_t)0x0000F800)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_int_en << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_9 << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_serren << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)pci_type_idsel_stepping << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_parity_err_en << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)pci_type_vga_palette_snoop << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)pci_type_mwi_enable << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_special_cycle_operation << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bus_master_en << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_mem_space_en << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_io_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR,  ((uint32_t)detected_parity_err << 31) |((uint32_t)signaled_sys_err << 30) |((uint32_t)rcvd_master_abort << 29) |((uint32_t)rcvd_target_abort << 28) |((uint32_t)signaled_target_abort << 27) |((uint32_t)dev_sel_timing << 25) |((uint32_t)master_dpe << 24) |((uint32_t)fast_b2_b_cap << 23) |((uint32_t)rsvdp_22 << 22) |((uint32_t)fast_66_mhz_cap << 21) |((uint32_t)cap_list << 20) |((uint32_t)int_status << 19) |((uint32_t)rsvdp_17 << 17) |((uint32_t)pci_type_reserv << 11) |((uint32_t)pci_type0_int_en << 10) |((uint32_t)rsvdp_9 << 9) |((uint32_t)pci_type0_serren << 8) |((uint32_t)pci_type_idsel_stepping << 7) |((uint32_t)pci_type0_parity_err_en << 6) |((uint32_t)pci_type_vga_palette_snoop << 5) |((uint32_t)pci_type_mwi_enable << 4) |((uint32_t)pci_type0_special_cycle_operation << 3) |((uint32_t)pci_type0_bus_master_en << 2) |((uint32_t)pci_type0_mem_space_en << 1) |((uint32_t)pci_type0_io_en << 0));
}

__INLINE void pcie_ep_status_command_reg_unpack(uint8_t* detected_parity_err, uint8_t* signaled_sys_err, uint8_t* rcvd_master_abort, uint8_t* rcvd_target_abort, uint8_t* signaled_target_abort, uint8_t* dev_sel_timing, uint8_t* master_dpe, uint8_t* fast_b2_b_cap, uint8_t* rsvdp_22, uint8_t* fast_66_mhz_cap, uint8_t* cap_list, uint8_t* int_status, uint8_t* rsvdp_17, uint8_t* pci_type_reserv, uint8_t* pci_type0_int_en, uint8_t* rsvdp_9, uint8_t* pci_type0_serren, uint8_t* pci_type_idsel_stepping, uint8_t* pci_type0_parity_err_en, uint8_t* pci_type_vga_palette_snoop, uint8_t* pci_type_mwi_enable, uint8_t* pci_type0_special_cycle_operation, uint8_t* pci_type0_bus_master_en, uint8_t* pci_type0_mem_space_en, uint8_t* pci_type0_io_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);

	*detected_parity_err = (localVal & ((uint32_t)0x80000000)) >>  31;
	*signaled_sys_err = (localVal & ((uint32_t)0x40000000)) >>  30;
	*rcvd_master_abort = (localVal & ((uint32_t)0x20000000)) >>  29;
	*rcvd_target_abort = (localVal & ((uint32_t)0x10000000)) >>  28;
	*signaled_target_abort = (localVal & ((uint32_t)0x08000000)) >>  27;
	*dev_sel_timing = (localVal & ((uint32_t)0x06000000)) >>  25;
	*master_dpe = (localVal & ((uint32_t)0x01000000)) >>  24;
	*fast_b2_b_cap = (localVal & ((uint32_t)0x00800000)) >>  23;
	*rsvdp_22 = (localVal & ((uint32_t)0x00400000)) >>  22;
	*fast_66_mhz_cap = (localVal & ((uint32_t)0x00200000)) >>  21;
	*cap_list = (localVal & ((uint32_t)0x00100000)) >>  20;
	*int_status = (localVal & ((uint32_t)0x00080000)) >>  19;
	*rsvdp_17 = (localVal & ((uint32_t)0x00060000)) >>  17;
	*pci_type_reserv = (localVal & ((uint32_t)0x0000F800)) >>  11;
	*pci_type0_int_en = (localVal & ((uint32_t)0x00000400)) >>  10;
	*rsvdp_9 = (localVal & ((uint32_t)0x00000200)) >>  9;
	*pci_type0_serren = (localVal & ((uint32_t)0x00000100)) >>  8;
	*pci_type_idsel_stepping = (localVal & ((uint32_t)0x00000080)) >>  7;
	*pci_type0_parity_err_en = (localVal & ((uint32_t)0x00000040)) >>  6;
	*pci_type_vga_palette_snoop = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pci_type_mwi_enable = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pci_type0_special_cycle_operation = (localVal & ((uint32_t)0x00000008)) >>  3;
	*pci_type0_bus_master_en = (localVal & ((uint32_t)0x00000004)) >>  2;
	*pci_type0_mem_space_en = (localVal & ((uint32_t)0x00000002)) >>  1;
	*pci_type0_io_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_status_command_reg_detected_parity_err_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_status_command_reg_detected_parity_err_setf(uint8_t detectedparityerr)
{
	ASSERT_ERR((((uint32_t)detectedparityerr << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)detectedparityerr <<31));
}
__INLINE uint8_t pcie_ep_status_command_reg_signaled_sys_err_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_status_command_reg_signaled_sys_err_setf(uint8_t signaledsyserr)
{
	ASSERT_ERR((((uint32_t)signaledsyserr << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)signaledsyserr <<30));
}
__INLINE uint8_t pcie_ep_status_command_reg_rcvd_master_abort_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void pcie_ep_status_command_reg_rcvd_master_abort_setf(uint8_t rcvdmasterabort)
{
	ASSERT_ERR((((uint32_t)rcvdmasterabort << 29) & ~((uint32_t)0x20000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)rcvdmasterabort <<29));
}
__INLINE uint8_t pcie_ep_status_command_reg_rcvd_target_abort_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_status_command_reg_rcvd_target_abort_setf(uint8_t rcvdtargetabort)
{
	ASSERT_ERR((((uint32_t)rcvdtargetabort << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)rcvdtargetabort <<28));
}
__INLINE uint8_t pcie_ep_status_command_reg_signaled_target_abort_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_status_command_reg_signaled_target_abort_setf(uint8_t signaledtargetabort)
{
	ASSERT_ERR((((uint32_t)signaledtargetabort << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)signaledtargetabort <<27));
}
__INLINE uint8_t pcie_ep_status_command_reg_dev_sel_timing_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x06000000)) >> 25);
}
__INLINE uint8_t pcie_ep_status_command_reg_master_dpe_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_status_command_reg_master_dpe_setf(uint8_t masterdpe)
{
	ASSERT_ERR((((uint32_t)masterdpe << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)masterdpe <<24));
}
__INLINE uint8_t pcie_ep_status_command_reg_fast_b_2_b_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_status_command_reg_rsvdp_22_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE uint8_t pcie_ep_status_command_reg_fast_66_mhz_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE uint8_t pcie_ep_status_command_reg_cap_list_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE uint8_t pcie_ep_status_command_reg_int_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE uint8_t pcie_ep_status_command_reg_rsvdp_17_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00060000)) >> 17);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_reserv_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000F800)) >> 11);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_int_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_int_en_setf(uint8_t pcitype0inten)
{
	ASSERT_ERR((((uint32_t)pcitype0inten << 10) & ~((uint32_t)0x00000400)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)pcitype0inten <<10));
}
__INLINE uint8_t pcie_ep_status_command_reg_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_serren_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_serren_setf(uint8_t pcitype0serren)
{
	ASSERT_ERR((((uint32_t)pcitype0serren << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)pcitype0serren <<8));
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_idsel_stepping_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_parity_err_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_parity_err_en_setf(uint8_t pcitype0parityerren)
{
	ASSERT_ERR((((uint32_t)pcitype0parityerren << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)pcitype0parityerren <<6));
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_vga_palette_snoop_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_mwi_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_special_cycle_operation_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_bus_master_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_bus_master_en_setf(uint8_t pcitype0busmasteren)
{
	ASSERT_ERR((((uint32_t)pcitype0busmasteren << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)pcitype0busmasteren <<2));
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_mem_space_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_mem_space_en_setf(uint8_t pcitype0memspaceen)
{
	ASSERT_ERR((((uint32_t)pcitype0memspaceen << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)pcitype0memspaceen <<1));
}
__INLINE uint8_t pcie_ep_status_command_reg_pci_type_0_io_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_status_command_reg_pci_type_0_io_en_setf(uint8_t pcitype0ioen)
{
	ASSERT_ERR((((uint32_t)pcitype0ioen << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_STATUS_COMMAND_REG_ADDR, (REG_PL_RD(PCIE_EP_STATUS_COMMAND_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0ioen <<0));
}

/**
 * @brief CLASS_CODE_REVISION_ID register definition
 *  This register specifies the class code and revision ID of a function. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 BASE_CLASS_CODE           0x2
 *    23:16 SUBCLASS_CODE             0x0
 *    15:08 PROGRAM_INTERFACE         0x0
 *    07:00 REVISION_ID               0x1
 * </pre>
 */
#define PCIE_EP_CLASS_CODE_REVISION_ID_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000008)
#define PCIE_EP_CLASS_CODE_REVISION_ID_OFFSET      0x00000008
#define PCIE_EP_CLASS_CODE_REVISION_ID_INDEX       0x00000002
#define PCIE_EP_CLASS_CODE_REVISION_ID_RESET       0x02000001

__INLINE uint32_t  pcie_ep_class_code_revision_id_get(void)
{
	return REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);
}

__INLINE void pcie_ep_class_code_revision_id_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR, value);
}

// field definitions
#define PCIE_EP_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_LSB    24
#define PCIE_EP_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_LSB    16
#define PCIE_EP_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_LSB    8
#define PCIE_EP_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_CLASS_CODE_REVISION_ID_REVISION_ID_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_CLASS_CODE_REVISION_ID_REVISION_ID_LSB    0
#define PCIE_EP_CLASS_CODE_REVISION_ID_REVISION_ID_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_CLASS_CODE_REVISION_ID_BASE_CLASS_CODE_RST    0x2
#define PCIE_EP_CLASS_CODE_REVISION_ID_SUBCLASS_CODE_RST    0x0
#define PCIE_EP_CLASS_CODE_REVISION_ID_PROGRAM_INTERFACE_RST    0x0
#define PCIE_EP_CLASS_CODE_REVISION_ID_REVISION_ID_RST    0x1

__INLINE void pcie_ep_class_code_revision_id_pack(uint8_t base_class_code, uint8_t subclass_code, uint8_t program_interface, uint8_t revision_id)
{
	ASSERT_ERR((((uint32_t)base_class_code << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)subclass_code << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)program_interface << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)revision_id << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR,  ((uint32_t)base_class_code << 24) |((uint32_t)subclass_code << 16) |((uint32_t)program_interface << 8) |((uint32_t)revision_id << 0));
}

__INLINE void pcie_ep_class_code_revision_id_unpack(uint8_t* base_class_code, uint8_t* subclass_code, uint8_t* program_interface, uint8_t* revision_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);

	*base_class_code = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*subclass_code = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*program_interface = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*revision_id = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_class_code_revision_id_base_class_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE void pcie_ep_class_code_revision_id_base_class_code_setf(uint8_t baseclasscode)
{
	ASSERT_ERR((((uint32_t)baseclasscode << 24) & ~((uint32_t)0xFF000000)) == 0);
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR, (REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR) & ~((uint32_t)0xFF000000)) | ((uint32_t)baseclasscode <<24));
}
__INLINE uint8_t pcie_ep_class_code_revision_id_subclass_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_class_code_revision_id_subclass_code_setf(uint8_t subclasscode)
{
	ASSERT_ERR((((uint32_t)subclasscode << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR, (REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)subclasscode <<16));
}
__INLINE uint8_t pcie_ep_class_code_revision_id_program_interface_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_class_code_revision_id_program_interface_setf(uint8_t programinterface)
{
	ASSERT_ERR((((uint32_t)programinterface << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR, (REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)programinterface <<8));
}
__INLINE uint8_t pcie_ep_class_code_revision_id_revision_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_class_code_revision_id_revision_id_setf(uint8_t revisionid)
{
	ASSERT_ERR((((uint32_t)revisionid << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR, (REG_PL_RD(PCIE_EP_CLASS_CODE_REVISION_ID_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)revisionid <<0));
}

/**
 * @brief BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG register definition
 *  This register provides the status and controls BIST. It also holds information regarding the header layout, latency timer, and cache line size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 BIST                      0x0
 *    23    MULTI_FUNC                0              
 *    22:16 HEADER_TYPE               0x0
 *    15:08 LATENCY_MASTER_TIMER      0x0
 *    07:00 CACHE_LINE_SIZE           0x0
 * </pre>
 */
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000000C)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_OFFSET      0x0000000C
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_INDEX       0x00000003
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bist_header_type_latency_cache_line_size_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
}

__INLINE void pcie_ep_bist_header_type_latency_cache_line_size_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_BIST_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_BIST_LSB    24
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_BIST_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_MULTI_FUNC_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_MULTI_FUNC_POS    23
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_HEADER_TYPE_MASK    ((uint32_t)0x007F0000)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_HEADER_TYPE_LSB    16
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_HEADER_TYPE_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_LATENCY_MASTER_TIMER_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_LATENCY_MASTER_TIMER_LSB    8
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_LATENCY_MASTER_TIMER_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_CACHE_LINE_SIZE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_CACHE_LINE_SIZE_LSB    0
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_CACHE_LINE_SIZE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_BIST_RST    0x0
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_MULTI_FUNC_RST    0x0
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_HEADER_TYPE_RST    0x0
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_LATENCY_MASTER_TIMER_RST    0x0
#define PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_CACHE_LINE_SIZE_RST    0x0

__INLINE void pcie_ep_bist_header_type_latency_cache_line_size_reg_pack(uint8_t bist, uint8_t multi_func, uint8_t header_type, uint8_t latency_master_timer, uint8_t cache_line_size)
{
	ASSERT_ERR((((uint32_t)bist << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)multi_func << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)header_type << 16) & ~((uint32_t)0x007F0000)) == 0);
	ASSERT_ERR((((uint32_t)latency_master_timer << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)cache_line_size << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR,  ((uint32_t)bist << 24) |((uint32_t)multi_func << 23) |((uint32_t)header_type << 16) |((uint32_t)latency_master_timer << 8) |((uint32_t)cache_line_size << 0));
}

__INLINE void pcie_ep_bist_header_type_latency_cache_line_size_reg_unpack(uint8_t* bist, uint8_t* multi_func, uint8_t* header_type, uint8_t* latency_master_timer, uint8_t* cache_line_size)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);

	*bist = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*multi_func = (localVal & ((uint32_t)0x00800000)) >>  23;
	*header_type = (localVal & ((uint32_t)0x007F0000)) >>  16;
	*latency_master_timer = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*cache_line_size = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_bist_header_type_latency_cache_line_size_reg_bist_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_bist_header_type_latency_cache_line_size_reg_multi_func_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_bist_header_type_latency_cache_line_size_reg_multi_func_setf(uint8_t multifunc)
{
	ASSERT_ERR((((uint32_t)multifunc << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR, (REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)multifunc <<23));
}
__INLINE uint8_t pcie_ep_bist_header_type_latency_cache_line_size_reg_header_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x007F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_bist_header_type_latency_cache_line_size_reg_latency_master_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_bist_header_type_latency_cache_line_size_reg_cache_line_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_bist_header_type_latency_cache_line_size_reg_cache_line_size_setf(uint8_t cachelinesize)
{
	ASSERT_ERR((((uint32_t)cachelinesize << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR, (REG_PL_RD(PCIE_EP_BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE_REG_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)cachelinesize <<0));
}

/**
 * @brief BAR_0_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR0_START                0x0
 *    03    BAR0_PREFETCH             1              
 *    02:01 BAR0_TYPE                 0x2
 *    00    BAR0_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_0_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000010)
#define PCIE_EP_BAR_0_REG_OFFSET      0x00000010
#define PCIE_EP_BAR_0_REG_INDEX       0x00000004
#define PCIE_EP_BAR_0_REG_RESET       0x0000000C

__INLINE uint32_t  pcie_ep_bar_0_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);
}

__INLINE void pcie_ep_bar_0_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_0_REG_BAR_0_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_0_REG_BAR_0_START_LSB    4
#define PCIE_EP_BAR_0_REG_BAR_0_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_0_REG_BAR_0_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_0_REG_BAR_0_PREFETCH_POS    3
#define PCIE_EP_BAR_0_REG_BAR_0_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_0_REG_BAR_0_TYPE_LSB    1
#define PCIE_EP_BAR_0_REG_BAR_0_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_0_REG_BAR_0_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_0_REG_BAR_0_MEM_IO_POS    0

#define PCIE_EP_BAR_0_REG_BAR_0_START_RST    0x0
#define PCIE_EP_BAR_0_REG_BAR_0_PREFETCH_RST    0x1
#define PCIE_EP_BAR_0_REG_BAR_0_TYPE_RST    0x2
#define PCIE_EP_BAR_0_REG_BAR_0_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_0_reg_pack(uint32_t bar0_start, uint8_t bar0_prefetch, uint8_t bar0_type, uint8_t bar0_mem_io)
{
	ASSERT_ERR((((uint32_t)bar0_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar0_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar0_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar0_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR,  ((uint32_t)bar0_start << 4) |((uint32_t)bar0_prefetch << 3) |((uint32_t)bar0_type << 1) |((uint32_t)bar0_mem_io << 0));
}

__INLINE void pcie_ep_bar_0_reg_unpack(uint32_t* bar0_start, uint8_t* bar0_prefetch, uint8_t* bar0_type, uint8_t* bar0_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);

	*bar0_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar0_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar0_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar0_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_0_reg_bar_0_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_0_reg_bar_0_start_setf(uint32_t bar0start)
{
	ASSERT_ERR((((uint32_t)bar0start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar0start <<4));
}
__INLINE uint8_t pcie_ep_bar_0_reg_bar_0_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_bar_0_reg_bar_0_prefetch_setf(uint8_t bar0prefetch)
{
	ASSERT_ERR((((uint32_t)bar0prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)bar0prefetch <<3));
}
__INLINE uint8_t pcie_ep_bar_0_reg_bar_0_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE void pcie_ep_bar_0_reg_bar_0_type_setf(uint8_t bar0type)
{
	ASSERT_ERR((((uint32_t)bar0type << 1) & ~((uint32_t)0x00000006)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR) & ~((uint32_t)0x00000006)) | ((uint32_t)bar0type <<1));
}
__INLINE uint8_t pcie_ep_bar_0_reg_bar_0_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_bar_0_reg_bar_0_mem_io_setf(uint8_t bar0memio)
{
	ASSERT_ERR((((uint32_t)bar0memio << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)bar0memio <<0));
}

/**
 * @brief BAR_1_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR1_START                0x0
 *    03    BAR1_PREFETCH             0              
 *    02:01 BAR1_TYPE                 0x0
 *    00    BAR1_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_1_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000014)
#define PCIE_EP_BAR_1_REG_OFFSET      0x00000014
#define PCIE_EP_BAR_1_REG_INDEX       0x00000005
#define PCIE_EP_BAR_1_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bar_1_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);
}

__INLINE void pcie_ep_bar_1_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_1_REG_BAR_1_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_1_REG_BAR_1_START_LSB    4
#define PCIE_EP_BAR_1_REG_BAR_1_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_1_REG_BAR_1_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_1_REG_BAR_1_PREFETCH_POS    3
#define PCIE_EP_BAR_1_REG_BAR_1_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_1_REG_BAR_1_TYPE_LSB    1
#define PCIE_EP_BAR_1_REG_BAR_1_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_1_REG_BAR_1_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_1_REG_BAR_1_MEM_IO_POS    0

#define PCIE_EP_BAR_1_REG_BAR_1_START_RST    0x0
#define PCIE_EP_BAR_1_REG_BAR_1_PREFETCH_RST    0x0
#define PCIE_EP_BAR_1_REG_BAR_1_TYPE_RST    0x0
#define PCIE_EP_BAR_1_REG_BAR_1_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_1_reg_pack(uint32_t bar1_start, uint8_t bar1_prefetch, uint8_t bar1_type, uint8_t bar1_mem_io)
{
	ASSERT_ERR((((uint32_t)bar1_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar1_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar1_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar1_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR,  ((uint32_t)bar1_start << 4) |((uint32_t)bar1_prefetch << 3) |((uint32_t)bar1_type << 1) |((uint32_t)bar1_mem_io << 0));
}

__INLINE void pcie_ep_bar_1_reg_unpack(uint32_t* bar1_start, uint8_t* bar1_prefetch, uint8_t* bar1_type, uint8_t* bar1_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);

	*bar1_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar1_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar1_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar1_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_1_reg_bar_1_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_1_reg_bar_1_start_setf(uint32_t bar1start)
{
	ASSERT_ERR((((uint32_t)bar1start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar1start <<4));
}
__INLINE uint8_t pcie_ep_bar_1_reg_bar_1_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_bar_1_reg_bar_1_prefetch_setf(uint8_t bar1prefetch)
{
	ASSERT_ERR((((uint32_t)bar1prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)bar1prefetch <<3));
}
__INLINE uint8_t pcie_ep_bar_1_reg_bar_1_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE void pcie_ep_bar_1_reg_bar_1_type_setf(uint8_t bar1type)
{
	ASSERT_ERR((((uint32_t)bar1type << 1) & ~((uint32_t)0x00000006)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR) & ~((uint32_t)0x00000006)) | ((uint32_t)bar1type <<1));
}
__INLINE uint8_t pcie_ep_bar_1_reg_bar_1_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_bar_1_reg_bar_1_mem_io_setf(uint8_t bar1memio)
{
	ASSERT_ERR((((uint32_t)bar1memio << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)bar1memio <<0));
}

/**
 * @brief BAR_2_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR2_START                0x0
 *    03    BAR2_PREFETCH             0              
 *    02:01 BAR2_TYPE                 0x0
 *    00    BAR2_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_2_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000018)
#define PCIE_EP_BAR_2_REG_OFFSET      0x00000018
#define PCIE_EP_BAR_2_REG_INDEX       0x00000006
#define PCIE_EP_BAR_2_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bar_2_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);
}

__INLINE void pcie_ep_bar_2_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_2_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_2_REG_BAR_2_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_2_REG_BAR_2_START_LSB    4
#define PCIE_EP_BAR_2_REG_BAR_2_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_2_REG_BAR_2_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_2_REG_BAR_2_PREFETCH_POS    3
#define PCIE_EP_BAR_2_REG_BAR_2_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_2_REG_BAR_2_TYPE_LSB    1
#define PCIE_EP_BAR_2_REG_BAR_2_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_2_REG_BAR_2_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_2_REG_BAR_2_MEM_IO_POS    0

#define PCIE_EP_BAR_2_REG_BAR_2_START_RST    0x0
#define PCIE_EP_BAR_2_REG_BAR_2_PREFETCH_RST    0x0
#define PCIE_EP_BAR_2_REG_BAR_2_TYPE_RST    0x0
#define PCIE_EP_BAR_2_REG_BAR_2_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_2_reg_pack(uint32_t bar2_start, uint8_t bar2_prefetch, uint8_t bar2_type, uint8_t bar2_mem_io)
{
	ASSERT_ERR((((uint32_t)bar2_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar2_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar2_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar2_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_2_REG_ADDR,  ((uint32_t)bar2_start << 4) |((uint32_t)bar2_prefetch << 3) |((uint32_t)bar2_type << 1) |((uint32_t)bar2_mem_io << 0));
}

__INLINE void pcie_ep_bar_2_reg_unpack(uint32_t* bar2_start, uint8_t* bar2_prefetch, uint8_t* bar2_type, uint8_t* bar2_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);

	*bar2_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar2_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar2_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar2_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_2_reg_bar_2_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_2_reg_bar_2_start_setf(uint32_t bar2start)
{
	ASSERT_ERR((((uint32_t)bar2start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_2_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar2start <<4));
}
__INLINE uint8_t pcie_ep_bar_2_reg_bar_2_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_bar_2_reg_bar_2_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE uint8_t pcie_ep_bar_2_reg_bar_2_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief BAR_3_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR3_START                0x0
 *    03    BAR3_PREFETCH             0              
 *    02:01 BAR3_TYPE                 0x0
 *    00    BAR3_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_3_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000001C)
#define PCIE_EP_BAR_3_REG_OFFSET      0x0000001C
#define PCIE_EP_BAR_3_REG_INDEX       0x00000007
#define PCIE_EP_BAR_3_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bar_3_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);
}

__INLINE void pcie_ep_bar_3_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_3_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_3_REG_BAR_3_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_3_REG_BAR_3_START_LSB    4
#define PCIE_EP_BAR_3_REG_BAR_3_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_3_REG_BAR_3_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_3_REG_BAR_3_PREFETCH_POS    3
#define PCIE_EP_BAR_3_REG_BAR_3_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_3_REG_BAR_3_TYPE_LSB    1
#define PCIE_EP_BAR_3_REG_BAR_3_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_3_REG_BAR_3_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_3_REG_BAR_3_MEM_IO_POS    0

#define PCIE_EP_BAR_3_REG_BAR_3_START_RST    0x0
#define PCIE_EP_BAR_3_REG_BAR_3_PREFETCH_RST    0x0
#define PCIE_EP_BAR_3_REG_BAR_3_TYPE_RST    0x0
#define PCIE_EP_BAR_3_REG_BAR_3_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_3_reg_pack(uint32_t bar3_start, uint8_t bar3_prefetch, uint8_t bar3_type, uint8_t bar3_mem_io)
{
	ASSERT_ERR((((uint32_t)bar3_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar3_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar3_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar3_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_3_REG_ADDR,  ((uint32_t)bar3_start << 4) |((uint32_t)bar3_prefetch << 3) |((uint32_t)bar3_type << 1) |((uint32_t)bar3_mem_io << 0));
}

__INLINE void pcie_ep_bar_3_reg_unpack(uint32_t* bar3_start, uint8_t* bar3_prefetch, uint8_t* bar3_type, uint8_t* bar3_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);

	*bar3_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar3_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar3_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar3_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_3_reg_bar_3_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_3_reg_bar_3_start_setf(uint32_t bar3start)
{
	ASSERT_ERR((((uint32_t)bar3start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_3_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar3start <<4));
}
__INLINE uint8_t pcie_ep_bar_3_reg_bar_3_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_bar_3_reg_bar_3_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE uint8_t pcie_ep_bar_3_reg_bar_3_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_3_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief BAR_4_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR4_START                0x0
 *    03    BAR4_PREFETCH             0              
 *    02:01 BAR4_TYPE                 0x0
 *    00    BAR4_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_4_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000020)
#define PCIE_EP_BAR_4_REG_OFFSET      0x00000020
#define PCIE_EP_BAR_4_REG_INDEX       0x00000008
#define PCIE_EP_BAR_4_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bar_4_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);
}

__INLINE void pcie_ep_bar_4_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_4_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_4_REG_BAR_4_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_4_REG_BAR_4_START_LSB    4
#define PCIE_EP_BAR_4_REG_BAR_4_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_4_REG_BAR_4_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_4_REG_BAR_4_PREFETCH_POS    3
#define PCIE_EP_BAR_4_REG_BAR_4_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_4_REG_BAR_4_TYPE_LSB    1
#define PCIE_EP_BAR_4_REG_BAR_4_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_4_REG_BAR_4_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_4_REG_BAR_4_MEM_IO_POS    0

#define PCIE_EP_BAR_4_REG_BAR_4_START_RST    0x0
#define PCIE_EP_BAR_4_REG_BAR_4_PREFETCH_RST    0x0
#define PCIE_EP_BAR_4_REG_BAR_4_TYPE_RST    0x0
#define PCIE_EP_BAR_4_REG_BAR_4_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_4_reg_pack(uint32_t bar4_start, uint8_t bar4_prefetch, uint8_t bar4_type, uint8_t bar4_mem_io)
{
	ASSERT_ERR((((uint32_t)bar4_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar4_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar4_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar4_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_4_REG_ADDR,  ((uint32_t)bar4_start << 4) |((uint32_t)bar4_prefetch << 3) |((uint32_t)bar4_type << 1) |((uint32_t)bar4_mem_io << 0));
}

__INLINE void pcie_ep_bar_4_reg_unpack(uint32_t* bar4_start, uint8_t* bar4_prefetch, uint8_t* bar4_type, uint8_t* bar4_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);

	*bar4_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar4_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar4_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar4_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_4_reg_bar_4_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_4_reg_bar_4_start_setf(uint32_t bar4start)
{
	ASSERT_ERR((((uint32_t)bar4start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_4_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar4start <<4));
}
__INLINE uint8_t pcie_ep_bar_4_reg_bar_4_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_bar_4_reg_bar_4_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE uint8_t pcie_ep_bar_4_reg_bar_4_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_4_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief BAR_5_REG register definition
 *  System software must build a consistent address map before booting the machine to an operating system. This means it has to determine how much memory is in the system, and how much address space the Functions in the system require. After determining this information, system software can map the Functions into reasonable locations and proceed with system boot. In order to do this mapping in a device-independent manner, the base registers for this mapping are placed in the predefined header portion of Configuration Space. It is strongly recommended that power-up firmware/software also support the optional Enhanced Configuration Access Mechanism (ECAM). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 BAR5_START                0x0
 *    03    BAR5_PREFETCH             0              
 *    02:01 BAR5_TYPE                 0x0
 *    00    BAR5_MEM_IO               0              
 * </pre>
 */
#define PCIE_EP_BAR_5_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000024)
#define PCIE_EP_BAR_5_REG_OFFSET      0x00000024
#define PCIE_EP_BAR_5_REG_INDEX       0x00000009
#define PCIE_EP_BAR_5_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_bar_5_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);
}

__INLINE void pcie_ep_bar_5_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_5_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_5_REG_BAR_5_START_MASK    ((uint32_t)0xFFFFFFF0)
#define PCIE_EP_BAR_5_REG_BAR_5_START_LSB    4
#define PCIE_EP_BAR_5_REG_BAR_5_START_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_BAR_5_REG_BAR_5_PREFETCH_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_BAR_5_REG_BAR_5_PREFETCH_POS    3
#define PCIE_EP_BAR_5_REG_BAR_5_TYPE_MASK    ((uint32_t)0x00000006)
#define PCIE_EP_BAR_5_REG_BAR_5_TYPE_LSB    1
#define PCIE_EP_BAR_5_REG_BAR_5_TYPE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_BAR_5_REG_BAR_5_MEM_IO_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_5_REG_BAR_5_MEM_IO_POS    0

#define PCIE_EP_BAR_5_REG_BAR_5_START_RST    0x0
#define PCIE_EP_BAR_5_REG_BAR_5_PREFETCH_RST    0x0
#define PCIE_EP_BAR_5_REG_BAR_5_TYPE_RST    0x0
#define PCIE_EP_BAR_5_REG_BAR_5_MEM_IO_RST    0x0

__INLINE void pcie_ep_bar_5_reg_pack(uint32_t bar5_start, uint8_t bar5_prefetch, uint8_t bar5_type, uint8_t bar5_mem_io)
{
	ASSERT_ERR((((uint32_t)bar5_start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)bar5_prefetch << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)bar5_type << 1) & ~((uint32_t)0x00000006)) == 0);
	ASSERT_ERR((((uint32_t)bar5_mem_io << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_5_REG_ADDR,  ((uint32_t)bar5_start << 4) |((uint32_t)bar5_prefetch << 3) |((uint32_t)bar5_type << 1) |((uint32_t)bar5_mem_io << 0));
}

__INLINE void pcie_ep_bar_5_reg_unpack(uint32_t* bar5_start, uint8_t* bar5_prefetch, uint8_t* bar5_type, uint8_t* bar5_mem_io)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);

	*bar5_start = (localVal & ((uint32_t)0xFFFFFFF0)) >>  4;
	*bar5_prefetch = (localVal & ((uint32_t)0x00000008)) >>  3;
	*bar5_type = (localVal & ((uint32_t)0x00000006)) >>  1;
	*bar5_mem_io = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_bar_5_reg_bar_5_start_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFF0)) >> 4);
}
__INLINE void pcie_ep_bar_5_reg_bar_5_start_setf(uint32_t bar5start)
{
	ASSERT_ERR((((uint32_t)bar5start << 4) & ~((uint32_t)0xFFFFFFF0)) == 0);
	REG_PL_WR(PCIE_EP_BAR_5_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR) & ~((uint32_t)0xFFFFFFF0)) | ((uint32_t)bar5start <<4));
}
__INLINE uint8_t pcie_ep_bar_5_reg_bar_5_prefetch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_bar_5_reg_bar_5_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000006)) >> 1);
}
__INLINE uint8_t pcie_ep_bar_5_reg_bar_5_mem_io_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_BAR_5_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief CARDBUS_CIS_PTR_REG register definition
 *  This register holds the CardBus CIS pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CARDBUS_CIS_POINTER       0x0
 * </pre>
 */
#define PCIE_EP_CARDBUS_CIS_PTR_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000028)
#define PCIE_EP_CARDBUS_CIS_PTR_REG_OFFSET      0x00000028
#define PCIE_EP_CARDBUS_CIS_PTR_REG_INDEX       0x0000000A
#define PCIE_EP_CARDBUS_CIS_PTR_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_cardbus_cis_ptr_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_CARDBUS_CIS_PTR_REG_ADDR);
}

__INLINE void pcie_ep_cardbus_cis_ptr_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CARDBUS_CIS_PTR_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_CARDBUS_CIS_PTR_REG_CARDBUS_CIS_POINTER_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_CARDBUS_CIS_PTR_REG_CARDBUS_CIS_POINTER_LSB    0
#define PCIE_EP_CARDBUS_CIS_PTR_REG_CARDBUS_CIS_POINTER_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_CARDBUS_CIS_PTR_REG_CARDBUS_CIS_POINTER_RST    0x0

__INLINE uint32_t pcie_ep_cardbus_cis_ptr_reg_cardbus_cis_pointer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CARDBUS_CIS_PTR_REG_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_cardbus_cis_ptr_reg_cardbus_cis_pointer_setf(uint32_t cardbuscispointer)
{
	ASSERT_ERR((((uint32_t)cardbuscispointer << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_CARDBUS_CIS_PTR_REG_ADDR, (uint32_t)cardbuscispointer << 0);
}

/**
 * @brief SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG register definition
 *  These registers are used to uniquely identify the add-in card or subsystem where the PCI Express component resides. They provide a mechanism for vendors to distinguish their products from one another even though the assemblies may have the same PCI Express component on them (and, therefore, the same Vendor ID and Device ID). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 SUBSYS_DEV_ID             0x6000
 *    15:00 SUBSYS_VENDOR_ID          0x0
 * </pre>
 */
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000002C)
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_OFFSET      0x0000002C
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_INDEX       0x0000000B
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_RESET       0x60000000

__INLINE uint32_t  pcie_ep_subsystem_id_subsystem_vendor_id_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR);
}

__INLINE void pcie_ep_subsystem_id_subsystem_vendor_id_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_DEV_ID_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_DEV_ID_LSB    16
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_DEV_ID_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_VENDOR_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_VENDOR_ID_LSB    0
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_VENDOR_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_DEV_ID_RST    0x6000
#define PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_SUBSYS_VENDOR_ID_RST    0x0

__INLINE void pcie_ep_subsystem_id_subsystem_vendor_id_reg_pack(uint16_t subsys_dev_id, uint16_t subsys_vendor_id)
{
	ASSERT_ERR((((uint32_t)subsys_dev_id << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)subsys_vendor_id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR,  ((uint32_t)subsys_dev_id << 16) |((uint32_t)subsys_vendor_id << 0));
}

__INLINE void pcie_ep_subsystem_id_subsystem_vendor_id_reg_unpack(uint16_t* subsys_dev_id, uint16_t* subsys_vendor_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR);

	*subsys_dev_id = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*subsys_vendor_id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_subsystem_id_subsystem_vendor_id_reg_subsys_dev_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_subsystem_id_subsystem_vendor_id_reg_subsys_dev_id_setf(uint16_t subsysdevid)
{
	ASSERT_ERR((((uint32_t)subsysdevid << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR, (REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)subsysdevid <<16));
}
__INLINE uint16_t pcie_ep_subsystem_id_subsystem_vendor_id_reg_subsys_vendor_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_subsystem_id_subsystem_vendor_id_reg_subsys_vendor_id_setf(uint16_t subsysvendorid)
{
	ASSERT_ERR((((uint32_t)subsysvendorid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR, (REG_PL_RD(PCIE_EP_SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID_REG_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)subsysvendorid <<0));
}

/**
 * @brief EXP_ROM_BASE_ADDR_REG register definition
 *  This register handles the base address and size information for this expansion ROM. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:11 EXP_ROM_BASE_ADDRESS      0x0
 *    10:08 RSVDP_8                   0x0
 *    07:04 ROM_BAR_VALIDATION_DETAILS 0x0
 *    03:01 ROM_BAR_VALIDATION_STATUS 0x0
 *    00    ROM_BAR_ENABLE            0              
 * </pre>
 */
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000030)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_OFFSET      0x00000030
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_INDEX       0x0000000C
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_exp_rom_base_addr_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
}

__INLINE void pcie_ep_exp_rom_base_addr_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_EXP_ROM_BASE_ADDRESS_MASK    ((uint32_t)0xFFFFF800)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_EXP_ROM_BASE_ADDRESS_LSB    11
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_EXP_ROM_BASE_ADDRESS_WIDTH    ((uint32_t)0x00000015)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_RSVDP_8_MASK    ((uint32_t)0x00000700)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_RSVDP_8_LSB    8
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_RSVDP_8_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_DETAILS_MASK    ((uint32_t)0x000000F0)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_DETAILS_LSB    4
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_DETAILS_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_STATUS_MASK    ((uint32_t)0x0000000E)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_STATUS_LSB    1
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_STATUS_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_ENABLE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_ENABLE_POS    0

#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_EXP_ROM_BASE_ADDRESS_RST    0x0
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_RSVDP_8_RST    0x0
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_DETAILS_RST    0x0
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_VALIDATION_STATUS_RST    0x0
#define PCIE_EP_EXP_ROM_BASE_ADDR_REG_ROM_BAR_ENABLE_RST    0x0

__INLINE void pcie_ep_exp_rom_base_addr_reg_pack(uint32_t exp_rom_base_address, uint8_t rsvdp_8, uint8_t rom_bar_validation_details, uint8_t rom_bar_validation_status, uint8_t rom_bar_enable)
{
	ASSERT_ERR((((uint32_t)exp_rom_base_address << 11) & ~((uint32_t)0xFFFFF800)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x00000700)) == 0);
	ASSERT_ERR((((uint32_t)rom_bar_validation_details << 4) & ~((uint32_t)0x000000F0)) == 0);
	ASSERT_ERR((((uint32_t)rom_bar_validation_status << 1) & ~((uint32_t)0x0000000E)) == 0);
	ASSERT_ERR((((uint32_t)rom_bar_enable << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR,  ((uint32_t)exp_rom_base_address << 11) |((uint32_t)rsvdp_8 << 8) |((uint32_t)rom_bar_validation_details << 4) |((uint32_t)rom_bar_validation_status << 1) |((uint32_t)rom_bar_enable << 0));
}

__INLINE void pcie_ep_exp_rom_base_addr_reg_unpack(uint32_t* exp_rom_base_address, uint8_t* rsvdp_8, uint8_t* rom_bar_validation_details, uint8_t* rom_bar_validation_status, uint8_t* rom_bar_enable)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);

	*exp_rom_base_address = (localVal & ((uint32_t)0xFFFFF800)) >>  11;
	*rsvdp_8 = (localVal & ((uint32_t)0x00000700)) >>  8;
	*rom_bar_validation_details = (localVal & ((uint32_t)0x000000F0)) >>  4;
	*rom_bar_validation_status = (localVal & ((uint32_t)0x0000000E)) >>  1;
	*rom_bar_enable = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_exp_rom_base_addr_reg_exp_rom_base_address_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFF800)) >> 11);
}
__INLINE void pcie_ep_exp_rom_base_addr_reg_exp_rom_base_address_setf(uint32_t exprombaseaddress)
{
	ASSERT_ERR((((uint32_t)exprombaseaddress << 11) & ~((uint32_t)0xFFFFF800)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR) & ~((uint32_t)0xFFFFF800)) | ((uint32_t)exprombaseaddress <<11));
}
__INLINE uint8_t pcie_ep_exp_rom_base_addr_reg_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000700)) >> 8);
}
__INLINE uint8_t pcie_ep_exp_rom_base_addr_reg_rom_bar_validation_details_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE void pcie_ep_exp_rom_base_addr_reg_rom_bar_validation_details_setf(uint8_t rombarvalidationdetails)
{
	ASSERT_ERR((((uint32_t)rombarvalidationdetails << 4) & ~((uint32_t)0x000000F0)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR) & ~((uint32_t)0x000000F0)) | ((uint32_t)rombarvalidationdetails <<4));
}
__INLINE uint8_t pcie_ep_exp_rom_base_addr_reg_rom_bar_validation_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000E)) >> 1);
}
__INLINE void pcie_ep_exp_rom_base_addr_reg_rom_bar_validation_status_setf(uint8_t rombarvalidationstatus)
{
	ASSERT_ERR((((uint32_t)rombarvalidationstatus << 1) & ~((uint32_t)0x0000000E)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR) & ~((uint32_t)0x0000000E)) | ((uint32_t)rombarvalidationstatus <<1));
}
__INLINE uint8_t pcie_ep_exp_rom_base_addr_reg_rom_bar_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_exp_rom_base_addr_reg_rom_bar_enable_setf(uint8_t rombarenable)
{
	ASSERT_ERR((((uint32_t)rombarenable << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BASE_ADDR_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)rombarenable <<0));
}

/**
 * @brief PCI_CAP_PTR_REG register definition
 *  This register is used to point to a linked list of capabilities implemented by a Function. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:08 RSVDP_8                   0x0
 *    07:00 CAP_POINTER               0x40
 * </pre>
 */
#define PCIE_EP_PCI_CAP_PTR_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000034)
#define PCIE_EP_PCI_CAP_PTR_REG_OFFSET      0x00000034
#define PCIE_EP_PCI_CAP_PTR_REG_INDEX       0x0000000D
#define PCIE_EP_PCI_CAP_PTR_REG_RESET       0x00000040

__INLINE uint32_t  pcie_ep_pci_cap_ptr_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_PCI_CAP_PTR_REG_ADDR);
}

__INLINE void pcie_ep_pci_cap_ptr_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PCI_CAP_PTR_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_PCI_CAP_PTR_REG_RSVDP_8_MASK    ((uint32_t)0xFFFFFF00)
#define PCIE_EP_PCI_CAP_PTR_REG_RSVDP_8_LSB    8
#define PCIE_EP_PCI_CAP_PTR_REG_RSVDP_8_WIDTH    ((uint32_t)0x00000018)
#define PCIE_EP_PCI_CAP_PTR_REG_CAP_POINTER_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_PCI_CAP_PTR_REG_CAP_POINTER_LSB    0
#define PCIE_EP_PCI_CAP_PTR_REG_CAP_POINTER_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_PCI_CAP_PTR_REG_RSVDP_8_RST    0x0
#define PCIE_EP_PCI_CAP_PTR_REG_CAP_POINTER_RST    0x40

__INLINE void pcie_ep_pci_cap_ptr_reg_pack(uint32_t rsvdp_8, uint8_t cap_pointer)
{
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0xFFFFFF00)) == 0);
	ASSERT_ERR((((uint32_t)cap_pointer << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PCI_CAP_PTR_REG_ADDR,  ((uint32_t)rsvdp_8 << 8) |((uint32_t)cap_pointer << 0));
}

__INLINE void pcie_ep_pci_cap_ptr_reg_unpack(uint32_t* rsvdp_8, uint8_t* cap_pointer)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_CAP_PTR_REG_ADDR);

	*rsvdp_8 = (localVal & ((uint32_t)0xFFFFFF00)) >>  8;
	*cap_pointer = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint32_t pcie_ep_pci_cap_ptr_reg_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_CAP_PTR_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFF00)) >> 8);
}
__INLINE uint8_t pcie_ep_pci_cap_ptr_reg_cap_pointer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_CAP_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_pci_cap_ptr_reg_cap_pointer_setf(uint8_t cappointer)
{
	ASSERT_ERR((((uint32_t)cappointer << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PCI_CAP_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_CAP_PTR_REG_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)cappointer <<0));
}

/**
 * @brief MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG register definition
 *  The Interrupt Line register communicates interrupt line routing information. The Interrupt Pin register identifies the legacy interrupt Message(s) the Function uses. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15:08 INT_PIN                   0x1
 *    07:00 INT_LINE                  0xff
 * </pre>
 */
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000003C)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_OFFSET      0x0000003C
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INDEX       0x0000000F
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_RESET       0x000001FF

__INLINE uint32_t  pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR);
}

__INLINE void pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_RSVDP_16_LSB    16
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_PIN_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_PIN_LSB    8
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_PIN_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_LINE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_LINE_LSB    0
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_LINE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_RSVDP_16_RST    0x0
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_PIN_RST    0x1
#define PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_INT_LINE_RST    0xff

__INLINE void pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_pack(uint16_t rsvdp_16, uint8_t int_pin, uint8_t int_line)
{
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)int_pin << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)int_line << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR,  ((uint32_t)rsvdp_16 << 16) |((uint32_t)int_pin << 8) |((uint32_t)int_line << 0));
}

__INLINE void pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_unpack(uint16_t* rsvdp_16, uint8_t* int_pin, uint8_t* int_line)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*int_pin = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*int_line = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint16_t pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_int_pin_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_int_pin_setf(uint8_t intpin)
{
	ASSERT_ERR((((uint32_t)intpin << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR, (REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)intpin <<8));
}
__INLINE uint8_t pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_int_line_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_max_latency_min_grant_interrupt_pin_interrupt_line_reg_int_line_setf(uint8_t intline)
{
	ASSERT_ERR((((uint32_t)intline << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR, (REG_PL_RD(PCIE_EP_MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE_REG_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)intline <<0));
}

/**
 * @brief CAP_ID_NXT_PTR_REG register definition
 *  This register provides information refarding the Power Management Capabilities. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:27 PME_SUPPORT               0x1b
 *    26    D2_SUPPORT                0              
 *    25    D1_SUPPORT                1              
 *    24:22 AUX_CURR                  0x7
 *    21    DSI                       0              
 *    19    PME_CLK                   0              
 *    18:16 PM_SPEC_VER               0x3
 *    15:08 PM_NEXT_POINTER           0x50
 *    07:00 PM_CAP_ID                 0x1
 * </pre>
 */
#define PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000040)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_OFFSET      0x00000040
#define PCIE_EP_CAP_ID_NXT_PTR_REG_INDEX       0x00000010
#define PCIE_EP_CAP_ID_NXT_PTR_REG_RESET       0xDBC35001

__INLINE uint32_t  pcie_ep_cap_id_nxt_ptr_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
}

__INLINE void pcie_ep_cap_id_nxt_ptr_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_SUPPORT_MASK    ((uint32_t)0xF8000000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_SUPPORT_LSB    27
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_SUPPORT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_2_SUPPORT_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_2_SUPPORT_POS    26
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_1_SUPPORT_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_1_SUPPORT_POS    25
#define PCIE_EP_CAP_ID_NXT_PTR_REG_AUX_CURR_MASK    ((uint32_t)0x01C00000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_AUX_CURR_LSB    22
#define PCIE_EP_CAP_ID_NXT_PTR_REG_AUX_CURR_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_DSI_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_DSI_POS    21
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_CLK_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_CLK_POS    19
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_SPEC_VER_MASK    ((uint32_t)0x00070000)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_SPEC_VER_LSB    16
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_SPEC_VER_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_NEXT_POINTER_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_NEXT_POINTER_LSB    8
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_NEXT_POINTER_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_CAP_ID_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_CAP_ID_LSB    0
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_CAP_ID_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_SUPPORT_RST    0x1b
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_2_SUPPORT_RST    0x0
#define PCIE_EP_CAP_ID_NXT_PTR_REG_D_1_SUPPORT_RST    0x1
#define PCIE_EP_CAP_ID_NXT_PTR_REG_AUX_CURR_RST    0x7
#define PCIE_EP_CAP_ID_NXT_PTR_REG_DSI_RST    0x0
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PME_CLK_RST    0x0
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_SPEC_VER_RST    0x3
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_NEXT_POINTER_RST    0x50
#define PCIE_EP_CAP_ID_NXT_PTR_REG_PM_CAP_ID_RST    0x1

__INLINE void pcie_ep_cap_id_nxt_ptr_reg_pack(uint8_t pme_support, uint8_t d2_support, uint8_t d1_support, uint8_t aux_curr, uint8_t dsi, uint8_t pme_clk, uint8_t pm_spec_ver, uint8_t pm_next_pointer, uint8_t pm_cap_id)
{
	ASSERT_ERR((((uint32_t)pme_support << 27) & ~((uint32_t)0xF8000000)) == 0);
	ASSERT_ERR((((uint32_t)d2_support << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)d1_support << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)aux_curr << 22) & ~((uint32_t)0x01C00000)) == 0);
	ASSERT_ERR((((uint32_t)dsi << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)pme_clk << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)pm_spec_ver << 16) & ~((uint32_t)0x00070000)) == 0);
	ASSERT_ERR((((uint32_t)pm_next_pointer << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)pm_cap_id << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR,  ((uint32_t)pme_support << 27) |((uint32_t)d2_support << 26) |((uint32_t)d1_support << 25) |((uint32_t)aux_curr << 22) |((uint32_t)dsi << 21) |((uint32_t)pme_clk << 19) |((uint32_t)pm_spec_ver << 16) |((uint32_t)pm_next_pointer << 8) |((uint32_t)pm_cap_id << 0));
}

__INLINE void pcie_ep_cap_id_nxt_ptr_reg_unpack(uint8_t* pme_support, uint8_t* d2_support, uint8_t* d1_support, uint8_t* aux_curr, uint8_t* dsi, uint8_t* pme_clk, uint8_t* pm_spec_ver, uint8_t* pm_next_pointer, uint8_t* pm_cap_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);

	*pme_support = (localVal & ((uint32_t)0xF8000000)) >>  27;
	*d2_support = (localVal & ((uint32_t)0x04000000)) >>  26;
	*d1_support = (localVal & ((uint32_t)0x02000000)) >>  25;
	*aux_curr = (localVal & ((uint32_t)0x01C00000)) >>  22;
	*dsi = (localVal & ((uint32_t)0x00200000)) >>  21;
	*pme_clk = (localVal & ((uint32_t)0x00080000)) >>  19;
	*pm_spec_ver = (localVal & ((uint32_t)0x00070000)) >>  16;
	*pm_next_pointer = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*pm_cap_id = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_pme_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF8000000)) >> 27);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_pme_support_setf(uint8_t pmesupport)
{
	ASSERT_ERR((((uint32_t)pmesupport << 27) & ~((uint32_t)0xF8000000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0xF8000000)) | ((uint32_t)pmesupport <<27));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_d_2_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_d_2_support_setf(uint8_t d2support)
{
	ASSERT_ERR((((uint32_t)d2support << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)d2support <<26));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_d_1_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_d_1_support_setf(uint8_t d1support)
{
	ASSERT_ERR((((uint32_t)d1support << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)d1support <<25));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_aux_curr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01C00000)) >> 22);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_aux_curr_setf(uint8_t auxcurr)
{
	ASSERT_ERR((((uint32_t)auxcurr << 22) & ~((uint32_t)0x01C00000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x01C00000)) | ((uint32_t)auxcurr <<22));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_dsi_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_dsi_setf(uint8_t dsi)
{
	ASSERT_ERR((((uint32_t)dsi << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)dsi <<21));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_pme_clk_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_pm_spec_ver_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00070000)) >> 16);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_pm_spec_ver_setf(uint8_t pmspecver)
{
	ASSERT_ERR((((uint32_t)pmspecver << 16) & ~((uint32_t)0x00070000)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x00070000)) | ((uint32_t)pmspecver <<16));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_pm_next_pointer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_cap_id_nxt_ptr_reg_pm_next_pointer_setf(uint8_t pmnextpointer)
{
	ASSERT_ERR((((uint32_t)pmnextpointer << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR, (REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)pmnextpointer <<8));
}
__INLINE uint8_t pcie_ep_cap_id_nxt_ptr_reg_pm_cap_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CAP_ID_NXT_PTR_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief CON_STATUS_REG register definition
 *  This register is used to manage the PCI function s power management state as well as to enable/monitor PMEs. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 DATA_REG_ADD_INFO         0x0
 *    23    BUS_PWR_CLK_CON_EN        0              
 *    22    B2_B3_SUPPORT             0              
 *    21:16 RSVDP_16                  0x0
 *    15    PME_STATUS                0              
 *    14:13 DATA_SCALE                0x0
 *    12:09 DATA_SELECT               0x0
 *    08    PME_ENABLE                0              
 *    07:04 RSVDP_4                   0x0
 *    03    NO_SOFT_RST               1              
 *    02    RSVDP_2                   0              
 *    01:00 POWER_STATE               0x0
 * </pre>
 */
#define PCIE_EP_CON_STATUS_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000044)
#define PCIE_EP_CON_STATUS_REG_OFFSET      0x00000044
#define PCIE_EP_CON_STATUS_REG_INDEX       0x00000011
#define PCIE_EP_CON_STATUS_REG_RESET       0x00000008

__INLINE uint32_t  pcie_ep_con_status_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
}

__INLINE void pcie_ep_con_status_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_CON_STATUS_REG_DATA_REG_ADD_INFO_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_CON_STATUS_REG_DATA_REG_ADD_INFO_LSB    24
#define PCIE_EP_CON_STATUS_REG_DATA_REG_ADD_INFO_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_CON_STATUS_REG_BUS_PWR_CLK_CON_EN_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_CON_STATUS_REG_BUS_PWR_CLK_CON_EN_POS    23
#define PCIE_EP_CON_STATUS_REG_B_2_B_3_SUPPORT_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_CON_STATUS_REG_B_2_B_3_SUPPORT_POS    22
#define PCIE_EP_CON_STATUS_REG_RSVDP_16_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_CON_STATUS_REG_RSVDP_16_LSB    16
#define PCIE_EP_CON_STATUS_REG_RSVDP_16_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_CON_STATUS_REG_PME_STATUS_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_CON_STATUS_REG_PME_STATUS_POS    15
#define PCIE_EP_CON_STATUS_REG_DATA_SCALE_MASK    ((uint32_t)0x00006000)
#define PCIE_EP_CON_STATUS_REG_DATA_SCALE_LSB    13
#define PCIE_EP_CON_STATUS_REG_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_CON_STATUS_REG_DATA_SELECT_MASK    ((uint32_t)0x00001E00)
#define PCIE_EP_CON_STATUS_REG_DATA_SELECT_LSB    9
#define PCIE_EP_CON_STATUS_REG_DATA_SELECT_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_CON_STATUS_REG_PME_ENABLE_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_CON_STATUS_REG_PME_ENABLE_POS    8
#define PCIE_EP_CON_STATUS_REG_RSVDP_4_MASK    ((uint32_t)0x000000F0)
#define PCIE_EP_CON_STATUS_REG_RSVDP_4_LSB    4
#define PCIE_EP_CON_STATUS_REG_RSVDP_4_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_CON_STATUS_REG_NO_SOFT_RST_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_CON_STATUS_REG_NO_SOFT_RST_POS    3
#define PCIE_EP_CON_STATUS_REG_RSVDP_2_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_CON_STATUS_REG_RSVDP_2_POS    2
#define PCIE_EP_CON_STATUS_REG_POWER_STATE_MASK    ((uint32_t)0x00000003)
#define PCIE_EP_CON_STATUS_REG_POWER_STATE_LSB    0
#define PCIE_EP_CON_STATUS_REG_POWER_STATE_WIDTH    ((uint32_t)0x00000002)

#define PCIE_EP_CON_STATUS_REG_DATA_REG_ADD_INFO_RST    0x0
#define PCIE_EP_CON_STATUS_REG_BUS_PWR_CLK_CON_EN_RST    0x0
#define PCIE_EP_CON_STATUS_REG_B_2_B_3_SUPPORT_RST    0x0
#define PCIE_EP_CON_STATUS_REG_RSVDP_16_RST    0x0
#define PCIE_EP_CON_STATUS_REG_PME_STATUS_RST    0x0
#define PCIE_EP_CON_STATUS_REG_DATA_SCALE_RST    0x0
#define PCIE_EP_CON_STATUS_REG_DATA_SELECT_RST    0x0
#define PCIE_EP_CON_STATUS_REG_PME_ENABLE_RST    0x0
#define PCIE_EP_CON_STATUS_REG_RSVDP_4_RST    0x0
#define PCIE_EP_CON_STATUS_REG_NO_SOFT_RST_RST    0x1
#define PCIE_EP_CON_STATUS_REG_RSVDP_2_RST    0x0
#define PCIE_EP_CON_STATUS_REG_POWER_STATE_RST    0x0

__INLINE void pcie_ep_con_status_reg_pack(uint8_t data_reg_add_info, uint8_t bus_pwr_clk_con_en, uint8_t b2_b3_support, uint8_t rsvdp_16, uint8_t pme_status, uint8_t data_scale, uint8_t data_select, uint8_t pme_enable, uint8_t rsvdp_4, uint8_t no_soft_rst, uint8_t rsvdp_2, uint8_t power_state)
{
	ASSERT_ERR((((uint32_t)data_reg_add_info << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)bus_pwr_clk_con_en << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)b2_b3_support << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0x003F0000)) == 0);
	ASSERT_ERR((((uint32_t)pme_status << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)data_scale << 13) & ~((uint32_t)0x00006000)) == 0);
	ASSERT_ERR((((uint32_t)data_select << 9) & ~((uint32_t)0x00001E00)) == 0);
	ASSERT_ERR((((uint32_t)pme_enable << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x000000F0)) == 0);
	ASSERT_ERR((((uint32_t)no_soft_rst << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_2 << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)power_state << 0) & ~((uint32_t)0x00000003)) == 0);
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR,  ((uint32_t)data_reg_add_info << 24) |((uint32_t)bus_pwr_clk_con_en << 23) |((uint32_t)b2_b3_support << 22) |((uint32_t)rsvdp_16 << 16) |((uint32_t)pme_status << 15) |((uint32_t)data_scale << 13) |((uint32_t)data_select << 9) |((uint32_t)pme_enable << 8) |((uint32_t)rsvdp_4 << 4) |((uint32_t)no_soft_rst << 3) |((uint32_t)rsvdp_2 << 2) |((uint32_t)power_state << 0));
}

__INLINE void pcie_ep_con_status_reg_unpack(uint8_t* data_reg_add_info, uint8_t* bus_pwr_clk_con_en, uint8_t* b2_b3_support, uint8_t* rsvdp_16, uint8_t* pme_status, uint8_t* data_scale, uint8_t* data_select, uint8_t* pme_enable, uint8_t* rsvdp_4, uint8_t* no_soft_rst, uint8_t* rsvdp_2, uint8_t* power_state)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);

	*data_reg_add_info = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*bus_pwr_clk_con_en = (localVal & ((uint32_t)0x00800000)) >>  23;
	*b2_b3_support = (localVal & ((uint32_t)0x00400000)) >>  22;
	*rsvdp_16 = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*pme_status = (localVal & ((uint32_t)0x00008000)) >>  15;
	*data_scale = (localVal & ((uint32_t)0x00006000)) >>  13;
	*data_select = (localVal & ((uint32_t)0x00001E00)) >>  9;
	*pme_enable = (localVal & ((uint32_t)0x00000100)) >>  8;
	*rsvdp_4 = (localVal & ((uint32_t)0x000000F0)) >>  4;
	*no_soft_rst = (localVal & ((uint32_t)0x00000008)) >>  3;
	*rsvdp_2 = (localVal & ((uint32_t)0x00000004)) >>  2;
	*power_state = (localVal & ((uint32_t)0x00000003)) >>  0;
}

__INLINE uint8_t pcie_ep_con_status_reg_data_reg_add_info_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_con_status_reg_bus_pwr_clk_con_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_con_status_reg_b_2_b_3_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE uint8_t pcie_ep_con_status_reg_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_con_status_reg_pme_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_con_status_reg_pme_status_setf(uint8_t pmestatus)
{
	ASSERT_ERR((((uint32_t)pmestatus << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)pmestatus <<15));
}
__INLINE uint8_t pcie_ep_con_status_reg_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00006000)) >> 13);
}
__INLINE uint8_t pcie_ep_con_status_reg_data_select_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001E00)) >> 9);
}
__INLINE uint8_t pcie_ep_con_status_reg_pme_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_con_status_reg_pme_enable_setf(uint8_t pmeenable)
{
	ASSERT_ERR((((uint32_t)pmeenable << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)pmeenable <<8));
}
__INLINE uint8_t pcie_ep_con_status_reg_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE uint8_t pcie_ep_con_status_reg_no_soft_rst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_con_status_reg_no_soft_rst_setf(uint8_t nosoftrst)
{
	ASSERT_ERR((((uint32_t)nosoftrst << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)nosoftrst <<3));
}
__INLINE uint8_t pcie_ep_con_status_reg_rsvdp_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE uint8_t pcie_ep_con_status_reg_power_state_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000003)) >> 0);
}
__INLINE void pcie_ep_con_status_reg_power_state_setf(uint8_t powerstate)
{
	ASSERT_ERR((((uint32_t)powerstate << 0) & ~((uint32_t)0x00000003)) == 0);
	REG_PL_WR(PCIE_EP_CON_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_CON_STATUS_REG_ADDR) & ~((uint32_t)0x00000003)) | ((uint32_t)powerstate <<0));
}

/**
 * @brief PCI_MSI_CAP_ID_NEXT_CTRL_REG register definition
 *  This register holds MSI Capability Header information and controls the MSI behaviour. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:27 RSVDP_27                  0x0
 *    26    PCI_MSI_EXT_DATA_EN       0              
 *    25    PCI_MSI_EXT_DATA_CAP      0              
 *    24    PCI_PVM_SUPPORT           0              
 *    23    PCI_MSI_64_BIT_ADDR_CAP   1              
 *    22:20 PCI_MSI_MULTIPLE_MSG_EN   0x0
 *    19:17 PCI_MSI_MULTIPLE_MSG_CAP  0x0
 *    16    PCI_MSI_ENABLE            0              
 *    15:08 PCI_MSI_CAP_NEXT_OFFSET   0x70
 *    07:00 PCI_MSI_CAP_ID            0x5
 * </pre>
 */
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000050)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_OFFSET      0x00000050
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_INDEX       0x00000014
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_RESET       0x00807005

__INLINE uint32_t  pcie_ep_pci_msi_cap_id_next_ctrl_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
}

__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_RSVDP_27_MASK    ((uint32_t)0xF8000000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_RSVDP_27_LSB    27
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_RSVDP_27_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_EN_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_EN_POS    26
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_CAP_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_CAP_POS    25
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_PVM_SUPPORT_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_PVM_SUPPORT_POS    24
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_64_BIT_ADDR_CAP_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_64_BIT_ADDR_CAP_POS    23
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_EN_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_EN_LSB    20
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_EN_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_CAP_MASK    ((uint32_t)0x000E0000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_CAP_LSB    17
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_CAP_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_ENABLE_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_ENABLE_POS    16
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_NEXT_OFFSET_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_NEXT_OFFSET_LSB    8
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_NEXT_OFFSET_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_ID_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_ID_LSB    0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_ID_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_RSVDP_27_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_EN_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_EXT_DATA_CAP_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_PVM_SUPPORT_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_64_BIT_ADDR_CAP_RST    0x1
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_EN_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_MULTIPLE_MSG_CAP_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_ENABLE_RST    0x0
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_NEXT_OFFSET_RST    0x70
#define PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_PCI_MSI_CAP_ID_RST    0x5

__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pack(uint8_t rsvdp_27, uint8_t pci_msi_ext_data_en, uint8_t pci_msi_ext_data_cap, uint8_t pci_pvm_support, uint8_t pci_msi_64_bit_addr_cap, uint8_t pci_msi_multiple_msg_en, uint8_t pci_msi_multiple_msg_cap, uint8_t pci_msi_enable, uint8_t pci_msi_cap_next_offset, uint8_t pci_msi_cap_id)
{
	ASSERT_ERR((((uint32_t)rsvdp_27 << 27) & ~((uint32_t)0xF8000000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_ext_data_en << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_ext_data_cap << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)pci_pvm_support << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_64_bit_addr_cap << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_multiple_msg_en << 20) & ~((uint32_t)0x00700000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_multiple_msg_cap << 17) & ~((uint32_t)0x000E0000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_enable << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_cap_next_offset << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_cap_id << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR,  ((uint32_t)rsvdp_27 << 27) |((uint32_t)pci_msi_ext_data_en << 26) |((uint32_t)pci_msi_ext_data_cap << 25) |((uint32_t)pci_pvm_support << 24) |((uint32_t)pci_msi_64_bit_addr_cap << 23) |((uint32_t)pci_msi_multiple_msg_en << 20) |((uint32_t)pci_msi_multiple_msg_cap << 17) |((uint32_t)pci_msi_enable << 16) |((uint32_t)pci_msi_cap_next_offset << 8) |((uint32_t)pci_msi_cap_id << 0));
}

__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_unpack(uint8_t* rsvdp_27, uint8_t* pci_msi_ext_data_en, uint8_t* pci_msi_ext_data_cap, uint8_t* pci_pvm_support, uint8_t* pci_msi_64_bit_addr_cap, uint8_t* pci_msi_multiple_msg_en, uint8_t* pci_msi_multiple_msg_cap, uint8_t* pci_msi_enable, uint8_t* pci_msi_cap_next_offset, uint8_t* pci_msi_cap_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);

	*rsvdp_27 = (localVal & ((uint32_t)0xF8000000)) >>  27;
	*pci_msi_ext_data_en = (localVal & ((uint32_t)0x04000000)) >>  26;
	*pci_msi_ext_data_cap = (localVal & ((uint32_t)0x02000000)) >>  25;
	*pci_pvm_support = (localVal & ((uint32_t)0x01000000)) >>  24;
	*pci_msi_64_bit_addr_cap = (localVal & ((uint32_t)0x00800000)) >>  23;
	*pci_msi_multiple_msg_en = (localVal & ((uint32_t)0x00700000)) >>  20;
	*pci_msi_multiple_msg_cap = (localVal & ((uint32_t)0x000E0000)) >>  17;
	*pci_msi_enable = (localVal & ((uint32_t)0x00010000)) >>  16;
	*pci_msi_cap_next_offset = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*pci_msi_cap_id = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_rsvdp_27_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF8000000)) >> 27);
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_ext_data_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_ext_data_en_setf(uint8_t pcimsiextdataen)
{
	ASSERT_ERR((((uint32_t)pcimsiextdataen << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)pcimsiextdataen <<26));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_ext_data_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_ext_data_cap_setf(uint8_t pcimsiextdatacap)
{
	ASSERT_ERR((((uint32_t)pcimsiextdatacap << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)pcimsiextdatacap <<25));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_pvm_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_64_bit_addr_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_64_bit_addr_cap_setf(uint8_t pcimsi64bitaddrcap)
{
	ASSERT_ERR((((uint32_t)pcimsi64bitaddrcap << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)pcimsi64bitaddrcap <<23));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_multiple_msg_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_multiple_msg_en_setf(uint8_t pcimsimultiplemsgen)
{
	ASSERT_ERR((((uint32_t)pcimsimultiplemsgen << 20) & ~((uint32_t)0x00700000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x00700000)) | ((uint32_t)pcimsimultiplemsgen <<20));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_multiple_msg_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000E0000)) >> 17);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_multiple_msg_cap_setf(uint8_t pcimsimultiplemsgcap)
{
	ASSERT_ERR((((uint32_t)pcimsimultiplemsgcap << 17) & ~((uint32_t)0x000E0000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x000E0000)) | ((uint32_t)pcimsimultiplemsgcap <<17));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_enable_setf(uint8_t pcimsienable)
{
	ASSERT_ERR((((uint32_t)pcimsienable << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)pcimsienable <<16));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_cap_next_offset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_cap_next_offset_setf(uint8_t pcimsicapnextoffset)
{
	ASSERT_ERR((((uint32_t)pcimsicapnextoffset << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR, (REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)pcimsicapnextoffset <<8));
}
__INLINE uint8_t pcie_ep_pci_msi_cap_id_next_ctrl_reg_pci_msi_cap_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCI_MSI_CAP_ID_NEXT_CTRL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief MSI_CAP_OFF_04_H_REG register definition
 *  This register holds the system specified message address for an MSI transaction. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 PCI_MSI_CAP_OFF_04_H      0x0
 *    01:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000054)
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_OFFSET      0x00000054
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_INDEX       0x00000015
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_msi_cap_off_04_h_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR);
}

__INLINE void pcie_ep_msi_cap_off_04_h_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_PCI_MSI_CAP_OFF_04_H_MASK    ((uint32_t)0xFFFFFFFC)
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_PCI_MSI_CAP_OFF_04_H_LSB    2
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_PCI_MSI_CAP_OFF_04_H_WIDTH    ((uint32_t)0x0000001E)
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_RSVDP_0_MASK    ((uint32_t)0x00000003)
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_RSVDP_0_LSB    0
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_RSVDP_0_WIDTH    ((uint32_t)0x00000002)

#define PCIE_EP_MSI_CAP_OFF_04_H_REG_PCI_MSI_CAP_OFF_04_H_RST    0x0
#define PCIE_EP_MSI_CAP_OFF_04_H_REG_RSVDP_0_RST    0x0

__INLINE void pcie_ep_msi_cap_off_04_h_reg_pack(uint32_t pci_msi_cap_off_04_h, uint8_t rsvdp_0)
{
	ASSERT_ERR((((uint32_t)pci_msi_cap_off_04_h << 2) & ~((uint32_t)0xFFFFFFFC)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_0 << 0) & ~((uint32_t)0x00000003)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR,  ((uint32_t)pci_msi_cap_off_04_h << 2) |((uint32_t)rsvdp_0 << 0));
}

__INLINE void pcie_ep_msi_cap_off_04_h_reg_unpack(uint32_t* pci_msi_cap_off_04_h, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR);

	*pci_msi_cap_off_04_h = (localVal & ((uint32_t)0xFFFFFFFC)) >>  2;
	*rsvdp_0 = (localVal & ((uint32_t)0x00000003)) >>  0;
}

__INLINE uint32_t pcie_ep_msi_cap_off_04_h_reg_pci_msi_cap_off_04_h_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFC)) >> 2);
}
__INLINE void pcie_ep_msi_cap_off_04_h_reg_pci_msi_cap_off_04_h_setf(uint32_t pcimsicapoff04h)
{
	ASSERT_ERR((((uint32_t)pcimsicapoff04h << 2) & ~((uint32_t)0xFFFFFFFC)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR, (REG_PL_RD(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR) & ~((uint32_t)0xFFFFFFFC)) | ((uint32_t)pcimsicapoff04h <<2));
}
__INLINE uint8_t pcie_ep_msi_cap_off_04_h_reg_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_04_H_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000003)) >> 0);
}

/**
 * @brief MSI_CAP_OFF_08_H_REG register definition
 *  For a function that supports a 32-bit message address,  - bits[31:16] of this register represent the Extended Message Data, and  - bits[15:0] of this register represent the Message Data For a function that supports a 64-bit message address (bit 23 in PCI_MSI_CAP_ID_NEXT_CTRL_REG register set), this register represents the Message Upper Address Register for MSI (Offset 08h). It specifies the Message Upper Address (System-specified message upper address). This register is required for PCI Express Endpoints and is optional for other function types. If the Message Enable bit (bit 0 of the Message Control register) is set, the contents of this register (if non-zero) specify the upper 32-bits of a 64-bit message address (Address[63:32]). If the contents of this register are zero, the Function uses the 32 bit address specified by the Message Address register.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 PCI_MSI_CAP_OFF_0_AH      0x0
 *    15:00 PCI_MSI_CAP_OFF_08_H      0x0
 * </pre>
 */
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000058)
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_OFFSET      0x00000058
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_INDEX       0x00000016
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_msi_cap_off_08_h_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR);
}

__INLINE void pcie_ep_msi_cap_off_08_h_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_0_AH_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_0_AH_LSB    16
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_0_AH_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_08_H_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_08_H_LSB    0
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_08_H_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_0_AH_RST    0x0
#define PCIE_EP_MSI_CAP_OFF_08_H_REG_PCI_MSI_CAP_OFF_08_H_RST    0x0

__INLINE void pcie_ep_msi_cap_off_08_h_reg_pack(uint16_t pci_msi_cap_off_0_ah, uint16_t pci_msi_cap_off_08_h)
{
	ASSERT_ERR((((uint32_t)pci_msi_cap_off_0_ah << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_cap_off_08_h << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR,  ((uint32_t)pci_msi_cap_off_0_ah << 16) |((uint32_t)pci_msi_cap_off_08_h << 0));
}

__INLINE void pcie_ep_msi_cap_off_08_h_reg_unpack(uint16_t* pci_msi_cap_off_0_ah, uint16_t* pci_msi_cap_off_08_h)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR);

	*pci_msi_cap_off_0_ah = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*pci_msi_cap_off_08_h = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_msi_cap_off_08_h_reg_pci_msi_cap_off_0_ah_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_msi_cap_off_08_h_reg_pci_msi_cap_off_0_ah_setf(uint16_t pcimsicapoff0ah)
{
	ASSERT_ERR((((uint32_t)pcimsicapoff0ah << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR, (REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)pcimsicapoff0ah <<16));
}
__INLINE uint16_t pcie_ep_msi_cap_off_08_h_reg_pci_msi_cap_off_08_h_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_msi_cap_off_08_h_reg_pci_msi_cap_off_08_h_setf(uint16_t pcimsicapoff08h)
{
	ASSERT_ERR((((uint32_t)pcimsicapoff08h << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR, (REG_PL_RD(PCIE_EP_MSI_CAP_OFF_08_H_REG_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)pcimsicapoff08h <<0));
}

/**
 * @brief MSI_CAP_OFF_0_CH_REG register definition
 *  For a function that supports a 32-bit message address, this register contains the Mask Bits when the Per-Vector Masking Capable bit (bit 24 of PCI_MSI_CAP_ID_NEXT_CTRL_REG) is set.  For a function that supports a 64-bit message address, this register contains Message Data.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 PCI_MSI_CAP_OFF_0_EH      0x0
 *    15:00 PCI_MSI_CAP_OFF_0_CH      0x0
 * </pre>
 */
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000005C)
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_OFFSET      0x0000005C
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_INDEX       0x00000017
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_msi_cap_off_0_ch_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR);
}

__INLINE void pcie_ep_msi_cap_off_0_ch_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_EH_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_EH_LSB    16
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_EH_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_CH_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_CH_LSB    0
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_CH_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_EH_RST    0x0
#define PCIE_EP_MSI_CAP_OFF_0_CH_REG_PCI_MSI_CAP_OFF_0_CH_RST    0x0

__INLINE void pcie_ep_msi_cap_off_0_ch_reg_pack(uint16_t pci_msi_cap_off_0_eh, uint16_t pci_msi_cap_off_0_ch)
{
	ASSERT_ERR((((uint32_t)pci_msi_cap_off_0_eh << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)pci_msi_cap_off_0_ch << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR,  ((uint32_t)pci_msi_cap_off_0_eh << 16) |((uint32_t)pci_msi_cap_off_0_ch << 0));
}

__INLINE void pcie_ep_msi_cap_off_0_ch_reg_unpack(uint16_t* pci_msi_cap_off_0_eh, uint16_t* pci_msi_cap_off_0_ch)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR);

	*pci_msi_cap_off_0_eh = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*pci_msi_cap_off_0_ch = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_msi_cap_off_0_ch_reg_pci_msi_cap_off_0_eh_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_msi_cap_off_0_ch_reg_pci_msi_cap_off_0_eh_setf(uint16_t pcimsicapoff0eh)
{
	ASSERT_ERR((((uint32_t)pcimsicapoff0eh << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR, (REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)pcimsicapoff0eh <<16));
}
__INLINE uint16_t pcie_ep_msi_cap_off_0_ch_reg_pci_msi_cap_off_0_ch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_msi_cap_off_0_ch_reg_pci_msi_cap_off_0_ch_setf(uint16_t pcimsicapoff0ch)
{
	ASSERT_ERR((((uint32_t)pcimsicapoff0ch << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR, (REG_PL_RD(PCIE_EP_MSI_CAP_OFF_0_CH_REG_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)pcimsicapoff0ch <<0));
}

/**
 * @brief PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG register definition
 *  This is the PCI Express Capabilities, ID, and Next Pointer Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RSVDP_31                  0              
 *    30    RSVD                      0              
 *    29:25 PCIE_INT_MSG_NUM          0x0
 *    24    PCIE_SLOT_IMP             0              
 *    23:20 PCIE_DEV_PORT_TYPE        0x0
 *    19:16 PCIE_CAP_REG              0x2
 *    15:08 PCIE_CAP_NEXT_PTR         0x0
 *    07:00 PCIE_CAP_ID               0x10
 * </pre>
 */
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000070)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_OFFSET      0x00000070
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_INDEX       0x0000001C
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RESET       0x00020010

__INLINE uint32_t  pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
}

__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVDP_31_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVDP_31_POS    31
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVD_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVD_POS    30
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_INT_MSG_NUM_MASK    ((uint32_t)0x3E000000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_INT_MSG_NUM_LSB    25
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_INT_MSG_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_SLOT_IMP_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_SLOT_IMP_POS    24
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_DEV_PORT_TYPE_MASK    ((uint32_t)0x00F00000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_DEV_PORT_TYPE_LSB    20
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_DEV_PORT_TYPE_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_REG_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_REG_LSB    16
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_REG_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_NEXT_PTR_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_NEXT_PTR_LSB    8
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_NEXT_PTR_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_ID_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_ID_LSB    0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_ID_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVDP_31_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_RSVD_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_INT_MSG_NUM_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_SLOT_IMP_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_DEV_PORT_TYPE_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_REG_RST    0x2
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_NEXT_PTR_RST    0x0
#define PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_PCIE_CAP_ID_RST    0x10

__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pack(uint8_t rsvdp_31, uint8_t rsvd, uint8_t pcie_int_msg_num, uint8_t pcie_slot_imp, uint8_t pcie_dev_port_type, uint8_t pcie_cap_reg, uint8_t pcie_cap_next_ptr, uint8_t pcie_cap_id)
{
	ASSERT_ERR((((uint32_t)rsvdp_31 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvd << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_int_msg_num << 25) & ~((uint32_t)0x3E000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_slot_imp << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_dev_port_type << 20) & ~((uint32_t)0x00F00000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_reg << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_next_ptr << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_id << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR,  ((uint32_t)rsvdp_31 << 31) |((uint32_t)rsvd << 30) |((uint32_t)pcie_int_msg_num << 25) |((uint32_t)pcie_slot_imp << 24) |((uint32_t)pcie_dev_port_type << 20) |((uint32_t)pcie_cap_reg << 16) |((uint32_t)pcie_cap_next_ptr << 8) |((uint32_t)pcie_cap_id << 0));
}

__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_unpack(uint8_t* rsvdp_31, uint8_t* rsvd, uint8_t* pcie_int_msg_num, uint8_t* pcie_slot_imp, uint8_t* pcie_dev_port_type, uint8_t* pcie_cap_reg, uint8_t* pcie_cap_next_ptr, uint8_t* pcie_cap_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);

	*rsvdp_31 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvd = (localVal & ((uint32_t)0x40000000)) >>  30;
	*pcie_int_msg_num = (localVal & ((uint32_t)0x3E000000)) >>  25;
	*pcie_slot_imp = (localVal & ((uint32_t)0x01000000)) >>  24;
	*pcie_dev_port_type = (localVal & ((uint32_t)0x00F00000)) >>  20;
	*pcie_cap_reg = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*pcie_cap_next_ptr = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*pcie_cap_id = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_rsvdp_31_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_rsvd_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_int_msg_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x3E000000)) >> 25);
}
__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_int_msg_num_setf(uint8_t pcieintmsgnum)
{
	ASSERT_ERR((((uint32_t)pcieintmsgnum << 25) & ~((uint32_t)0x3E000000)) == 0);
	REG_PL_WR(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR, (REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR) & ~((uint32_t)0x3E000000)) | ((uint32_t)pcieintmsgnum <<25));
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_slot_imp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_slot_imp_setf(uint8_t pcieslotimp)
{
	ASSERT_ERR((((uint32_t)pcieslotimp << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR, (REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)pcieslotimp <<24));
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_dev_port_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_cap_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_cap_next_ptr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_cap_next_ptr_setf(uint8_t pciecapnextptr)
{
	ASSERT_ERR((((uint32_t)pciecapnextptr << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR, (REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)pciecapnextptr <<8));
}
__INLINE uint8_t pcie_ep_pcie_cap_id_pcie_next_cap_ptr_pcie_cap_reg_pcie_cap_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief DEVICE_CAPABILITIES_REG register definition
 *  The Device Capabilities register identifies PCI Express device function specific capabilities. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:29 RSVDP_29                  0x0
 *    28    PCIE_CAP_FLR_CAP          0              
 *    27:26 PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE 0x0
 *    25:18 PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE 0x0
 *    17:16 RSVDP_16                  0x0
 *    15    PCIE_CAP_ROLE_BASED_ERR_REPORT 1              
 *    14:12 RSVDP_12                  0x0
 *    11:09 PCIE_CAP_EP_L1_ACCPT_LATENCY 0x7
 *    08:06 PCIE_CAP_EP_L0_S_ACCPT_LATENCY 0x7
 *    05    PCIE_CAP_EXT_TAG_SUPP     1              
 *    04:03 PCIE_CAP_PHANTOM_FUNC_SUPPORT 0x0
 *    02:00 PCIE_CAP_MAX_PAYLOAD_SIZE 0x2
 * </pre>
 */
#define PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000074)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_OFFSET      0x00000074
#define PCIE_EP_DEVICE_CAPABILITIES_REG_INDEX       0x0000001D
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RESET       0x00008FE2

__INLINE uint32_t  pcie_ep_device_capabilities_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
}

__INLINE void pcie_ep_device_capabilities_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_29_MASK    ((uint32_t)0xE0000000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_29_LSB    29
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_29_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_FLR_CAP_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_FLR_CAP_POS    28
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE_LSB    26
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE_MASK    ((uint32_t)0x03FC0000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE_LSB    18
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_16_MASK    ((uint32_t)0x00030000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_16_LSB    16
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_16_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_ROLE_BASED_ERR_REPORT_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_ROLE_BASED_ERR_REPORT_POS    15
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_12_MASK    ((uint32_t)0x00007000)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_12_LSB    12
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_12_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_1_ACCPT_LATENCY_MASK    ((uint32_t)0x00000E00)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_1_ACCPT_LATENCY_LSB    9
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_1_ACCPT_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_0_S_ACCPT_LATENCY_MASK    ((uint32_t)0x000001C0)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_0_S_ACCPT_LATENCY_LSB    6
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_0_S_ACCPT_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EXT_TAG_SUPP_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EXT_TAG_SUPP_POS    5
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_PHANTOM_FUNC_SUPPORT_MASK    ((uint32_t)0x00000018)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_PHANTOM_FUNC_SUPPORT_LSB    3
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_PHANTOM_FUNC_SUPPORT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_MAX_PAYLOAD_SIZE_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_MAX_PAYLOAD_SIZE_LSB    0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_MAX_PAYLOAD_SIZE_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_29_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_FLR_CAP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_SCALE_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_CAP_SLOT_PWR_LMT_VALUE_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_16_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_ROLE_BASED_ERR_REPORT_RST    0x1
#define PCIE_EP_DEVICE_CAPABILITIES_REG_RSVDP_12_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_1_ACCPT_LATENCY_RST    0x7
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EP_L_0_S_ACCPT_LATENCY_RST    0x7
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_EXT_TAG_SUPP_RST    0x1
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_PHANTOM_FUNC_SUPPORT_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_REG_PCIE_CAP_MAX_PAYLOAD_SIZE_RST    0x2

__INLINE void pcie_ep_device_capabilities_reg_pack(uint8_t rsvdp_29, uint8_t pcie_cap_flr_cap, uint8_t pcie_cap_cap_slot_pwr_lmt_scale, uint8_t pcie_cap_cap_slot_pwr_lmt_value, uint8_t rsvdp_16, uint8_t pcie_cap_role_based_err_report, uint8_t rsvdp_12, uint8_t pcie_cap_ep_l1_accpt_latency, uint8_t pcie_cap_ep_l0_s_accpt_latency, uint8_t pcie_cap_ext_tag_supp, uint8_t pcie_cap_phantom_func_support, uint8_t pcie_cap_max_payload_size)
{
	ASSERT_ERR((((uint32_t)rsvdp_29 << 29) & ~((uint32_t)0xE0000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_flr_cap << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_cap_slot_pwr_lmt_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_cap_slot_pwr_lmt_value << 18) & ~((uint32_t)0x03FC0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0x00030000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_role_based_err_report << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0x00007000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_ep_l1_accpt_latency << 9) & ~((uint32_t)0x00000E00)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_ep_l0_s_accpt_latency << 6) & ~((uint32_t)0x000001C0)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_ext_tag_supp << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_phantom_func_support << 3) & ~((uint32_t)0x00000018)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_max_payload_size << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR,  ((uint32_t)rsvdp_29 << 29) |((uint32_t)pcie_cap_flr_cap << 28) |((uint32_t)pcie_cap_cap_slot_pwr_lmt_scale << 26) |((uint32_t)pcie_cap_cap_slot_pwr_lmt_value << 18) |((uint32_t)rsvdp_16 << 16) |((uint32_t)pcie_cap_role_based_err_report << 15) |((uint32_t)rsvdp_12 << 12) |((uint32_t)pcie_cap_ep_l1_accpt_latency << 9) |((uint32_t)pcie_cap_ep_l0_s_accpt_latency << 6) |((uint32_t)pcie_cap_ext_tag_supp << 5) |((uint32_t)pcie_cap_phantom_func_support << 3) |((uint32_t)pcie_cap_max_payload_size << 0));
}

__INLINE void pcie_ep_device_capabilities_reg_unpack(uint8_t* rsvdp_29, uint8_t* pcie_cap_flr_cap, uint8_t* pcie_cap_cap_slot_pwr_lmt_scale, uint8_t* pcie_cap_cap_slot_pwr_lmt_value, uint8_t* rsvdp_16, uint8_t* pcie_cap_role_based_err_report, uint8_t* rsvdp_12, uint8_t* pcie_cap_ep_l1_accpt_latency, uint8_t* pcie_cap_ep_l0_s_accpt_latency, uint8_t* pcie_cap_ext_tag_supp, uint8_t* pcie_cap_phantom_func_support, uint8_t* pcie_cap_max_payload_size)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);

	*rsvdp_29 = (localVal & ((uint32_t)0xE0000000)) >>  29;
	*pcie_cap_flr_cap = (localVal & ((uint32_t)0x10000000)) >>  28;
	*pcie_cap_cap_slot_pwr_lmt_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*pcie_cap_cap_slot_pwr_lmt_value = (localVal & ((uint32_t)0x03FC0000)) >>  18;
	*rsvdp_16 = (localVal & ((uint32_t)0x00030000)) >>  16;
	*pcie_cap_role_based_err_report = (localVal & ((uint32_t)0x00008000)) >>  15;
	*rsvdp_12 = (localVal & ((uint32_t)0x00007000)) >>  12;
	*pcie_cap_ep_l1_accpt_latency = (localVal & ((uint32_t)0x00000E00)) >>  9;
	*pcie_cap_ep_l0_s_accpt_latency = (localVal & ((uint32_t)0x000001C0)) >>  6;
	*pcie_cap_ext_tag_supp = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pcie_cap_phantom_func_support = (localVal & ((uint32_t)0x00000018)) >>  3;
	*pcie_cap_max_payload_size = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint8_t pcie_ep_device_capabilities_reg_rsvdp_29_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xE0000000)) >> 29);
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_flr_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_flr_cap_setf(uint8_t pciecapflrcap)
{
	ASSERT_ERR((((uint32_t)pciecapflrcap << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)pciecapflrcap <<28));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_cap_slot_pwr_lmt_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_cap_slot_pwr_lmt_value_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03FC0000)) >> 18);
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00030000)) >> 16);
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_role_based_err_report_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_role_based_err_report_setf(uint8_t pciecaprolebasederrreport)
{
	ASSERT_ERR((((uint32_t)pciecaprolebasederrreport << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)pciecaprolebasederrreport <<15));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007000)) >> 12);
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_ep_l_1_accpt_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000E00)) >> 9);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_ep_l_1_accpt_latency_setf(uint8_t pciecapepl1accptlatency)
{
	ASSERT_ERR((((uint32_t)pciecapepl1accptlatency << 9) & ~((uint32_t)0x00000E00)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00000E00)) | ((uint32_t)pciecapepl1accptlatency <<9));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_ep_l_0_s_accpt_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000001C0)) >> 6);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_ep_l_0_s_accpt_latency_setf(uint8_t pciecapepl0saccptlatency)
{
	ASSERT_ERR((((uint32_t)pciecapepl0saccptlatency << 6) & ~((uint32_t)0x000001C0)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x000001C0)) | ((uint32_t)pciecapepl0saccptlatency <<6));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_ext_tag_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_ext_tag_supp_setf(uint8_t pciecapexttagsupp)
{
	ASSERT_ERR((((uint32_t)pciecapexttagsupp << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)pciecapexttagsupp <<5));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_phantom_func_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000018)) >> 3);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_phantom_func_support_setf(uint8_t pciecapphantomfuncsupport)
{
	ASSERT_ERR((((uint32_t)pciecapphantomfuncsupport << 3) & ~((uint32_t)0x00000018)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00000018)) | ((uint32_t)pciecapphantomfuncsupport <<3));
}
__INLINE uint8_t pcie_ep_device_capabilities_reg_pcie_cap_max_payload_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE void pcie_ep_device_capabilities_reg_pcie_cap_max_payload_size_setf(uint8_t pciecapmaxpayloadsize)
{
	ASSERT_ERR((((uint32_t)pciecapmaxpayloadsize << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00000007)) | ((uint32_t)pciecapmaxpayloadsize <<0));
}

/**
 * @brief DEVICE_CONTROL_DEVICE_STATUS register definition
 *  This register controls PCI Express device specific parameters and provides information about PCI Express device (function) specific parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:23 RSVDP_23                  0x0
 *    21    PCIE_CAP_TRANS_PENDING    0              
 *    20    PCIE_CAP_AUX_POWER_DETECTED 1              
 *    19    PCIE_CAP_UNSUPPORTED_REQ_DETECTED 0              
 *    18    PCIE_CAP_FATAL_ERR_DETECTED 0              
 *    17    PCIE_CAP_NON_FATAL_ERR_DETECTED 0              
 *    16    PCIE_CAP_CORR_ERR_DETECTED 0              
 *    14:12 PCIE_CAP_MAX_READ_REQ_SIZE 0x2
 *    11    PCIE_CAP_EN_NO_SNOOP      0              
 *    10    PCIE_CAP_AUX_POWER_PM_EN  0              
 *    09    PCIE_CAP_PHANTOM_FUNC_EN  0              
 *    08    PCIE_CAP_EXT_TAG_EN       1              
 *    07:05 PCIE_CAP_MAX_PAYLOAD_SIZE_CS 0x0
 *    04    PCIE_CAP_EN_REL_ORDER     1              
 *    03    PCIE_CAP_UNSUPPORT_REQ_REP_EN 0              
 *    02    PCIE_CAP_FATAL_ERR_REPORT_EN 0              
 *    01    PCIE_CAP_NON_FATAL_ERR_REPORT_EN 0              
 *    00    PCIE_CAP_CORR_ERR_REPORT_EN 0              
 * </pre>
 */
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000078)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_OFFSET      0x00000078
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_INDEX       0x0000001E
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_RESET       0x00102110

__INLINE uint32_t  pcie_ep_device_control_device_status_get(void)
{
	return REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
}

__INLINE void pcie_ep_device_control_device_status_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, value);
}

// field definitions
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_RSVDP_23_MASK    ((uint32_t)0xFF800000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_RSVDP_23_LSB    23
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_RSVDP_23_WIDTH    ((uint32_t)0x00000009)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_TRANS_PENDING_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_TRANS_PENDING_POS    21
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_DETECTED_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_DETECTED_POS    20
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_POS    19
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_DETECTED_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_DETECTED_POS    18
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_DETECTED_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_DETECTED_POS    17
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_DETECTED_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_DETECTED_POS    16
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_READ_REQ_SIZE_MASK    ((uint32_t)0x00007000)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_READ_REQ_SIZE_LSB    12
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_READ_REQ_SIZE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_NO_SNOOP_BIT    ((uint32_t)0x00000800)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_NO_SNOOP_POS    11
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_PM_EN_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_PM_EN_POS    10
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_PHANTOM_FUNC_EN_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_PHANTOM_FUNC_EN_POS    9
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EXT_TAG_EN_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EXT_TAG_EN_POS    8
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_MASK    ((uint32_t)0x000000E0)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_LSB    5
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_REL_ORDER_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_REL_ORDER_POS    4
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORT_REQ_REP_EN_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORT_REQ_REP_EN_POS    3
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_REPORT_EN_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_REPORT_EN_POS    2
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_REPORT_EN_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_REPORT_EN_POS    1
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_REPORT_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_REPORT_EN_POS    0

#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_RSVDP_23_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_TRANS_PENDING_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_DETECTED_RST    0x1
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORTED_REQ_DETECTED_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_DETECTED_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_DETECTED_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_DETECTED_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_READ_REQ_SIZE_RST    0x2
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_NO_SNOOP_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_AUX_POWER_PM_EN_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_PHANTOM_FUNC_EN_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EXT_TAG_EN_RST    0x1
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_MAX_PAYLOAD_SIZE_CS_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_EN_REL_ORDER_RST    0x1
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_UNSUPPORT_REQ_REP_EN_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_FATAL_ERR_REPORT_EN_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_NON_FATAL_ERR_REPORT_EN_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_PCIE_CAP_CORR_ERR_REPORT_EN_RST    0x0

__INLINE void pcie_ep_device_control_device_status_pack(uint16_t rsvdp_23, uint8_t pcie_cap_trans_pending, uint8_t pcie_cap_aux_power_detected, uint8_t pcie_cap_unsupported_req_detected, uint8_t pcie_cap_fatal_err_detected, uint8_t pcie_cap_non_fatal_err_detected, uint8_t pcie_cap_corr_err_detected, uint8_t pcie_cap_max_read_req_size, uint8_t pcie_cap_en_no_snoop, uint8_t pcie_cap_aux_power_pm_en, uint8_t pcie_cap_phantom_func_en, uint8_t pcie_cap_ext_tag_en, uint8_t pcie_cap_max_payload_size_cs, uint8_t pcie_cap_en_rel_order, uint8_t pcie_cap_unsupport_req_rep_en, uint8_t pcie_cap_fatal_err_report_en, uint8_t pcie_cap_non_fatal_err_report_en, uint8_t pcie_cap_corr_err_report_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0xFF800000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_trans_pending << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_aux_power_detected << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_unsupported_req_detected << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_fatal_err_detected << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_non_fatal_err_detected << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_corr_err_detected << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_max_read_req_size << 12) & ~((uint32_t)0x00007000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_en_no_snoop << 11) & ~((uint32_t)0x00000800)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_aux_power_pm_en << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_phantom_func_en << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_ext_tag_en << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_max_payload_size_cs << 5) & ~((uint32_t)0x000000E0)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_en_rel_order << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_unsupport_req_rep_en << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_fatal_err_report_en << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_non_fatal_err_report_en << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_corr_err_report_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR,  ((uint32_t)rsvdp_23 << 23) |((uint32_t)pcie_cap_trans_pending << 21) |((uint32_t)pcie_cap_aux_power_detected << 20) |((uint32_t)pcie_cap_unsupported_req_detected << 19) |((uint32_t)pcie_cap_fatal_err_detected << 18) |((uint32_t)pcie_cap_non_fatal_err_detected << 17) |((uint32_t)pcie_cap_corr_err_detected << 16) |((uint32_t)pcie_cap_max_read_req_size << 12) |((uint32_t)pcie_cap_en_no_snoop << 11) |((uint32_t)pcie_cap_aux_power_pm_en << 10) |((uint32_t)pcie_cap_phantom_func_en << 9) |((uint32_t)pcie_cap_ext_tag_en << 8) |((uint32_t)pcie_cap_max_payload_size_cs << 5) |((uint32_t)pcie_cap_en_rel_order << 4) |((uint32_t)pcie_cap_unsupport_req_rep_en << 3) |((uint32_t)pcie_cap_fatal_err_report_en << 2) |((uint32_t)pcie_cap_non_fatal_err_report_en << 1) |((uint32_t)pcie_cap_corr_err_report_en << 0));
}

__INLINE void pcie_ep_device_control_device_status_unpack(uint16_t* rsvdp_23, uint8_t* pcie_cap_trans_pending, uint8_t* pcie_cap_aux_power_detected, uint8_t* pcie_cap_unsupported_req_detected, uint8_t* pcie_cap_fatal_err_detected, uint8_t* pcie_cap_non_fatal_err_detected, uint8_t* pcie_cap_corr_err_detected, uint8_t* pcie_cap_max_read_req_size, uint8_t* pcie_cap_en_no_snoop, uint8_t* pcie_cap_aux_power_pm_en, uint8_t* pcie_cap_phantom_func_en, uint8_t* pcie_cap_ext_tag_en, uint8_t* pcie_cap_max_payload_size_cs, uint8_t* pcie_cap_en_rel_order, uint8_t* pcie_cap_unsupport_req_rep_en, uint8_t* pcie_cap_fatal_err_report_en, uint8_t* pcie_cap_non_fatal_err_report_en, uint8_t* pcie_cap_corr_err_report_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);

	*rsvdp_23 = (localVal & ((uint32_t)0xFF800000)) >>  23;
	*pcie_cap_trans_pending = (localVal & ((uint32_t)0x00200000)) >>  21;
	*pcie_cap_aux_power_detected = (localVal & ((uint32_t)0x00100000)) >>  20;
	*pcie_cap_unsupported_req_detected = (localVal & ((uint32_t)0x00080000)) >>  19;
	*pcie_cap_fatal_err_detected = (localVal & ((uint32_t)0x00040000)) >>  18;
	*pcie_cap_non_fatal_err_detected = (localVal & ((uint32_t)0x00020000)) >>  17;
	*pcie_cap_corr_err_detected = (localVal & ((uint32_t)0x00010000)) >>  16;
	*pcie_cap_max_read_req_size = (localVal & ((uint32_t)0x00007000)) >>  12;
	*pcie_cap_en_no_snoop = (localVal & ((uint32_t)0x00000800)) >>  11;
	*pcie_cap_aux_power_pm_en = (localVal & ((uint32_t)0x00000400)) >>  10;
	*pcie_cap_phantom_func_en = (localVal & ((uint32_t)0x00000200)) >>  9;
	*pcie_cap_ext_tag_en = (localVal & ((uint32_t)0x00000100)) >>  8;
	*pcie_cap_max_payload_size_cs = (localVal & ((uint32_t)0x000000E0)) >>  5;
	*pcie_cap_en_rel_order = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pcie_cap_unsupport_req_rep_en = (localVal & ((uint32_t)0x00000008)) >>  3;
	*pcie_cap_fatal_err_report_en = (localVal & ((uint32_t)0x00000004)) >>  2;
	*pcie_cap_non_fatal_err_report_en = (localVal & ((uint32_t)0x00000002)) >>  1;
	*pcie_cap_corr_err_report_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_device_control_device_status_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFF800000)) >> 23);
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_trans_pending_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_aux_power_detected_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_unsupported_req_detected_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_unsupported_req_detected_setf(uint8_t pciecapunsupportedreqdetected)
{
	ASSERT_ERR((((uint32_t)pciecapunsupportedreqdetected << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)pciecapunsupportedreqdetected <<19));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_fatal_err_detected_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_fatal_err_detected_setf(uint8_t pciecapfatalerrdetected)
{
	ASSERT_ERR((((uint32_t)pciecapfatalerrdetected << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)pciecapfatalerrdetected <<18));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_non_fatal_err_detected_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_non_fatal_err_detected_setf(uint8_t pciecapnonfatalerrdetected)
{
	ASSERT_ERR((((uint32_t)pciecapnonfatalerrdetected << 17) & ~((uint32_t)0x00020000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)pciecapnonfatalerrdetected <<17));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_corr_err_detected_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_corr_err_detected_setf(uint8_t pciecapcorrerrdetected)
{
	ASSERT_ERR((((uint32_t)pciecapcorrerrdetected << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)pciecapcorrerrdetected <<16));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_max_read_req_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007000)) >> 12);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_max_read_req_size_setf(uint8_t pciecapmaxreadreqsize)
{
	ASSERT_ERR((((uint32_t)pciecapmaxreadreqsize << 12) & ~((uint32_t)0x00007000)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00007000)) | ((uint32_t)pciecapmaxreadreqsize <<12));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_en_no_snoop_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_aux_power_pm_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_aux_power_pm_en_setf(uint8_t pciecapauxpowerpmen)
{
	ASSERT_ERR((((uint32_t)pciecapauxpowerpmen << 10) & ~((uint32_t)0x00000400)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)pciecapauxpowerpmen <<10));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_phantom_func_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_ext_tag_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_ext_tag_en_setf(uint8_t pciecapexttagen)
{
	ASSERT_ERR((((uint32_t)pciecapexttagen << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)pciecapexttagen <<8));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_max_payload_size_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000E0)) >> 5);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_max_payload_size_cs_setf(uint8_t pciecapmaxpayloadsizecs)
{
	ASSERT_ERR((((uint32_t)pciecapmaxpayloadsizecs << 5) & ~((uint32_t)0x000000E0)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x000000E0)) | ((uint32_t)pciecapmaxpayloadsizecs <<5));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_en_rel_order_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_en_rel_order_setf(uint8_t pciecapenrelorder)
{
	ASSERT_ERR((((uint32_t)pciecapenrelorder << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)pciecapenrelorder <<4));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_unsupport_req_rep_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_unsupport_req_rep_en_setf(uint8_t pciecapunsupportreqrepen)
{
	ASSERT_ERR((((uint32_t)pciecapunsupportreqrepen << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)pciecapunsupportreqrepen <<3));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_fatal_err_report_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_fatal_err_report_en_setf(uint8_t pciecapfatalerrreporten)
{
	ASSERT_ERR((((uint32_t)pciecapfatalerrreporten << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)pciecapfatalerrreporten <<2));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_non_fatal_err_report_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_non_fatal_err_report_en_setf(uint8_t pciecapnonfatalerrreporten)
{
	ASSERT_ERR((((uint32_t)pciecapnonfatalerrreporten << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)pciecapnonfatalerrreporten <<1));
}
__INLINE uint8_t pcie_ep_device_control_device_status_pcie_cap_corr_err_report_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_device_control_device_status_pcie_cap_corr_err_report_en_setf(uint8_t pciecapcorrerrreporten)
{
	ASSERT_ERR((((uint32_t)pciecapcorrerrreporten << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_DEVICE_STATUS_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pciecapcorrerrreporten <<0));
}

/**
 * @brief LINK_CAPABILITIES_REG register definition
 *  The Link Capabilities register identifies PCI Express Link specific capabilities and CXL-RCRB link specific capabilities. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 PCIE_CAP_PORT_NUM         0x0
 *    23    RSVDP_23                  0              
 *    22    PCIE_CAP_ASPM_OPT_COMPLIANCE 1              
 *    21    PCIE_CAP_LINK_BW_NOT_CAP  0              
 *    20    PCIE_CAP_DLL_ACTIVE_REP_CAP 0              
 *    19    PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP 0              
 *    18    PCIE_CAP_CLOCK_POWER_MAN  0              
 *    17:15 PCIE_CAP_L1_EXIT_LATENCY  0x6
 *    14:12 PCIE_CAP_L0_S_EXIT_LATENCY 0x3
 *    11:10 PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT 0x3
 *    09:04 PCIE_CAP_MAX_LINK_WIDTH   0x1
 *    03:00 PCIE_CAP_MAX_LINK_SPEED   0x2
 * </pre>
 */
#define PCIE_EP_LINK_CAPABILITIES_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000007C)
#define PCIE_EP_LINK_CAPABILITIES_REG_OFFSET      0x0000007C
#define PCIE_EP_LINK_CAPABILITIES_REG_INDEX       0x0000001F
#define PCIE_EP_LINK_CAPABILITIES_REG_RESET       0x00433C12

__INLINE uint32_t  pcie_ep_link_capabilities_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
}

__INLINE void pcie_ep_link_capabilities_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_PORT_NUM_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_PORT_NUM_LSB    24
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_PORT_NUM_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_LINK_CAPABILITIES_REG_RSVDP_23_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_LINK_CAPABILITIES_REG_RSVDP_23_POS    23
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ASPM_OPT_COMPLIANCE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ASPM_OPT_COMPLIANCE_POS    22
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_LINK_BW_NOT_CAP_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_LINK_BW_NOT_CAP_POS    21
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_DLL_ACTIVE_REP_CAP_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_DLL_ACTIVE_REP_CAP_POS    20
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_POS    19
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_CLOCK_POWER_MAN_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_CLOCK_POWER_MAN_POS    18
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_1_EXIT_LATENCY_MASK    ((uint32_t)0x00038000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_1_EXIT_LATENCY_LSB    15
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_1_EXIT_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_0_S_EXIT_LATENCY_MASK    ((uint32_t)0x00007000)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_0_S_EXIT_LATENCY_LSB    12
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_0_S_EXIT_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_LSB    10
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_WIDTH_MASK    ((uint32_t)0x000003F0)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_WIDTH_LSB    4
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_WIDTH_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_SPEED_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_SPEED_LSB    0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_SPEED_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_PORT_NUM_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_RSVDP_23_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ASPM_OPT_COMPLIANCE_RST    0x1
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_LINK_BW_NOT_CAP_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_DLL_ACTIVE_REP_CAP_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_CLOCK_POWER_MAN_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_1_EXIT_LATENCY_RST    0x6
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_L_0_S_EXIT_LATENCY_RST    0x3
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT_RST    0x3
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_WIDTH_RST    0x1
#define PCIE_EP_LINK_CAPABILITIES_REG_PCIE_CAP_MAX_LINK_SPEED_RST    0x2

__INLINE void pcie_ep_link_capabilities_reg_pack(uint8_t pcie_cap_port_num, uint8_t rsvdp_23, uint8_t pcie_cap_aspm_opt_compliance, uint8_t pcie_cap_link_bw_not_cap, uint8_t pcie_cap_dll_active_rep_cap, uint8_t pcie_cap_surprise_down_err_rep_cap, uint8_t pcie_cap_clock_power_man, uint8_t pcie_cap_l1_exit_latency, uint8_t pcie_cap_l0_s_exit_latency, uint8_t pcie_cap_active_state_link_pm_support, uint8_t pcie_cap_max_link_width, uint8_t pcie_cap_max_link_speed)
{
	ASSERT_ERR((((uint32_t)pcie_cap_port_num << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_aspm_opt_compliance << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_bw_not_cap << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_dll_active_rep_cap << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_surprise_down_err_rep_cap << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_clock_power_man << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_l1_exit_latency << 15) & ~((uint32_t)0x00038000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_l0_s_exit_latency << 12) & ~((uint32_t)0x00007000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_active_state_link_pm_support << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_max_link_width << 4) & ~((uint32_t)0x000003F0)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_max_link_speed << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR,  ((uint32_t)pcie_cap_port_num << 24) |((uint32_t)rsvdp_23 << 23) |((uint32_t)pcie_cap_aspm_opt_compliance << 22) |((uint32_t)pcie_cap_link_bw_not_cap << 21) |((uint32_t)pcie_cap_dll_active_rep_cap << 20) |((uint32_t)pcie_cap_surprise_down_err_rep_cap << 19) |((uint32_t)pcie_cap_clock_power_man << 18) |((uint32_t)pcie_cap_l1_exit_latency << 15) |((uint32_t)pcie_cap_l0_s_exit_latency << 12) |((uint32_t)pcie_cap_active_state_link_pm_support << 10) |((uint32_t)pcie_cap_max_link_width << 4) |((uint32_t)pcie_cap_max_link_speed << 0));
}

__INLINE void pcie_ep_link_capabilities_reg_unpack(uint8_t* pcie_cap_port_num, uint8_t* rsvdp_23, uint8_t* pcie_cap_aspm_opt_compliance, uint8_t* pcie_cap_link_bw_not_cap, uint8_t* pcie_cap_dll_active_rep_cap, uint8_t* pcie_cap_surprise_down_err_rep_cap, uint8_t* pcie_cap_clock_power_man, uint8_t* pcie_cap_l1_exit_latency, uint8_t* pcie_cap_l0_s_exit_latency, uint8_t* pcie_cap_active_state_link_pm_support, uint8_t* pcie_cap_max_link_width, uint8_t* pcie_cap_max_link_speed)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);

	*pcie_cap_port_num = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_23 = (localVal & ((uint32_t)0x00800000)) >>  23;
	*pcie_cap_aspm_opt_compliance = (localVal & ((uint32_t)0x00400000)) >>  22;
	*pcie_cap_link_bw_not_cap = (localVal & ((uint32_t)0x00200000)) >>  21;
	*pcie_cap_dll_active_rep_cap = (localVal & ((uint32_t)0x00100000)) >>  20;
	*pcie_cap_surprise_down_err_rep_cap = (localVal & ((uint32_t)0x00080000)) >>  19;
	*pcie_cap_clock_power_man = (localVal & ((uint32_t)0x00040000)) >>  18;
	*pcie_cap_l1_exit_latency = (localVal & ((uint32_t)0x00038000)) >>  15;
	*pcie_cap_l0_s_exit_latency = (localVal & ((uint32_t)0x00007000)) >>  12;
	*pcie_cap_active_state_link_pm_support = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*pcie_cap_max_link_width = (localVal & ((uint32_t)0x000003F0)) >>  4;
	*pcie_cap_max_link_speed = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_port_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_port_num_setf(uint8_t pciecapportnum)
{
	ASSERT_ERR((((uint32_t)pciecapportnum << 24) & ~((uint32_t)0xFF000000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0xFF000000)) | ((uint32_t)pciecapportnum <<24));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_aspm_opt_compliance_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_aspm_opt_compliance_setf(uint8_t pciecapaspmoptcompliance)
{
	ASSERT_ERR((((uint32_t)pciecapaspmoptcompliance << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)pciecapaspmoptcompliance <<22));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_link_bw_not_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_dll_active_rep_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_surprise_down_err_rep_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_clock_power_man_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_clock_power_man_setf(uint8_t pciecapclockpowerman)
{
	ASSERT_ERR((((uint32_t)pciecapclockpowerman << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)pciecapclockpowerman <<18));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_l_1_exit_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00038000)) >> 15);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_l_1_exit_latency_setf(uint8_t pciecapl1exitlatency)
{
	ASSERT_ERR((((uint32_t)pciecapl1exitlatency << 15) & ~((uint32_t)0x00038000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00038000)) | ((uint32_t)pciecapl1exitlatency <<15));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_l_0_s_exit_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007000)) >> 12);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_l_0_s_exit_latency_setf(uint8_t pciecapl0sexitlatency)
{
	ASSERT_ERR((((uint32_t)pciecapl0sexitlatency << 12) & ~((uint32_t)0x00007000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00007000)) | ((uint32_t)pciecapl0sexitlatency <<12));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_active_state_link_pm_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_active_state_link_pm_support_setf(uint8_t pciecapactivestatelinkpmsupport)
{
	ASSERT_ERR((((uint32_t)pciecapactivestatelinkpmsupport << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)pciecapactivestatelinkpmsupport <<10));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_max_link_width_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003F0)) >> 4);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_max_link_width_setf(uint8_t pciecapmaxlinkwidth)
{
	ASSERT_ERR((((uint32_t)pciecapmaxlinkwidth << 4) & ~((uint32_t)0x000003F0)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x000003F0)) | ((uint32_t)pciecapmaxlinkwidth <<4));
}
__INLINE uint8_t pcie_ep_link_capabilities_reg_pcie_cap_max_link_speed_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void pcie_ep_link_capabilities_reg_pcie_cap_max_link_speed_setf(uint8_t pciecapmaxlinkspeed)
{
	ASSERT_ERR((((uint32_t)pciecapmaxlinkspeed << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CAPABILITIES_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_REG_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)pciecapmaxlinkspeed <<0));
}

/**
 * @brief LINK_CONTROL_LINK_STATUS_REG register definition
 *  This register controls and provides information about PCI Express Link specific parameters as well as RCRB link associated parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    PCIE_CAP_LINK_AUTO_BW_STATUS 0              
 *    30    PCIE_CAP_LINK_BW_MAN_STATUS 0              
 *    29    PCIE_CAP_DLL_ACTIVE       0              
 *    28    PCIE_CAP_SLOT_CLK_CONFIG  1              
 *    27    PCIE_CAP_LINK_TRAINING    0              
 *    26    RSVDP_26                  0              
 *    25:20 PCIE_CAP_NEGO_LINK_WIDTH  0x1
 *    19:16 PCIE_CAP_LINK_SPEED       0x1
 *    15:14 PCIE_CAP_DRS_SIGNALING_CONTROL 0x0
 *    13:12 RSVDP_12                  0x0
 *    11    PCIE_CAP_LINK_AUTO_BW_INT_EN 0              
 *    10    PCIE_CAP_LINK_BW_MAN_INT_EN 0              
 *    09    PCIE_CAP_HW_AUTO_WIDTH_DISABLE 0              
 *    08    PCIE_CAP_EN_CLK_POWER_MAN 0              
 *    07    PCIE_CAP_EXTENDED_SYNCH   0              
 *    06    PCIE_CAP_COMMON_CLK_CONFIG 0              
 *    05    PCIE_CAP_RETRAIN_LINK     0              
 *    04    PCIE_CAP_LINK_DISABLE     0              
 *    03    PCIE_CAP_RCB              0              
 *    02    RSVDP_2                   0              
 *    01:00 PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL 0x0
 * </pre>
 */
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000080)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_OFFSET      0x00000080
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_INDEX       0x00000020
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RESET       0x10110000

__INLINE uint32_t  pcie_ep_link_control_link_status_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
}

__INLINE void pcie_ep_link_control_link_status_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_STATUS_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_STATUS_POS    31
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_STATUS_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_STATUS_POS    30
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DLL_ACTIVE_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DLL_ACTIVE_POS    29
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_SLOT_CLK_CONFIG_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_SLOT_CLK_CONFIG_POS    28
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_TRAINING_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_TRAINING_POS    27
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_26_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_26_POS    26
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_NEGO_LINK_WIDTH_MASK    ((uint32_t)0x03F00000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_NEGO_LINK_WIDTH_LSB    20
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_NEGO_LINK_WIDTH_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_SPEED_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_SPEED_LSB    16
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_SPEED_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DRS_SIGNALING_CONTROL_MASK    ((uint32_t)0x0000C000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DRS_SIGNALING_CONTROL_LSB    14
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DRS_SIGNALING_CONTROL_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_12_MASK    ((uint32_t)0x00003000)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_12_LSB    12
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_12_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_INT_EN_BIT    ((uint32_t)0x00000800)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_INT_EN_POS    11
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_INT_EN_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_INT_EN_POS    10
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_HW_AUTO_WIDTH_DISABLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_HW_AUTO_WIDTH_DISABLE_POS    9
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EN_CLK_POWER_MAN_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EN_CLK_POWER_MAN_POS    8
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EXTENDED_SYNCH_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EXTENDED_SYNCH_POS    7
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_COMMON_CLK_CONFIG_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_COMMON_CLK_CONFIG_POS    6
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RETRAIN_LINK_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RETRAIN_LINK_POS    5
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_DISABLE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_DISABLE_POS    4
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RCB_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RCB_POS    3
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_2_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_2_POS    2
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL_MASK    ((uint32_t)0x00000003)
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL_LSB    0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL_WIDTH    ((uint32_t)0x00000002)

#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_STATUS_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_STATUS_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DLL_ACTIVE_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_SLOT_CLK_CONFIG_RST    0x1
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_TRAINING_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_26_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_NEGO_LINK_WIDTH_RST    0x1
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_SPEED_RST    0x1
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_DRS_SIGNALING_CONTROL_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_12_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_AUTO_BW_INT_EN_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_BW_MAN_INT_EN_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_HW_AUTO_WIDTH_DISABLE_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EN_CLK_POWER_MAN_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_EXTENDED_SYNCH_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_COMMON_CLK_CONFIG_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RETRAIN_LINK_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_LINK_DISABLE_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_RCB_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_RSVDP_2_RST    0x0
#define PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL_RST    0x0

__INLINE void pcie_ep_link_control_link_status_reg_pack(uint8_t pcie_cap_link_auto_bw_status, uint8_t pcie_cap_link_bw_man_status, uint8_t pcie_cap_dll_active, uint8_t pcie_cap_slot_clk_config, uint8_t pcie_cap_link_training, uint8_t rsvdp_26, uint8_t pcie_cap_nego_link_width, uint8_t pcie_cap_link_speed, uint8_t pcie_cap_drs_signaling_control, uint8_t rsvdp_12, uint8_t pcie_cap_link_auto_bw_int_en, uint8_t pcie_cap_link_bw_man_int_en, uint8_t pcie_cap_hw_auto_width_disable, uint8_t pcie_cap_en_clk_power_man, uint8_t pcie_cap_extended_synch, uint8_t pcie_cap_common_clk_config, uint8_t pcie_cap_retrain_link, uint8_t pcie_cap_link_disable, uint8_t pcie_cap_rcb, uint8_t rsvdp_2, uint8_t pcie_cap_active_state_link_pm_control)
{
	ASSERT_ERR((((uint32_t)pcie_cap_link_auto_bw_status << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_bw_man_status << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_dll_active << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_slot_clk_config << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_training << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_26 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_nego_link_width << 20) & ~((uint32_t)0x03F00000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_speed << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_drs_signaling_control << 14) & ~((uint32_t)0x0000C000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0x00003000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_auto_bw_int_en << 11) & ~((uint32_t)0x00000800)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_bw_man_int_en << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_hw_auto_width_disable << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_en_clk_power_man << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_extended_synch << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_common_clk_config << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_retrain_link << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_link_disable << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_rcb << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_2 << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_active_state_link_pm_control << 0) & ~((uint32_t)0x00000003)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR,  ((uint32_t)pcie_cap_link_auto_bw_status << 31) |((uint32_t)pcie_cap_link_bw_man_status << 30) |((uint32_t)pcie_cap_dll_active << 29) |((uint32_t)pcie_cap_slot_clk_config << 28) |((uint32_t)pcie_cap_link_training << 27) |((uint32_t)rsvdp_26 << 26) |((uint32_t)pcie_cap_nego_link_width << 20) |((uint32_t)pcie_cap_link_speed << 16) |((uint32_t)pcie_cap_drs_signaling_control << 14) |((uint32_t)rsvdp_12 << 12) |((uint32_t)pcie_cap_link_auto_bw_int_en << 11) |((uint32_t)pcie_cap_link_bw_man_int_en << 10) |((uint32_t)pcie_cap_hw_auto_width_disable << 9) |((uint32_t)pcie_cap_en_clk_power_man << 8) |((uint32_t)pcie_cap_extended_synch << 7) |((uint32_t)pcie_cap_common_clk_config << 6) |((uint32_t)pcie_cap_retrain_link << 5) |((uint32_t)pcie_cap_link_disable << 4) |((uint32_t)pcie_cap_rcb << 3) |((uint32_t)rsvdp_2 << 2) |((uint32_t)pcie_cap_active_state_link_pm_control << 0));
}

__INLINE void pcie_ep_link_control_link_status_reg_unpack(uint8_t* pcie_cap_link_auto_bw_status, uint8_t* pcie_cap_link_bw_man_status, uint8_t* pcie_cap_dll_active, uint8_t* pcie_cap_slot_clk_config, uint8_t* pcie_cap_link_training, uint8_t* rsvdp_26, uint8_t* pcie_cap_nego_link_width, uint8_t* pcie_cap_link_speed, uint8_t* pcie_cap_drs_signaling_control, uint8_t* rsvdp_12, uint8_t* pcie_cap_link_auto_bw_int_en, uint8_t* pcie_cap_link_bw_man_int_en, uint8_t* pcie_cap_hw_auto_width_disable, uint8_t* pcie_cap_en_clk_power_man, uint8_t* pcie_cap_extended_synch, uint8_t* pcie_cap_common_clk_config, uint8_t* pcie_cap_retrain_link, uint8_t* pcie_cap_link_disable, uint8_t* pcie_cap_rcb, uint8_t* rsvdp_2, uint8_t* pcie_cap_active_state_link_pm_control)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);

	*pcie_cap_link_auto_bw_status = (localVal & ((uint32_t)0x80000000)) >>  31;
	*pcie_cap_link_bw_man_status = (localVal & ((uint32_t)0x40000000)) >>  30;
	*pcie_cap_dll_active = (localVal & ((uint32_t)0x20000000)) >>  29;
	*pcie_cap_slot_clk_config = (localVal & ((uint32_t)0x10000000)) >>  28;
	*pcie_cap_link_training = (localVal & ((uint32_t)0x08000000)) >>  27;
	*rsvdp_26 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*pcie_cap_nego_link_width = (localVal & ((uint32_t)0x03F00000)) >>  20;
	*pcie_cap_link_speed = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*pcie_cap_drs_signaling_control = (localVal & ((uint32_t)0x0000C000)) >>  14;
	*rsvdp_12 = (localVal & ((uint32_t)0x00003000)) >>  12;
	*pcie_cap_link_auto_bw_int_en = (localVal & ((uint32_t)0x00000800)) >>  11;
	*pcie_cap_link_bw_man_int_en = (localVal & ((uint32_t)0x00000400)) >>  10;
	*pcie_cap_hw_auto_width_disable = (localVal & ((uint32_t)0x00000200)) >>  9;
	*pcie_cap_en_clk_power_man = (localVal & ((uint32_t)0x00000100)) >>  8;
	*pcie_cap_extended_synch = (localVal & ((uint32_t)0x00000080)) >>  7;
	*pcie_cap_common_clk_config = (localVal & ((uint32_t)0x00000040)) >>  6;
	*pcie_cap_retrain_link = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pcie_cap_link_disable = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pcie_cap_rcb = (localVal & ((uint32_t)0x00000008)) >>  3;
	*rsvdp_2 = (localVal & ((uint32_t)0x00000004)) >>  2;
	*pcie_cap_active_state_link_pm_control = (localVal & ((uint32_t)0x00000003)) >>  0;
}

__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_auto_bw_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_bw_man_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_dll_active_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_slot_clk_config_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_slot_clk_config_setf(uint8_t pciecapslotclkconfig)
{
	ASSERT_ERR((((uint32_t)pciecapslotclkconfig << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)pciecapslotclkconfig <<28));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_training_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_rsvdp_26_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_nego_link_width_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03F00000)) >> 20);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_speed_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_drs_signaling_control_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000C000)) >> 14);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00003000)) >> 12);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_auto_bw_int_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_link_auto_bw_int_en_setf(uint8_t pciecaplinkautobwinten)
{
	ASSERT_ERR((((uint32_t)pciecaplinkautobwinten << 11) & ~((uint32_t)0x00000800)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)pciecaplinkautobwinten <<11));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_bw_man_int_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_link_bw_man_int_en_setf(uint8_t pciecaplinkbwmaninten)
{
	ASSERT_ERR((((uint32_t)pciecaplinkbwmaninten << 10) & ~((uint32_t)0x00000400)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)pciecaplinkbwmaninten <<10));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_hw_auto_width_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_hw_auto_width_disable_setf(uint8_t pciecaphwautowidthdisable)
{
	ASSERT_ERR((((uint32_t)pciecaphwautowidthdisable << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)pciecaphwautowidthdisable <<9));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_en_clk_power_man_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_en_clk_power_man_setf(uint8_t pciecapenclkpowerman)
{
	ASSERT_ERR((((uint32_t)pciecapenclkpowerman << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)pciecapenclkpowerman <<8));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_extended_synch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_extended_synch_setf(uint8_t pciecapextendedsynch)
{
	ASSERT_ERR((((uint32_t)pciecapextendedsynch << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)pciecapextendedsynch <<7));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_common_clk_config_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_common_clk_config_setf(uint8_t pciecapcommonclkconfig)
{
	ASSERT_ERR((((uint32_t)pciecapcommonclkconfig << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)pciecapcommonclkconfig <<6));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_retrain_link_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_retrain_link_setf(uint8_t pciecapretrainlink)
{
	ASSERT_ERR((((uint32_t)pciecapretrainlink << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)pciecapretrainlink <<5));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_link_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_link_disable_setf(uint8_t pciecaplinkdisable)
{
	ASSERT_ERR((((uint32_t)pciecaplinkdisable << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)pciecaplinkdisable <<4));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_rcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_rcb_setf(uint8_t pciecaprcb)
{
	ASSERT_ERR((((uint32_t)pciecaprcb << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)pciecaprcb <<3));
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_rsvdp_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE uint8_t pcie_ep_link_control_link_status_reg_pcie_cap_active_state_link_pm_control_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000003)) >> 0);
}
__INLINE void pcie_ep_link_control_link_status_reg_pcie_cap_active_state_link_pm_control_setf(uint8_t pciecapactivestatelinkpmcontrol)
{
	ASSERT_ERR((((uint32_t)pciecapactivestatelinkpmcontrol << 0) & ~((uint32_t)0x00000003)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_LINK_STATUS_REG_ADDR) & ~((uint32_t)0x00000003)) | ((uint32_t)pciecapactivestatelinkpmcontrol <<0));
}

/**
 * @brief DEVICE_CAPABILITIES_2_REG register definition
 *  This register identifies PCI Express device specific capabilities; in addition to the Device Capabilities Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:29 PCIE_CAP_DMWR_LEN_SUPP    0x0
 *    28    PCIE_CAP_DMWR_CPL_SUPP    0              
 *    27    RSVDP_27                  0              
 *    17    PCIE_CAP2_10_BIT_TAG_REQ_SUPPORT 0              
 *    16    PCIE_CAP2_10_BIT_TAG_COMP_SUPPORT 0              
 *    15:14 PCIE_CAP2_LN_SYS_CLS      0x0
 *    13    PCIE_CAP_TPH_CMPLT_SUPPORT_1 0              
 *    12    PCIE_CAP_TPH_CMPLT_SUPPORT_0 0              
 *    10    PCIE_CAP_NO_RO_EN_PR2_PR_PAR 0              
 *    09    PCIE_CAP_128_CAS_CPL_SUPP 0              
 *    08    PCIE_CAP_64_ATOMIC_CPL_SUPP 0              
 *    07    PCIE_CAP_32_ATOMIC_CPL_SUPP 0              
 *    06    PCIE_CAP_ATOMIC_ROUTING_SUPP 0              
 *    05    PCIE_CAP_ARI_FORWARD_SUPPORT 0              
 *    04    PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT 1              
 *    03:00 PCIE_CAP_CPL_TIMEOUT_RANGE 0x0
 * </pre>
 */
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000094)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_OFFSET      0x00000094
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_INDEX       0x00000025
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_RESET       0x00000010

__INLINE uint32_t  pcie_ep_device_capabilities_2_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
}

// field definitions
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_LEN_SUPP_MASK    ((uint32_t)0x60000000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_LEN_SUPP_LSB    29
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_LEN_SUPP_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_CPL_SUPP_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_CPL_SUPP_POS    28
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_RSVDP_27_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_RSVDP_27_POS    27
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_REQ_SUPPORT_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_REQ_SUPPORT_POS    17
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_COMP_SUPPORT_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_COMP_SUPPORT_POS    16
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_LN_SYS_CLS_MASK    ((uint32_t)0x0000C000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_LN_SYS_CLS_LSB    14
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_LN_SYS_CLS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_1_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_1_POS    13
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_0_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_0_POS    12
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_NO_RO_EN_PR_2_PR_PAR_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_NO_RO_EN_PR_2_PR_PAR_POS    10
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_128_CAS_CPL_SUPP_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_128_CAS_CPL_SUPP_POS    9
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_64_ATOMIC_CPL_SUPP_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_64_ATOMIC_CPL_SUPP_POS    8
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_32_ATOMIC_CPL_SUPP_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_32_ATOMIC_CPL_SUPP_POS    7
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ATOMIC_ROUTING_SUPP_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ATOMIC_ROUTING_SUPP_POS    6
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_POS    5
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT_POS    4
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_RANGE_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_RANGE_LSB    0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_RANGE_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_LEN_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_DMWR_CPL_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_RSVDP_27_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_REQ_SUPPORT_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_10_BIT_TAG_COMP_SUPPORT_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_2_LN_SYS_CLS_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_1_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_TPH_CMPLT_SUPPORT_0_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_NO_RO_EN_PR_2_PR_PAR_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_128_CAS_CPL_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_64_ATOMIC_CPL_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_32_ATOMIC_CPL_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ATOMIC_ROUTING_SUPP_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_RST    0x0
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT_RST    0x1
#define PCIE_EP_DEVICE_CAPABILITIES_2_REG_PCIE_CAP_CPL_TIMEOUT_RANGE_RST    0x0

__INLINE void pcie_ep_device_capabilities_2_reg_unpack(uint8_t* pcie_cap_dmwr_len_supp, uint8_t* pcie_cap_dmwr_cpl_supp, uint8_t* rsvdp_27, uint8_t* pcie_cap2_10_bit_tag_req_support, uint8_t* pcie_cap2_10_bit_tag_comp_support, uint8_t* pcie_cap2_ln_sys_cls, uint8_t* pcie_cap_tph_cmplt_support_1, uint8_t* pcie_cap_tph_cmplt_support_0, uint8_t* pcie_cap_no_ro_en_pr2_pr_par, uint8_t* pcie_cap_128_cas_cpl_supp, uint8_t* pcie_cap_64_atomic_cpl_supp, uint8_t* pcie_cap_32_atomic_cpl_supp, uint8_t* pcie_cap_atomic_routing_supp, uint8_t* pcie_cap_ari_forward_support, uint8_t* pcie_cap_cpl_timeout_disable_support, uint8_t* pcie_cap_cpl_timeout_range)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);

	*pcie_cap_dmwr_len_supp = (localVal & ((uint32_t)0x60000000)) >>  29;
	*pcie_cap_dmwr_cpl_supp = (localVal & ((uint32_t)0x10000000)) >>  28;
	*rsvdp_27 = (localVal & ((uint32_t)0x08000000)) >>  27;
	*pcie_cap2_10_bit_tag_req_support = (localVal & ((uint32_t)0x00020000)) >>  17;
	*pcie_cap2_10_bit_tag_comp_support = (localVal & ((uint32_t)0x00010000)) >>  16;
	*pcie_cap2_ln_sys_cls = (localVal & ((uint32_t)0x0000C000)) >>  14;
	*pcie_cap_tph_cmplt_support_1 = (localVal & ((uint32_t)0x00002000)) >>  13;
	*pcie_cap_tph_cmplt_support_0 = (localVal & ((uint32_t)0x00001000)) >>  12;
	*pcie_cap_no_ro_en_pr2_pr_par = (localVal & ((uint32_t)0x00000400)) >>  10;
	*pcie_cap_128_cas_cpl_supp = (localVal & ((uint32_t)0x00000200)) >>  9;
	*pcie_cap_64_atomic_cpl_supp = (localVal & ((uint32_t)0x00000100)) >>  8;
	*pcie_cap_32_atomic_cpl_supp = (localVal & ((uint32_t)0x00000080)) >>  7;
	*pcie_cap_atomic_routing_supp = (localVal & ((uint32_t)0x00000040)) >>  6;
	*pcie_cap_ari_forward_support = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pcie_cap_cpl_timeout_disable_support = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pcie_cap_cpl_timeout_range = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_dmwr_len_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x60000000)) >> 29);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_dmwr_cpl_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_rsvdp_27_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_2_10_bit_tag_req_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_2_10_bit_tag_comp_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_2_ln_sys_cls_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000C000)) >> 14);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_tph_cmplt_support_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_tph_cmplt_support_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_no_ro_en_pr_2_pr_par_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_128_cas_cpl_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_64_atomic_cpl_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_32_atomic_cpl_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_atomic_routing_supp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_ari_forward_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_cpl_timeout_disable_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE uint8_t pcie_ep_device_capabilities_2_reg_pcie_cap_cpl_timeout_range_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief DEVICE_CONTROL_2_DEVICE_STATUS_2_REG register definition
 *  This register controls PCI Express device specific parameters and provides information about PCI Express device (function) specific parameters; in addition to the Device Control and Device Status Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    05    PCIE_CAP_ARI_FORWARD_SUPPORT_CS 0              
 *    04    PCIE_CAP_CPL_TIMEOUT_DISABLE 0              
 *    03:00 PCIE_CAP_CPL_TIMEOUT_VALUE 0x0
 * </pre>
 */
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000098)
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_OFFSET      0x00000098
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_INDEX       0x00000026
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_device_control_2_device_status_2_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR);
}

__INLINE void pcie_ep_device_control_2_device_status_2_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_POS    5
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_POS    4
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_VALUE_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_VALUE_LSB    0
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_VALUE_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_ARI_FORWARD_SUPPORT_CS_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_DISABLE_RST    0x0
#define PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_PCIE_CAP_CPL_TIMEOUT_VALUE_RST    0x0

__INLINE void pcie_ep_device_control_2_device_status_2_reg_pack(uint8_t pcie_cap_ari_forward_support_cs, uint8_t pcie_cap_cpl_timeout_disable, uint8_t pcie_cap_cpl_timeout_value)
{
	ASSERT_ERR((((uint32_t)pcie_cap_ari_forward_support_cs << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_cpl_timeout_disable << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_cpl_timeout_value << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR,  ((uint32_t)pcie_cap_ari_forward_support_cs << 5) |((uint32_t)pcie_cap_cpl_timeout_disable << 4) |((uint32_t)pcie_cap_cpl_timeout_value << 0));
}

__INLINE void pcie_ep_device_control_2_device_status_2_reg_unpack(uint8_t* pcie_cap_ari_forward_support_cs, uint8_t* pcie_cap_cpl_timeout_disable, uint8_t* pcie_cap_cpl_timeout_value)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR);

	*pcie_cap_ari_forward_support_cs = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pcie_cap_cpl_timeout_disable = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pcie_cap_cpl_timeout_value = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_device_control_2_device_status_2_reg_pcie_cap_ari_forward_support_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_device_control_2_device_status_2_reg_pcie_cap_cpl_timeout_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_device_control_2_device_status_2_reg_pcie_cap_cpl_timeout_disable_setf(uint8_t pciecapcpltimeoutdisable)
{
	ASSERT_ERR((((uint32_t)pciecapcpltimeoutdisable << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)pciecapcpltimeoutdisable <<4));
}
__INLINE uint8_t pcie_ep_device_control_2_device_status_2_reg_pcie_cap_cpl_timeout_value_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DEVICE_CONTROL_2_DEVICE_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief LINK_CAPABILITIES_2_REG register definition
 *  This register identifies PCI Express Link specific capabilities and CXL-RCRB link specific capabilities; in addition to the Link Capabilities Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:25 RSVDP_25                  0x0
 *    22:09 RSVDP_9                   0x0
 *    08    PCIE_CAP_CROSS_LINK_SUPPORT 0              
 *    07:01 PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR 0x3
 *    00    RSVDP_0                   0              
 * </pre>
 */
#define PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000009C)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_OFFSET      0x0000009C
#define PCIE_EP_LINK_CAPABILITIES_2_REG_INDEX       0x00000027
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RESET       0x00000006

__INLINE uint32_t  pcie_ep_link_capabilities_2_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
}

// field definitions
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_25_MASK    ((uint32_t)0x7E000000)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_25_LSB    25
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_25_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_9_MASK    ((uint32_t)0x007FFE00)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_9_LSB    9
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_9_WIDTH    ((uint32_t)0x0000000E)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_CROSS_LINK_SUPPORT_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_CROSS_LINK_SUPPORT_POS    8
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_MASK    ((uint32_t)0x000000FE)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_LSB    1
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_0_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_0_POS    0

#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_25_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_9_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_CROSS_LINK_SUPPORT_RST    0x0
#define PCIE_EP_LINK_CAPABILITIES_2_REG_PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR_RST    0x3
#define PCIE_EP_LINK_CAPABILITIES_2_REG_RSVDP_0_RST    0x0

__INLINE void pcie_ep_link_capabilities_2_reg_unpack(uint8_t* rsvdp_25, uint16_t* rsvdp_9, uint8_t* pcie_cap_cross_link_support, uint8_t* pcie_cap_support_link_speed_vector, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);

	*rsvdp_25 = (localVal & ((uint32_t)0x7E000000)) >>  25;
	*rsvdp_9 = (localVal & ((uint32_t)0x007FFE00)) >>  9;
	*pcie_cap_cross_link_support = (localVal & ((uint32_t)0x00000100)) >>  8;
	*pcie_cap_support_link_speed_vector = (localVal & ((uint32_t)0x000000FE)) >>  1;
	*rsvdp_0 = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_link_capabilities_2_reg_rsvdp_25_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x7E000000)) >> 25);
}
__INLINE uint16_t pcie_ep_link_capabilities_2_reg_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x007FFE00)) >> 9);
}
__INLINE uint8_t pcie_ep_link_capabilities_2_reg_pcie_cap_cross_link_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE uint8_t pcie_ep_link_capabilities_2_reg_pcie_cap_support_link_speed_vector_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FE)) >> 1);
}
__INLINE uint8_t pcie_ep_link_capabilities_2_reg_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CAPABILITIES_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief LINK_CONTROL_2_LINK_STATUS_2_REG register definition
 *  This register controls and provides information about PCI Express Link specific parameters as well as RCRB link associated parameters; in addition to the Link Control and Link Status Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:26 RSVDP_26                  0x0
 *    16    PCIE_CAP_CURR_DEEMPHASIS  1              
 *    15:12 PCIE_CAP_COMPLIANCE_PRESET 0x0
 *    11    PCIE_CAP_COMPLIANCE_SOS   0              
 *    10    PCIE_CAP_ENTER_MODIFIED_COMPLIANCE 0              
 *    09:07 PCIE_CAP_TX_MARGIN        0x0
 *    06    PCIE_CAP_SEL_DEEMPHASIS   0              
 *    05    PCIE_CAP_HW_AUTO_SPEED_DISABLE 0              
 *    04    PCIE_CAP_ENTER_COMPLIANCE 0              
 *    03:00 PCIE_CAP_TARGET_LINK_SPEED 0x2
 * </pre>
 */
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000000A0)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_OFFSET      0x000000A0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_INDEX       0x00000028
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_RESET       0x00010002

__INLINE uint32_t  pcie_ep_link_control_2_link_status_2_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
}

__INLINE void pcie_ep_link_control_2_link_status_2_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_RSVDP_26_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_RSVDP_26_LSB    26
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_RSVDP_26_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_CURR_DEEMPHASIS_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_CURR_DEEMPHASIS_POS    16
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_PRESET_MASK    ((uint32_t)0x0000F000)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_PRESET_LSB    12
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_PRESET_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_SOS_BIT    ((uint32_t)0x00000800)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_SOS_POS    11
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_POS    10
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TX_MARGIN_MASK    ((uint32_t)0x00000380)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TX_MARGIN_LSB    7
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TX_MARGIN_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_SEL_DEEMPHASIS_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_SEL_DEEMPHASIS_POS    6
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_HW_AUTO_SPEED_DISABLE_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_HW_AUTO_SPEED_DISABLE_POS    5
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_COMPLIANCE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_COMPLIANCE_POS    4
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TARGET_LINK_SPEED_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TARGET_LINK_SPEED_LSB    0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TARGET_LINK_SPEED_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_RSVDP_26_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_CURR_DEEMPHASIS_RST    0x1
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_PRESET_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_COMPLIANCE_SOS_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_MODIFIED_COMPLIANCE_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TX_MARGIN_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_SEL_DEEMPHASIS_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_HW_AUTO_SPEED_DISABLE_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_ENTER_COMPLIANCE_RST    0x0
#define PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_PCIE_CAP_TARGET_LINK_SPEED_RST    0x2

__INLINE void pcie_ep_link_control_2_link_status_2_reg_pack(uint8_t rsvdp_26, uint8_t pcie_cap_curr_deemphasis, uint8_t pcie_cap_compliance_preset, uint8_t pcie_cap_compliance_sos, uint8_t pcie_cap_enter_modified_compliance, uint8_t pcie_cap_tx_margin, uint8_t pcie_cap_sel_deemphasis, uint8_t pcie_cap_hw_auto_speed_disable, uint8_t pcie_cap_enter_compliance, uint8_t pcie_cap_target_link_speed)
{
	ASSERT_ERR((((uint32_t)rsvdp_26 << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_curr_deemphasis << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_compliance_preset << 12) & ~((uint32_t)0x0000F000)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_compliance_sos << 11) & ~((uint32_t)0x00000800)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_enter_modified_compliance << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_tx_margin << 7) & ~((uint32_t)0x00000380)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_sel_deemphasis << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_hw_auto_speed_disable << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_enter_compliance << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)pcie_cap_target_link_speed << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR,  ((uint32_t)rsvdp_26 << 26) |((uint32_t)pcie_cap_curr_deemphasis << 16) |((uint32_t)pcie_cap_compliance_preset << 12) |((uint32_t)pcie_cap_compliance_sos << 11) |((uint32_t)pcie_cap_enter_modified_compliance << 10) |((uint32_t)pcie_cap_tx_margin << 7) |((uint32_t)pcie_cap_sel_deemphasis << 6) |((uint32_t)pcie_cap_hw_auto_speed_disable << 5) |((uint32_t)pcie_cap_enter_compliance << 4) |((uint32_t)pcie_cap_target_link_speed << 0));
}

__INLINE void pcie_ep_link_control_2_link_status_2_reg_unpack(uint8_t* rsvdp_26, uint8_t* pcie_cap_curr_deemphasis, uint8_t* pcie_cap_compliance_preset, uint8_t* pcie_cap_compliance_sos, uint8_t* pcie_cap_enter_modified_compliance, uint8_t* pcie_cap_tx_margin, uint8_t* pcie_cap_sel_deemphasis, uint8_t* pcie_cap_hw_auto_speed_disable, uint8_t* pcie_cap_enter_compliance, uint8_t* pcie_cap_target_link_speed)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);

	*rsvdp_26 = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*pcie_cap_curr_deemphasis = (localVal & ((uint32_t)0x00010000)) >>  16;
	*pcie_cap_compliance_preset = (localVal & ((uint32_t)0x0000F000)) >>  12;
	*pcie_cap_compliance_sos = (localVal & ((uint32_t)0x00000800)) >>  11;
	*pcie_cap_enter_modified_compliance = (localVal & ((uint32_t)0x00000400)) >>  10;
	*pcie_cap_tx_margin = (localVal & ((uint32_t)0x00000380)) >>  7;
	*pcie_cap_sel_deemphasis = (localVal & ((uint32_t)0x00000040)) >>  6;
	*pcie_cap_hw_auto_speed_disable = (localVal & ((uint32_t)0x00000020)) >>  5;
	*pcie_cap_enter_compliance = (localVal & ((uint32_t)0x00000010)) >>  4;
	*pcie_cap_target_link_speed = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_rsvdp_26_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_curr_deemphasis_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_compliance_preset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_compliance_preset_setf(uint8_t pciecapcompliancepreset)
{
	ASSERT_ERR((((uint32_t)pciecapcompliancepreset << 12) & ~((uint32_t)0x0000F000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x0000F000)) | ((uint32_t)pciecapcompliancepreset <<12));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_compliance_sos_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000800)) >> 11);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_compliance_sos_setf(uint8_t pciecapcompliancesos)
{
	ASSERT_ERR((((uint32_t)pciecapcompliancesos << 11) & ~((uint32_t)0x00000800)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000800)) | ((uint32_t)pciecapcompliancesos <<11));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_enter_modified_compliance_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_enter_modified_compliance_setf(uint8_t pciecapentermodifiedcompliance)
{
	ASSERT_ERR((((uint32_t)pciecapentermodifiedcompliance << 10) & ~((uint32_t)0x00000400)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)pciecapentermodifiedcompliance <<10));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_tx_margin_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000380)) >> 7);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_tx_margin_setf(uint8_t pciecaptxmargin)
{
	ASSERT_ERR((((uint32_t)pciecaptxmargin << 7) & ~((uint32_t)0x00000380)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000380)) | ((uint32_t)pciecaptxmargin <<7));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_sel_deemphasis_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_hw_auto_speed_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_hw_auto_speed_disable_setf(uint8_t pciecaphwautospeeddisable)
{
	ASSERT_ERR((((uint32_t)pciecaphwautospeeddisable << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)pciecaphwautospeeddisable <<5));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_enter_compliance_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_enter_compliance_setf(uint8_t pciecapentercompliance)
{
	ASSERT_ERR((((uint32_t)pciecapentercompliance << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)pciecapentercompliance <<4));
}
__INLINE uint8_t pcie_ep_link_control_2_link_status_2_reg_pcie_cap_target_link_speed_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void pcie_ep_link_control_2_link_status_2_reg_pcie_cap_target_link_speed_setf(uint8_t pciecaptargetlinkspeed)
{
	ASSERT_ERR((((uint32_t)pciecaptargetlinkspeed << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR, (REG_PL_RD(PCIE_EP_LINK_CONTROL_2_LINK_STATUS_2_REG_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)pciecaptargetlinkspeed <<0));
}

/**
 * @brief AER_EXT_CAP_HDR_OFF register definition
 *  Advanced Error Reporting Extended Capability Header provides information about Capability ID, Version, and next offset. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 NEXT_OFFSET               0x148
 *    19:16 CAP_VERSION               0x2
 *    15:00 CAP_ID                    0x1
 * </pre>
 */
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000100)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_OFFSET      0x00000100
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_INDEX       0x00000040
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_RESET       0x14820001

__INLINE uint32_t  pcie_ep_aer_ext_cap_hdr_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR);
}

__INLINE void pcie_ep_aer_ext_cap_hdr_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_LSB    20
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_VERSION_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_VERSION_LSB    16
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_VERSION_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_ID_LSB    0
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_AER_EXT_CAP_HDR_OFF_NEXT_OFFSET_RST    0x148
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_VERSION_RST    0x2
#define PCIE_EP_AER_EXT_CAP_HDR_OFF_CAP_ID_RST    0x1

__INLINE void pcie_ep_aer_ext_cap_hdr_off_pack(uint16_t next_offset, uint8_t cap_version, uint16_t cap_id)
{
	ASSERT_ERR((((uint32_t)next_offset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)cap_version << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)cap_id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR,  ((uint32_t)next_offset << 20) |((uint32_t)cap_version << 16) |((uint32_t)cap_id << 0));
}

__INLINE void pcie_ep_aer_ext_cap_hdr_off_unpack(uint16_t* next_offset, uint8_t* cap_version, uint16_t* cap_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR);

	*next_offset = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*cap_version = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*cap_id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_aer_ext_cap_hdr_off_next_offset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE void pcie_ep_aer_ext_cap_hdr_off_next_offset_setf(uint16_t nextoffset)
{
	ASSERT_ERR((((uint32_t)nextoffset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	REG_PL_WR(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0xFFF00000)) | ((uint32_t)nextoffset <<20));
}
__INLINE uint8_t pcie_ep_aer_ext_cap_hdr_off_cap_version_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void pcie_ep_aer_ext_cap_hdr_off_cap_version_setf(uint8_t capversion)
{
	ASSERT_ERR((((uint32_t)capversion << 16) & ~((uint32_t)0x000F0000)) == 0);
	REG_PL_WR(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)capversion <<16));
}
__INLINE uint16_t pcie_ep_aer_ext_cap_hdr_off_cap_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_aer_ext_cap_hdr_off_cap_id_setf(uint16_t capid)
{
	ASSERT_ERR((((uint32_t)capid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_AER_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)capid <<0));
}

/**
 * @brief UNCORR_ERR_STATUS_OFF register definition
 *  The Uncorrectable Error Status Register (Offset 04h) indicates error detection status of individual errors on a PCI Express device Function. An individual error status bit that is Set indicates that a particular error was detected; software may clear an error status by writing a 1b to the respective bit. Register bits not implemented by the Function are hardwired to 0b. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RSVDP_28                  0x0
 *    23    RSVDP_23                  0              
 *    22    INTERNAL_ERR_STATUS       0              
 *    20    UNSUPPORTED_REQ_ERR_STATUS 0              
 *    19    ECRC_ERR_STATUS           0              
 *    18    MALF_TLP_ERR_STATUS       0              
 *    17    REC_OVERFLOW_ERR_STATUS   0              
 *    16    UNEXP_CMPLT_ERR_STATUS    0              
 *    15    CMPLT_ABORT_ERR_STATUS    0              
 *    14    CMPLT_TIMEOUT_ERR_STATUS  0              
 *    13    FC_PROTOCOL_ERR_STATUS    0              
 *    12    POIS_TLP_ERR_STATUS       0              
 *    11:06 RSVDP_6                   0x0
 *    05    SURPRISE_DOWN_ERR_STATUS  0              
 *    04    DL_PROTOCOL_ERR_STATUS    0              
 *    03:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000104)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_OFFSET      0x00000104
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_INDEX       0x00000041
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_uncorr_err_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_uncorr_err_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_28_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_28_LSB    28
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_28_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_23_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_23_POS    23
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_INTERNAL_ERR_STATUS_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_INTERNAL_ERR_STATUS_POS    22
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNSUPPORTED_REQ_ERR_STATUS_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNSUPPORTED_REQ_ERR_STATUS_POS    20
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_ECRC_ERR_STATUS_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_ECRC_ERR_STATUS_POS    19
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_MALF_TLP_ERR_STATUS_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_MALF_TLP_ERR_STATUS_POS    18
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_REC_OVERFLOW_ERR_STATUS_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_REC_OVERFLOW_ERR_STATUS_POS    17
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNEXP_CMPLT_ERR_STATUS_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNEXP_CMPLT_ERR_STATUS_POS    16
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_ABORT_ERR_STATUS_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_ABORT_ERR_STATUS_POS    15
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_TIMEOUT_ERR_STATUS_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_TIMEOUT_ERR_STATUS_POS    14
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_FC_PROTOCOL_ERR_STATUS_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_FC_PROTOCOL_ERR_STATUS_POS    13
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_POIS_TLP_ERR_STATUS_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_POIS_TLP_ERR_STATUS_POS    12
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_6_MASK    ((uint32_t)0x00000FC0)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_6_LSB    6
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_6_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_SURPRISE_DOWN_ERR_STATUS_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_SURPRISE_DOWN_ERR_STATUS_POS    5
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_DL_PROTOCOL_ERR_STATUS_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_DL_PROTOCOL_ERR_STATUS_POS    4
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_0_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_0_LSB    0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_0_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_28_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_23_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_INTERNAL_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNSUPPORTED_REQ_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_ECRC_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_MALF_TLP_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_REC_OVERFLOW_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_UNEXP_CMPLT_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_ABORT_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_CMPLT_TIMEOUT_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_FC_PROTOCOL_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_POIS_TLP_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_6_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_SURPRISE_DOWN_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_DL_PROTOCOL_ERR_STATUS_RST    0x0
#define PCIE_EP_UNCORR_ERR_STATUS_OFF_RSVDP_0_RST    0x0

__INLINE void pcie_ep_uncorr_err_status_off_pack(uint8_t rsvdp_28, uint8_t rsvdp_23, uint8_t internal_err_status, uint8_t unsupported_req_err_status, uint8_t ecrc_err_status, uint8_t malf_tlp_err_status, uint8_t rec_overflow_err_status, uint8_t unexp_cmplt_err_status, uint8_t cmplt_abort_err_status, uint8_t cmplt_timeout_err_status, uint8_t fc_protocol_err_status, uint8_t pois_tlp_err_status, uint8_t rsvdp_6, uint8_t surprise_down_err_status, uint8_t dl_protocol_err_status, uint8_t rsvdp_0)
{
	ASSERT_ERR((((uint32_t)rsvdp_28 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)internal_err_status << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)unsupported_req_err_status << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_err_status << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)malf_tlp_err_status << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)rec_overflow_err_status << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)unexp_cmplt_err_status << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_abort_err_status << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_timeout_err_status << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)fc_protocol_err_status << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)pois_tlp_err_status << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_6 << 6) & ~((uint32_t)0x00000FC0)) == 0);
	ASSERT_ERR((((uint32_t)surprise_down_err_status << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)dl_protocol_err_status << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_0 << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR,  ((uint32_t)rsvdp_28 << 28) |((uint32_t)rsvdp_23 << 23) |((uint32_t)internal_err_status << 22) |((uint32_t)unsupported_req_err_status << 20) |((uint32_t)ecrc_err_status << 19) |((uint32_t)malf_tlp_err_status << 18) |((uint32_t)rec_overflow_err_status << 17) |((uint32_t)unexp_cmplt_err_status << 16) |((uint32_t)cmplt_abort_err_status << 15) |((uint32_t)cmplt_timeout_err_status << 14) |((uint32_t)fc_protocol_err_status << 13) |((uint32_t)pois_tlp_err_status << 12) |((uint32_t)rsvdp_6 << 6) |((uint32_t)surprise_down_err_status << 5) |((uint32_t)dl_protocol_err_status << 4) |((uint32_t)rsvdp_0 << 0));
}

__INLINE void pcie_ep_uncorr_err_status_off_unpack(uint8_t* rsvdp_28, uint8_t* rsvdp_23, uint8_t* internal_err_status, uint8_t* unsupported_req_err_status, uint8_t* ecrc_err_status, uint8_t* malf_tlp_err_status, uint8_t* rec_overflow_err_status, uint8_t* unexp_cmplt_err_status, uint8_t* cmplt_abort_err_status, uint8_t* cmplt_timeout_err_status, uint8_t* fc_protocol_err_status, uint8_t* pois_tlp_err_status, uint8_t* rsvdp_6, uint8_t* surprise_down_err_status, uint8_t* dl_protocol_err_status, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);

	*rsvdp_28 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*rsvdp_23 = (localVal & ((uint32_t)0x00800000)) >>  23;
	*internal_err_status = (localVal & ((uint32_t)0x00400000)) >>  22;
	*unsupported_req_err_status = (localVal & ((uint32_t)0x00100000)) >>  20;
	*ecrc_err_status = (localVal & ((uint32_t)0x00080000)) >>  19;
	*malf_tlp_err_status = (localVal & ((uint32_t)0x00040000)) >>  18;
	*rec_overflow_err_status = (localVal & ((uint32_t)0x00020000)) >>  17;
	*unexp_cmplt_err_status = (localVal & ((uint32_t)0x00010000)) >>  16;
	*cmplt_abort_err_status = (localVal & ((uint32_t)0x00008000)) >>  15;
	*cmplt_timeout_err_status = (localVal & ((uint32_t)0x00004000)) >>  14;
	*fc_protocol_err_status = (localVal & ((uint32_t)0x00002000)) >>  13;
	*pois_tlp_err_status = (localVal & ((uint32_t)0x00001000)) >>  12;
	*rsvdp_6 = (localVal & ((uint32_t)0x00000FC0)) >>  6;
	*surprise_down_err_status = (localVal & ((uint32_t)0x00000020)) >>  5;
	*dl_protocol_err_status = (localVal & ((uint32_t)0x00000010)) >>  4;
	*rsvdp_0 = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_uncorr_err_status_off_rsvdp_28_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_internal_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_uncorr_err_status_off_internal_err_status_setf(uint8_t internalerrstatus)
{
	ASSERT_ERR((((uint32_t)internalerrstatus << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)internalerrstatus <<22));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_unsupported_req_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_uncorr_err_status_off_unsupported_req_err_status_setf(uint8_t unsupportedreqerrstatus)
{
	ASSERT_ERR((((uint32_t)unsupportedreqerrstatus << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)unsupportedreqerrstatus <<20));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_ecrc_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_uncorr_err_status_off_ecrc_err_status_setf(uint8_t ecrcerrstatus)
{
	ASSERT_ERR((((uint32_t)ecrcerrstatus << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)ecrcerrstatus <<19));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_malf_tlp_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_uncorr_err_status_off_malf_tlp_err_status_setf(uint8_t malftlperrstatus)
{
	ASSERT_ERR((((uint32_t)malftlperrstatus << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)malftlperrstatus <<18));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_rec_overflow_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_uncorr_err_status_off_rec_overflow_err_status_setf(uint8_t recoverflowerrstatus)
{
	ASSERT_ERR((((uint32_t)recoverflowerrstatus << 17) & ~((uint32_t)0x00020000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)recoverflowerrstatus <<17));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_unexp_cmplt_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_uncorr_err_status_off_unexp_cmplt_err_status_setf(uint8_t unexpcmplterrstatus)
{
	ASSERT_ERR((((uint32_t)unexpcmplterrstatus << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)unexpcmplterrstatus <<16));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_cmplt_abort_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_uncorr_err_status_off_cmplt_abort_err_status_setf(uint8_t cmpltaborterrstatus)
{
	ASSERT_ERR((((uint32_t)cmpltaborterrstatus << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)cmpltaborterrstatus <<15));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_cmplt_timeout_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_uncorr_err_status_off_cmplt_timeout_err_status_setf(uint8_t cmplttimeouterrstatus)
{
	ASSERT_ERR((((uint32_t)cmplttimeouterrstatus << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)cmplttimeouterrstatus <<14));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_fc_protocol_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_uncorr_err_status_off_fc_protocol_err_status_setf(uint8_t fcprotocolerrstatus)
{
	ASSERT_ERR((((uint32_t)fcprotocolerrstatus << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)fcprotocolerrstatus <<13));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_pois_tlp_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void pcie_ep_uncorr_err_status_off_pois_tlp_err_status_setf(uint8_t poistlperrstatus)
{
	ASSERT_ERR((((uint32_t)poistlperrstatus << 12) & ~((uint32_t)0x00001000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)poistlperrstatus <<12));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_rsvdp_6_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000FC0)) >> 6);
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_surprise_down_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_uncorr_err_status_off_surprise_down_err_status_setf(uint8_t surprisedownerrstatus)
{
	ASSERT_ERR((((uint32_t)surprisedownerrstatus << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)surprisedownerrstatus <<5));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_dl_protocol_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_uncorr_err_status_off_dl_protocol_err_status_setf(uint8_t dlprotocolerrstatus)
{
	ASSERT_ERR((((uint32_t)dlprotocolerrstatus << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)dlprotocolerrstatus <<4));
}
__INLINE uint8_t pcie_ep_uncorr_err_status_off_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief UNCORR_ERR_MASK_OFF register definition
 *  The Uncorrectable Error Mask Register controls reporting of individual errors by the device Function to the PCI Express Root Complex through a PCI Express error Message. A masked error (respective bit Set in the mask register) is not recorded or reported in the Header Log, TLP Prefix Log, or First Error Pointer, and is not reported to the PCI Express Root Complex by this Function. There is a mask bit per error bit of the Uncorrectable Error Status register. Register fields for bits not implemented by the Function are hardwired to 0b. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RSVDP_28                  0x0
 *    27    DMWR_EGRESS_BLOCKED_ERR_MASK 0              
 *    26    RSVDP_26                  0              
 *    25    TLP_PRFX_BLOCKED_ERR_MASK 0              
 *    24    ATOMIC_EGRESS_BLOCKED_ERR_MASK 0              
 *    23    RSVDP_23                  0              
 *    22    INTERNAL_ERR_MASK         1              
 *    20    UNSUPPORTED_REQ_ERR_MASK  0              
 *    19    ECRC_ERR_MASK             0              
 *    18    MALF_TLP_ERR_MASK         0              
 *    17    REC_OVERFLOW_ERR_MASK     0              
 *    16    UNEXP_CMPLT_ERR_MASK      0              
 *    15    CMPLT_ABORT_ERR_MASK      0              
 *    14    CMPLT_TIMEOUT_ERR_MASK    0              
 *    13    FC_PROTOCOL_ERR_MASK      0              
 *    12    POIS_TLP_ERR_MASK         0              
 *    11:06 RSVDP_6                   0x0
 *    05    SURPRISE_DOWN_ERR_MASK    0              
 *    04    DL_PROTOCOL_ERR_MASK      0              
 *    03:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000108)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_OFFSET      0x00000108
#define PCIE_EP_UNCORR_ERR_MASK_OFF_INDEX       0x00000042
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RESET       0x00400000

__INLINE uint32_t  pcie_ep_uncorr_err_mask_off_get(void)
{
	return REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
}

__INLINE void pcie_ep_uncorr_err_mask_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_28_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_28_LSB    28
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_28_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLOCKED_ERR_MASK_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLOCKED_ERR_MASK_POS    27
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_26_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_26_POS    26
#define PCIE_EP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLOCKED_ERR_MASK_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLOCKED_ERR_MASK_POS    25
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLOCKED_ERR_MASK_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLOCKED_ERR_MASK_POS    24
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_23_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_23_POS    23
#define PCIE_EP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_POS    22
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_POS    20
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_POS    19
#define PCIE_EP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_POS    18
#define PCIE_EP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_POS    17
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_POS    16
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_POS    15
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_POS    14
#define PCIE_EP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_POS    13
#define PCIE_EP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_POS    12
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_6_MASK    ((uint32_t)0x00000FC0)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_6_LSB    6
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_6_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_POS    5
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_POS    4
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_0_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_0_LSB    0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_0_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_28_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DMWR_EGRESS_BLOCKED_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_26_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_TLP_PRFX_BLOCKED_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ATOMIC_EGRESS_BLOCKED_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_23_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_INTERNAL_ERR_MASK_RST    0x1
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNSUPPORTED_REQ_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_ECRC_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_MALF_TLP_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_REC_OVERFLOW_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_UNEXP_CMPLT_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_ABORT_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_CMPLT_TIMEOUT_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_FC_PROTOCOL_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_POIS_TLP_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_6_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_SURPRISE_DOWN_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_DL_PROTOCOL_ERR_MASK_RST    0x0
#define PCIE_EP_UNCORR_ERR_MASK_OFF_RSVDP_0_RST    0x0

__INLINE void pcie_ep_uncorr_err_mask_off_pack(uint8_t rsvdp_28, uint8_t dmwr_egress_blocked_err_mask, uint8_t rsvdp_26, uint8_t tlp_prfx_blocked_err_mask, uint8_t atomic_egress_blocked_err_mask, uint8_t rsvdp_23, uint8_t internal_err_mask, uint8_t unsupported_req_err_mask, uint8_t ecrc_err_mask, uint8_t malf_tlp_err_mask, uint8_t rec_overflow_err_mask, uint8_t unexp_cmplt_err_mask, uint8_t cmplt_abort_err_mask, uint8_t cmplt_timeout_err_mask, uint8_t fc_protocol_err_mask, uint8_t pois_tlp_err_mask, uint8_t rsvdp_6, uint8_t surprise_down_err_mask, uint8_t dl_protocol_err_mask, uint8_t rsvdp_0)
{
	ASSERT_ERR((((uint32_t)rsvdp_28 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)dmwr_egress_blocked_err_mask << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_26 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_prfx_blocked_err_mask << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)atomic_egress_blocked_err_mask << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)internal_err_mask << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)unsupported_req_err_mask << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_err_mask << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)malf_tlp_err_mask << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)rec_overflow_err_mask << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)unexp_cmplt_err_mask << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_abort_err_mask << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_timeout_err_mask << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)fc_protocol_err_mask << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)pois_tlp_err_mask << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_6 << 6) & ~((uint32_t)0x00000FC0)) == 0);
	ASSERT_ERR((((uint32_t)surprise_down_err_mask << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)dl_protocol_err_mask << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_0 << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR,  ((uint32_t)rsvdp_28 << 28) |((uint32_t)dmwr_egress_blocked_err_mask << 27) |((uint32_t)rsvdp_26 << 26) |((uint32_t)tlp_prfx_blocked_err_mask << 25) |((uint32_t)atomic_egress_blocked_err_mask << 24) |((uint32_t)rsvdp_23 << 23) |((uint32_t)internal_err_mask << 22) |((uint32_t)unsupported_req_err_mask << 20) |((uint32_t)ecrc_err_mask << 19) |((uint32_t)malf_tlp_err_mask << 18) |((uint32_t)rec_overflow_err_mask << 17) |((uint32_t)unexp_cmplt_err_mask << 16) |((uint32_t)cmplt_abort_err_mask << 15) |((uint32_t)cmplt_timeout_err_mask << 14) |((uint32_t)fc_protocol_err_mask << 13) |((uint32_t)pois_tlp_err_mask << 12) |((uint32_t)rsvdp_6 << 6) |((uint32_t)surprise_down_err_mask << 5) |((uint32_t)dl_protocol_err_mask << 4) |((uint32_t)rsvdp_0 << 0));
}

__INLINE void pcie_ep_uncorr_err_mask_off_unpack(uint8_t* rsvdp_28, uint8_t* dmwr_egress_blocked_err_mask, uint8_t* rsvdp_26, uint8_t* tlp_prfx_blocked_err_mask, uint8_t* atomic_egress_blocked_err_mask, uint8_t* rsvdp_23, uint8_t* internal_err_mask, uint8_t* unsupported_req_err_mask, uint8_t* ecrc_err_mask, uint8_t* malf_tlp_err_mask, uint8_t* rec_overflow_err_mask, uint8_t* unexp_cmplt_err_mask, uint8_t* cmplt_abort_err_mask, uint8_t* cmplt_timeout_err_mask, uint8_t* fc_protocol_err_mask, uint8_t* pois_tlp_err_mask, uint8_t* rsvdp_6, uint8_t* surprise_down_err_mask, uint8_t* dl_protocol_err_mask, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);

	*rsvdp_28 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*dmwr_egress_blocked_err_mask = (localVal & ((uint32_t)0x08000000)) >>  27;
	*rsvdp_26 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*tlp_prfx_blocked_err_mask = (localVal & ((uint32_t)0x02000000)) >>  25;
	*atomic_egress_blocked_err_mask = (localVal & ((uint32_t)0x01000000)) >>  24;
	*rsvdp_23 = (localVal & ((uint32_t)0x00800000)) >>  23;
	*internal_err_mask = (localVal & ((uint32_t)0x00400000)) >>  22;
	*unsupported_req_err_mask = (localVal & ((uint32_t)0x00100000)) >>  20;
	*ecrc_err_mask = (localVal & ((uint32_t)0x00080000)) >>  19;
	*malf_tlp_err_mask = (localVal & ((uint32_t)0x00040000)) >>  18;
	*rec_overflow_err_mask = (localVal & ((uint32_t)0x00020000)) >>  17;
	*unexp_cmplt_err_mask = (localVal & ((uint32_t)0x00010000)) >>  16;
	*cmplt_abort_err_mask = (localVal & ((uint32_t)0x00008000)) >>  15;
	*cmplt_timeout_err_mask = (localVal & ((uint32_t)0x00004000)) >>  14;
	*fc_protocol_err_mask = (localVal & ((uint32_t)0x00002000)) >>  13;
	*pois_tlp_err_mask = (localVal & ((uint32_t)0x00001000)) >>  12;
	*rsvdp_6 = (localVal & ((uint32_t)0x00000FC0)) >>  6;
	*surprise_down_err_mask = (localVal & ((uint32_t)0x00000020)) >>  5;
	*dl_protocol_err_mask = (localVal & ((uint32_t)0x00000010)) >>  4;
	*rsvdp_0 = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rsvdp_28_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_dmwr_egress_blocked_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rsvdp_26_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_tlp_prfx_blocked_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_atomic_egress_blocked_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_internal_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_uncorr_err_mask_off_internal_err_mask_setf(uint8_t internalerrmask)
{
	ASSERT_ERR((((uint32_t)internalerrmask << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)internalerrmask <<22));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_unsupported_req_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_uncorr_err_mask_off_unsupported_req_err_mask_setf(uint8_t unsupportedreqerrmask)
{
	ASSERT_ERR((((uint32_t)unsupportedreqerrmask << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)unsupportedreqerrmask <<20));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_ecrc_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_uncorr_err_mask_off_ecrc_err_mask_setf(uint8_t ecrcerrmask)
{
	ASSERT_ERR((((uint32_t)ecrcerrmask << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)ecrcerrmask <<19));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_malf_tlp_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_uncorr_err_mask_off_malf_tlp_err_mask_setf(uint8_t malftlperrmask)
{
	ASSERT_ERR((((uint32_t)malftlperrmask << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)malftlperrmask <<18));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rec_overflow_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_uncorr_err_mask_off_rec_overflow_err_mask_setf(uint8_t recoverflowerrmask)
{
	ASSERT_ERR((((uint32_t)recoverflowerrmask << 17) & ~((uint32_t)0x00020000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)recoverflowerrmask <<17));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_unexp_cmplt_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_uncorr_err_mask_off_unexp_cmplt_err_mask_setf(uint8_t unexpcmplterrmask)
{
	ASSERT_ERR((((uint32_t)unexpcmplterrmask << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)unexpcmplterrmask <<16));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_cmplt_abort_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_uncorr_err_mask_off_cmplt_abort_err_mask_setf(uint8_t cmpltaborterrmask)
{
	ASSERT_ERR((((uint32_t)cmpltaborterrmask << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)cmpltaborterrmask <<15));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_cmplt_timeout_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_uncorr_err_mask_off_cmplt_timeout_err_mask_setf(uint8_t cmplttimeouterrmask)
{
	ASSERT_ERR((((uint32_t)cmplttimeouterrmask << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)cmplttimeouterrmask <<14));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_fc_protocol_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_uncorr_err_mask_off_fc_protocol_err_mask_setf(uint8_t fcprotocolerrmask)
{
	ASSERT_ERR((((uint32_t)fcprotocolerrmask << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)fcprotocolerrmask <<13));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_pois_tlp_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void pcie_ep_uncorr_err_mask_off_pois_tlp_err_mask_setf(uint8_t poistlperrmask)
{
	ASSERT_ERR((((uint32_t)poistlperrmask << 12) & ~((uint32_t)0x00001000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)poistlperrmask <<12));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rsvdp_6_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000FC0)) >> 6);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_surprise_down_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_dl_protocol_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_uncorr_err_mask_off_dl_protocol_err_mask_setf(uint8_t dlprotocolerrmask)
{
	ASSERT_ERR((((uint32_t)dlprotocolerrmask << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)dlprotocolerrmask <<4));
}
__INLINE uint8_t pcie_ep_uncorr_err_mask_off_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief UNCORR_ERR_SEV_OFF register definition
 *  The Uncorrectable Error Severity Register controls whether an individual error is reported as a Non-fatal or Fatal error. An error is reported as fatal when the corresponding error bit in the severity register is Set. If the bit is Clear, the corresponding error is considered non-fatal. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RSVDP_28                  0x0
 *    27    DMWR_EGRESS_BLOCKED_ERR_SEVERITY 0              
 *    25    TLP_PRFX_BLOCKED_ERR_SEVERITY 0              
 *    23    RSVDP_23                  0              
 *    22    INTERNAL_ERR_SEVERITY     1              
 *    20    UNSUPPORTED_REQ_ERR_SEVERITY 0              
 *    19    ECRC_ERR_SEVERITY         0              
 *    18    MALF_TLP_ERR_SEVERITY     1              
 *    17    REC_OVERFLOW_ERR_SEVERITY 1              
 *    16    UNEXP_CMPLT_ERR_SEVERITY  0              
 *    15    CMPLT_ABORT_ERR_SEVERITY  0              
 *    14    CMPLT_TIMEOUT_ERR_SEVERITY 0              
 *    13    FC_PROTOCOL_ERR_SEVERITY  1              
 *    12    POIS_TLP_ERR_SEVERITY     0              
 *    11:06 RSVDP_6                   0x0
 *    05    SURPRISE_DOWN_ERR_SVRITY  1              
 *    04    DL_PROTOCOL_ERR_SEVERITY  1              
 *    03:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000010C)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_OFFSET      0x0000010C
#define PCIE_EP_UNCORR_ERR_SEV_OFF_INDEX       0x00000043
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RESET       0x00462030

__INLINE uint32_t  pcie_ep_uncorr_err_sev_off_get(void)
{
	return REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
}

__INLINE void pcie_ep_uncorr_err_sev_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_28_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_28_LSB    28
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_28_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLOCKED_ERR_SEVERITY_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLOCKED_ERR_SEVERITY_POS    27
#define PCIE_EP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLOCKED_ERR_SEVERITY_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLOCKED_ERR_SEVERITY_POS    25
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_23_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_23_POS    23
#define PCIE_EP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_POS    22
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_POS    20
#define PCIE_EP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_POS    19
#define PCIE_EP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_POS    18
#define PCIE_EP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_POS    17
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_POS    16
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_POS    15
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_POS    14
#define PCIE_EP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_POS    13
#define PCIE_EP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_POS    12
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_6_MASK    ((uint32_t)0x00000FC0)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_6_LSB    6
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_6_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_POS    5
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_POS    4
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_0_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_0_LSB    0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_0_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_28_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DMWR_EGRESS_BLOCKED_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_TLP_PRFX_BLOCKED_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_23_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_INTERNAL_ERR_SEVERITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNSUPPORTED_REQ_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_ECRC_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_MALF_TLP_ERR_SEVERITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_REC_OVERFLOW_ERR_SEVERITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_UNEXP_CMPLT_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_ABORT_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_CMPLT_TIMEOUT_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_FC_PROTOCOL_ERR_SEVERITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_POIS_TLP_ERR_SEVERITY_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_6_RST    0x0
#define PCIE_EP_UNCORR_ERR_SEV_OFF_SURPRISE_DOWN_ERR_SVRITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_DL_PROTOCOL_ERR_SEVERITY_RST    0x1
#define PCIE_EP_UNCORR_ERR_SEV_OFF_RSVDP_0_RST    0x0

__INLINE void pcie_ep_uncorr_err_sev_off_pack(uint8_t rsvdp_28, uint8_t dmwr_egress_blocked_err_severity, uint8_t tlp_prfx_blocked_err_severity, uint8_t rsvdp_23, uint8_t internal_err_severity, uint8_t unsupported_req_err_severity, uint8_t ecrc_err_severity, uint8_t malf_tlp_err_severity, uint8_t rec_overflow_err_severity, uint8_t unexp_cmplt_err_severity, uint8_t cmplt_abort_err_severity, uint8_t cmplt_timeout_err_severity, uint8_t fc_protocol_err_severity, uint8_t pois_tlp_err_severity, uint8_t rsvdp_6, uint8_t surprise_down_err_svrity, uint8_t dl_protocol_err_severity, uint8_t rsvdp_0)
{
	ASSERT_ERR((((uint32_t)rsvdp_28 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)dmwr_egress_blocked_err_severity << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_prfx_blocked_err_severity << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)internal_err_severity << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)unsupported_req_err_severity << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_err_severity << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)malf_tlp_err_severity << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)rec_overflow_err_severity << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)unexp_cmplt_err_severity << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_abort_err_severity << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)cmplt_timeout_err_severity << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)fc_protocol_err_severity << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)pois_tlp_err_severity << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_6 << 6) & ~((uint32_t)0x00000FC0)) == 0);
	ASSERT_ERR((((uint32_t)surprise_down_err_svrity << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)dl_protocol_err_severity << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_0 << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR,  ((uint32_t)rsvdp_28 << 28) |((uint32_t)dmwr_egress_blocked_err_severity << 27) |((uint32_t)tlp_prfx_blocked_err_severity << 25) |((uint32_t)rsvdp_23 << 23) |((uint32_t)internal_err_severity << 22) |((uint32_t)unsupported_req_err_severity << 20) |((uint32_t)ecrc_err_severity << 19) |((uint32_t)malf_tlp_err_severity << 18) |((uint32_t)rec_overflow_err_severity << 17) |((uint32_t)unexp_cmplt_err_severity << 16) |((uint32_t)cmplt_abort_err_severity << 15) |((uint32_t)cmplt_timeout_err_severity << 14) |((uint32_t)fc_protocol_err_severity << 13) |((uint32_t)pois_tlp_err_severity << 12) |((uint32_t)rsvdp_6 << 6) |((uint32_t)surprise_down_err_svrity << 5) |((uint32_t)dl_protocol_err_severity << 4) |((uint32_t)rsvdp_0 << 0));
}

__INLINE void pcie_ep_uncorr_err_sev_off_unpack(uint8_t* rsvdp_28, uint8_t* dmwr_egress_blocked_err_severity, uint8_t* tlp_prfx_blocked_err_severity, uint8_t* rsvdp_23, uint8_t* internal_err_severity, uint8_t* unsupported_req_err_severity, uint8_t* ecrc_err_severity, uint8_t* malf_tlp_err_severity, uint8_t* rec_overflow_err_severity, uint8_t* unexp_cmplt_err_severity, uint8_t* cmplt_abort_err_severity, uint8_t* cmplt_timeout_err_severity, uint8_t* fc_protocol_err_severity, uint8_t* pois_tlp_err_severity, uint8_t* rsvdp_6, uint8_t* surprise_down_err_svrity, uint8_t* dl_protocol_err_severity, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);

	*rsvdp_28 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*dmwr_egress_blocked_err_severity = (localVal & ((uint32_t)0x08000000)) >>  27;
	*tlp_prfx_blocked_err_severity = (localVal & ((uint32_t)0x02000000)) >>  25;
	*rsvdp_23 = (localVal & ((uint32_t)0x00800000)) >>  23;
	*internal_err_severity = (localVal & ((uint32_t)0x00400000)) >>  22;
	*unsupported_req_err_severity = (localVal & ((uint32_t)0x00100000)) >>  20;
	*ecrc_err_severity = (localVal & ((uint32_t)0x00080000)) >>  19;
	*malf_tlp_err_severity = (localVal & ((uint32_t)0x00040000)) >>  18;
	*rec_overflow_err_severity = (localVal & ((uint32_t)0x00020000)) >>  17;
	*unexp_cmplt_err_severity = (localVal & ((uint32_t)0x00010000)) >>  16;
	*cmplt_abort_err_severity = (localVal & ((uint32_t)0x00008000)) >>  15;
	*cmplt_timeout_err_severity = (localVal & ((uint32_t)0x00004000)) >>  14;
	*fc_protocol_err_severity = (localVal & ((uint32_t)0x00002000)) >>  13;
	*pois_tlp_err_severity = (localVal & ((uint32_t)0x00001000)) >>  12;
	*rsvdp_6 = (localVal & ((uint32_t)0x00000FC0)) >>  6;
	*surprise_down_err_svrity = (localVal & ((uint32_t)0x00000020)) >>  5;
	*dl_protocol_err_severity = (localVal & ((uint32_t)0x00000010)) >>  4;
	*rsvdp_0 = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_uncorr_err_sev_off_rsvdp_28_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_dmwr_egress_blocked_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_tlp_prfx_blocked_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_internal_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_uncorr_err_sev_off_internal_err_severity_setf(uint8_t internalerrseverity)
{
	ASSERT_ERR((((uint32_t)internalerrseverity << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)internalerrseverity <<22));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_unsupported_req_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_uncorr_err_sev_off_unsupported_req_err_severity_setf(uint8_t unsupportedreqerrseverity)
{
	ASSERT_ERR((((uint32_t)unsupportedreqerrseverity << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)unsupportedreqerrseverity <<20));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_ecrc_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_uncorr_err_sev_off_ecrc_err_severity_setf(uint8_t ecrcerrseverity)
{
	ASSERT_ERR((((uint32_t)ecrcerrseverity << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)ecrcerrseverity <<19));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_malf_tlp_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_uncorr_err_sev_off_malf_tlp_err_severity_setf(uint8_t malftlperrseverity)
{
	ASSERT_ERR((((uint32_t)malftlperrseverity << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)malftlperrseverity <<18));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_rec_overflow_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_uncorr_err_sev_off_rec_overflow_err_severity_setf(uint8_t recoverflowerrseverity)
{
	ASSERT_ERR((((uint32_t)recoverflowerrseverity << 17) & ~((uint32_t)0x00020000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)recoverflowerrseverity <<17));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_unexp_cmplt_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_uncorr_err_sev_off_unexp_cmplt_err_severity_setf(uint8_t unexpcmplterrseverity)
{
	ASSERT_ERR((((uint32_t)unexpcmplterrseverity << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)unexpcmplterrseverity <<16));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_cmplt_abort_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_uncorr_err_sev_off_cmplt_abort_err_severity_setf(uint8_t cmpltaborterrseverity)
{
	ASSERT_ERR((((uint32_t)cmpltaborterrseverity << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)cmpltaborterrseverity <<15));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_cmplt_timeout_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_uncorr_err_sev_off_cmplt_timeout_err_severity_setf(uint8_t cmplttimeouterrseverity)
{
	ASSERT_ERR((((uint32_t)cmplttimeouterrseverity << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)cmplttimeouterrseverity <<14));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_fc_protocol_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_uncorr_err_sev_off_fc_protocol_err_severity_setf(uint8_t fcprotocolerrseverity)
{
	ASSERT_ERR((((uint32_t)fcprotocolerrseverity << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)fcprotocolerrseverity <<13));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_pois_tlp_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void pcie_ep_uncorr_err_sev_off_pois_tlp_err_severity_setf(uint8_t poistlperrseverity)
{
	ASSERT_ERR((((uint32_t)poistlperrseverity << 12) & ~((uint32_t)0x00001000)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)poistlperrseverity <<12));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_rsvdp_6_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000FC0)) >> 6);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_surprise_down_err_svrity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_dl_protocol_err_severity_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_uncorr_err_sev_off_dl_protocol_err_severity_setf(uint8_t dlprotocolerrseverity)
{
	ASSERT_ERR((((uint32_t)dlprotocolerrseverity << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR, (REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)dlprotocolerrseverity <<4));
}
__INLINE uint8_t pcie_ep_uncorr_err_sev_off_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_UNCORR_ERR_SEV_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief CORR_ERR_STATUS_OFF register definition
 *  The Correctable Error Status register reports error status of individual correctable error sources on a PCI Express device Function. When an individual error status bit is Set, it indicates that a particular error occurred; software may clear an error status by writing a 1b to the respective bit. Register bits not implemented by the Function are hardwired to 0b by the controller. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15    HEADER_LOG_OVERFLOW_STATUS 0              
 *    14    CORRECTED_INT_ERR_STATUS  0              
 *    13    ADVISORY_NON_FATAL_ERR_STATUS 0              
 *    12    RPL_TIMER_TIMEOUT_STATUS  0              
 *    11:09 RSVDP_9                   0x0
 *    08    REPLAY_NO_ROLEOVER_STATUS 0              
 *    07    BAD_DLLP_STATUS           0              
 *    06    BAD_TLP_STATUS            0              
 *    05:01 RSVDP_1                   0x0
 *    00    RX_ERR_STATUS             0              
 * </pre>
 */
#define PCIE_EP_CORR_ERR_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000110)
#define PCIE_EP_CORR_ERR_STATUS_OFF_OFFSET      0x00000110
#define PCIE_EP_CORR_ERR_STATUS_OFF_INDEX       0x00000044
#define PCIE_EP_CORR_ERR_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_corr_err_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_corr_err_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_16_LSB    16
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_CORR_ERR_STATUS_OFF_HEADER_LOG_OVERFLOW_STATUS_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_CORR_ERR_STATUS_OFF_HEADER_LOG_OVERFLOW_STATUS_POS    15
#define PCIE_EP_CORR_ERR_STATUS_OFF_CORRECTED_INT_ERR_STATUS_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_CORR_ERR_STATUS_OFF_CORRECTED_INT_ERR_STATUS_POS    14
#define PCIE_EP_CORR_ERR_STATUS_OFF_ADVISORY_NON_FATAL_ERR_STATUS_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_CORR_ERR_STATUS_OFF_ADVISORY_NON_FATAL_ERR_STATUS_POS    13
#define PCIE_EP_CORR_ERR_STATUS_OFF_RPL_TIMER_TIMEOUT_STATUS_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RPL_TIMER_TIMEOUT_STATUS_POS    12
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_9_MASK    ((uint32_t)0x00000E00)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_9_LSB    9
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_9_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_CORR_ERR_STATUS_OFF_REPLAY_NO_ROLEOVER_STATUS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_CORR_ERR_STATUS_OFF_REPLAY_NO_ROLEOVER_STATUS_POS    8
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_DLLP_STATUS_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_DLLP_STATUS_POS    7
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_TLP_STATUS_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_TLP_STATUS_POS    6
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_1_MASK    ((uint32_t)0x0000003E)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_1_LSB    1
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_1_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RX_ERR_STATUS_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_CORR_ERR_STATUS_OFF_RX_ERR_STATUS_POS    0

#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_16_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_HEADER_LOG_OVERFLOW_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_CORRECTED_INT_ERR_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_ADVISORY_NON_FATAL_ERR_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_RPL_TIMER_TIMEOUT_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_9_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_REPLAY_NO_ROLEOVER_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_DLLP_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_BAD_TLP_STATUS_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_CORR_ERR_STATUS_OFF_RX_ERR_STATUS_RST    0x0

__INLINE void pcie_ep_corr_err_status_off_pack(uint16_t rsvdp_16, uint8_t header_log_overflow_status, uint8_t corrected_int_err_status, uint8_t advisory_non_fatal_err_status, uint8_t rpl_timer_timeout_status, uint8_t rsvdp_9, uint8_t replay_no_roleover_status, uint8_t bad_dllp_status, uint8_t bad_tlp_status, uint8_t rsvdp_1, uint8_t rx_err_status)
{
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)header_log_overflow_status << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)corrected_int_err_status << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)advisory_non_fatal_err_status << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)rpl_timer_timeout_status << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_9 << 9) & ~((uint32_t)0x00000E00)) == 0);
	ASSERT_ERR((((uint32_t)replay_no_roleover_status << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)bad_dllp_status << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)bad_tlp_status << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x0000003E)) == 0);
	ASSERT_ERR((((uint32_t)rx_err_status << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR,  ((uint32_t)rsvdp_16 << 16) |((uint32_t)header_log_overflow_status << 15) |((uint32_t)corrected_int_err_status << 14) |((uint32_t)advisory_non_fatal_err_status << 13) |((uint32_t)rpl_timer_timeout_status << 12) |((uint32_t)rsvdp_9 << 9) |((uint32_t)replay_no_roleover_status << 8) |((uint32_t)bad_dllp_status << 7) |((uint32_t)bad_tlp_status << 6) |((uint32_t)rsvdp_1 << 1) |((uint32_t)rx_err_status << 0));
}

__INLINE void pcie_ep_corr_err_status_off_unpack(uint16_t* rsvdp_16, uint8_t* header_log_overflow_status, uint8_t* corrected_int_err_status, uint8_t* advisory_non_fatal_err_status, uint8_t* rpl_timer_timeout_status, uint8_t* rsvdp_9, uint8_t* replay_no_roleover_status, uint8_t* bad_dllp_status, uint8_t* bad_tlp_status, uint8_t* rsvdp_1, uint8_t* rx_err_status)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*header_log_overflow_status = (localVal & ((uint32_t)0x00008000)) >>  15;
	*corrected_int_err_status = (localVal & ((uint32_t)0x00004000)) >>  14;
	*advisory_non_fatal_err_status = (localVal & ((uint32_t)0x00002000)) >>  13;
	*rpl_timer_timeout_status = (localVal & ((uint32_t)0x00001000)) >>  12;
	*rsvdp_9 = (localVal & ((uint32_t)0x00000E00)) >>  9;
	*replay_no_roleover_status = (localVal & ((uint32_t)0x00000100)) >>  8;
	*bad_dllp_status = (localVal & ((uint32_t)0x00000080)) >>  7;
	*bad_tlp_status = (localVal & ((uint32_t)0x00000040)) >>  6;
	*rsvdp_1 = (localVal & ((uint32_t)0x0000003E)) >>  1;
	*rx_err_status = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_corr_err_status_off_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_corr_err_status_off_header_log_overflow_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_corr_err_status_off_header_log_overflow_status_setf(uint8_t headerlogoverflowstatus)
{
	ASSERT_ERR((((uint32_t)headerlogoverflowstatus << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)headerlogoverflowstatus <<15));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_corrected_int_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_corr_err_status_off_corrected_int_err_status_setf(uint8_t correctedinterrstatus)
{
	ASSERT_ERR((((uint32_t)correctedinterrstatus << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)correctedinterrstatus <<14));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_advisory_non_fatal_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_corr_err_status_off_advisory_non_fatal_err_status_setf(uint8_t advisorynonfatalerrstatus)
{
	ASSERT_ERR((((uint32_t)advisorynonfatalerrstatus << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)advisorynonfatalerrstatus <<13));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_rpl_timer_timeout_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void pcie_ep_corr_err_status_off_rpl_timer_timeout_status_setf(uint8_t rpltimertimeoutstatus)
{
	ASSERT_ERR((((uint32_t)rpltimertimeoutstatus << 12) & ~((uint32_t)0x00001000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)rpltimertimeoutstatus <<12));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000E00)) >> 9);
}
__INLINE uint8_t pcie_ep_corr_err_status_off_replay_no_roleover_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_corr_err_status_off_replay_no_roleover_status_setf(uint8_t replaynoroleoverstatus)
{
	ASSERT_ERR((((uint32_t)replaynoroleoverstatus << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)replaynoroleoverstatus <<8));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_bad_dllp_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_corr_err_status_off_bad_dllp_status_setf(uint8_t baddllpstatus)
{
	ASSERT_ERR((((uint32_t)baddllpstatus << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)baddllpstatus <<7));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_bad_tlp_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_corr_err_status_off_bad_tlp_status_setf(uint8_t badtlpstatus)
{
	ASSERT_ERR((((uint32_t)badtlpstatus << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)badtlpstatus <<6));
}
__INLINE uint8_t pcie_ep_corr_err_status_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000003E)) >> 1);
}
__INLINE uint8_t pcie_ep_corr_err_status_off_rx_err_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_corr_err_status_off_rx_err_status_setf(uint8_t rxerrstatus)
{
	ASSERT_ERR((((uint32_t)rxerrstatus << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_STATUS_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)rxerrstatus <<0));
}

/**
 * @brief CORR_ERR_MASK_OFF register definition
 *  The Correctable Error Mask Register controls reporting of individual correctable errors by this Function to the PCI Express Root Complex through a PCI Express error Message. A masked error (respective bit Set in the mask register) is not reported to the PCI Express Root Complex by this Function. There is a mask bit per error bit in the Correctable Error Status register. Register fields for bits not implemented by the Function are hardwired to 0b by the controller. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15    HEADER_LOG_OVERFLOW_MASK  1              
 *    14    CORRECTED_INT_ERR_MASK    1              
 *    13    ADVISORY_NON_FATAL_ERR_MASK 1              
 *    12    RPL_TIMER_TIMEOUT_MASK    0              
 *    11:09 RSVDP_9                   0x0
 *    08    REPLAY_NO_ROLEOVER_MASK   0              
 *    07    BAD_DLLP_MASK             0              
 *    06    BAD_TLP_MASK              0              
 *    05:01 RSVDP_1                   0x0
 *    00    RX_ERR_MASK               0              
 * </pre>
 */
#define PCIE_EP_CORR_ERR_MASK_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000114)
#define PCIE_EP_CORR_ERR_MASK_OFF_OFFSET      0x00000114
#define PCIE_EP_CORR_ERR_MASK_OFF_INDEX       0x00000045
#define PCIE_EP_CORR_ERR_MASK_OFF_RESET       0x0000E000

__INLINE uint32_t  pcie_ep_corr_err_mask_off_get(void)
{
	return REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
}

__INLINE void pcie_ep_corr_err_mask_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_16_LSB    16
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_POS    15
#define PCIE_EP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_POS    14
#define PCIE_EP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_POS    13
#define PCIE_EP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_POS    12
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_9_MASK    ((uint32_t)0x00000E00)
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_9_LSB    9
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_9_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_POS    8
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_POS    7
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_POS    6
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_1_MASK    ((uint32_t)0x0000003E)
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_1_LSB    1
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_1_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_CORR_ERR_MASK_OFF_RX_ERR_MASK_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_CORR_ERR_MASK_OFF_RX_ERR_MASK_POS    0

#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_16_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_HEADER_LOG_OVERFLOW_MASK_RST    0x1
#define PCIE_EP_CORR_ERR_MASK_OFF_CORRECTED_INT_ERR_MASK_RST    0x1
#define PCIE_EP_CORR_ERR_MASK_OFF_ADVISORY_NON_FATAL_ERR_MASK_RST    0x1
#define PCIE_EP_CORR_ERR_MASK_OFF_RPL_TIMER_TIMEOUT_MASK_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_9_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_REPLAY_NO_ROLEOVER_MASK_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_DLLP_MASK_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_BAD_TLP_MASK_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_CORR_ERR_MASK_OFF_RX_ERR_MASK_RST    0x0

__INLINE void pcie_ep_corr_err_mask_off_pack(uint16_t rsvdp_16, uint8_t header_log_overflow_mask, uint8_t corrected_int_err_mask, uint8_t advisory_non_fatal_err_mask, uint8_t rpl_timer_timeout_mask, uint8_t rsvdp_9, uint8_t replay_no_roleover_mask, uint8_t bad_dllp_mask, uint8_t bad_tlp_mask, uint8_t rsvdp_1, uint8_t rx_err_mask)
{
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)header_log_overflow_mask << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)corrected_int_err_mask << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)advisory_non_fatal_err_mask << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)rpl_timer_timeout_mask << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_9 << 9) & ~((uint32_t)0x00000E00)) == 0);
	ASSERT_ERR((((uint32_t)replay_no_roleover_mask << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)bad_dllp_mask << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)bad_tlp_mask << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x0000003E)) == 0);
	ASSERT_ERR((((uint32_t)rx_err_mask << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR,  ((uint32_t)rsvdp_16 << 16) |((uint32_t)header_log_overflow_mask << 15) |((uint32_t)corrected_int_err_mask << 14) |((uint32_t)advisory_non_fatal_err_mask << 13) |((uint32_t)rpl_timer_timeout_mask << 12) |((uint32_t)rsvdp_9 << 9) |((uint32_t)replay_no_roleover_mask << 8) |((uint32_t)bad_dllp_mask << 7) |((uint32_t)bad_tlp_mask << 6) |((uint32_t)rsvdp_1 << 1) |((uint32_t)rx_err_mask << 0));
}

__INLINE void pcie_ep_corr_err_mask_off_unpack(uint16_t* rsvdp_16, uint8_t* header_log_overflow_mask, uint8_t* corrected_int_err_mask, uint8_t* advisory_non_fatal_err_mask, uint8_t* rpl_timer_timeout_mask, uint8_t* rsvdp_9, uint8_t* replay_no_roleover_mask, uint8_t* bad_dllp_mask, uint8_t* bad_tlp_mask, uint8_t* rsvdp_1, uint8_t* rx_err_mask)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*header_log_overflow_mask = (localVal & ((uint32_t)0x00008000)) >>  15;
	*corrected_int_err_mask = (localVal & ((uint32_t)0x00004000)) >>  14;
	*advisory_non_fatal_err_mask = (localVal & ((uint32_t)0x00002000)) >>  13;
	*rpl_timer_timeout_mask = (localVal & ((uint32_t)0x00001000)) >>  12;
	*rsvdp_9 = (localVal & ((uint32_t)0x00000E00)) >>  9;
	*replay_no_roleover_mask = (localVal & ((uint32_t)0x00000100)) >>  8;
	*bad_dllp_mask = (localVal & ((uint32_t)0x00000080)) >>  7;
	*bad_tlp_mask = (localVal & ((uint32_t)0x00000040)) >>  6;
	*rsvdp_1 = (localVal & ((uint32_t)0x0000003E)) >>  1;
	*rx_err_mask = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_corr_err_mask_off_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_header_log_overflow_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_corr_err_mask_off_header_log_overflow_mask_setf(uint8_t headerlogoverflowmask)
{
	ASSERT_ERR((((uint32_t)headerlogoverflowmask << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)headerlogoverflowmask <<15));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_corrected_int_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_corr_err_mask_off_corrected_int_err_mask_setf(uint8_t correctedinterrmask)
{
	ASSERT_ERR((((uint32_t)correctedinterrmask << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)correctedinterrmask <<14));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_advisory_non_fatal_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_corr_err_mask_off_advisory_non_fatal_err_mask_setf(uint8_t advisorynonfatalerrmask)
{
	ASSERT_ERR((((uint32_t)advisorynonfatalerrmask << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)advisorynonfatalerrmask <<13));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_rpl_timer_timeout_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE void pcie_ep_corr_err_mask_off_rpl_timer_timeout_mask_setf(uint8_t rpltimertimeoutmask)
{
	ASSERT_ERR((((uint32_t)rpltimertimeoutmask << 12) & ~((uint32_t)0x00001000)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00001000)) | ((uint32_t)rpltimertimeoutmask <<12));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000E00)) >> 9);
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_replay_no_roleover_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_corr_err_mask_off_replay_no_roleover_mask_setf(uint8_t replaynoroleovermask)
{
	ASSERT_ERR((((uint32_t)replaynoroleovermask << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)replaynoroleovermask <<8));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_bad_dllp_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_corr_err_mask_off_bad_dllp_mask_setf(uint8_t baddllpmask)
{
	ASSERT_ERR((((uint32_t)baddllpmask << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)baddllpmask <<7));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_bad_tlp_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_corr_err_mask_off_bad_tlp_mask_setf(uint8_t badtlpmask)
{
	ASSERT_ERR((((uint32_t)badtlpmask << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)badtlpmask <<6));
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000003E)) >> 1);
}
__INLINE uint8_t pcie_ep_corr_err_mask_off_rx_err_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_corr_err_mask_off_rx_err_mask_setf(uint8_t rxerrmask)
{
	ASSERT_ERR((((uint32_t)rxerrmask << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CORR_ERR_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_CORR_ERR_MASK_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)rxerrmask <<0));
}

/**
 * @brief ADV_ERR_CAP_CTRL_OFF register definition
 *  Advanced Error Capabilities and Control Register provides information whether the individual capability is supported or not. If the capability is supported then it is enabled or not. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:13 RSVDP_13                  0x0
 *    12    CTO_PRFX_HDR_LOG_CAP      0              
 *    10    MULTIPLE_HEADER_EN        0              
 *    09    MULTIPLE_HEADER_CAP       0              
 *    08    ECRC_CHECK_EN             0              
 *    07    ECRC_CHECK_CAP            1              
 *    06    ECRC_GEN_EN               0              
 *    05    ECRC_GEN_CAP              1              
 *    04:00 FIRST_ERR_POINTER         0x0
 * </pre>
 */
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000118)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_OFFSET      0x00000118
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_INDEX       0x00000046
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_RESET       0x000000A0

__INLINE uint32_t  pcie_ep_adv_err_cap_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_adv_err_cap_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_RSVDP_13_MASK    ((uint32_t)0xFFFFE000)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_RSVDP_13_LSB    13
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_RSVDP_13_WIDTH    ((uint32_t)0x00000013)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_BIT    ((uint32_t)0x00001000)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_POS    12
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_POS    10
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_POS    9
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_POS    8
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_POS    7
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_POS    6
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_POS    5
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_POINTER_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_POINTER_LSB    0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_POINTER_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_RSVDP_13_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_CTO_PRFX_HDR_LOG_CAP_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_EN_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_MULTIPLE_HEADER_CAP_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_EN_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_CHECK_CAP_RST    0x1
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_EN_RST    0x0
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ECRC_GEN_CAP_RST    0x1
#define PCIE_EP_ADV_ERR_CAP_CTRL_OFF_FIRST_ERR_POINTER_RST    0x0

__INLINE void pcie_ep_adv_err_cap_ctrl_off_pack(uint32_t rsvdp_13, uint8_t cto_prfx_hdr_log_cap, uint8_t multiple_header_en, uint8_t multiple_header_cap, uint8_t ecrc_check_en, uint8_t ecrc_check_cap, uint8_t ecrc_gen_en, uint8_t ecrc_gen_cap, uint8_t first_err_pointer)
{
	ASSERT_ERR((((uint32_t)rsvdp_13 << 13) & ~((uint32_t)0xFFFFE000)) == 0);
	ASSERT_ERR((((uint32_t)cto_prfx_hdr_log_cap << 12) & ~((uint32_t)0x00001000)) == 0);
	ASSERT_ERR((((uint32_t)multiple_header_en << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)multiple_header_cap << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_check_en << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_check_cap << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_gen_en << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)ecrc_gen_cap << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)first_err_pointer << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_13 << 13) |((uint32_t)cto_prfx_hdr_log_cap << 12) |((uint32_t)multiple_header_en << 10) |((uint32_t)multiple_header_cap << 9) |((uint32_t)ecrc_check_en << 8) |((uint32_t)ecrc_check_cap << 7) |((uint32_t)ecrc_gen_en << 6) |((uint32_t)ecrc_gen_cap << 5) |((uint32_t)first_err_pointer << 0));
}

__INLINE void pcie_ep_adv_err_cap_ctrl_off_unpack(uint32_t* rsvdp_13, uint8_t* cto_prfx_hdr_log_cap, uint8_t* multiple_header_en, uint8_t* multiple_header_cap, uint8_t* ecrc_check_en, uint8_t* ecrc_check_cap, uint8_t* ecrc_gen_en, uint8_t* ecrc_gen_cap, uint8_t* first_err_pointer)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);

	*rsvdp_13 = (localVal & ((uint32_t)0xFFFFE000)) >>  13;
	*cto_prfx_hdr_log_cap = (localVal & ((uint32_t)0x00001000)) >>  12;
	*multiple_header_en = (localVal & ((uint32_t)0x00000400)) >>  10;
	*multiple_header_cap = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ecrc_check_en = (localVal & ((uint32_t)0x00000100)) >>  8;
	*ecrc_check_cap = (localVal & ((uint32_t)0x00000080)) >>  7;
	*ecrc_gen_en = (localVal & ((uint32_t)0x00000040)) >>  6;
	*ecrc_gen_cap = (localVal & ((uint32_t)0x00000020)) >>  5;
	*first_err_pointer = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint32_t pcie_ep_adv_err_cap_ctrl_off_rsvdp_13_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFE000)) >> 13);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_cto_prfx_hdr_log_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001000)) >> 12);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_multiple_header_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_multiple_header_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_ecrc_check_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_adv_err_cap_ctrl_off_ecrc_check_en_setf(uint8_t ecrcchecken)
{
	ASSERT_ERR((((uint32_t)ecrcchecken << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ecrcchecken <<8));
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_ecrc_check_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_ecrc_gen_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_adv_err_cap_ctrl_off_ecrc_gen_en_setf(uint8_t ecrcgenen)
{
	ASSERT_ERR((((uint32_t)ecrcgenen << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)ecrcgenen <<6));
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_ecrc_gen_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE uint8_t pcie_ep_adv_err_cap_ctrl_off_first_err_pointer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ADV_ERR_CAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}

/**
 * @brief HDR_LOG_0_OFF register definition
 *  The Header Log Register 0 contains the header for the TLP corresponding to a detected error; The header is captured such that, when read using DW accesses, the fields of the header are laid out in the same way the headers are presented in the specification. Therefore, byte 0 of the header is located in byte 3 of the Header Log Register 0, byte 1 of the header is in byte 2 of the Header Log Register 0, and so forth. For 12-byte headers, only bytes 0 through 11 of the Header Log Register are used and values in bytes 12 through 15 are undefined. In certain cases where a Malformed TLP is reported, the Header Log Register may contain TLP Prefix information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 FIRST_DWORD_FOURTH_BYTE   0x0
 *    23:16 FIRST_DWORD_THIRD_BYTE    0x0
 *    15:08 FIRST_DWORD_SECOND_BYTE   0x0
 *    07:00 FIRST_DWORD_FIRST_BYTE    0x0
 * </pre>
 */
#define PCIE_EP_HDR_LOG_0_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000011C)
#define PCIE_EP_HDR_LOG_0_OFF_OFFSET      0x0000011C
#define PCIE_EP_HDR_LOG_0_OFF_INDEX       0x00000047
#define PCIE_EP_HDR_LOG_0_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_hdr_log_0_off_get(void)
{
	return REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);
}

// field definitions
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_LSB    24
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_LSB    16
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_LSB    8
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_LSB    0
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FOURTH_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_THIRD_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_SECOND_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_0_OFF_FIRST_DWORD_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_hdr_log_0_off_unpack(uint8_t* first_dword_fourth_byte, uint8_t* first_dword_third_byte, uint8_t* first_dword_second_byte, uint8_t* first_dword_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);

	*first_dword_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*first_dword_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*first_dword_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*first_dword_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_hdr_log_0_off_first_dword_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_hdr_log_0_off_first_dword_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_hdr_log_0_off_first_dword_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_hdr_log_0_off_first_dword_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_0_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief HDR_LOG_1_OFF register definition
 *  The Header Log Register 1 contains the header for the TLP corresponding to a detected error; The header is captured such that, when read using DW accesses, the fields of the header are laid out in the same way the headers are presented in the specification. Therefore, byte 0 of the header is located in byte 3 of the Header Log Register 1, byte 1 of the header is in byte 2 of the Header Log Register 1 and so forth. For 12-byte headers, only bytes 0 through 11 of the Header Log Register are used and values in bytes 12 through 15 are undefined. In certain cases where a Malformed TLP is reported, the Header Log Register may contain TLP Prefix information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SECOND_DWORD_FOURTH_BYTE  0x0
 *    23:16 SECOND_DWORD_THIRD_BYTE   0x0
 *    15:08 SECOND_DWORD_SECOND_BYTE  0x0
 *    07:00 SECOND_DWORD_FIRST_BYTE   0x0
 * </pre>
 */
#define PCIE_EP_HDR_LOG_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000120)
#define PCIE_EP_HDR_LOG_1_OFF_OFFSET      0x00000120
#define PCIE_EP_HDR_LOG_1_OFF_INDEX       0x00000048
#define PCIE_EP_HDR_LOG_1_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_hdr_log_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);
}

// field definitions
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_LSB    24
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_LSB    16
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_LSB    8
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_LSB    0
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FOURTH_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_THIRD_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_SECOND_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_1_OFF_SECOND_DWORD_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_hdr_log_1_off_unpack(uint8_t* second_dword_fourth_byte, uint8_t* second_dword_third_byte, uint8_t* second_dword_second_byte, uint8_t* second_dword_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);

	*second_dword_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*second_dword_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*second_dword_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*second_dword_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_hdr_log_1_off_second_dword_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_hdr_log_1_off_second_dword_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_hdr_log_1_off_second_dword_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_hdr_log_1_off_second_dword_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief HDR_LOG_2_OFF register definition
 *  The Header Log Register 2 contains the header for the TLP corresponding to a detected error; The header is captured such that, when read using DW accesses, the fields of the header are laid out in the same way the headers are presented in the specification. Therefore, byte 0 of the header is located in byte 3 of the Header Log Register 2, byte 1 of the header is in byte 2 of the Header Log Register 2 and so forth. For 12-byte headers, only bytes 0 through 11 of the Header Log Register are used and values in bytes 12 through 15 are undefined. In certain cases where a Malformed TLP is reported, the Header Log Register may contain TLP Prefix information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 THIRD_DWORD_FOURTH_BYTE   0x0
 *    23:16 THIRD_DWORD_THIRD_BYTE    0x0
 *    15:08 THIRD_DWORD_SECOND_BYTE   0x0
 *    07:00 THIRD_DWORD_FIRST_BYTE    0x0
 * </pre>
 */
#define PCIE_EP_HDR_LOG_2_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000124)
#define PCIE_EP_HDR_LOG_2_OFF_OFFSET      0x00000124
#define PCIE_EP_HDR_LOG_2_OFF_INDEX       0x00000049
#define PCIE_EP_HDR_LOG_2_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_hdr_log_2_off_get(void)
{
	return REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);
}

// field definitions
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_LSB    24
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_LSB    16
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_LSB    8
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_LSB    0
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FOURTH_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_THIRD_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_SECOND_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_2_OFF_THIRD_DWORD_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_hdr_log_2_off_unpack(uint8_t* third_dword_fourth_byte, uint8_t* third_dword_third_byte, uint8_t* third_dword_second_byte, uint8_t* third_dword_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);

	*third_dword_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*third_dword_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*third_dword_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*third_dword_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_hdr_log_2_off_third_dword_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_hdr_log_2_off_third_dword_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_hdr_log_2_off_third_dword_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_hdr_log_2_off_third_dword_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief HDR_LOG_3_OFF register definition
 *  The Header Log Register 3 contains the header for the TLP corresponding to a detected error; The header is captured such that, when read using DW accesses, the fields of the header are laid out in the same way the headers are presented in the specification. Therefore, byte 0 of the header is located in byte 3 of the Header Log Register 3, byte 1 of the header is in byte 2 of the Header Log Register 3 and so forth. For 12-byte headers, only bytes 0 through 11 of the Header Log Register are used and values in bytes 12 through 15 are undefined. In certain cases where a Malformed TLP is reported, the Header Log Register may contain TLP Prefix information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 FOURTH_DWORD_FOURTH_BYTE  0x0
 *    23:16 FOURTH_DWORD_THIRD_BYTE   0x0
 *    15:08 FOURTH_DWORD_SECOND_BYTE  0x0
 *    07:00 FOURTH_DWORD_FIRST_BYTE   0x0
 * </pre>
 */
#define PCIE_EP_HDR_LOG_3_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000128)
#define PCIE_EP_HDR_LOG_3_OFF_OFFSET      0x00000128
#define PCIE_EP_HDR_LOG_3_OFF_INDEX       0x0000004A
#define PCIE_EP_HDR_LOG_3_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_hdr_log_3_off_get(void)
{
	return REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);
}

// field definitions
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_LSB    24
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_LSB    16
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_LSB    8
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_LSB    0
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FOURTH_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_THIRD_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_SECOND_BYTE_RST    0x0
#define PCIE_EP_HDR_LOG_3_OFF_FOURTH_DWORD_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_hdr_log_3_off_unpack(uint8_t* fourth_dword_fourth_byte, uint8_t* fourth_dword_third_byte, uint8_t* fourth_dword_second_byte, uint8_t* fourth_dword_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);

	*fourth_dword_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*fourth_dword_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*fourth_dword_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*fourth_dword_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_hdr_log_3_off_fourth_dword_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_hdr_log_3_off_fourth_dword_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_hdr_log_3_off_fourth_dword_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_hdr_log_3_off_fourth_dword_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_HDR_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief TLP_PREFIX_LOG_1_OFF register definition
 *  The First TLP Prefix Log Register contains the first End-End TLP Prefix from the TLP corresponding to the detected error.  The TLP Prefix Log Register is only meaningful when the TLP Prefix Log Present bit is Set. The TLP Prefixes are captured such that, when read using DW accesses, the fields of the TLP Prefix are laid out in the same way the fields of the TLP Prefix are described. Therefore, byte 0 of a TLP Prefix is located in byte 3 of the associated TLP Prefix Log Register; byte 1 of a TLP Prefix is located in byte 2; and so forth. The TLP Prefix Log Registers beyond the number supported by the Function are hardwired to zero by controller. If the End-End TLP Prefix Supported bit is Clear, the TLP Prefix Log Register is not required to be implemented. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 CFG_TLP_PFX_LOG_1_FOURTH_BYTE 0x0
 *    23:16 CFG_TLP_PFX_LOG_1_THIRD_BYTE 0x0
 *    15:08 CFG_TLP_PFX_LOG_1_SECOND_BYTE 0x0
 *    07:00 CFG_TLP_PFX_LOG_1_FIRST_BYTE 0x0
 * </pre>
 */
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000138)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_OFFSET      0x00000138
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_INDEX       0x0000004E
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tlp_prefix_log_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_LSB    24
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_LSB    16
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_LSB    8
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_LSB    0
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FOURTH_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_THIRD_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_SECOND_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_1_OFF_CFG_TLP_PFX_LOG_1_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_tlp_prefix_log_1_off_unpack(uint8_t* cfg_tlp_pfx_log_1_fourth_byte, uint8_t* cfg_tlp_pfx_log_1_third_byte, uint8_t* cfg_tlp_pfx_log_1_second_byte, uint8_t* cfg_tlp_pfx_log_1_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);

	*cfg_tlp_pfx_log_1_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*cfg_tlp_pfx_log_1_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*cfg_tlp_pfx_log_1_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*cfg_tlp_pfx_log_1_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_tlp_prefix_log_1_off_cfg_tlp_pfx_log_1_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_1_off_cfg_tlp_pfx_log_1_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_1_off_cfg_tlp_pfx_log_1_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_1_off_cfg_tlp_pfx_log_1_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief TLP_PREFIX_LOG_2_OFF register definition
 *  The Second TLP Prefix Log Register contains the second End-End TLP Prefix from the TLP corresponding to the detected error. The TLP Prefix Log Register is only meaningful when the TLP Prefix Log Present bit is Set. The TLP Prefixes are captured such that, when read using DW accesses, the fields of the TLP Prefix are laid out in the same way the fields of the TLP Prefix are described. Therefore, byte 0 of a TLP Prefix is located in byte 3 of the associated TLP Prefix Log Register; byte 1 of a TLP Prefix is located in byte 2; and so forth. The TLP Prefix Log Registers beyond the number supported by the Function are hardwired to zero by controller. If the End-End TLP Prefix Supported bit is Clear, the TLP Prefix Log Register is not required to be implemented. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 CFG_TLP_PFX_LOG_2_FOURTH_BYTE 0x0
 *    23:16 CFG_TLP_PFX_LOG_2_THIRD_BYTE 0x0
 *    15:08 CFG_TLP_PFX_LOG_2_SECOND_BYTE 0x0
 *    07:00 CFG_TLP_PFX_LOG_2_FIRST_BYTE 0x0
 * </pre>
 */
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000013C)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_OFFSET      0x0000013C
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_INDEX       0x0000004F
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tlp_prefix_log_2_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_LSB    24
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_LSB    16
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_LSB    8
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_LSB    0
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FOURTH_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_THIRD_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_SECOND_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_2_OFF_CFG_TLP_PFX_LOG_2_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_tlp_prefix_log_2_off_unpack(uint8_t* cfg_tlp_pfx_log_2_fourth_byte, uint8_t* cfg_tlp_pfx_log_2_third_byte, uint8_t* cfg_tlp_pfx_log_2_second_byte, uint8_t* cfg_tlp_pfx_log_2_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);

	*cfg_tlp_pfx_log_2_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*cfg_tlp_pfx_log_2_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*cfg_tlp_pfx_log_2_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*cfg_tlp_pfx_log_2_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_tlp_prefix_log_2_off_cfg_tlp_pfx_log_2_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_2_off_cfg_tlp_pfx_log_2_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_2_off_cfg_tlp_pfx_log_2_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_2_off_cfg_tlp_pfx_log_2_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief TLP_PREFIX_LOG_3_OFF register definition
 *  The Third TLP Prefix Log Register contains the third End-End TLP Prefix from the TLP corresponding to the detected error.  The TLP Prefix Log Register is only meaningful when the TLP Prefix Log Present bit is Set. The TLP Prefixes are captured such that, when read using DW accesses, the fields of the TLP Prefix are laid out in the same way the fields of the TLP Prefix are described. Therefore, byte 0 of a TLP Prefix is located in byte 3 of the associated TLP Prefix Log Register; byte 1 of a TLP Prefix is located in byte 2; and so forth. The TLP Prefix Log Registers beyond the number supported by the Function are hardwired to zero by controller. If the End-End TLP Prefix Supported bit is Clear, the TLP Prefix Log Register is not required to be implemented. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 CFG_TLP_PFX_LOG_3_FOURTH_BYTE 0x0
 *    23:16 CFG_TLP_PFX_LOG_3_THIRD_BYTE 0x0
 *    15:08 CFG_TLP_PFX_LOG_3_SECOND_BYTE 0x0
 *    07:00 CFG_TLP_PFX_LOG_3_FIRST_BYTE 0x0
 * </pre>
 */
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000140)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_OFFSET      0x00000140
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_INDEX       0x00000050
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tlp_prefix_log_3_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_LSB    24
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_LSB    16
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_LSB    8
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_LSB    0
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FOURTH_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_THIRD_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_SECOND_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_3_OFF_CFG_TLP_PFX_LOG_3_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_tlp_prefix_log_3_off_unpack(uint8_t* cfg_tlp_pfx_log_3_fourth_byte, uint8_t* cfg_tlp_pfx_log_3_third_byte, uint8_t* cfg_tlp_pfx_log_3_second_byte, uint8_t* cfg_tlp_pfx_log_3_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);

	*cfg_tlp_pfx_log_3_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*cfg_tlp_pfx_log_3_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*cfg_tlp_pfx_log_3_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*cfg_tlp_pfx_log_3_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_tlp_prefix_log_3_off_cfg_tlp_pfx_log_3_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_3_off_cfg_tlp_pfx_log_3_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_3_off_cfg_tlp_pfx_log_3_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_3_off_cfg_tlp_pfx_log_3_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief TLP_PREFIX_LOG_4_OFF register definition
 *  The Fourth TLP Prefix Log Register contains the fourth End-End TLP Prefix from the TLP corresponding to the detected error.  The TLP Prefix Log Register is only meaningful when the TLP Prefix Log Present bit is Set. The TLP Prefixes are captured such that, when read using DW accesses, the fields of the TLP Prefix are laid out in the same way the fields of the TLP Prefix are described. Therefore, byte 0 of a TLP Prefix is located in byte 3 of the associated TLP Prefix Log Register; byte 1 of a TLP Prefix is located in byte 2; and so forth. The TLP Prefix Log Registers beyond the number supported by the Function are hardwired to zero by controller. If the End-End TLP Prefix Supported bit is Clear, the TLP Prefix Log Register is not required to be implemented. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 CFG_TLP_PFX_LOG_4_FOURTH_BYTE 0x0
 *    23:16 CFG_TLP_PFX_LOG_4_THIRD_BYTE 0x0
 *    15:08 CFG_TLP_PFX_LOG_4_SECOND_BYTE 0x0
 *    07:00 CFG_TLP_PFX_LOG_4_FIRST_BYTE 0x0
 * </pre>
 */
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000144)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_OFFSET      0x00000144
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_INDEX       0x00000051
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tlp_prefix_log_4_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_LSB    24
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_LSB    16
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_LSB    8
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_LSB    0
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FOURTH_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_THIRD_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_SECOND_BYTE_RST    0x0
#define PCIE_EP_TLP_PREFIX_LOG_4_OFF_CFG_TLP_PFX_LOG_4_FIRST_BYTE_RST    0x0

__INLINE void pcie_ep_tlp_prefix_log_4_off_unpack(uint8_t* cfg_tlp_pfx_log_4_fourth_byte, uint8_t* cfg_tlp_pfx_log_4_third_byte, uint8_t* cfg_tlp_pfx_log_4_second_byte, uint8_t* cfg_tlp_pfx_log_4_first_byte)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);

	*cfg_tlp_pfx_log_4_fourth_byte = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*cfg_tlp_pfx_log_4_third_byte = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*cfg_tlp_pfx_log_4_second_byte = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*cfg_tlp_pfx_log_4_first_byte = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_tlp_prefix_log_4_off_cfg_tlp_pfx_log_4_fourth_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_4_off_cfg_tlp_pfx_log_4_third_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_4_off_cfg_tlp_pfx_log_4_second_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_tlp_prefix_log_4_off_cfg_tlp_pfx_log_4_first_byte_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TLP_PREFIX_LOG_4_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief VC_BASE register definition
 *  This Register provides Capability Id, Capability version, and next offset of VC Extended Capability Structure. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 VC_NEXT_OFFSET            0x170
 *    19:16 VC_CAP_VERSION            0x1
 *    15:00 VC_PCIE_EXTENDED_CAP_ID   0x2
 * </pre>
 */
#define PCIE_EP_VC_BASE_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000148)
#define PCIE_EP_VC_BASE_OFFSET      0x00000148
#define PCIE_EP_VC_BASE_INDEX       0x00000052
#define PCIE_EP_VC_BASE_RESET       0x17010002

__INLINE uint32_t  pcie_ep_vc_base_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_BASE_ADDR);
}

__INLINE void pcie_ep_vc_base_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_BASE_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_BASE_VC_NEXT_OFFSET_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_VC_BASE_VC_NEXT_OFFSET_LSB    20
#define PCIE_EP_VC_BASE_VC_NEXT_OFFSET_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_VC_BASE_VC_CAP_VERSION_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_VC_BASE_VC_CAP_VERSION_LSB    16
#define PCIE_EP_VC_BASE_VC_CAP_VERSION_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VC_BASE_VC_PCIE_EXTENDED_CAP_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_VC_BASE_VC_PCIE_EXTENDED_CAP_ID_LSB    0
#define PCIE_EP_VC_BASE_VC_PCIE_EXTENDED_CAP_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_VC_BASE_VC_NEXT_OFFSET_RST    0x170
#define PCIE_EP_VC_BASE_VC_CAP_VERSION_RST    0x1
#define PCIE_EP_VC_BASE_VC_PCIE_EXTENDED_CAP_ID_RST    0x2

__INLINE void pcie_ep_vc_base_pack(uint16_t vc_next_offset, uint8_t vc_cap_version, uint16_t vc_pcie_extended_cap_id)
{
	ASSERT_ERR((((uint32_t)vc_next_offset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)vc_cap_version << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)vc_pcie_extended_cap_id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_BASE_ADDR,  ((uint32_t)vc_next_offset << 20) |((uint32_t)vc_cap_version << 16) |((uint32_t)vc_pcie_extended_cap_id << 0));
}

__INLINE void pcie_ep_vc_base_unpack(uint16_t* vc_next_offset, uint8_t* vc_cap_version, uint16_t* vc_pcie_extended_cap_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_BASE_ADDR);

	*vc_next_offset = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*vc_cap_version = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*vc_pcie_extended_cap_id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_vc_base_vc_next_offset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_BASE_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE void pcie_ep_vc_base_vc_next_offset_setf(uint16_t vcnextoffset)
{
	ASSERT_ERR((((uint32_t)vcnextoffset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_BASE_ADDR, (REG_PL_RD(PCIE_EP_VC_BASE_ADDR) & ~((uint32_t)0xFFF00000)) | ((uint32_t)vcnextoffset <<20));
}
__INLINE uint8_t pcie_ep_vc_base_vc_cap_version_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_BASE_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void pcie_ep_vc_base_vc_cap_version_setf(uint8_t vccapversion)
{
	ASSERT_ERR((((uint32_t)vccapversion << 16) & ~((uint32_t)0x000F0000)) == 0);
	REG_PL_WR(PCIE_EP_VC_BASE_ADDR, (REG_PL_RD(PCIE_EP_VC_BASE_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)vccapversion <<16));
}
__INLINE uint16_t pcie_ep_vc_base_vc_pcie_extended_cap_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_BASE_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_vc_base_vc_pcie_extended_cap_id_setf(uint16_t vcpcieextendedcapid)
{
	ASSERT_ERR((((uint32_t)vcpcieextendedcapid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_BASE_ADDR, (REG_PL_RD(PCIE_EP_VC_BASE_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)vcpcieextendedcapid <<0));
}

/**
 * @brief VC_CAPABILITIES_REG_1 register definition
 *  The Port VC Capability Register 1 describes the configuration of the Virtual Channels associated with a PCI Express Port. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:12 RSVDP_12                  0x0
 *    11:10 VC_PORT_ARBI_TBL_ENTRY_SIZE 0x0
 *    09:08 VC_REFERENCE_CLOCK        0x0
 *    07    RSVDP_7                   0              
 *    06:04 VC_LOW_PRI_EXT_VC_CNT     0x0
 *    03    RSVDP_3                   0              
 *    02:00 VC_EXT_VC_CNT             0x1
 * </pre>
 */
#define PCIE_EP_VC_CAPABILITIES_REG_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000014C)
#define PCIE_EP_VC_CAPABILITIES_REG_1_OFFSET      0x0000014C
#define PCIE_EP_VC_CAPABILITIES_REG_1_INDEX       0x00000053
#define PCIE_EP_VC_CAPABILITIES_REG_1_RESET       0x00000001

__INLINE uint32_t  pcie_ep_vc_capabilities_reg_1_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
}

__INLINE void pcie_ep_vc_capabilities_reg_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_12_MASK    ((uint32_t)0xFFFFF000)
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_12_LSB    12
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_12_WIDTH    ((uint32_t)0x00000014)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_PORT_ARBI_TBL_ENTRY_SIZE_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_PORT_ARBI_TBL_ENTRY_SIZE_LSB    10
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_PORT_ARBI_TBL_ENTRY_SIZE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_REFERENCE_CLOCK_MASK    ((uint32_t)0x00000300)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_REFERENCE_CLOCK_LSB    8
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_REFERENCE_CLOCK_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_7_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_7_POS    7
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_LOW_PRI_EXT_VC_CNT_MASK    ((uint32_t)0x00000070)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_LOW_PRI_EXT_VC_CNT_LSB    4
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_LOW_PRI_EXT_VC_CNT_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_3_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_3_POS    3
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_EXT_VC_CNT_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_EXT_VC_CNT_LSB    0
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_EXT_VC_CNT_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_12_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_PORT_ARBI_TBL_ENTRY_SIZE_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_REFERENCE_CLOCK_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_7_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_LOW_PRI_EXT_VC_CNT_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_RSVDP_3_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_1_VC_EXT_VC_CNT_RST    0x1

__INLINE void pcie_ep_vc_capabilities_reg_1_pack(uint32_t rsvdp_12, uint8_t vc_port_arbi_tbl_entry_size, uint8_t vc_reference_clock, uint8_t rsvdp_7, uint8_t vc_low_pri_ext_vc_cnt, uint8_t rsvdp_3, uint8_t vc_ext_vc_cnt)
{
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0xFFFFF000)) == 0);
	ASSERT_ERR((((uint32_t)vc_port_arbi_tbl_entry_size << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)vc_reference_clock << 8) & ~((uint32_t)0x00000300)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_7 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)vc_low_pri_ext_vc_cnt << 4) & ~((uint32_t)0x00000070)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_3 << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)vc_ext_vc_cnt << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR,  ((uint32_t)rsvdp_12 << 12) |((uint32_t)vc_port_arbi_tbl_entry_size << 10) |((uint32_t)vc_reference_clock << 8) |((uint32_t)rsvdp_7 << 7) |((uint32_t)vc_low_pri_ext_vc_cnt << 4) |((uint32_t)rsvdp_3 << 3) |((uint32_t)vc_ext_vc_cnt << 0));
}

__INLINE void pcie_ep_vc_capabilities_reg_1_unpack(uint32_t* rsvdp_12, uint8_t* vc_port_arbi_tbl_entry_size, uint8_t* vc_reference_clock, uint8_t* rsvdp_7, uint8_t* vc_low_pri_ext_vc_cnt, uint8_t* rsvdp_3, uint8_t* vc_ext_vc_cnt)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);

	*rsvdp_12 = (localVal & ((uint32_t)0xFFFFF000)) >>  12;
	*vc_port_arbi_tbl_entry_size = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*vc_reference_clock = (localVal & ((uint32_t)0x00000300)) >>  8;
	*rsvdp_7 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*vc_low_pri_ext_vc_cnt = (localVal & ((uint32_t)0x00000070)) >>  4;
	*rsvdp_3 = (localVal & ((uint32_t)0x00000008)) >>  3;
	*vc_ext_vc_cnt = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint32_t pcie_ep_vc_capabilities_reg_1_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFF000)) >> 12);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_vc_port_arbi_tbl_entry_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_vc_reference_clock_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000300)) >> 8);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_rsvdp_7_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_vc_low_pri_ext_vc_cnt_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000070)) >> 4);
}
__INLINE void pcie_ep_vc_capabilities_reg_1_vc_low_pri_ext_vc_cnt_setf(uint8_t vclowpriextvccnt)
{
	ASSERT_ERR((((uint32_t)vclowpriextvccnt << 4) & ~((uint32_t)0x00000070)) == 0);
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR, (REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR) & ~((uint32_t)0x00000070)) | ((uint32_t)vclowpriextvccnt <<4));
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_rsvdp_3_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_1_vc_ext_vc_cnt_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}

/**
 * @brief VC_CAPABILITIES_REG_2 register definition
 *  The Port VC Capability Register 2 provides further information about the configuration of the Virtual Channels associated with a PCI Express Port. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 VC_ARBI_TABLE_OFFSET      0x0
 *    23:04 RSVDP_4                   0x0
 *    03:00 VC_ARBI_CAP               0x0
 * </pre>
 */
#define PCIE_EP_VC_CAPABILITIES_REG_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000150)
#define PCIE_EP_VC_CAPABILITIES_REG_2_OFFSET      0x00000150
#define PCIE_EP_VC_CAPABILITIES_REG_2_INDEX       0x00000054
#define PCIE_EP_VC_CAPABILITIES_REG_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_vc_capabilities_reg_2_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR);
}

__INLINE void pcie_ep_vc_capabilities_reg_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_TABLE_OFFSET_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_TABLE_OFFSET_LSB    24
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_TABLE_OFFSET_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_CAPABILITIES_REG_2_RSVDP_4_MASK    ((uint32_t)0x00FFFFF0)
#define PCIE_EP_VC_CAPABILITIES_REG_2_RSVDP_4_LSB    4
#define PCIE_EP_VC_CAPABILITIES_REG_2_RSVDP_4_WIDTH    ((uint32_t)0x00000014)
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_CAP_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_CAP_LSB    0
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_CAP_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_TABLE_OFFSET_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_2_RSVDP_4_RST    0x0
#define PCIE_EP_VC_CAPABILITIES_REG_2_VC_ARBI_CAP_RST    0x0

__INLINE void pcie_ep_vc_capabilities_reg_2_pack(uint8_t vc_arbi_table_offset, uint32_t rsvdp_4, uint8_t vc_arbi_cap)
{
	ASSERT_ERR((((uint32_t)vc_arbi_table_offset << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x00FFFFF0)) == 0);
	ASSERT_ERR((((uint32_t)vc_arbi_cap << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR,  ((uint32_t)vc_arbi_table_offset << 24) |((uint32_t)rsvdp_4 << 4) |((uint32_t)vc_arbi_cap << 0));
}

__INLINE void pcie_ep_vc_capabilities_reg_2_unpack(uint8_t* vc_arbi_table_offset, uint32_t* rsvdp_4, uint8_t* vc_arbi_cap)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR);

	*vc_arbi_table_offset = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_4 = (localVal & ((uint32_t)0x00FFFFF0)) >>  4;
	*vc_arbi_cap = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_capabilities_reg_2_vc_arbi_table_offset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint32_t pcie_ep_vc_capabilities_reg_2_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x00FFFFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_vc_capabilities_reg_2_vc_arbi_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void pcie_ep_vc_capabilities_reg_2_vc_arbi_cap_setf(uint8_t vcarbicap)
{
	ASSERT_ERR((((uint32_t)vcarbicap << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR, (REG_PL_RD(PCIE_EP_VC_CAPABILITIES_REG_2_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)vcarbicap <<0));
}

/**
 * @brief VC_STATUS_CONTROL_REG register definition
 *  This register provides the status and controls the behaviour of the extended capability. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:17 RSVDP_17                  0x0
 *    16    VC_ARBI_TABLE_STATUS      0              
 *    15:04 RSVDP_4                   0x0
 *    03:01 VC_ARBI_SELECT            0x0
 *    00    VC_LOAD_VC_ARBI_TABLE     0              
 * </pre>
 */
#define PCIE_EP_VC_STATUS_CONTROL_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000154)
#define PCIE_EP_VC_STATUS_CONTROL_REG_OFFSET      0x00000154
#define PCIE_EP_VC_STATUS_CONTROL_REG_INDEX       0x00000055
#define PCIE_EP_VC_STATUS_CONTROL_REG_RESET       0x00000000

__INLINE uint32_t  pcie_ep_vc_status_control_reg_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
}

__INLINE void pcie_ep_vc_status_control_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_17_MASK    ((uint32_t)0xFFFE0000)
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_17_LSB    17
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_17_WIDTH    ((uint32_t)0x0000000F)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_TABLE_STATUS_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_TABLE_STATUS_POS    16
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_4_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_4_LSB    4
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_4_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_SELECT_MASK    ((uint32_t)0x0000000E)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_SELECT_LSB    1
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_SELECT_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_LOAD_VC_ARBI_TABLE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_LOAD_VC_ARBI_TABLE_POS    0

#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_17_RST    0x0
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_TABLE_STATUS_RST    0x0
#define PCIE_EP_VC_STATUS_CONTROL_REG_RSVDP_4_RST    0x0
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_ARBI_SELECT_RST    0x0
#define PCIE_EP_VC_STATUS_CONTROL_REG_VC_LOAD_VC_ARBI_TABLE_RST    0x0

__INLINE void pcie_ep_vc_status_control_reg_pack(uint16_t rsvdp_17, uint8_t vc_arbi_table_status, uint16_t rsvdp_4, uint8_t vc_arbi_select, uint8_t vc_load_vc_arbi_table)
{
	ASSERT_ERR((((uint32_t)rsvdp_17 << 17) & ~((uint32_t)0xFFFE0000)) == 0);
	ASSERT_ERR((((uint32_t)vc_arbi_table_status << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)vc_arbi_select << 1) & ~((uint32_t)0x0000000E)) == 0);
	ASSERT_ERR((((uint32_t)vc_load_vc_arbi_table << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR,  ((uint32_t)rsvdp_17 << 17) |((uint32_t)vc_arbi_table_status << 16) |((uint32_t)rsvdp_4 << 4) |((uint32_t)vc_arbi_select << 1) |((uint32_t)vc_load_vc_arbi_table << 0));
}

__INLINE void pcie_ep_vc_status_control_reg_unpack(uint16_t* rsvdp_17, uint8_t* vc_arbi_table_status, uint16_t* rsvdp_4, uint8_t* vc_arbi_select, uint8_t* vc_load_vc_arbi_table)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);

	*rsvdp_17 = (localVal & ((uint32_t)0xFFFE0000)) >>  17;
	*vc_arbi_table_status = (localVal & ((uint32_t)0x00010000)) >>  16;
	*rsvdp_4 = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*vc_arbi_select = (localVal & ((uint32_t)0x0000000E)) >>  1;
	*vc_load_vc_arbi_table = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_vc_status_control_reg_rsvdp_17_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFE0000)) >> 17);
}
__INLINE uint8_t pcie_ep_vc_status_control_reg_vc_arbi_table_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint16_t pcie_ep_vc_status_control_reg_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_vc_status_control_reg_vc_arbi_select_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000E)) >> 1);
}
__INLINE void pcie_ep_vc_status_control_reg_vc_arbi_select_setf(uint8_t vcarbiselect)
{
	ASSERT_ERR((((uint32_t)vcarbiselect << 1) & ~((uint32_t)0x0000000E)) == 0);
	REG_PL_WR(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR, (REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR) & ~((uint32_t)0x0000000E)) | ((uint32_t)vcarbiselect <<1));
}
__INLINE uint8_t pcie_ep_vc_status_control_reg_vc_load_vc_arbi_table_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_STATUS_CONTROL_REG_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief RESOURCE_CAP_REG_VC_0 register definition
 *  The VC Resource Capability Register describes the capabilities and configuration of a particular Virtual Channel (0) resource. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 VC_PORT_ARBI_TABLE_VC0    0x0
 *    23:22 RSVDP_22                  0x0
 *    21:16 VC_MAX_TIME_SLOT_VC0      0x0
 *    15    VC_REJECT_SNOOP_TRANS_VC0 0              
 *    14:08 RSVDP_8                   0x0
 *    07:00 VC_PORT_ARBI_CAP_VC0      0x0
 * </pre>
 */
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000158)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_OFFSET      0x00000158
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_INDEX       0x00000056
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_resource_cap_reg_vc_0_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
}

// field definitions
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_TABLE_VC_0_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_TABLE_VC_0_LSB    24
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_TABLE_VC_0_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_22_MASK    ((uint32_t)0x00C00000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_22_LSB    22
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_22_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_MAX_TIME_SLOT_VC_0_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_MAX_TIME_SLOT_VC_0_LSB    16
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_MAX_TIME_SLOT_VC_0_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_REJECT_SNOOP_TRANS_VC_0_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_REJECT_SNOOP_TRANS_VC_0_POS    15
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_8_MASK    ((uint32_t)0x00007F00)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_8_LSB    8
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_8_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_CAP_VC_0_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_CAP_VC_0_LSB    0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_CAP_VC_0_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_TABLE_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_22_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_MAX_TIME_SLOT_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_REJECT_SNOOP_TRANS_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_RSVDP_8_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_0_VC_PORT_ARBI_CAP_VC_0_RST    0x0

__INLINE void pcie_ep_resource_cap_reg_vc_0_unpack(uint8_t* vc_port_arbi_table_vc0, uint8_t* rsvdp_22, uint8_t* vc_max_time_slot_vc0, uint8_t* vc_reject_snoop_trans_vc0, uint8_t* rsvdp_8, uint8_t* vc_port_arbi_cap_vc0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);

	*vc_port_arbi_table_vc0 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_22 = (localVal & ((uint32_t)0x00C00000)) >>  22;
	*vc_max_time_slot_vc0 = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*vc_reject_snoop_trans_vc0 = (localVal & ((uint32_t)0x00008000)) >>  15;
	*rsvdp_8 = (localVal & ((uint32_t)0x00007F00)) >>  8;
	*vc_port_arbi_cap_vc0 = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_vc_port_arbi_table_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_rsvdp_22_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00C00000)) >> 22);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_vc_max_time_slot_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_vc_reject_snoop_trans_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007F00)) >> 8);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_0_vc_port_arbi_cap_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief RESOURCE_CON_REG_VC_0 register definition
 *  This Register provides VC Enable, VC ID, port Arbitration table and select, and so on for VC (0). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    VC_ENABLE_VC0             1              
 *    30:27 RSVDP_27                  0x0
 *    26:24 VC_ID_VC                  0x0
 *    23:18 RSVDP_18                  0x0
 *    17    VC_PORT_ARBI_SELECT_VC0   0              
 *    16    VC_LOAD_PORT_ARBI_TABLE_VC0 0              
 *    15:08 RSVDP_8                   0x0
 *    07:01 VC_TC_MAP_VC0_BIT1        0x7f
 *    00    VC_TC_MAP_VC0             1              
 * </pre>
 */
#define PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000015C)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_OFFSET      0x0000015C
#define PCIE_EP_RESOURCE_CON_REG_VC_0_INDEX       0x00000057
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RESET       0x800000FF

__INLINE uint32_t  pcie_ep_resource_con_reg_vc_0_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
}

__INLINE void pcie_ep_resource_con_reg_vc_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR, value);
}

// field definitions
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ENABLE_VC_0_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ENABLE_VC_0_POS    31
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_27_MASK    ((uint32_t)0x78000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_27_LSB    27
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_27_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ID_VC_MASK    ((uint32_t)0x07000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ID_VC_LSB    24
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ID_VC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_18_MASK    ((uint32_t)0x00FC0000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_18_LSB    18
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_18_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_PORT_ARBI_SELECT_VC_0_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_PORT_ARBI_SELECT_VC_0_POS    17
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_LOAD_PORT_ARBI_TABLE_VC_0_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_LOAD_PORT_ARBI_TABLE_VC_0_POS    16
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_8_LSB    8
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_BIT_1_MASK    ((uint32_t)0x000000FE)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_BIT_1_LSB    1
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_BIT_1_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_POS    0

#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ENABLE_VC_0_RST    0x1
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_27_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_ID_VC_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_18_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_PORT_ARBI_SELECT_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_LOAD_PORT_ARBI_TABLE_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_RSVDP_8_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_BIT_1_RST    0x7f
#define PCIE_EP_RESOURCE_CON_REG_VC_0_VC_TC_MAP_VC_0_RST    0x1

__INLINE void pcie_ep_resource_con_reg_vc_0_pack(uint8_t vc_enable_vc0, uint8_t rsvdp_27, uint8_t vc_id_vc, uint8_t rsvdp_18, uint8_t vc_port_arbi_select_vc0, uint8_t vc_load_port_arbi_table_vc0, uint8_t rsvdp_8, uint8_t vc_tc_map_vc0_bit1, uint8_t vc_tc_map_vc0)
{
	ASSERT_ERR((((uint32_t)vc_enable_vc0 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_27 << 27) & ~((uint32_t)0x78000000)) == 0);
	ASSERT_ERR((((uint32_t)vc_id_vc << 24) & ~((uint32_t)0x07000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_18 << 18) & ~((uint32_t)0x00FC0000)) == 0);
	ASSERT_ERR((((uint32_t)vc_port_arbi_select_vc0 << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)vc_load_port_arbi_table_vc0 << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)vc_tc_map_vc0_bit1 << 1) & ~((uint32_t)0x000000FE)) == 0);
	ASSERT_ERR((((uint32_t)vc_tc_map_vc0 << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR,  ((uint32_t)vc_enable_vc0 << 31) |((uint32_t)rsvdp_27 << 27) |((uint32_t)vc_id_vc << 24) |((uint32_t)rsvdp_18 << 18) |((uint32_t)vc_port_arbi_select_vc0 << 17) |((uint32_t)vc_load_port_arbi_table_vc0 << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)vc_tc_map_vc0_bit1 << 1) |((uint32_t)vc_tc_map_vc0 << 0));
}

__INLINE void pcie_ep_resource_con_reg_vc_0_unpack(uint8_t* vc_enable_vc0, uint8_t* rsvdp_27, uint8_t* vc_id_vc, uint8_t* rsvdp_18, uint8_t* vc_port_arbi_select_vc0, uint8_t* vc_load_port_arbi_table_vc0, uint8_t* rsvdp_8, uint8_t* vc_tc_map_vc0_bit1, uint8_t* vc_tc_map_vc0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);

	*vc_enable_vc0 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_27 = (localVal & ((uint32_t)0x78000000)) >>  27;
	*vc_id_vc = (localVal & ((uint32_t)0x07000000)) >>  24;
	*rsvdp_18 = (localVal & ((uint32_t)0x00FC0000)) >>  18;
	*vc_port_arbi_select_vc0 = (localVal & ((uint32_t)0x00020000)) >>  17;
	*vc_load_port_arbi_table_vc0 = (localVal & ((uint32_t)0x00010000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*vc_tc_map_vc0_bit1 = (localVal & ((uint32_t)0x000000FE)) >>  1;
	*vc_tc_map_vc0 = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_vc_enable_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_rsvdp_27_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x78000000)) >> 27);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_vc_id_vc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x07000000)) >> 24);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_rsvdp_18_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FC0000)) >> 18);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_vc_port_arbi_select_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_resource_con_reg_vc_0_vc_load_port_arbi_table_vc_0_setf(uint8_t vcloadportarbitablevc0)
{
	ASSERT_ERR((((uint32_t)vcloadportarbitablevc0 << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)vcloadportarbitablevc0 <<16));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_vc_tc_map_vc_0_bit_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FE)) >> 1);
}
__INLINE void pcie_ep_resource_con_reg_vc_0_vc_tc_map_vc_0_bit_1_setf(uint8_t vctcmapvc0bit1)
{
	ASSERT_ERR((((uint32_t)vctcmapvc0bit1 << 1) & ~((uint32_t)0x000000FE)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR) & ~((uint32_t)0x000000FE)) | ((uint32_t)vctcmapvc0bit1 <<1));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_0_vc_tc_map_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief RESOURCE_STATUS_REG_VC_0 register definition
 *  This Register provides VC Port Arbitration table status and VC Negotiation Pending status for VC(0). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:18 RSVDP_18                  0x0
 *    17    VC_NEGO_PENDING_VC0       1              
 *    16    VC_PORT_ARBI_TABLE_STATUS_VC0 0              
 *    15:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000160)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_OFFSET      0x00000160
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_INDEX       0x00000058
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RESET       0x00020000

__INLINE uint32_t  pcie_ep_resource_status_reg_vc_0_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);
}

// field definitions
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_18_MASK    ((uint32_t)0xFFFC0000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_18_LSB    18
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_18_WIDTH    ((uint32_t)0x0000000E)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_NEGO_PENDING_VC_0_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_NEGO_PENDING_VC_0_POS    17
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_PORT_ARBI_TABLE_STATUS_VC_0_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_PORT_ARBI_TABLE_STATUS_VC_0_POS    16
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_0_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_0_LSB    0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_0_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_18_RST    0x0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_NEGO_PENDING_VC_0_RST    0x1
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_VC_PORT_ARBI_TABLE_STATUS_VC_0_RST    0x0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_0_RSVDP_0_RST    0x0

__INLINE void pcie_ep_resource_status_reg_vc_0_unpack(uint16_t* rsvdp_18, uint8_t* vc_nego_pending_vc0, uint8_t* vc_port_arbi_table_status_vc0, uint16_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);

	*rsvdp_18 = (localVal & ((uint32_t)0xFFFC0000)) >>  18;
	*vc_nego_pending_vc0 = (localVal & ((uint32_t)0x00020000)) >>  17;
	*vc_port_arbi_table_status_vc0 = (localVal & ((uint32_t)0x00010000)) >>  16;
	*rsvdp_0 = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_resource_status_reg_vc_0_rsvdp_18_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFC0000)) >> 18);
}
__INLINE uint8_t pcie_ep_resource_status_reg_vc_0_vc_nego_pending_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE uint8_t pcie_ep_resource_status_reg_vc_0_vc_port_arbi_table_status_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint16_t pcie_ep_resource_status_reg_vc_0_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief RESOURCE_CAP_REG_VC_1 register definition
 *  The VC Resource Capability Register describes the capabilities and configuration of a particular Virtual Channel (1) resource. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 VC_PORT_ARBI_TABLE_VC1    0x0
 *    23:22 RSVDP_22                  0x0
 *    21:16 VC_MAX_TIME_SLOT_VC1      0x0
 *    15    VC_REJECT_SNOOP_TRANS_VC1 0              
 *    14:08 RSVDP_8                   0x0
 *    07:00 VC_PORT_ARBI_CAP_VC1      0x0
 * </pre>
 */
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000164)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_OFFSET      0x00000164
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_INDEX       0x00000059
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_resource_cap_reg_vc_1_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
}

// field definitions
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_TABLE_VC_1_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_TABLE_VC_1_LSB    24
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_TABLE_VC_1_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_22_MASK    ((uint32_t)0x00C00000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_22_LSB    22
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_22_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_MAX_TIME_SLOT_VC_1_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_MAX_TIME_SLOT_VC_1_LSB    16
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_MAX_TIME_SLOT_VC_1_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_REJECT_SNOOP_TRANS_VC_1_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_REJECT_SNOOP_TRANS_VC_1_POS    15
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_8_MASK    ((uint32_t)0x00007F00)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_8_LSB    8
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_8_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_CAP_VC_1_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_CAP_VC_1_LSB    0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_CAP_VC_1_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_TABLE_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_22_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_MAX_TIME_SLOT_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_REJECT_SNOOP_TRANS_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_RSVDP_8_RST    0x0
#define PCIE_EP_RESOURCE_CAP_REG_VC_1_VC_PORT_ARBI_CAP_VC_1_RST    0x0

__INLINE void pcie_ep_resource_cap_reg_vc_1_unpack(uint8_t* vc_port_arbi_table_vc1, uint8_t* rsvdp_22, uint8_t* vc_max_time_slot_vc1, uint8_t* vc_reject_snoop_trans_vc1, uint8_t* rsvdp_8, uint8_t* vc_port_arbi_cap_vc1)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);

	*vc_port_arbi_table_vc1 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_22 = (localVal & ((uint32_t)0x00C00000)) >>  22;
	*vc_max_time_slot_vc1 = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*vc_reject_snoop_trans_vc1 = (localVal & ((uint32_t)0x00008000)) >>  15;
	*rsvdp_8 = (localVal & ((uint32_t)0x00007F00)) >>  8;
	*vc_port_arbi_cap_vc1 = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_vc_port_arbi_table_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_rsvdp_22_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00C00000)) >> 22);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_vc_max_time_slot_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_vc_reject_snoop_trans_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007F00)) >> 8);
}
__INLINE uint8_t pcie_ep_resource_cap_reg_vc_1_vc_port_arbi_cap_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CAP_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief RESOURCE_CON_REG_VC_1 register definition
 *  This Register provides VC Enable, VC ID, port Arbitration table and select, and so on for VC (1). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    VC_ENABLE_VC1             0              
 *    30:27 RSVDP_27                  0x0
 *    26:24 VC_ID_VC1                 0x0
 *    23:20 RSVDP_20                  0x0
 *    19:17 VC_PORT_ARBI_SELECT_VC1   0x0
 *    16    VC_LOAD_PORT_ARBI_TABLE_VC1 0              
 *    15:08 RSVDP_8                   0x0
 *    07:01 VC_TC_MAP_VC1_BIT1        0x0
 *    00    VC_TC_MAP_VC1             0              
 * </pre>
 */
#define PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000168)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_OFFSET      0x00000168
#define PCIE_EP_RESOURCE_CON_REG_VC_1_INDEX       0x0000005A
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_resource_con_reg_vc_1_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
}

__INLINE void pcie_ep_resource_con_reg_vc_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR, value);
}

// field definitions
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ENABLE_VC_1_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ENABLE_VC_1_POS    31
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_27_MASK    ((uint32_t)0x78000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_27_LSB    27
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_27_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ID_VC_1_MASK    ((uint32_t)0x07000000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ID_VC_1_LSB    24
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ID_VC_1_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_20_MASK    ((uint32_t)0x00F00000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_20_LSB    20
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_20_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_PORT_ARBI_SELECT_VC_1_MASK    ((uint32_t)0x000E0000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_PORT_ARBI_SELECT_VC_1_LSB    17
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_PORT_ARBI_SELECT_VC_1_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_LOAD_PORT_ARBI_TABLE_VC_1_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_LOAD_PORT_ARBI_TABLE_VC_1_POS    16
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_8_LSB    8
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_BIT_1_MASK    ((uint32_t)0x000000FE)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_BIT_1_LSB    1
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_BIT_1_WIDTH    ((uint32_t)0x00000007)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_POS    0

#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ENABLE_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_27_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_ID_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_20_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_PORT_ARBI_SELECT_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_LOAD_PORT_ARBI_TABLE_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_RSVDP_8_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_BIT_1_RST    0x0
#define PCIE_EP_RESOURCE_CON_REG_VC_1_VC_TC_MAP_VC_1_RST    0x0

__INLINE void pcie_ep_resource_con_reg_vc_1_pack(uint8_t vc_enable_vc1, uint8_t rsvdp_27, uint8_t vc_id_vc1, uint8_t rsvdp_20, uint8_t vc_port_arbi_select_vc1, uint8_t vc_load_port_arbi_table_vc1, uint8_t rsvdp_8, uint8_t vc_tc_map_vc1_bit1, uint8_t vc_tc_map_vc1)
{
	ASSERT_ERR((((uint32_t)vc_enable_vc1 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_27 << 27) & ~((uint32_t)0x78000000)) == 0);
	ASSERT_ERR((((uint32_t)vc_id_vc1 << 24) & ~((uint32_t)0x07000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0x00F00000)) == 0);
	ASSERT_ERR((((uint32_t)vc_port_arbi_select_vc1 << 17) & ~((uint32_t)0x000E0000)) == 0);
	ASSERT_ERR((((uint32_t)vc_load_port_arbi_table_vc1 << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)vc_tc_map_vc1_bit1 << 1) & ~((uint32_t)0x000000FE)) == 0);
	ASSERT_ERR((((uint32_t)vc_tc_map_vc1 << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR,  ((uint32_t)vc_enable_vc1 << 31) |((uint32_t)rsvdp_27 << 27) |((uint32_t)vc_id_vc1 << 24) |((uint32_t)rsvdp_20 << 20) |((uint32_t)vc_port_arbi_select_vc1 << 17) |((uint32_t)vc_load_port_arbi_table_vc1 << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)vc_tc_map_vc1_bit1 << 1) |((uint32_t)vc_tc_map_vc1 << 0));
}

__INLINE void pcie_ep_resource_con_reg_vc_1_unpack(uint8_t* vc_enable_vc1, uint8_t* rsvdp_27, uint8_t* vc_id_vc1, uint8_t* rsvdp_20, uint8_t* vc_port_arbi_select_vc1, uint8_t* vc_load_port_arbi_table_vc1, uint8_t* rsvdp_8, uint8_t* vc_tc_map_vc1_bit1, uint8_t* vc_tc_map_vc1)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);

	*vc_enable_vc1 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_27 = (localVal & ((uint32_t)0x78000000)) >>  27;
	*vc_id_vc1 = (localVal & ((uint32_t)0x07000000)) >>  24;
	*rsvdp_20 = (localVal & ((uint32_t)0x00F00000)) >>  20;
	*vc_port_arbi_select_vc1 = (localVal & ((uint32_t)0x000E0000)) >>  17;
	*vc_load_port_arbi_table_vc1 = (localVal & ((uint32_t)0x00010000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*vc_tc_map_vc1_bit1 = (localVal & ((uint32_t)0x000000FE)) >>  1;
	*vc_tc_map_vc1 = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_vc_enable_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_resource_con_reg_vc_1_vc_enable_vc_1_setf(uint8_t vcenablevc1)
{
	ASSERT_ERR((((uint32_t)vcenablevc1 << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)vcenablevc1 <<31));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_rsvdp_27_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x78000000)) >> 27);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_vc_id_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x07000000)) >> 24);
}
__INLINE void pcie_ep_resource_con_reg_vc_1_vc_id_vc_1_setf(uint8_t vcidvc1)
{
	ASSERT_ERR((((uint32_t)vcidvc1 << 24) & ~((uint32_t)0x07000000)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR) & ~((uint32_t)0x07000000)) | ((uint32_t)vcidvc1 <<24));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_vc_port_arbi_select_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000E0000)) >> 17);
}
__INLINE void pcie_ep_resource_con_reg_vc_1_vc_load_port_arbi_table_vc_1_setf(uint8_t vcloadportarbitablevc1)
{
	ASSERT_ERR((((uint32_t)vcloadportarbitablevc1 << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)vcloadportarbitablevc1 <<16));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_vc_tc_map_vc_1_bit_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FE)) >> 1);
}
__INLINE void pcie_ep_resource_con_reg_vc_1_vc_tc_map_vc_1_bit_1_setf(uint8_t vctcmapvc1bit1)
{
	ASSERT_ERR((((uint32_t)vctcmapvc1bit1 << 1) & ~((uint32_t)0x000000FE)) == 0);
	REG_PL_WR(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR, (REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR) & ~((uint32_t)0x000000FE)) | ((uint32_t)vctcmapvc1bit1 <<1));
}
__INLINE uint8_t pcie_ep_resource_con_reg_vc_1_vc_tc_map_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_CON_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief RESOURCE_STATUS_REG_VC_1 register definition
 *  This Register provides VC Port Arbitration table status and VC Negotiation Pending status for VC(1). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:18 RSVDP_18                  0x0
 *    17    VC_NEGO_PENDING_VC1       0              
 *    16    VC_PORT_ARBI_TABLE_STATUS_VC1 0              
 *    15:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000016C)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_OFFSET      0x0000016C
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_INDEX       0x0000005B
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_resource_status_reg_vc_1_get(void)
{
	return REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);
}

// field definitions
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_18_MASK    ((uint32_t)0xFFFC0000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_18_LSB    18
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_18_WIDTH    ((uint32_t)0x0000000E)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_NEGO_PENDING_VC_1_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_NEGO_PENDING_VC_1_POS    17
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_PORT_ARBI_TABLE_STATUS_VC_1_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_PORT_ARBI_TABLE_STATUS_VC_1_POS    16
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_0_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_0_LSB    0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_0_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_18_RST    0x0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_NEGO_PENDING_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_VC_PORT_ARBI_TABLE_STATUS_VC_1_RST    0x0
#define PCIE_EP_RESOURCE_STATUS_REG_VC_1_RSVDP_0_RST    0x0

__INLINE void pcie_ep_resource_status_reg_vc_1_unpack(uint16_t* rsvdp_18, uint8_t* vc_nego_pending_vc1, uint8_t* vc_port_arbi_table_status_vc1, uint16_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);

	*rsvdp_18 = (localVal & ((uint32_t)0xFFFC0000)) >>  18;
	*vc_nego_pending_vc1 = (localVal & ((uint32_t)0x00020000)) >>  17;
	*vc_port_arbi_table_status_vc1 = (localVal & ((uint32_t)0x00010000)) >>  16;
	*rsvdp_0 = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_resource_status_reg_vc_1_rsvdp_18_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFC0000)) >> 18);
}
__INLINE uint8_t pcie_ep_resource_status_reg_vc_1_vc_nego_pending_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE uint8_t pcie_ep_resource_status_reg_vc_1_vc_port_arbi_table_status_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE uint16_t pcie_ep_resource_status_reg_vc_1_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_RESOURCE_STATUS_REG_VC_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief VSECDMA_EXT_CAP_HDR_OFF register definition
 *  This register provides capability ID, capability version, and next capability offset for PCIe extended capability structure.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 NEXT_OFFSET               0x0
 *    19:16 CAP                       0x1
 *    15:00 ID                        0xb
 * </pre>
 */
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000170)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_OFFSET      0x00000170
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_INDEX       0x0000005C
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_RESET       0x0001000B

__INLINE uint32_t  pcie_ep_vsecdma_ext_cap_hdr_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR);
}

__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_LSB    20
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_CAP_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_CAP_LSB    16
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_CAP_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ID_LSB    0
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_NEXT_OFFSET_RST    0x0
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_CAP_RST    0x1
#define PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ID_RST    0xb

__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_pack(uint16_t next_offset, uint8_t cap, uint16_t id)
{
	ASSERT_ERR((((uint32_t)next_offset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)cap << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR,  ((uint32_t)next_offset << 20) |((uint32_t)cap << 16) |((uint32_t)id << 0));
}

__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_unpack(uint16_t* next_offset, uint8_t* cap, uint16_t* id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR);

	*next_offset = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*cap = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_vsecdma_ext_cap_hdr_off_next_offset_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_next_offset_setf(uint16_t nextoffset)
{
	ASSERT_ERR((((uint32_t)nextoffset << 20) & ~((uint32_t)0xFFF00000)) == 0);
	REG_PL_WR(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0xFFF00000)) | ((uint32_t)nextoffset <<20));
}
__INLINE uint8_t pcie_ep_vsecdma_ext_cap_hdr_off_cap_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_cap_setf(uint8_t cap)
{
	ASSERT_ERR((((uint32_t)cap << 16) & ~((uint32_t)0x000F0000)) == 0);
	REG_PL_WR(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0x000F0000)) | ((uint32_t)cap <<16));
}
__INLINE uint16_t pcie_ep_vsecdma_ext_cap_hdr_off_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_vsecdma_ext_cap_hdr_off_id_setf(uint16_t id)
{
	ASSERT_ERR((((uint32_t)id << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR, (REG_PL_RD(PCIE_EP_VSECDMA_EXT_CAP_HDR_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)id <<0));
}

/**
 * @brief VSECDMA_VENDOR_SPECIFIC_HDR_OFF register definition
 *  This Register provides VSEC Length, VSEC ID, and VSEC Rev(Version Number). Vendor-specific software must qualify the associated Vendor ID of the PCI Express Function or RCRB before attempting to interpret the values in the VSEC ID or VSEC Rev fields.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 VSEC_LENGTH               0x18
 *    19:16 VSEC_REV                  0x0
 *    15:00 VSEC_ID                   0x6
 * </pre>
 */
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000174)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_OFFSET      0x00000174
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_INDEX       0x0000005D
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_RESET       0x01800006

__INLINE uint32_t  pcie_ep_vsecdma_vendor_specific_hdr_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_LSB    20
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_LSB    16
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_LSB    0
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_LENGTH_RST    0x18
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_REV_RST    0x0
#define PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_VSEC_ID_RST    0x6

__INLINE void pcie_ep_vsecdma_vendor_specific_hdr_off_unpack(uint16_t* vsec_length, uint8_t* vsec_rev, uint16_t* vsec_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR);

	*vsec_length = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*vsec_rev = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*vsec_id = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_vsecdma_vendor_specific_hdr_off_vsec_length_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_vsecdma_vendor_specific_hdr_off_vsec_rev_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE uint16_t pcie_ep_vsecdma_vendor_specific_hdr_off_vsec_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_VENDOR_SPECIFIC_HDR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief VSECDMA_DEVICE_INFORMATION_OFF register definition
 *  This register provides DMA and AXI Bridge implementation-specific information:  -  DMA Architecture: Legacy DMA or Hyper DMA (HDMA).  -  Register Location: Port-logic or Mapped to a Function and BAR.  -  Register Map: Legacy DMA or HDMA.  -  Channel Separation: Address distance between read and write channels.  -  AXI Bridge: Used or Not Used  -  AXI Master Bus Specification: AXI Master Bus Width, Burst Length, and Boundary Pointer Width You must use this information along with the IP version registers:  -  PCIE_VERSION_NUMBER_OFF  -  PCIE_VERSION_TYPE_OFF  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 RSVDP_30                  0x0
 *    29:26 MASTER_PAGE_BOUNDARY_POINTER_WIDTH 0xd
 *    25:23 MASTER_BURST_LENGTH       0x4
 *    22:20 MASTER_BUS_WIDTH          0x0
 *    19    AXI                       1              
 *    18:16 CHANNEL_SEPARATION        0x0
 *    15:11 PFN                       0x0
 *    10:08 BARN                      0x0
 *    07:03 RSVDP_3                   0x0
 *    02:00 MAP_FORMAT                0x0
 * </pre>
 */
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000178)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_OFFSET      0x00000178
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_INDEX       0x0000005E
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RESET       0x36080000

__INLINE uint32_t  pcie_ep_vsecdma_device_information_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_30_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_30_LSB    30
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_30_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_POINTER_WIDTH_MASK    ((uint32_t)0x3C000000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_POINTER_WIDTH_LSB    26
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_POINTER_WIDTH_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_MASK    ((uint32_t)0x03800000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_LSB    23
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_LSB    20
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_POS    19
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_CHANNEL_SEPARATION_MASK    ((uint32_t)0x00070000)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_CHANNEL_SEPARATION_LSB    16
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_CHANNEL_SEPARATION_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_MASK    ((uint32_t)0x0000F800)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_LSB    11
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_MASK    ((uint32_t)0x00000700)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_LSB    8
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_3_MASK    ((uint32_t)0x000000F8)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_3_LSB    3
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_3_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MAP_FORMAT_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MAP_FORMAT_LSB    0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MAP_FORMAT_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_30_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_PAGE_BOUNDARY_POINTER_WIDTH_RST    0xd
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BURST_LENGTH_RST    0x4
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MASTER_BUS_WIDTH_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_AXI_RST    0x1
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_CHANNEL_SEPARATION_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_PFN_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_BARN_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_RSVDP_3_RST    0x0
#define PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_MAP_FORMAT_RST    0x0

__INLINE void pcie_ep_vsecdma_device_information_off_unpack(uint8_t* rsvdp_30, uint8_t* master_page_boundary_pointer_width, uint8_t* master_burst_length, uint8_t* master_bus_width, uint8_t* axi, uint8_t* channel_separation, uint8_t* pfn, uint8_t* barn, uint8_t* rsvdp_3, uint8_t* map_format)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);

	*rsvdp_30 = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*master_page_boundary_pointer_width = (localVal & ((uint32_t)0x3C000000)) >>  26;
	*master_burst_length = (localVal & ((uint32_t)0x03800000)) >>  23;
	*master_bus_width = (localVal & ((uint32_t)0x00700000)) >>  20;
	*axi = (localVal & ((uint32_t)0x00080000)) >>  19;
	*channel_separation = (localVal & ((uint32_t)0x00070000)) >>  16;
	*pfn = (localVal & ((uint32_t)0x0000F800)) >>  11;
	*barn = (localVal & ((uint32_t)0x00000700)) >>  8;
	*rsvdp_3 = (localVal & ((uint32_t)0x000000F8)) >>  3;
	*map_format = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint8_t pcie_ep_vsecdma_device_information_off_rsvdp_30_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_master_page_boundary_pointer_width_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x3C000000)) >> 26);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_master_burst_length_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03800000)) >> 23);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_master_bus_width_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_axi_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_channel_separation_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00070000)) >> 16);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_pfn_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000F800)) >> 11);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_barn_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000700)) >> 8);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_rsvdp_3_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F8)) >> 3);
}
__INLINE uint8_t pcie_ep_vsecdma_device_information_off_map_format_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_DEVICE_INFORMATION_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}

/**
 * @brief VSECDMA_NUM_CHAN_OFF register definition
 *  This register specifies the number of read and write channels implemented.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:26 RSVDP_26                  0x0
 *    25:16 NUM_DMA_RD_CHAN           0x8
 *    15:10 RSVDP_10                  0x0
 *    09:00 NUM_DMA_WR_CHAN           0x8
 * </pre>
 */
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000017C)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_OFFSET      0x0000017C
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_INDEX       0x0000005F
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RESET       0x00080008

__INLINE uint32_t  pcie_ep_vsecdma_num_chan_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_26_MASK    ((uint32_t)0xFC000000)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_26_LSB    26
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_26_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_MASK    ((uint32_t)0x03FF0000)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_LSB    16
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_WIDTH    ((uint32_t)0x0000000A)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_10_MASK    ((uint32_t)0x0000FC00)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_10_LSB    10
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_10_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_MASK    ((uint32_t)0x000003FF)
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_LSB    0
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_WIDTH    ((uint32_t)0x0000000A)

#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_26_RST    0x0
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_RD_CHAN_RST    0x8
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_RSVDP_10_RST    0x0
#define PCIE_EP_VSECDMA_NUM_CHAN_OFF_NUM_DMA_WR_CHAN_RST    0x8

__INLINE void pcie_ep_vsecdma_num_chan_off_unpack(uint8_t* rsvdp_26, uint16_t* num_dma_rd_chan, uint8_t* rsvdp_10, uint16_t* num_dma_wr_chan)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);

	*rsvdp_26 = (localVal & ((uint32_t)0xFC000000)) >>  26;
	*num_dma_rd_chan = (localVal & ((uint32_t)0x03FF0000)) >>  16;
	*rsvdp_10 = (localVal & ((uint32_t)0x0000FC00)) >>  10;
	*num_dma_wr_chan = (localVal & ((uint32_t)0x000003FF)) >>  0;
}

__INLINE uint8_t pcie_ep_vsecdma_num_chan_off_rsvdp_26_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFC000000)) >> 26);
}
__INLINE uint16_t pcie_ep_vsecdma_num_chan_off_num_dma_rd_chan_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x03FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_vsecdma_num_chan_off_rsvdp_10_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FC00)) >> 10);
}
__INLINE uint16_t pcie_ep_vsecdma_num_chan_off_num_dma_wr_chan_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_NUM_CHAN_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x000003FF)) >> 0);
}

/**
 * @brief VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF register definition
 *  This register specifies the lower 32 bits of the offset of the start address of the DMA register map. Applicable only if MAP_FORMAT  0, that is, all map formats other than EDMA_LEGACY_PL.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UNROLL_ADDR_OFFSET_LOW    0x0
 * </pre>
 */
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000180)
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_OFFSET      0x00000180
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_INDEX       0x00000060
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_vsecdma_unroll_addr_offset_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_LSB    0
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_UNROLL_ADDR_OFFSET_LOW_RST    0x0

__INLINE uint32_t pcie_ep_vsecdma_unroll_addr_offset_low_off_unroll_addr_offset_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_LOW_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF register definition
 *  This register specifies the upper 32 bits of the offset of the start address of the DMA register map. Applicable only if MAP_FORMAT  0, that is, all map formats other than EDMA_LEGACY_PL.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UNROLL_ADDR_OFFSET_HIGH   0x0
 * </pre>
 */
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000184)
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_OFFSET      0x00000184
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_INDEX       0x00000061
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_vsecdma_unroll_addr_offset_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_LSB    0
#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_UNROLL_ADDR_OFFSET_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_vsecdma_unroll_addr_offset_high_off_unroll_addr_offset_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VSECDMA_UNROLL_ADDR_OFFSET_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief ACK_LATENCY_TIMER_OFF register definition
 *  This register holds the ack latency timer limit and replay timer limit values. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 REPLAY_TIME_LIMIT         0x1846
 *    15:00 ROUND_TRIP_LATENCY_TIME_LIMIT 0x817
 * </pre>
 */
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000700)
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_OFFSET      0x00000700
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_INDEX       0x000001C0
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_RESET       0x18460817

__INLINE uint32_t  pcie_ep_ack_latency_timer_off_get(void)
{
	return REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR);
}

__INLINE void pcie_ep_ack_latency_timer_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_LSB    16
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_LSB    0
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_ACK_LATENCY_TIMER_OFF_REPLAY_TIME_LIMIT_RST    0x1846
#define PCIE_EP_ACK_LATENCY_TIMER_OFF_ROUND_TRIP_LATENCY_TIME_LIMIT_RST    0x817

__INLINE void pcie_ep_ack_latency_timer_off_pack(uint16_t replay_time_limit, uint16_t round_trip_latency_time_limit)
{
	ASSERT_ERR((((uint32_t)replay_time_limit << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)round_trip_latency_time_limit << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR,  ((uint32_t)replay_time_limit << 16) |((uint32_t)round_trip_latency_time_limit << 0));
}

__INLINE void pcie_ep_ack_latency_timer_off_unpack(uint16_t* replay_time_limit, uint16_t* round_trip_latency_time_limit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR);

	*replay_time_limit = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*round_trip_latency_time_limit = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_ack_latency_timer_off_replay_time_limit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_ack_latency_timer_off_replay_time_limit_setf(uint16_t replaytimelimit)
{
	ASSERT_ERR((((uint32_t)replaytimelimit << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)replaytimelimit <<16));
}
__INLINE uint16_t pcie_ep_ack_latency_timer_off_round_trip_latency_time_limit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_ack_latency_timer_off_round_trip_latency_time_limit_setf(uint16_t roundtriplatencytimelimit)
{
	ASSERT_ERR((((uint32_t)roundtriplatencytimelimit << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_LATENCY_TIMER_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)roundtriplatencytimelimit <<0));
}

/**
 * @brief VENDOR_SPEC_DLLP_OFF register definition
 *  This register holds the vendor specific DLLP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 VENDOR_SPEC_DLLP          0xffffffff
 * </pre>
 */
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000704)
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_OFFSET      0x00000704
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_INDEX       0x000001C1
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_RESET       0xFFFFFFFF

__INLINE uint32_t  pcie_ep_vendor_spec_dllp_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VENDOR_SPEC_DLLP_OFF_ADDR);
}

__INLINE void pcie_ep_vendor_spec_dllp_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VENDOR_SPEC_DLLP_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_LSB    0
#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_VENDOR_SPEC_DLLP_OFF_VENDOR_SPEC_DLLP_RST    0xffffffff

__INLINE uint32_t pcie_ep_vendor_spec_dllp_off_vendor_spec_dllp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VENDOR_SPEC_DLLP_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_vendor_spec_dllp_off_vendor_spec_dllp_setf(uint32_t vendorspecdllp)
{
	ASSERT_ERR((((uint32_t)vendorspecdllp << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_VENDOR_SPEC_DLLP_OFF_ADDR, (uint32_t)vendorspecdllp << 0);
}

/**
 * @brief PORT_FORCE_OFF register definition
 *  This register can be used for testing and debuggong the link. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23    DO_DESKEW_FOR_SRIS        0              
 *    22    SUPPORT_PART_LANES_RXEI_EXIT 0              
 *    21:16 LINK_STATE                0x0
 *    15    FORCE_EN                  0              
 *    14:12 RSVDP_12                  0x0
 *    11:08 FORCED_LTSSM              0x0
 *    07:00 LINK_NUM                  0x4
 * </pre>
 */
#define PCIE_EP_PORT_FORCE_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000708)
#define PCIE_EP_PORT_FORCE_OFF_OFFSET      0x00000708
#define PCIE_EP_PORT_FORCE_OFF_INDEX       0x000001C2
#define PCIE_EP_PORT_FORCE_OFF_RESET       0x00000004

__INLINE uint32_t  pcie_ep_port_force_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
}

__INLINE void pcie_ep_port_force_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_24_LSB    24
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_POS    23
#define PCIE_EP_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_POS    22
#define PCIE_EP_PORT_FORCE_OFF_LINK_STATE_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_PORT_FORCE_OFF_LINK_STATE_LSB    16
#define PCIE_EP_PORT_FORCE_OFF_LINK_STATE_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_PORT_FORCE_OFF_FORCE_EN_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_PORT_FORCE_OFF_FORCE_EN_POS    15
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_12_MASK    ((uint32_t)0x00007000)
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_12_LSB    12
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_12_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_PORT_FORCE_OFF_FORCED_LTSSM_MASK    ((uint32_t)0x00000F00)
#define PCIE_EP_PORT_FORCE_OFF_FORCED_LTSSM_LSB    8
#define PCIE_EP_PORT_FORCE_OFF_FORCED_LTSSM_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PORT_FORCE_OFF_LINK_NUM_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_PORT_FORCE_OFF_LINK_NUM_LSB    0
#define PCIE_EP_PORT_FORCE_OFF_LINK_NUM_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_PORT_FORCE_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_DO_DESKEW_FOR_SRIS_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_SUPPORT_PART_LANES_RXEI_EXIT_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_LINK_STATE_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_FORCE_EN_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_RSVDP_12_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_FORCED_LTSSM_RST    0x0
#define PCIE_EP_PORT_FORCE_OFF_LINK_NUM_RST    0x4

__INLINE void pcie_ep_port_force_off_pack(uint8_t rsvdp_24, uint8_t do_deskew_for_sris, uint8_t support_part_lanes_rxei_exit, uint8_t link_state, uint8_t force_en, uint8_t rsvdp_12, uint8_t forced_ltssm, uint8_t link_num)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)do_deskew_for_sris << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)support_part_lanes_rxei_exit << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)link_state << 16) & ~((uint32_t)0x003F0000)) == 0);
	ASSERT_ERR((((uint32_t)force_en << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0x00007000)) == 0);
	ASSERT_ERR((((uint32_t)forced_ltssm << 8) & ~((uint32_t)0x00000F00)) == 0);
	ASSERT_ERR((((uint32_t)link_num << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)do_deskew_for_sris << 23) |((uint32_t)support_part_lanes_rxei_exit << 22) |((uint32_t)link_state << 16) |((uint32_t)force_en << 15) |((uint32_t)rsvdp_12 << 12) |((uint32_t)forced_ltssm << 8) |((uint32_t)link_num << 0));
}

__INLINE void pcie_ep_port_force_off_unpack(uint8_t* rsvdp_24, uint8_t* do_deskew_for_sris, uint8_t* support_part_lanes_rxei_exit, uint8_t* link_state, uint8_t* force_en, uint8_t* rsvdp_12, uint8_t* forced_ltssm, uint8_t* link_num)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*do_deskew_for_sris = (localVal & ((uint32_t)0x00800000)) >>  23;
	*support_part_lanes_rxei_exit = (localVal & ((uint32_t)0x00400000)) >>  22;
	*link_state = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*force_en = (localVal & ((uint32_t)0x00008000)) >>  15;
	*rsvdp_12 = (localVal & ((uint32_t)0x00007000)) >>  12;
	*forced_ltssm = (localVal & ((uint32_t)0x00000F00)) >>  8;
	*link_num = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_port_force_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_port_force_off_do_deskew_for_sris_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_port_force_off_do_deskew_for_sris_setf(uint8_t dodeskewforsris)
{
	ASSERT_ERR((((uint32_t)dodeskewforsris << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dodeskewforsris <<23));
}
__INLINE uint8_t pcie_ep_port_force_off_support_part_lanes_rxei_exit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_port_force_off_support_part_lanes_rxei_exit_setf(uint8_t supportpartlanesrxeiexit)
{
	ASSERT_ERR((((uint32_t)supportpartlanesrxeiexit << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)supportpartlanesrxeiexit <<22));
}
__INLINE uint8_t pcie_ep_port_force_off_link_state_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE void pcie_ep_port_force_off_link_state_setf(uint8_t linkstate)
{
	ASSERT_ERR((((uint32_t)linkstate << 16) & ~((uint32_t)0x003F0000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x003F0000)) | ((uint32_t)linkstate <<16));
}
__INLINE void pcie_ep_port_force_off_force_en_setf(uint8_t forceen)
{
	ASSERT_ERR((((uint32_t)forceen << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)forceen <<15));
}
__INLINE uint8_t pcie_ep_port_force_off_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007000)) >> 12);
}
__INLINE uint8_t pcie_ep_port_force_off_forced_ltssm_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void pcie_ep_port_force_off_forced_ltssm_setf(uint8_t forcedltssm)
{
	ASSERT_ERR((((uint32_t)forcedltssm << 8) & ~((uint32_t)0x00000F00)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)forcedltssm <<8));
}
__INLINE uint8_t pcie_ep_port_force_off_link_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_port_force_off_link_num_setf(uint8_t linknum)
{
	ASSERT_ERR((((uint32_t)linknum << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_PORT_FORCE_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_FORCE_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)linknum <<0));
}

/**
 * @brief ACK_F_ASPM_CTRL_OFF register definition
 *  This register is used to control ack frequency and L0-L1 ASPM behaviour. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RSVDP_31                  0              
 *    30    ENTER_ASPM                0              
 *    29:27 L1_ENTRANCE_LATENCY       0x3
 *    26:24 L0_S_ENTRANCE_LATENCY     0x3
 *    23:16 COMMON_CLK_N_FTS          0xf
 *    15:08 ACK_N_FTS                 0xf
 *    07:00 ACK_FREQ                  0x0
 * </pre>
 */
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000070C)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_OFFSET      0x0000070C
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_INDEX       0x000001C3
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_RESET       0x1B0F0F00

__INLINE uint32_t  pcie_ep_ack_f_aspm_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_ack_f_aspm_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_RSVDP_31_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_RSVDP_31_POS    31
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_POS    30
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_1_ENTRANCE_LATENCY_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_1_ENTRANCE_LATENCY_LSB    27
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_1_ENTRANCE_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_0_S_ENTRANCE_LATENCY_MASK    ((uint32_t)0x07000000)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_0_S_ENTRANCE_LATENCY_LSB    24
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_0_S_ENTRANCE_LATENCY_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_COMMON_CLK_N_FTS_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_COMMON_CLK_N_FTS_LSB    16
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_COMMON_CLK_N_FTS_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_LSB    8
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_LSB    0
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_RSVDP_31_RST    0x0
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ENTER_ASPM_RST    0x0
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_1_ENTRANCE_LATENCY_RST    0x3
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_L_0_S_ENTRANCE_LATENCY_RST    0x3
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_COMMON_CLK_N_FTS_RST    0xf
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_N_FTS_RST    0xf
#define PCIE_EP_ACK_F_ASPM_CTRL_OFF_ACK_FREQ_RST    0x0

__INLINE void pcie_ep_ack_f_aspm_ctrl_off_pack(uint8_t rsvdp_31, uint8_t enter_aspm, uint8_t l1_entrance_latency, uint8_t l0_s_entrance_latency, uint8_t common_clk_n_fts, uint8_t ack_n_fts, uint8_t ack_freq)
{
	ASSERT_ERR((((uint32_t)rsvdp_31 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)enter_aspm << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)l1_entrance_latency << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)l0_s_entrance_latency << 24) & ~((uint32_t)0x07000000)) == 0);
	ASSERT_ERR((((uint32_t)common_clk_n_fts << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)ack_n_fts << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)ack_freq << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_31 << 31) |((uint32_t)enter_aspm << 30) |((uint32_t)l1_entrance_latency << 27) |((uint32_t)l0_s_entrance_latency << 24) |((uint32_t)common_clk_n_fts << 16) |((uint32_t)ack_n_fts << 8) |((uint32_t)ack_freq << 0));
}

__INLINE void pcie_ep_ack_f_aspm_ctrl_off_unpack(uint8_t* rsvdp_31, uint8_t* enter_aspm, uint8_t* l1_entrance_latency, uint8_t* l0_s_entrance_latency, uint8_t* common_clk_n_fts, uint8_t* ack_n_fts, uint8_t* ack_freq)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);

	*rsvdp_31 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*enter_aspm = (localVal & ((uint32_t)0x40000000)) >>  30;
	*l1_entrance_latency = (localVal & ((uint32_t)0x38000000)) >>  27;
	*l0_s_entrance_latency = (localVal & ((uint32_t)0x07000000)) >>  24;
	*common_clk_n_fts = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*ack_n_fts = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*ack_freq = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_rsvdp_31_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_enter_aspm_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_ack_f_aspm_ctrl_off_enter_aspm_setf(uint8_t enteraspm)
{
	ASSERT_ERR((((uint32_t)enteraspm << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)enteraspm <<30));
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_l_1_entrance_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_ack_f_aspm_ctrl_off_l_1_entrance_latency_setf(uint8_t l1entrancelatency)
{
	ASSERT_ERR((((uint32_t)l1entrancelatency << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)l1entrancelatency <<27));
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_l_0_s_entrance_latency_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x07000000)) >> 24);
}
__INLINE void pcie_ep_ack_f_aspm_ctrl_off_l_0_s_entrance_latency_setf(uint8_t l0sentrancelatency)
{
	ASSERT_ERR((((uint32_t)l0sentrancelatency << 24) & ~((uint32_t)0x07000000)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR) & ~((uint32_t)0x07000000)) | ((uint32_t)l0sentrancelatency <<24));
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_common_clk_n_fts_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_ack_n_fts_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_ack_f_aspm_ctrl_off_ack_n_fts_setf(uint8_t acknfts)
{
	ASSERT_ERR((((uint32_t)acknfts << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)acknfts <<8));
}
__INLINE uint8_t pcie_ep_ack_f_aspm_ctrl_off_ack_freq_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_ack_f_aspm_ctrl_off_ack_freq_setf(uint8_t ackfreq)
{
	ASSERT_ERR((((uint32_t)ackfreq << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ACK_F_ASPM_CTRL_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)ackfreq <<0));
}

/**
 * @brief PORT_LINK_CTRL_OFF register definition
 *  Using this register you can control the port link behaviour. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RSVDP_28                  0x0
 *    27    TRANSMIT_LANE_REVERSALE_ENABLE 0              
 *    26    EXTENDED_SYNCH            0              
 *    25    CORRUPT_LCRC_ENABLE       0              
 *    24    BEACON_ENABLE             0              
 *    21:16 LINK_CAPABLE              0x1
 *    15:12 RSVDP_12                  0x0
 *    11:08 LINK_RATE                 0x1
 *    07    FAST_LINK_MODE            0              
 *    06    LINK_DISABLE              0              
 *    05    DLL_LINK_EN               1              
 *    04    RSVDP_4                   0              
 *    03    RESET_ASSERT              0              
 *    02    LOOPBACK_ENABLE           0              
 *    01    SCRAMBLE_DISABLE          0              
 *    00    VENDOR_SPECIFIC_DLLP_REQ  0              
 * </pre>
 */
#define PCIE_EP_PORT_LINK_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000710)
#define PCIE_EP_PORT_LINK_CTRL_OFF_OFFSET      0x00000710
#define PCIE_EP_PORT_LINK_CTRL_OFF_INDEX       0x000001C4
#define PCIE_EP_PORT_LINK_CTRL_OFF_RESET       0x00010120

__INLINE uint32_t  pcie_ep_port_link_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_port_link_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_28_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_28_LSB    28
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_28_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_ENABLE_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_ENABLE_POS    27
#define PCIE_EP_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_POS    26
#define PCIE_EP_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_ENABLE_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_ENABLE_POS    25
#define PCIE_EP_PORT_LINK_CTRL_OFF_BEACON_ENABLE_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_BEACON_ENABLE_POS    24
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_CAPABLE_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_CAPABLE_LSB    16
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_CAPABLE_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_12_MASK    ((uint32_t)0x0000F000)
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_12_LSB    12
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_12_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_RATE_MASK    ((uint32_t)0x00000F00)
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_RATE_LSB    8
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_RATE_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_POS    7
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_DISABLE_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_DISABLE_POS    6
#define PCIE_EP_PORT_LINK_CTRL_OFF_DLL_LINK_EN_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_PORT_LINK_CTRL_OFF_DLL_LINK_EN_POS    5
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_4_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_4_POS    4
#define PCIE_EP_PORT_LINK_CTRL_OFF_RESET_ASSERT_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_PORT_LINK_CTRL_OFF_RESET_ASSERT_POS    3
#define PCIE_EP_PORT_LINK_CTRL_OFF_LOOPBACK_ENABLE_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_PORT_LINK_CTRL_OFF_LOOPBACK_ENABLE_POS    2
#define PCIE_EP_PORT_LINK_CTRL_OFF_SCRAMBLE_DISABLE_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_PORT_LINK_CTRL_OFF_SCRAMBLE_DISABLE_POS    1
#define PCIE_EP_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_POS    0

#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_28_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_TRANSMIT_LANE_REVERSALE_ENABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_EXTENDED_SYNCH_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_CORRUPT_LCRC_ENABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_BEACON_ENABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_CAPABLE_RST    0x1
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_12_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_RATE_RST    0x1
#define PCIE_EP_PORT_LINK_CTRL_OFF_FAST_LINK_MODE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_LINK_DISABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_DLL_LINK_EN_RST    0x1
#define PCIE_EP_PORT_LINK_CTRL_OFF_RSVDP_4_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_RESET_ASSERT_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_LOOPBACK_ENABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_SCRAMBLE_DISABLE_RST    0x0
#define PCIE_EP_PORT_LINK_CTRL_OFF_VENDOR_SPECIFIC_DLLP_REQ_RST    0x0

__INLINE void pcie_ep_port_link_ctrl_off_pack(uint8_t rsvdp_28, uint8_t transmit_lane_reversale_enable, uint8_t extended_synch, uint8_t corrupt_lcrc_enable, uint8_t beacon_enable, uint8_t link_capable, uint8_t rsvdp_12, uint8_t link_rate, uint8_t fast_link_mode, uint8_t link_disable, uint8_t dll_link_en, uint8_t rsvdp_4, uint8_t reset_assert, uint8_t loopback_enable, uint8_t scramble_disable, uint8_t vendor_specific_dllp_req)
{
	ASSERT_ERR((((uint32_t)rsvdp_28 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)transmit_lane_reversale_enable << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)extended_synch << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)corrupt_lcrc_enable << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)beacon_enable << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)link_capable << 16) & ~((uint32_t)0x003F0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0x0000F000)) == 0);
	ASSERT_ERR((((uint32_t)link_rate << 8) & ~((uint32_t)0x00000F00)) == 0);
	ASSERT_ERR((((uint32_t)fast_link_mode << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)link_disable << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)dll_link_en << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)reset_assert << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)loopback_enable << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)scramble_disable << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)vendor_specific_dllp_req << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_28 << 28) |((uint32_t)transmit_lane_reversale_enable << 27) |((uint32_t)extended_synch << 26) |((uint32_t)corrupt_lcrc_enable << 25) |((uint32_t)beacon_enable << 24) |((uint32_t)link_capable << 16) |((uint32_t)rsvdp_12 << 12) |((uint32_t)link_rate << 8) |((uint32_t)fast_link_mode << 7) |((uint32_t)link_disable << 6) |((uint32_t)dll_link_en << 5) |((uint32_t)rsvdp_4 << 4) |((uint32_t)reset_assert << 3) |((uint32_t)loopback_enable << 2) |((uint32_t)scramble_disable << 1) |((uint32_t)vendor_specific_dllp_req << 0));
}

__INLINE void pcie_ep_port_link_ctrl_off_unpack(uint8_t* rsvdp_28, uint8_t* transmit_lane_reversale_enable, uint8_t* extended_synch, uint8_t* corrupt_lcrc_enable, uint8_t* beacon_enable, uint8_t* link_capable, uint8_t* rsvdp_12, uint8_t* link_rate, uint8_t* fast_link_mode, uint8_t* link_disable, uint8_t* dll_link_en, uint8_t* rsvdp_4, uint8_t* reset_assert, uint8_t* loopback_enable, uint8_t* scramble_disable, uint8_t* vendor_specific_dllp_req)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);

	*rsvdp_28 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*transmit_lane_reversale_enable = (localVal & ((uint32_t)0x08000000)) >>  27;
	*extended_synch = (localVal & ((uint32_t)0x04000000)) >>  26;
	*corrupt_lcrc_enable = (localVal & ((uint32_t)0x02000000)) >>  25;
	*beacon_enable = (localVal & ((uint32_t)0x01000000)) >>  24;
	*link_capable = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*rsvdp_12 = (localVal & ((uint32_t)0x0000F000)) >>  12;
	*link_rate = (localVal & ((uint32_t)0x00000F00)) >>  8;
	*fast_link_mode = (localVal & ((uint32_t)0x00000080)) >>  7;
	*link_disable = (localVal & ((uint32_t)0x00000040)) >>  6;
	*dll_link_en = (localVal & ((uint32_t)0x00000020)) >>  5;
	*rsvdp_4 = (localVal & ((uint32_t)0x00000010)) >>  4;
	*reset_assert = (localVal & ((uint32_t)0x00000008)) >>  3;
	*loopback_enable = (localVal & ((uint32_t)0x00000004)) >>  2;
	*scramble_disable = (localVal & ((uint32_t)0x00000002)) >>  1;
	*vendor_specific_dllp_req = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_port_link_ctrl_off_rsvdp_28_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_transmit_lane_reversale_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_port_link_ctrl_off_transmit_lane_reversale_enable_setf(uint8_t transmitlanereversaleenable)
{
	ASSERT_ERR((((uint32_t)transmitlanereversaleenable << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)transmitlanereversaleenable <<27));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_extended_synch_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_port_link_ctrl_off_extended_synch_setf(uint8_t extendedsynch)
{
	ASSERT_ERR((((uint32_t)extendedsynch << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)extendedsynch <<26));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_corrupt_lcrc_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_port_link_ctrl_off_corrupt_lcrc_enable_setf(uint8_t corruptlcrcenable)
{
	ASSERT_ERR((((uint32_t)corruptlcrcenable << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)corruptlcrcenable <<25));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_beacon_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_port_link_ctrl_off_beacon_enable_setf(uint8_t beaconenable)
{
	ASSERT_ERR((((uint32_t)beaconenable << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)beaconenable <<24));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_link_capable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE void pcie_ep_port_link_ctrl_off_link_capable_setf(uint8_t linkcapable)
{
	ASSERT_ERR((((uint32_t)linkcapable << 16) & ~((uint32_t)0x003F0000)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x003F0000)) | ((uint32_t)linkcapable <<16));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000F000)) >> 12);
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_link_rate_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE void pcie_ep_port_link_ctrl_off_link_rate_setf(uint8_t linkrate)
{
	ASSERT_ERR((((uint32_t)linkrate << 8) & ~((uint32_t)0x00000F00)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000F00)) | ((uint32_t)linkrate <<8));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_fast_link_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_port_link_ctrl_off_fast_link_mode_setf(uint8_t fastlinkmode)
{
	ASSERT_ERR((((uint32_t)fastlinkmode << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)fastlinkmode <<7));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_link_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_port_link_ctrl_off_link_disable_setf(uint8_t linkdisable)
{
	ASSERT_ERR((((uint32_t)linkdisable << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)linkdisable <<6));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_dll_link_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_port_link_ctrl_off_dll_link_en_setf(uint8_t dlllinken)
{
	ASSERT_ERR((((uint32_t)dlllinken << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)dlllinken <<5));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_reset_assert_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_port_link_ctrl_off_reset_assert_setf(uint8_t resetassert)
{
	ASSERT_ERR((((uint32_t)resetassert << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)resetassert <<3));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_loopback_enable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_port_link_ctrl_off_loopback_enable_setf(uint8_t loopbackenable)
{
	ASSERT_ERR((((uint32_t)loopbackenable << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)loopbackenable <<2));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_scramble_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_port_link_ctrl_off_scramble_disable_setf(uint8_t scrambledisable)
{
	ASSERT_ERR((((uint32_t)scrambledisable << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)scrambledisable <<1));
}
__INLINE uint8_t pcie_ep_port_link_ctrl_off_vendor_specific_dllp_req_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_port_link_ctrl_off_vendor_specific_dllp_req_setf(uint8_t vendorspecificdllpreq)
{
	ASSERT_ERR((((uint32_t)vendorspecificdllpreq << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PORT_LINK_CTRL_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)vendorspecificdllpreq <<0));
}

/**
 * @brief LANE_SKEW_OFF register definition
 *  This register is used to control the lane skew behaviour. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    DISABLE_LANE_TO_LANE_DESKEW 0              
 *    30:27 IMPLEMENT_NUM_LANES       0x0
 *    26    ELASTIC_BUFFER_MODE       0              
 *    25    ACK_NAK_DISABLE           0              
 *    24    FLOW_CTRL_DISABLE         0              
 *    23:00 INSERT_LANE_SKEW          0x0
 * </pre>
 */
#define PCIE_EP_LANE_SKEW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000714)
#define PCIE_EP_LANE_SKEW_OFF_OFFSET      0x00000714
#define PCIE_EP_LANE_SKEW_OFF_INDEX       0x000001C5
#define PCIE_EP_LANE_SKEW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_lane_skew_off_get(void)
{
	return REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
}

__INLINE void pcie_ep_lane_skew_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_LANE_SKEW_OFF_DISABLE_LANE_TO_LANE_DESKEW_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_LANE_SKEW_OFF_DISABLE_LANE_TO_LANE_DESKEW_POS    31
#define PCIE_EP_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_MASK    ((uint32_t)0x78000000)
#define PCIE_EP_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_LSB    27
#define PCIE_EP_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_LANE_SKEW_OFF_ELASTIC_BUFFER_MODE_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_LANE_SKEW_OFF_ELASTIC_BUFFER_MODE_POS    26
#define PCIE_EP_LANE_SKEW_OFF_ACK_NAK_DISABLE_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_LANE_SKEW_OFF_ACK_NAK_DISABLE_POS    25
#define PCIE_EP_LANE_SKEW_OFF_FLOW_CTRL_DISABLE_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_LANE_SKEW_OFF_FLOW_CTRL_DISABLE_POS    24
#define PCIE_EP_LANE_SKEW_OFF_INSERT_LANE_SKEW_MASK    ((uint32_t)0x00FFFFFF)
#define PCIE_EP_LANE_SKEW_OFF_INSERT_LANE_SKEW_LSB    0
#define PCIE_EP_LANE_SKEW_OFF_INSERT_LANE_SKEW_WIDTH    ((uint32_t)0x00000018)

#define PCIE_EP_LANE_SKEW_OFF_DISABLE_LANE_TO_LANE_DESKEW_RST    0x0
#define PCIE_EP_LANE_SKEW_OFF_IMPLEMENT_NUM_LANES_RST    0x0
#define PCIE_EP_LANE_SKEW_OFF_ELASTIC_BUFFER_MODE_RST    0x0
#define PCIE_EP_LANE_SKEW_OFF_ACK_NAK_DISABLE_RST    0x0
#define PCIE_EP_LANE_SKEW_OFF_FLOW_CTRL_DISABLE_RST    0x0
#define PCIE_EP_LANE_SKEW_OFF_INSERT_LANE_SKEW_RST    0x0

__INLINE void pcie_ep_lane_skew_off_pack(uint8_t disable_lane_to_lane_deskew, uint8_t implement_num_lanes, uint8_t elastic_buffer_mode, uint8_t ack_nak_disable, uint8_t flow_ctrl_disable, uint32_t insert_lane_skew)
{
	ASSERT_ERR((((uint32_t)disable_lane_to_lane_deskew << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)implement_num_lanes << 27) & ~((uint32_t)0x78000000)) == 0);
	ASSERT_ERR((((uint32_t)elastic_buffer_mode << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)ack_nak_disable << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)flow_ctrl_disable << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)insert_lane_skew << 0) & ~((uint32_t)0x00FFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR,  ((uint32_t)disable_lane_to_lane_deskew << 31) |((uint32_t)implement_num_lanes << 27) |((uint32_t)elastic_buffer_mode << 26) |((uint32_t)ack_nak_disable << 25) |((uint32_t)flow_ctrl_disable << 24) |((uint32_t)insert_lane_skew << 0));
}

__INLINE void pcie_ep_lane_skew_off_unpack(uint8_t* disable_lane_to_lane_deskew, uint8_t* implement_num_lanes, uint8_t* elastic_buffer_mode, uint8_t* ack_nak_disable, uint8_t* flow_ctrl_disable, uint32_t* insert_lane_skew)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);

	*disable_lane_to_lane_deskew = (localVal & ((uint32_t)0x80000000)) >>  31;
	*implement_num_lanes = (localVal & ((uint32_t)0x78000000)) >>  27;
	*elastic_buffer_mode = (localVal & ((uint32_t)0x04000000)) >>  26;
	*ack_nak_disable = (localVal & ((uint32_t)0x02000000)) >>  25;
	*flow_ctrl_disable = (localVal & ((uint32_t)0x01000000)) >>  24;
	*insert_lane_skew = (localVal & ((uint32_t)0x00FFFFFF)) >>  0;
}

__INLINE uint8_t pcie_ep_lane_skew_off_disable_lane_to_lane_deskew_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_lane_skew_off_disable_lane_to_lane_deskew_setf(uint8_t disablelanetolanedeskew)
{
	ASSERT_ERR((((uint32_t)disablelanetolanedeskew << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)disablelanetolanedeskew <<31));
}
__INLINE uint8_t pcie_ep_lane_skew_off_implement_num_lanes_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x78000000)) >> 27);
}
__INLINE void pcie_ep_lane_skew_off_implement_num_lanes_setf(uint8_t implementnumlanes)
{
	ASSERT_ERR((((uint32_t)implementnumlanes << 27) & ~((uint32_t)0x78000000)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x78000000)) | ((uint32_t)implementnumlanes <<27));
}
__INLINE uint8_t pcie_ep_lane_skew_off_elastic_buffer_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_lane_skew_off_elastic_buffer_mode_setf(uint8_t elasticbuffermode)
{
	ASSERT_ERR((((uint32_t)elasticbuffermode << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)elasticbuffermode <<26));
}
__INLINE uint8_t pcie_ep_lane_skew_off_ack_nak_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_lane_skew_off_ack_nak_disable_setf(uint8_t acknakdisable)
{
	ASSERT_ERR((((uint32_t)acknakdisable << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)acknakdisable <<25));
}
__INLINE uint8_t pcie_ep_lane_skew_off_flow_ctrl_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_lane_skew_off_flow_ctrl_disable_setf(uint8_t flowctrldisable)
{
	ASSERT_ERR((((uint32_t)flowctrldisable << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)flowctrldisable <<24));
}
__INLINE uint32_t pcie_ep_lane_skew_off_insert_lane_skew_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x00FFFFFF)) >> 0);
}
__INLINE void pcie_ep_lane_skew_off_insert_lane_skew_setf(uint32_t insertlaneskew)
{
	ASSERT_ERR((((uint32_t)insertlaneskew << 0) & ~((uint32_t)0x00FFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_LANE_SKEW_OFF_ADDR, (REG_PL_RD(PCIE_EP_LANE_SKEW_OFF_ADDR) & ~((uint32_t)0x00FFFFFF)) | ((uint32_t)insertlaneskew <<0));
}

/**
 * @brief TIMER_CTRL_MAX_FUNC_NUM_OFF register definition
 *  This register holds the ack frequency, latency, replay, fast link scaling timers,  and max function number values. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RSVDP_31                  0              
 *    30:29 FAST_LINK_SCALING_FACTOR  0x0
 *    28:24 UPDATE_FREQ_TIMER         0x0
 *    23:19 TIMER_MOD_ACK_NAK         0x0
 *    18:14 TIMER_MOD_REPLAY_TIMER    0x2
 *    13:08 RSVDP_8                   0x0
 *    07:00 MAX_FUNC_NUM              0x0
 * </pre>
 */
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000718)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_OFFSET      0x00000718
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_INDEX       0x000001C6
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RESET       0x00008000

__INLINE uint32_t  pcie_ep_timer_ctrl_max_func_num_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
}

__INLINE void pcie_ep_timer_ctrl_max_func_num_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_31_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_31_POS    31
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_MASK    ((uint32_t)0x60000000)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_LSB    29
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_MASK    ((uint32_t)0x1F000000)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_LSB    24
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_MASK    ((uint32_t)0x00F80000)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_LSB    19
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_MASK    ((uint32_t)0x0007C000)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_LSB    14
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_8_MASK    ((uint32_t)0x00003F00)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_8_LSB    8
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_LSB    0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_31_RST    0x0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_FAST_LINK_SCALING_FACTOR_RST    0x0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_UPDATE_FREQ_TIMER_RST    0x0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_ACK_NAK_RST    0x0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_TIMER_MOD_REPLAY_TIMER_RST    0x2
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_MAX_FUNC_NUM_RST    0x0

__INLINE void pcie_ep_timer_ctrl_max_func_num_off_pack(uint8_t rsvdp_31, uint8_t fast_link_scaling_factor, uint8_t update_freq_timer, uint8_t timer_mod_ack_nak, uint8_t timer_mod_replay_timer, uint8_t rsvdp_8, uint8_t max_func_num)
{
	ASSERT_ERR((((uint32_t)rsvdp_31 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)fast_link_scaling_factor << 29) & ~((uint32_t)0x60000000)) == 0);
	ASSERT_ERR((((uint32_t)update_freq_timer << 24) & ~((uint32_t)0x1F000000)) == 0);
	ASSERT_ERR((((uint32_t)timer_mod_ack_nak << 19) & ~((uint32_t)0x00F80000)) == 0);
	ASSERT_ERR((((uint32_t)timer_mod_replay_timer << 14) & ~((uint32_t)0x0007C000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x00003F00)) == 0);
	ASSERT_ERR((((uint32_t)max_func_num << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR,  ((uint32_t)rsvdp_31 << 31) |((uint32_t)fast_link_scaling_factor << 29) |((uint32_t)update_freq_timer << 24) |((uint32_t)timer_mod_ack_nak << 19) |((uint32_t)timer_mod_replay_timer << 14) |((uint32_t)rsvdp_8 << 8) |((uint32_t)max_func_num << 0));
}

__INLINE void pcie_ep_timer_ctrl_max_func_num_off_unpack(uint8_t* rsvdp_31, uint8_t* fast_link_scaling_factor, uint8_t* update_freq_timer, uint8_t* timer_mod_ack_nak, uint8_t* timer_mod_replay_timer, uint8_t* rsvdp_8, uint8_t* max_func_num)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);

	*rsvdp_31 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*fast_link_scaling_factor = (localVal & ((uint32_t)0x60000000)) >>  29;
	*update_freq_timer = (localVal & ((uint32_t)0x1F000000)) >>  24;
	*timer_mod_ack_nak = (localVal & ((uint32_t)0x00F80000)) >>  19;
	*timer_mod_replay_timer = (localVal & ((uint32_t)0x0007C000)) >>  14;
	*rsvdp_8 = (localVal & ((uint32_t)0x00003F00)) >>  8;
	*max_func_num = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_rsvdp_31_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_fast_link_scaling_factor_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x60000000)) >> 29);
}
__INLINE void pcie_ep_timer_ctrl_max_func_num_off_fast_link_scaling_factor_setf(uint8_t fastlinkscalingfactor)
{
	ASSERT_ERR((((uint32_t)fastlinkscalingfactor << 29) & ~((uint32_t)0x60000000)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, (REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR) & ~((uint32_t)0x60000000)) | ((uint32_t)fastlinkscalingfactor <<29));
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_update_freq_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x1F000000)) >> 24);
}
__INLINE void pcie_ep_timer_ctrl_max_func_num_off_update_freq_timer_setf(uint8_t updatefreqtimer)
{
	ASSERT_ERR((((uint32_t)updatefreqtimer << 24) & ~((uint32_t)0x1F000000)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, (REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR) & ~((uint32_t)0x1F000000)) | ((uint32_t)updatefreqtimer <<24));
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_timer_mod_ack_nak_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00F80000)) >> 19);
}
__INLINE void pcie_ep_timer_ctrl_max_func_num_off_timer_mod_ack_nak_setf(uint8_t timermodacknak)
{
	ASSERT_ERR((((uint32_t)timermodacknak << 19) & ~((uint32_t)0x00F80000)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, (REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR) & ~((uint32_t)0x00F80000)) | ((uint32_t)timermodacknak <<19));
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_timer_mod_replay_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0007C000)) >> 14);
}
__INLINE void pcie_ep_timer_ctrl_max_func_num_off_timer_mod_replay_timer_setf(uint8_t timermodreplaytimer)
{
	ASSERT_ERR((((uint32_t)timermodreplaytimer << 14) & ~((uint32_t)0x0007C000)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, (REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR) & ~((uint32_t)0x0007C000)) | ((uint32_t)timermodreplaytimer <<14));
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00003F00)) >> 8);
}
__INLINE uint8_t pcie_ep_timer_ctrl_max_func_num_off_max_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_timer_ctrl_max_func_num_off_max_func_num_setf(uint8_t maxfuncnum)
{
	ASSERT_ERR((((uint32_t)maxfuncnum << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR, (REG_PL_RD(PCIE_EP_TIMER_CTRL_MAX_FUNC_NUM_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)maxfuncnum <<0));
}

/**
 * @brief SYMBOL_TIMER_FILTER_1_OFF register definition
 *  The Filter Mask 1 Register modifies the RADM filtering and error handling rules. For more information, see the  Receive Filtering  section. In each case,  0  applies the associated filtering rule and  1  masks the associated filtering rule. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 MASK_RADM_1               0x0
 *    15    DISABLE_FC_WD_TIMER       0              
 *    14:11 EIDLE_TIMER               0x0
 *    10:00 SKP_INT_VAL               0x280
 * </pre>
 */
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000071C)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_OFFSET      0x0000071C
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_INDEX       0x000001C7
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_RESET       0x00000280

__INLINE uint32_t  pcie_ep_symbol_timer_filter_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);
}

__INLINE void pcie_ep_symbol_timer_filter_1_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_LSB    16
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_DISABLE_FC_WD_TIMER_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_DISABLE_FC_WD_TIMER_POS    15
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_MASK    ((uint32_t)0x00007800)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_LSB    11
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_MASK    ((uint32_t)0x000007FF)
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_LSB    0
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_WIDTH    ((uint32_t)0x0000000B)

#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_MASK_RADM_1_RST    0x0
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_DISABLE_FC_WD_TIMER_RST    0x0
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_EIDLE_TIMER_RST    0x0
#define PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_SKP_INT_VAL_RST    0x280

__INLINE void pcie_ep_symbol_timer_filter_1_off_pack(uint16_t mask_radm_1, uint8_t disable_fc_wd_timer, uint8_t eidle_timer, uint16_t skp_int_val)
{
	ASSERT_ERR((((uint32_t)mask_radm_1 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)disable_fc_wd_timer << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)eidle_timer << 11) & ~((uint32_t)0x00007800)) == 0);
	ASSERT_ERR((((uint32_t)skp_int_val << 0) & ~((uint32_t)0x000007FF)) == 0);
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR,  ((uint32_t)mask_radm_1 << 16) |((uint32_t)disable_fc_wd_timer << 15) |((uint32_t)eidle_timer << 11) |((uint32_t)skp_int_val << 0));
}

__INLINE void pcie_ep_symbol_timer_filter_1_off_unpack(uint16_t* mask_radm_1, uint8_t* disable_fc_wd_timer, uint8_t* eidle_timer, uint16_t* skp_int_val)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);

	*mask_radm_1 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*disable_fc_wd_timer = (localVal & ((uint32_t)0x00008000)) >>  15;
	*eidle_timer = (localVal & ((uint32_t)0x00007800)) >>  11;
	*skp_int_val = (localVal & ((uint32_t)0x000007FF)) >>  0;
}

__INLINE uint16_t pcie_ep_symbol_timer_filter_1_off_mask_radm_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_symbol_timer_filter_1_off_mask_radm_1_setf(uint16_t maskradm1)
{
	ASSERT_ERR((((uint32_t)maskradm1 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)maskradm1 <<16));
}
__INLINE uint8_t pcie_ep_symbol_timer_filter_1_off_disable_fc_wd_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_symbol_timer_filter_1_off_disable_fc_wd_timer_setf(uint8_t disablefcwdtimer)
{
	ASSERT_ERR((((uint32_t)disablefcwdtimer << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)disablefcwdtimer <<15));
}
__INLINE uint8_t pcie_ep_symbol_timer_filter_1_off_eidle_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007800)) >> 11);
}
__INLINE void pcie_ep_symbol_timer_filter_1_off_eidle_timer_setf(uint8_t eidletimer)
{
	ASSERT_ERR((((uint32_t)eidletimer << 11) & ~((uint32_t)0x00007800)) == 0);
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR) & ~((uint32_t)0x00007800)) | ((uint32_t)eidletimer <<11));
}
__INLINE uint16_t pcie_ep_symbol_timer_filter_1_off_skp_int_val_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x000007FF)) >> 0);
}
__INLINE void pcie_ep_symbol_timer_filter_1_off_skp_int_val_setf(uint16_t skpintval)
{
	ASSERT_ERR((((uint32_t)skpintval << 0) & ~((uint32_t)0x000007FF)) == 0);
	REG_PL_WR(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_SYMBOL_TIMER_FILTER_1_OFF_ADDR) & ~((uint32_t)0x000007FF)) | ((uint32_t)skpintval <<0));
}

/**
 * @brief FILTER_MASK_2_OFF register definition
 *  This register modifies the RADM filtering and error handling rules. For more information, see the  Receive Filtering  section. In each case,  0  applies the associated filtering rule and  1  masks the associated filtering rule. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MASK_RADM_2               0x0
 * </pre>
 */
#define PCIE_EP_FILTER_MASK_2_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000720)
#define PCIE_EP_FILTER_MASK_2_OFF_OFFSET      0x00000720
#define PCIE_EP_FILTER_MASK_2_OFF_INDEX       0x000001C8
#define PCIE_EP_FILTER_MASK_2_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_filter_mask_2_off_get(void)
{
	return REG_PL_RD(PCIE_EP_FILTER_MASK_2_OFF_ADDR);
}

__INLINE void pcie_ep_filter_mask_2_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_FILTER_MASK_2_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_FILTER_MASK_2_OFF_MASK_RADM_2_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_FILTER_MASK_2_OFF_MASK_RADM_2_LSB    0
#define PCIE_EP_FILTER_MASK_2_OFF_MASK_RADM_2_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_FILTER_MASK_2_OFF_MASK_RADM_2_RST    0x0

__INLINE uint32_t pcie_ep_filter_mask_2_off_mask_radm_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_FILTER_MASK_2_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_filter_mask_2_off_mask_radm_2_setf(uint32_t maskradm2)
{
	ASSERT_ERR((((uint32_t)maskradm2 << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_FILTER_MASK_2_OFF_ADDR, (uint32_t)maskradm2 << 0);
}

/**
 * @brief PL_DEBUG_0_OFF register definition
 *  This register holds cxpl_debug_info[31:0]. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DEB_REG_0                 0x0
 * </pre>
 */
#define PCIE_EP_PL_DEBUG_0_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000728)
#define PCIE_EP_PL_DEBUG_0_OFF_OFFSET      0x00000728
#define PCIE_EP_PL_DEBUG_0_OFF_INDEX       0x000001CA
#define PCIE_EP_PL_DEBUG_0_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_pl_debug_0_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PL_DEBUG_0_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PL_DEBUG_0_OFF_DEB_REG_0_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PL_DEBUG_0_OFF_DEB_REG_0_LSB    0
#define PCIE_EP_PL_DEBUG_0_OFF_DEB_REG_0_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PL_DEBUG_0_OFF_DEB_REG_0_RST    0x0

__INLINE uint32_t pcie_ep_pl_debug_0_off_deb_reg_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_DEBUG_0_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief PL_DEBUG_1_OFF register definition
 *  This register holds cxpl_debug_info[63:32]. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DEB_REG_1                 0x0
 * </pre>
 */
#define PCIE_EP_PL_DEBUG_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000072C)
#define PCIE_EP_PL_DEBUG_1_OFF_OFFSET      0x0000072C
#define PCIE_EP_PL_DEBUG_1_OFF_INDEX       0x000001CB
#define PCIE_EP_PL_DEBUG_1_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_pl_debug_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PL_DEBUG_1_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PL_DEBUG_1_OFF_DEB_REG_1_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PL_DEBUG_1_OFF_DEB_REG_1_LSB    0
#define PCIE_EP_PL_DEBUG_1_OFF_DEB_REG_1_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PL_DEBUG_1_OFF_DEB_REG_1_RST    0x0

__INLINE uint32_t pcie_ep_pl_debug_1_off_deb_reg_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_DEBUG_1_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief TX_P_FC_CREDIT_STATUS_OFF register definition
 *  This register provides transmit posted FC credit status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_TX_P_FC_CREDIT_STATUS 0x0
 *    19:12 TX_P_HEADER_FC_CREDIT     0x0
 *    11:00 TX_P_DATA_FC_CREDIT       0x0
 * </pre>
 */
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000730)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_OFFSET      0x00000730
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_INDEX       0x000001CC
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tx_p_fc_credit_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_RSVDP_TX_P_FC_CREDIT_STATUS_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_RSVDP_TX_P_FC_CREDIT_STATUS_LSB    20
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_RSVDP_TX_P_FC_CREDIT_STATUS_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_HEADER_FC_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_HEADER_FC_CREDIT_LSB    12
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_HEADER_FC_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_DATA_FC_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_DATA_FC_CREDIT_LSB    0
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_DATA_FC_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_RSVDP_TX_P_FC_CREDIT_STATUS_RST    0x0
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_HEADER_FC_CREDIT_RST    0x0
#define PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_TX_P_DATA_FC_CREDIT_RST    0x0

__INLINE void pcie_ep_tx_p_fc_credit_status_off_unpack(uint16_t* rsvdp_tx_p_fc_credit_status, uint8_t* tx_p_header_fc_credit, uint16_t* tx_p_data_fc_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR);

	*rsvdp_tx_p_fc_credit_status = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*tx_p_header_fc_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*tx_p_data_fc_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint16_t pcie_ep_tx_p_fc_credit_status_off_rsvdp_tx_p_fc_credit_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_tx_p_fc_credit_status_off_tx_p_header_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_tx_p_fc_credit_status_off_tx_p_data_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_P_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief TX_NP_FC_CREDIT_STATUS_OFF register definition
 *  This register provides the transmit Non-Posted FC credit status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_TX_NP_FC_CREDIT_STATUS 0x0
 *    19:12 TX_NP_HEADER_FC_CREDIT    0x0
 *    11:00 TX_NP_DATA_FC_CREDIT      0x0
 * </pre>
 */
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000734)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_OFFSET      0x00000734
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_INDEX       0x000001CD
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tx_np_fc_credit_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_RSVDP_TX_NP_FC_CREDIT_STATUS_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_RSVDP_TX_NP_FC_CREDIT_STATUS_LSB    20
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_RSVDP_TX_NP_FC_CREDIT_STATUS_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_HEADER_FC_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_HEADER_FC_CREDIT_LSB    12
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_HEADER_FC_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_DATA_FC_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_DATA_FC_CREDIT_LSB    0
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_DATA_FC_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_RSVDP_TX_NP_FC_CREDIT_STATUS_RST    0x0
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_HEADER_FC_CREDIT_RST    0x0
#define PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_TX_NP_DATA_FC_CREDIT_RST    0x0

__INLINE void pcie_ep_tx_np_fc_credit_status_off_unpack(uint16_t* rsvdp_tx_np_fc_credit_status, uint8_t* tx_np_header_fc_credit, uint16_t* tx_np_data_fc_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR);

	*rsvdp_tx_np_fc_credit_status = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*tx_np_header_fc_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*tx_np_data_fc_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint16_t pcie_ep_tx_np_fc_credit_status_off_rsvdp_tx_np_fc_credit_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_tx_np_fc_credit_status_off_tx_np_header_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_tx_np_fc_credit_status_off_tx_np_data_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_NP_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief TX_CPL_FC_CREDIT_STATUS_OFF register definition
 *  This register provides transmit completion FC credit status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_TX_CPL_FC_CREDIT_STATUS 0x0
 *    19:12 TX_CPL_HEADER_FC_CREDIT   0x0
 *    11:00 TX_CPL_DATA_FC_CREDIT     0x0
 * </pre>
 */
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000738)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_OFFSET      0x00000738
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_INDEX       0x000001CE
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_tx_cpl_fc_credit_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_RSVDP_TX_CPL_FC_CREDIT_STATUS_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_RSVDP_TX_CPL_FC_CREDIT_STATUS_LSB    20
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_RSVDP_TX_CPL_FC_CREDIT_STATUS_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_HEADER_FC_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_HEADER_FC_CREDIT_LSB    12
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_HEADER_FC_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_DATA_FC_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_DATA_FC_CREDIT_LSB    0
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_DATA_FC_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_RSVDP_TX_CPL_FC_CREDIT_STATUS_RST    0x0
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_HEADER_FC_CREDIT_RST    0x0
#define PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_TX_CPL_DATA_FC_CREDIT_RST    0x0

__INLINE void pcie_ep_tx_cpl_fc_credit_status_off_unpack(uint16_t* rsvdp_tx_cpl_fc_credit_status, uint8_t* tx_cpl_header_fc_credit, uint16_t* tx_cpl_data_fc_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR);

	*rsvdp_tx_cpl_fc_credit_status = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*tx_cpl_header_fc_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*tx_cpl_data_fc_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint16_t pcie_ep_tx_cpl_fc_credit_status_off_rsvdp_tx_cpl_fc_credit_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_tx_cpl_fc_credit_status_off_tx_cpl_header_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_tx_cpl_fc_credit_status_off_tx_cpl_data_fc_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TX_CPL_FC_CREDIT_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief QUEUE_STATUS_OFF register definition
 *  This register provides the queue status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    TIMER_MOD_FLOW_CONTROL_EN 0              
 *    30:29 RSVDP_29                  0x0
 *    28:16 TIMER_MOD_FLOW_CONTROL    0x0
 *    13    RX_SERIALIZATION_Q_NON_EMPTY 0              
 *    12:04 RSVDP_4                   0x0
 *    03    RX_QUEUE_OVERFLOW         0              
 *    02    RX_QUEUE_NON_EMPTY        0              
 *    01    TX_RETRY_BUFFER_NE        0              
 *    00    RX_TLP_FC_CREDIT_NON_RETURN 0              
 * </pre>
 */
#define PCIE_EP_QUEUE_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000073C)
#define PCIE_EP_QUEUE_STATUS_OFF_OFFSET      0x0000073C
#define PCIE_EP_QUEUE_STATUS_OFF_INDEX       0x000001CF
#define PCIE_EP_QUEUE_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_queue_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_queue_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_QUEUE_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_EN_POS    31
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_29_MASK    ((uint32_t)0x60000000)
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_29_LSB    29
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_29_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_MASK    ((uint32_t)0x1FFF0000)
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_LSB    16
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_WIDTH    ((uint32_t)0x0000000D)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_SERIALIZATION_Q_NON_EMPTY_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_SERIALIZATION_Q_NON_EMPTY_POS    13
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_4_MASK    ((uint32_t)0x00001FF0)
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_4_LSB    4
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_4_WIDTH    ((uint32_t)0x00000009)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_OVERFLOW_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_OVERFLOW_POS    3
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_NON_EMPTY_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_NON_EMPTY_POS    2
#define PCIE_EP_QUEUE_STATUS_OFF_TX_RETRY_BUFFER_NE_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_QUEUE_STATUS_OFF_TX_RETRY_BUFFER_NE_POS    1
#define PCIE_EP_QUEUE_STATUS_OFF_RX_TLP_FC_CREDIT_NON_RETURN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_QUEUE_STATUS_OFF_RX_TLP_FC_CREDIT_NON_RETURN_POS    0

#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_EN_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_29_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_TIMER_MOD_FLOW_CONTROL_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RX_SERIALIZATION_Q_NON_EMPTY_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RSVDP_4_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_OVERFLOW_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RX_QUEUE_NON_EMPTY_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_TX_RETRY_BUFFER_NE_RST    0x0
#define PCIE_EP_QUEUE_STATUS_OFF_RX_TLP_FC_CREDIT_NON_RETURN_RST    0x0

__INLINE void pcie_ep_queue_status_off_pack(uint8_t timer_mod_flow_control_en, uint8_t rsvdp_29, uint16_t timer_mod_flow_control, uint8_t rx_serialization_q_non_empty, uint16_t rsvdp_4, uint8_t rx_queue_overflow, uint8_t rx_queue_non_empty, uint8_t tx_retry_buffer_ne, uint8_t rx_tlp_fc_credit_non_return)
{
	ASSERT_ERR((((uint32_t)timer_mod_flow_control_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_29 << 29) & ~((uint32_t)0x60000000)) == 0);
	ASSERT_ERR((((uint32_t)timer_mod_flow_control << 16) & ~((uint32_t)0x1FFF0000)) == 0);
	ASSERT_ERR((((uint32_t)rx_serialization_q_non_empty << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x00001FF0)) == 0);
	ASSERT_ERR((((uint32_t)rx_queue_overflow << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)rx_queue_non_empty << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tx_retry_buffer_ne << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)rx_tlp_fc_credit_non_return << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_QUEUE_STATUS_OFF_ADDR,  ((uint32_t)timer_mod_flow_control_en << 31) |((uint32_t)rsvdp_29 << 29) |((uint32_t)timer_mod_flow_control << 16) |((uint32_t)rx_serialization_q_non_empty << 13) |((uint32_t)rsvdp_4 << 4) |((uint32_t)rx_queue_overflow << 3) |((uint32_t)rx_queue_non_empty << 2) |((uint32_t)tx_retry_buffer_ne << 1) |((uint32_t)rx_tlp_fc_credit_non_return << 0));
}

__INLINE void pcie_ep_queue_status_off_unpack(uint8_t* timer_mod_flow_control_en, uint8_t* rsvdp_29, uint16_t* timer_mod_flow_control, uint8_t* rx_serialization_q_non_empty, uint16_t* rsvdp_4, uint8_t* rx_queue_overflow, uint8_t* rx_queue_non_empty, uint8_t* tx_retry_buffer_ne, uint8_t* rx_tlp_fc_credit_non_return)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);

	*timer_mod_flow_control_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_29 = (localVal & ((uint32_t)0x60000000)) >>  29;
	*timer_mod_flow_control = (localVal & ((uint32_t)0x1FFF0000)) >>  16;
	*rx_serialization_q_non_empty = (localVal & ((uint32_t)0x00002000)) >>  13;
	*rsvdp_4 = (localVal & ((uint32_t)0x00001FF0)) >>  4;
	*rx_queue_overflow = (localVal & ((uint32_t)0x00000008)) >>  3;
	*rx_queue_non_empty = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tx_retry_buffer_ne = (localVal & ((uint32_t)0x00000002)) >>  1;
	*rx_tlp_fc_credit_non_return = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_queue_status_off_timer_mod_flow_control_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_queue_status_off_timer_mod_flow_control_en_setf(uint8_t timermodflowcontrolen)
{
	ASSERT_ERR((((uint32_t)timermodflowcontrolen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_QUEUE_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)timermodflowcontrolen <<31));
}
__INLINE uint8_t pcie_ep_queue_status_off_rsvdp_29_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x60000000)) >> 29);
}
__INLINE uint16_t pcie_ep_queue_status_off_timer_mod_flow_control_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x1FFF0000)) >> 16);
}
__INLINE void pcie_ep_queue_status_off_timer_mod_flow_control_setf(uint16_t timermodflowcontrol)
{
	ASSERT_ERR((((uint32_t)timermodflowcontrol << 16) & ~((uint32_t)0x1FFF0000)) == 0);
	REG_PL_WR(PCIE_EP_QUEUE_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR) & ~((uint32_t)0x1FFF0000)) | ((uint32_t)timermodflowcontrol <<16));
}
__INLINE uint8_t pcie_ep_queue_status_off_rx_serialization_q_non_empty_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE uint16_t pcie_ep_queue_status_off_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00001FF0)) >> 4);
}
__INLINE uint8_t pcie_ep_queue_status_off_rx_queue_overflow_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_queue_status_off_rx_queue_overflow_setf(uint8_t rxqueueoverflow)
{
	ASSERT_ERR((((uint32_t)rxqueueoverflow << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_QUEUE_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)rxqueueoverflow <<3));
}
__INLINE uint8_t pcie_ep_queue_status_off_rx_queue_non_empty_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE uint8_t pcie_ep_queue_status_off_tx_retry_buffer_ne_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE uint8_t pcie_ep_queue_status_off_rx_tlp_fc_credit_non_return_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_QUEUE_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief VC_TX_ARBI_1_OFF register definition
 *  This register is used for setting the WRR weights for VC0 - VC3. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 WRR_WEIGHT_VC_3           0x0
 *    23:16 WRR_WEIGHT_VC_2           0x0
 *    15:08 WRR_WEIGHT_VC_1           0x0
 *    07:00 WRR_WEIGHT_VC_0           0xf
 * </pre>
 */
#define PCIE_EP_VC_TX_ARBI_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000740)
#define PCIE_EP_VC_TX_ARBI_1_OFF_OFFSET      0x00000740
#define PCIE_EP_VC_TX_ARBI_1_OFF_INDEX       0x000001D0
#define PCIE_EP_VC_TX_ARBI_1_OFF_RESET       0x0000000F

__INLINE uint32_t  pcie_ep_vc_tx_arbi_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_LSB    24
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_LSB    16
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_LSB    8
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_LSB    0
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_3_RST    0x0
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_2_RST    0x0
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_1_RST    0x0
#define PCIE_EP_VC_TX_ARBI_1_OFF_WRR_WEIGHT_VC_0_RST    0xf

__INLINE void pcie_ep_vc_tx_arbi_1_off_unpack(uint8_t* wrr_weight_vc_3, uint8_t* wrr_weight_vc_2, uint8_t* wrr_weight_vc_1, uint8_t* wrr_weight_vc_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);

	*wrr_weight_vc_3 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wrr_weight_vc_2 = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*wrr_weight_vc_1 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wrr_weight_vc_0 = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_tx_arbi_1_off_wrr_weight_vc_3_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_1_off_wrr_weight_vc_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_1_off_wrr_weight_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_1_off_wrr_weight_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief VC_TX_ARBI_2_OFF register definition
 *  This register is used for setting the WRR weights for VC4 - VC7. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 WRR_WEIGHT_VC_7           0x0
 *    23:16 WRR_WEIGHT_VC_6           0x0
 *    15:08 WRR_WEIGHT_VC_5           0x0
 *    07:00 WRR_WEIGHT_VC_4           0x0
 * </pre>
 */
#define PCIE_EP_VC_TX_ARBI_2_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000744)
#define PCIE_EP_VC_TX_ARBI_2_OFF_OFFSET      0x00000744
#define PCIE_EP_VC_TX_ARBI_2_OFF_INDEX       0x000001D1
#define PCIE_EP_VC_TX_ARBI_2_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_vc_tx_arbi_2_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);
}

// field definitions
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_LSB    24
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_LSB    16
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_LSB    8
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_LSB    0
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_7_RST    0x0
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_6_RST    0x0
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_5_RST    0x0
#define PCIE_EP_VC_TX_ARBI_2_OFF_WRR_WEIGHT_VC_4_RST    0x0

__INLINE void pcie_ep_vc_tx_arbi_2_off_unpack(uint8_t* wrr_weight_vc_7, uint8_t* wrr_weight_vc_6, uint8_t* wrr_weight_vc_5, uint8_t* wrr_weight_vc_4)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);

	*wrr_weight_vc_7 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wrr_weight_vc_6 = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*wrr_weight_vc_5 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wrr_weight_vc_4 = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_tx_arbi_2_off_wrr_weight_vc_7_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_2_off_wrr_weight_vc_6_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_2_off_wrr_weight_vc_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_vc_tx_arbi_2_off_wrr_weight_vc_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_TX_ARBI_2_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief VC_0_P_RX_Q_CTRL_OFF register definition
 *  This register controls segmented-buffer VC0 posted receive queue operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    VC_ORDERING_RX_Q          0              
 *    30    TLP_TYPE_ORDERING_VC0     0              
 *    29:28 RESERVED5                 0x0
 *    27:26 VC0_P_DATA_SCALE          0x1
 *    25:24 VC0_P_HDR_SCALE           0x1
 *    23:21 VC0_P_TLP_Q_MODE          0x1
 *    20    RESERVED4                 0              
 *    19:12 VC0_P_HEADER_CREDIT       0x34
 *    11:00 VC0_P_DATA_CREDIT         0x80
 * </pre>
 */
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000748)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_OFFSET      0x00000748
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_INDEX       0x000001D2
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESET       0x05234080

__INLINE uint32_t  pcie_ep_vc_0_p_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_POS    31
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_0_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_0_POS    30
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_5_MASK    ((uint32_t)0x30000000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_5_LSB    28
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_5_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_SCALE_LSB    26
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HDR_SCALE_LSB    24
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_4_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_4_POS    20
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_ORDERING_RX_Q_RST    0x0
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_0_RST    0x0
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_5_RST    0x0
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_TLP_Q_MODE_RST    0x1
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_RESERVED_4_RST    0x0
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_HEADER_CREDIT_RST    0x34
#define PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_VC_0_P_DATA_CREDIT_RST    0x80

__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_pack(uint8_t vc_ordering_rx_q, uint8_t tlp_type_ordering_vc0, uint8_t reserved5, uint8_t vc0_p_data_scale, uint8_t vc0_p_hdr_scale, uint8_t vc0_p_tlp_q_mode, uint8_t reserved4, uint8_t vc0_p_header_credit, uint16_t vc0_p_data_credit)
{
	ASSERT_ERR((((uint32_t)vc_ordering_rx_q << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_type_ordering_vc0 << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)reserved5 << 28) & ~((uint32_t)0x30000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_p_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_p_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_p_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved4 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_p_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_p_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)vc_ordering_rx_q << 31) |((uint32_t)tlp_type_ordering_vc0 << 30) |((uint32_t)reserved5 << 28) |((uint32_t)vc0_p_data_scale << 26) |((uint32_t)vc0_p_hdr_scale << 24) |((uint32_t)vc0_p_tlp_q_mode << 21) |((uint32_t)reserved4 << 20) |((uint32_t)vc0_p_header_credit << 12) |((uint32_t)vc0_p_data_credit << 0));
}

__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_unpack(uint8_t* vc_ordering_rx_q, uint8_t* tlp_type_ordering_vc0, uint8_t* reserved5, uint8_t* vc0_p_data_scale, uint8_t* vc0_p_hdr_scale, uint8_t* vc0_p_tlp_q_mode, uint8_t* reserved4, uint8_t* vc0_p_header_credit, uint16_t* vc0_p_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);

	*vc_ordering_rx_q = (localVal & ((uint32_t)0x80000000)) >>  31;
	*tlp_type_ordering_vc0 = (localVal & ((uint32_t)0x40000000)) >>  30;
	*reserved5 = (localVal & ((uint32_t)0x30000000)) >>  28;
	*vc0_p_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc0_p_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc0_p_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved4 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc0_p_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc0_p_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_ordering_rx_q_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_vc_ordering_rx_q_setf(uint8_t vcorderingrxq)
{
	ASSERT_ERR((((uint32_t)vcorderingrxq << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)vcorderingrxq <<31));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_tlp_type_ordering_vc_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_tlp_type_ordering_vc_0_setf(uint8_t tlptypeorderingvc0)
{
	ASSERT_ERR((((uint32_t)tlptypeorderingvc0 << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)tlptypeorderingvc0 <<30));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x30000000)) >> 28);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_reserved_5_setf(uint8_t reserved5)
{
	ASSERT_ERR((((uint32_t)reserved5 << 28) & ~((uint32_t)0x30000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x30000000)) | ((uint32_t)reserved5 <<28));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_data_scale_setf(uint8_t vc0pdatascale)
{
	ASSERT_ERR((((uint32_t)vc0pdatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc0pdatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_hdr_scale_setf(uint8_t vc0phdrscale)
{
	ASSERT_ERR((((uint32_t)vc0phdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc0phdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_tlp_q_mode_setf(uint8_t vc0ptlpqmode)
{
	ASSERT_ERR((((uint32_t)vc0ptlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc0ptlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_reserved_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_0_p_rx_q_ctrl_off_reserved_4_setf(uint8_t reserved4)
{
	ASSERT_ERR((((uint32_t)reserved4 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved4 <<20));
}
__INLINE uint8_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_0_p_rx_q_ctrl_off_vc_0_p_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_P_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief VC_0_NP_RX_Q_CTRL_OFF register definition
 *  This register controls the segmented-buffer VC0 non-posted receive queue operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RESERVED7                 0x0
 *    27:26 VC0_NP_DATA_SCALE         0x1
 *    25:24 VC0_NP_HDR_SCALE          0x1
 *    23:21 VC0_NP_TLP_Q_MODE         0x1
 *    20    RESERVED6                 0              
 *    19:12 VC0_NP_HEADER_CREDIT      0x34
 *    11:00 VC0_NP_DATA_CREDIT        0xd
 * </pre>
 */
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000074C)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_OFFSET      0x0000074C
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_INDEX       0x000001D3
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESET       0x0523400D

__INLINE uint32_t  pcie_ep_vc_0_np_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_7_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_7_LSB    28
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_7_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_SCALE_LSB    26
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HDR_SCALE_LSB    24
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_6_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_6_POS    20
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_7_RST    0x0
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_TLP_Q_MODE_RST    0x1
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_RESERVED_6_RST    0x0
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_HEADER_CREDIT_RST    0x34
#define PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_VC_0_NP_DATA_CREDIT_RST    0xd

__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_pack(uint8_t reserved7, uint8_t vc0_np_data_scale, uint8_t vc0_np_hdr_scale, uint8_t vc0_np_tlp_q_mode, uint8_t reserved6, uint8_t vc0_np_header_credit, uint16_t vc0_np_data_credit)
{
	ASSERT_ERR((((uint32_t)reserved7 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_np_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_np_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_np_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved6 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_np_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_np_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)reserved7 << 28) |((uint32_t)vc0_np_data_scale << 26) |((uint32_t)vc0_np_hdr_scale << 24) |((uint32_t)vc0_np_tlp_q_mode << 21) |((uint32_t)reserved6 << 20) |((uint32_t)vc0_np_header_credit << 12) |((uint32_t)vc0_np_data_credit << 0));
}

__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_unpack(uint8_t* reserved7, uint8_t* vc0_np_data_scale, uint8_t* vc0_np_hdr_scale, uint8_t* vc0_np_tlp_q_mode, uint8_t* reserved6, uint8_t* vc0_np_header_credit, uint16_t* vc0_np_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);

	*reserved7 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*vc0_np_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc0_np_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc0_np_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved6 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc0_np_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc0_np_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_reserved_7_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_reserved_7_setf(uint8_t reserved7)
{
	ASSERT_ERR((((uint32_t)reserved7 << 28) & ~((uint32_t)0xF0000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)reserved7 <<28));
}
__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_data_scale_setf(uint8_t vc0npdatascale)
{
	ASSERT_ERR((((uint32_t)vc0npdatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc0npdatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_hdr_scale_setf(uint8_t vc0nphdrscale)
{
	ASSERT_ERR((((uint32_t)vc0nphdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc0nphdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_tlp_q_mode_setf(uint8_t vc0nptlpqmode)
{
	ASSERT_ERR((((uint32_t)vc0nptlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc0nptlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_reserved_6_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_0_np_rx_q_ctrl_off_reserved_6_setf(uint8_t reserved6)
{
	ASSERT_ERR((((uint32_t)reserved6 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved6 <<20));
}
__INLINE uint8_t pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_0_np_rx_q_ctrl_off_vc_0_np_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief VC_0_CPL_RX_Q_CTRL_OFF register definition
 *  This register controls the segmented-buffer VC0 completion receive queue operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RESERVED9                 0x0
 *    27:26 VC0_CPL_DATA_SCALE        0x1
 *    25:24 VC0_CPL_HDR_SCALE         0x1
 *    23:21 VC0_CPL_TLP_Q_MODE        0x4
 *    20    RESERVED8                 0              
 *    19:12 VC0_CPL_HEADER_CREDIT     0x0
 *    11:00 VC0_CPL_DATA_CREDIT       0x0
 * </pre>
 */
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000750)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_OFFSET      0x00000750
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_INDEX       0x000001D4
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESET       0x05800000

__INLINE uint32_t  pcie_ep_vc_0_cpl_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_9_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_9_LSB    28
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_9_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_SCALE_LSB    26
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HDR_SCALE_LSB    24
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_8_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_8_POS    20
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_9_RST    0x0
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_TLP_Q_MODE_RST    0x4
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_RESERVED_8_RST    0x0
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_HEADER_CREDIT_RST    0x0
#define PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_VC_0_CPL_DATA_CREDIT_RST    0x0

__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_pack(uint8_t reserved9, uint8_t vc0_cpl_data_scale, uint8_t vc0_cpl_hdr_scale, uint8_t vc0_cpl_tlp_q_mode, uint8_t reserved8, uint8_t vc0_cpl_header_credit, uint16_t vc0_cpl_data_credit)
{
	ASSERT_ERR((((uint32_t)reserved9 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_cpl_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_cpl_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_cpl_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved8 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_cpl_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc0_cpl_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)reserved9 << 28) |((uint32_t)vc0_cpl_data_scale << 26) |((uint32_t)vc0_cpl_hdr_scale << 24) |((uint32_t)vc0_cpl_tlp_q_mode << 21) |((uint32_t)reserved8 << 20) |((uint32_t)vc0_cpl_header_credit << 12) |((uint32_t)vc0_cpl_data_credit << 0));
}

__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_unpack(uint8_t* reserved9, uint8_t* vc0_cpl_data_scale, uint8_t* vc0_cpl_hdr_scale, uint8_t* vc0_cpl_tlp_q_mode, uint8_t* reserved8, uint8_t* vc0_cpl_header_credit, uint16_t* vc0_cpl_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);

	*reserved9 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*vc0_cpl_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc0_cpl_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc0_cpl_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved8 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc0_cpl_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc0_cpl_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_reserved_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_reserved_9_setf(uint8_t reserved9)
{
	ASSERT_ERR((((uint32_t)reserved9 << 28) & ~((uint32_t)0xF0000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)reserved9 <<28));
}
__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_data_scale_setf(uint8_t vc0cpldatascale)
{
	ASSERT_ERR((((uint32_t)vc0cpldatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc0cpldatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_hdr_scale_setf(uint8_t vc0cplhdrscale)
{
	ASSERT_ERR((((uint32_t)vc0cplhdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc0cplhdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_tlp_q_mode_setf(uint8_t vc0cpltlpqmode)
{
	ASSERT_ERR((((uint32_t)vc0cpltlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc0cpltlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_reserved_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_0_cpl_rx_q_ctrl_off_reserved_8_setf(uint8_t reserved8)
{
	ASSERT_ERR((((uint32_t)reserved8 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved8 <<20));
}
__INLINE uint8_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_0_cpl_rx_q_ctrl_off_vc_0_cpl_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_0_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief VC_1_P_RX_Q_CTRL_OFF register definition
 *  This register controls the segmented-buffer VC1 posted receive queue. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RESERVED2_VC1             0              
 *    30    TLP_TYPE_ORDERING_VC1     0              
 *    29:28 RESERVED1_VC1             0x0
 *    27:26 VC1_P_DATA_SCALE          0x1
 *    25:24 VC1_P_HDR_SCALE           0x1
 *    23:21 VC1_P_TLP_Q_MODE          0x1
 *    20    RESERVED0_VC1             0              
 *    19:12 VC1_P_HEADER_CREDIT       0x34
 *    11:00 VC1_P_DATA_CREDIT         0x80
 * </pre>
 */
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000754)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_OFFSET      0x00000754
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_INDEX       0x000001D5
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESET       0x05234080

__INLINE uint32_t  pcie_ep_vc_1_p_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_2_VC_1_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_2_VC_1_POS    31
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_1_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_1_POS    30
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_1_VC_1_MASK    ((uint32_t)0x30000000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_1_VC_1_LSB    28
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_1_VC_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_SCALE_LSB    26
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HDR_SCALE_LSB    24
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_0_VC_1_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_0_VC_1_POS    20
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_2_VC_1_RST    0x0
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_TLP_TYPE_ORDERING_VC_1_RST    0x0
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_1_VC_1_RST    0x0
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_TLP_Q_MODE_RST    0x1
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_RESERVED_0_VC_1_RST    0x0
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_HEADER_CREDIT_RST    0x34
#define PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_VC_1_P_DATA_CREDIT_RST    0x80

__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_pack(uint8_t reserved2_vc1, uint8_t tlp_type_ordering_vc1, uint8_t reserved1_vc1, uint8_t vc1_p_data_scale, uint8_t vc1_p_hdr_scale, uint8_t vc1_p_tlp_q_mode, uint8_t reserved0_vc1, uint8_t vc1_p_header_credit, uint16_t vc1_p_data_credit)
{
	ASSERT_ERR((((uint32_t)reserved2_vc1 << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_type_ordering_vc1 << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)reserved1_vc1 << 28) & ~((uint32_t)0x30000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_p_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_p_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_p_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved0_vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_p_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_p_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)reserved2_vc1 << 31) |((uint32_t)tlp_type_ordering_vc1 << 30) |((uint32_t)reserved1_vc1 << 28) |((uint32_t)vc1_p_data_scale << 26) |((uint32_t)vc1_p_hdr_scale << 24) |((uint32_t)vc1_p_tlp_q_mode << 21) |((uint32_t)reserved0_vc1 << 20) |((uint32_t)vc1_p_header_credit << 12) |((uint32_t)vc1_p_data_credit << 0));
}

__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_unpack(uint8_t* reserved2_vc1, uint8_t* tlp_type_ordering_vc1, uint8_t* reserved1_vc1, uint8_t* vc1_p_data_scale, uint8_t* vc1_p_hdr_scale, uint8_t* vc1_p_tlp_q_mode, uint8_t* reserved0_vc1, uint8_t* vc1_p_header_credit, uint16_t* vc1_p_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);

	*reserved2_vc1 = (localVal & ((uint32_t)0x80000000)) >>  31;
	*tlp_type_ordering_vc1 = (localVal & ((uint32_t)0x40000000)) >>  30;
	*reserved1_vc1 = (localVal & ((uint32_t)0x30000000)) >>  28;
	*vc1_p_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc1_p_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc1_p_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved0_vc1 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc1_p_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc1_p_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_2_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_2_vc_1_setf(uint8_t reserved2vc1)
{
	ASSERT_ERR((((uint32_t)reserved2vc1 << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)reserved2vc1 <<31));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_tlp_type_ordering_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_tlp_type_ordering_vc_1_setf(uint8_t tlptypeorderingvc1)
{
	ASSERT_ERR((((uint32_t)tlptypeorderingvc1 << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)tlptypeorderingvc1 <<30));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_1_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x30000000)) >> 28);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_1_vc_1_setf(uint8_t reserved1vc1)
{
	ASSERT_ERR((((uint32_t)reserved1vc1 << 28) & ~((uint32_t)0x30000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x30000000)) | ((uint32_t)reserved1vc1 <<28));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_data_scale_setf(uint8_t vc1pdatascale)
{
	ASSERT_ERR((((uint32_t)vc1pdatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc1pdatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_hdr_scale_setf(uint8_t vc1phdrscale)
{
	ASSERT_ERR((((uint32_t)vc1phdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc1phdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_tlp_q_mode_setf(uint8_t vc1ptlpqmode)
{
	ASSERT_ERR((((uint32_t)vc1ptlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc1ptlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_0_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_1_p_rx_q_ctrl_off_reserved_0_vc_1_setf(uint8_t reserved0vc1)
{
	ASSERT_ERR((((uint32_t)reserved0vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved0vc1 <<20));
}
__INLINE uint8_t pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_1_p_rx_q_ctrl_off_vc_1_p_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_P_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief VC_1_NP_RX_Q_CTRL_OFF register definition
 *  This registrer controls the segmented-buffer VC1 non-posted receive queue. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RESERVED4_VC1             0x0
 *    27:26 VC1_NP_DATA_SCALE         0x1
 *    25:24 VC1_NP_HDR_SCALE          0x1
 *    23:21 VC1_NP_TLP_Q_MODE         0x1
 *    20    RESERVED3_VC1             0              
 *    19:12 VC1_NP_HEADER_CREDIT      0x34
 *    11:00 VC1_NP_DATA_CREDIT        0x1
 * </pre>
 */
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000758)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_OFFSET      0x00000758
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_INDEX       0x000001D6
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESET       0x05234001

__INLINE uint32_t  pcie_ep_vc_1_np_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_4_VC_1_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_4_VC_1_LSB    28
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_4_VC_1_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_SCALE_LSB    26
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HDR_SCALE_LSB    24
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_3_VC_1_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_3_VC_1_POS    20
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_4_VC_1_RST    0x0
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_TLP_Q_MODE_RST    0x1
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_RESERVED_3_VC_1_RST    0x0
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_HEADER_CREDIT_RST    0x34
#define PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_VC_1_NP_DATA_CREDIT_RST    0x1

__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_pack(uint8_t reserved4_vc1, uint8_t vc1_np_data_scale, uint8_t vc1_np_hdr_scale, uint8_t vc1_np_tlp_q_mode, uint8_t reserved3_vc1, uint8_t vc1_np_header_credit, uint16_t vc1_np_data_credit)
{
	ASSERT_ERR((((uint32_t)reserved4_vc1 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_np_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_np_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_np_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved3_vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_np_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_np_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)reserved4_vc1 << 28) |((uint32_t)vc1_np_data_scale << 26) |((uint32_t)vc1_np_hdr_scale << 24) |((uint32_t)vc1_np_tlp_q_mode << 21) |((uint32_t)reserved3_vc1 << 20) |((uint32_t)vc1_np_header_credit << 12) |((uint32_t)vc1_np_data_credit << 0));
}

__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_unpack(uint8_t* reserved4_vc1, uint8_t* vc1_np_data_scale, uint8_t* vc1_np_hdr_scale, uint8_t* vc1_np_tlp_q_mode, uint8_t* reserved3_vc1, uint8_t* vc1_np_header_credit, uint16_t* vc1_np_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);

	*reserved4_vc1 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*vc1_np_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc1_np_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc1_np_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved3_vc1 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc1_np_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc1_np_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_reserved_4_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_reserved_4_vc_1_setf(uint8_t reserved4vc1)
{
	ASSERT_ERR((((uint32_t)reserved4vc1 << 28) & ~((uint32_t)0xF0000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)reserved4vc1 <<28));
}
__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_data_scale_setf(uint8_t vc1npdatascale)
{
	ASSERT_ERR((((uint32_t)vc1npdatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc1npdatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_hdr_scale_setf(uint8_t vc1nphdrscale)
{
	ASSERT_ERR((((uint32_t)vc1nphdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc1nphdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_tlp_q_mode_setf(uint8_t vc1nptlpqmode)
{
	ASSERT_ERR((((uint32_t)vc1nptlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc1nptlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_reserved_3_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_1_np_rx_q_ctrl_off_reserved_3_vc_1_setf(uint8_t reserved3vc1)
{
	ASSERT_ERR((((uint32_t)reserved3vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved3vc1 <<20));
}
__INLINE uint8_t pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_1_np_rx_q_ctrl_off_vc_1_np_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_NP_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief VC_1_CPL_RX_Q_CTRL_OFF register definition
 *  This register controls the segmented-buffer VC1 completion receive queue. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RESERVED6_VC1             0x0
 *    27:26 VC1_CPL_DATA_SCALE        0x1
 *    25:24 VC1_CPL_HDR_SCALE         0x1
 *    23:21 VC1_CPL_TLP_Q_MODE        0x4
 *    20    RESERVED5_VC1             0              
 *    19:12 VC1_CPL_HEADER_CREDIT     0x0
 *    11:00 VC1_CPL_DATA_CREDIT       0x0
 * </pre>
 */
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000075C)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_OFFSET      0x0000075C
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_INDEX       0x000001D7
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESET       0x05800000

__INLINE uint32_t  pcie_ep_vc_1_cpl_rx_q_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_6_VC_1_MASK    ((uint32_t)0xF0000000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_6_VC_1_LSB    28
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_6_VC_1_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_SCALE_MASK    ((uint32_t)0x0C000000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_SCALE_LSB    26
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HDR_SCALE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HDR_SCALE_LSB    24
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HDR_SCALE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_TLP_Q_MODE_MASK    ((uint32_t)0x00E00000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_TLP_Q_MODE_LSB    21
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_TLP_Q_MODE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_5_VC_1_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_5_VC_1_POS    20
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HEADER_CREDIT_MASK    ((uint32_t)0x000FF000)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HEADER_CREDIT_LSB    12
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HEADER_CREDIT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_CREDIT_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_CREDIT_LSB    0
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_CREDIT_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_6_VC_1_RST    0x0
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_SCALE_RST    0x1
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HDR_SCALE_RST    0x1
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_TLP_Q_MODE_RST    0x4
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_RESERVED_5_VC_1_RST    0x0
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_HEADER_CREDIT_RST    0x0
#define PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_VC_1_CPL_DATA_CREDIT_RST    0x0

__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_pack(uint8_t reserved6_vc1, uint8_t vc1_cpl_data_scale, uint8_t vc1_cpl_hdr_scale, uint8_t vc1_cpl_tlp_q_mode, uint8_t reserved5_vc1, uint8_t vc1_cpl_header_credit, uint16_t vc1_cpl_data_credit)
{
	ASSERT_ERR((((uint32_t)reserved6_vc1 << 28) & ~((uint32_t)0xF0000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_cpl_data_scale << 26) & ~((uint32_t)0x0C000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_cpl_hdr_scale << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_cpl_tlp_q_mode << 21) & ~((uint32_t)0x00E00000)) == 0);
	ASSERT_ERR((((uint32_t)reserved5_vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_cpl_header_credit << 12) & ~((uint32_t)0x000FF000)) == 0);
	ASSERT_ERR((((uint32_t)vc1_cpl_data_credit << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR,  ((uint32_t)reserved6_vc1 << 28) |((uint32_t)vc1_cpl_data_scale << 26) |((uint32_t)vc1_cpl_hdr_scale << 24) |((uint32_t)vc1_cpl_tlp_q_mode << 21) |((uint32_t)reserved5_vc1 << 20) |((uint32_t)vc1_cpl_header_credit << 12) |((uint32_t)vc1_cpl_data_credit << 0));
}

__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_unpack(uint8_t* reserved6_vc1, uint8_t* vc1_cpl_data_scale, uint8_t* vc1_cpl_hdr_scale, uint8_t* vc1_cpl_tlp_q_mode, uint8_t* reserved5_vc1, uint8_t* vc1_cpl_header_credit, uint16_t* vc1_cpl_data_credit)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);

	*reserved6_vc1 = (localVal & ((uint32_t)0xF0000000)) >>  28;
	*vc1_cpl_data_scale = (localVal & ((uint32_t)0x0C000000)) >>  26;
	*vc1_cpl_hdr_scale = (localVal & ((uint32_t)0x03000000)) >>  24;
	*vc1_cpl_tlp_q_mode = (localVal & ((uint32_t)0x00E00000)) >>  21;
	*reserved5_vc1 = (localVal & ((uint32_t)0x00100000)) >>  20;
	*vc1_cpl_header_credit = (localVal & ((uint32_t)0x000FF000)) >>  12;
	*vc1_cpl_data_credit = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_reserved_6_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xF0000000)) >> 28);
}
__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_reserved_6_vc_1_setf(uint8_t reserved6vc1)
{
	ASSERT_ERR((((uint32_t)reserved6vc1 << 28) & ~((uint32_t)0xF0000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0xF0000000)) | ((uint32_t)reserved6vc1 <<28));
}
__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_data_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0C000000)) >> 26);
}
__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_data_scale_setf(uint8_t vc1cpldatascale)
{
	ASSERT_ERR((((uint32_t)vc1cpldatascale << 26) & ~((uint32_t)0x0C000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x0C000000)) | ((uint32_t)vc1cpldatascale <<26));
}
__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_hdr_scale_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_hdr_scale_setf(uint8_t vc1cplhdrscale)
{
	ASSERT_ERR((((uint32_t)vc1cplhdrscale << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)vc1cplhdrscale <<24));
}
__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_tlp_q_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00E00000)) >> 21);
}
__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_tlp_q_mode_setf(uint8_t vc1cpltlpqmode)
{
	ASSERT_ERR((((uint32_t)vc1cpltlpqmode << 21) & ~((uint32_t)0x00E00000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00E00000)) | ((uint32_t)vc1cpltlpqmode <<21));
}
__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_reserved_5_vc_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_vc_1_cpl_rx_q_ctrl_off_reserved_5_vc_1_setf(uint8_t reserved5vc1)
{
	ASSERT_ERR((((uint32_t)reserved5vc1 << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)reserved5vc1 <<20));
}
__INLINE uint8_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_header_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000FF000)) >> 12);
}
__INLINE uint16_t pcie_ep_vc_1_cpl_rx_q_ctrl_off_vc_1_cpl_data_credit_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_VC_1_CPL_RX_Q_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief GEN_2_CTRL_OFF register definition
 *  This register controls various functions of the controller related to link training, lane reversal, and equalization. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23    SELECTABLE_DEEMPH_BIT_MUX 0              
 *    22    SELECT_DEEMPH_VAR_MUX     0              
 *    21    GEN1_EI_INFERENCE         0              
 *    20    SEL_DEEMPHASIS            0              
 *    19    CONFIG_TX_COMP_RX         0              
 *    18    CONFIG_PHY_TX_CHANGE      0              
 *    17    DIRECT_SPEED_CHANGE       0              
 *    16    AUTO_LANE_FLIP_CTRL_EN    0              
 *    15:13 PRE_DET_LANE              0x0
 *    12:08 NUM_OF_LANES              0x1
 *    07:00 FAST_TRAINING_SEQ         0xf
 * </pre>
 */
#define PCIE_EP_GEN_2_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000080C)
#define PCIE_EP_GEN_2_CTRL_OFF_OFFSET      0x0000080C
#define PCIE_EP_GEN_2_CTRL_OFF_INDEX       0x00000203
#define PCIE_EP_GEN_2_CTRL_OFF_RESET       0x0000010F

__INLINE uint32_t  pcie_ep_gen_2_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_gen_2_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_GEN_2_CTRL_OFF_SELECTABLE_DEEMPH_BIT_MUX_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_GEN_2_CTRL_OFF_SELECTABLE_DEEMPH_BIT_MUX_POS    23
#define PCIE_EP_GEN_2_CTRL_OFF_SELECT_DEEMPH_VAR_MUX_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_GEN_2_CTRL_OFF_SELECT_DEEMPH_VAR_MUX_POS    22
#define PCIE_EP_GEN_2_CTRL_OFF_GEN_1_EI_INFERENCE_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_GEN_2_CTRL_OFF_GEN_1_EI_INFERENCE_POS    21
#define PCIE_EP_GEN_2_CTRL_OFF_SEL_DEEMPHASIS_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_GEN_2_CTRL_OFF_SEL_DEEMPHASIS_POS    20
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_TX_COMP_RX_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_TX_COMP_RX_POS    19
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_PHY_TX_CHANGE_BIT    ((uint32_t)0x00040000)
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_PHY_TX_CHANGE_POS    18
#define PCIE_EP_GEN_2_CTRL_OFF_DIRECT_SPEED_CHANGE_BIT    ((uint32_t)0x00020000)
#define PCIE_EP_GEN_2_CTRL_OFF_DIRECT_SPEED_CHANGE_POS    17
#define PCIE_EP_GEN_2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_GEN_2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_POS    16
#define PCIE_EP_GEN_2_CTRL_OFF_PRE_DET_LANE_MASK    ((uint32_t)0x0000E000)
#define PCIE_EP_GEN_2_CTRL_OFF_PRE_DET_LANE_LSB    13
#define PCIE_EP_GEN_2_CTRL_OFF_PRE_DET_LANE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_GEN_2_CTRL_OFF_NUM_OF_LANES_MASK    ((uint32_t)0x00001F00)
#define PCIE_EP_GEN_2_CTRL_OFF_NUM_OF_LANES_LSB    8
#define PCIE_EP_GEN_2_CTRL_OFF_NUM_OF_LANES_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_GEN_2_CTRL_OFF_FAST_TRAINING_SEQ_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_GEN_2_CTRL_OFF_FAST_TRAINING_SEQ_LSB    0
#define PCIE_EP_GEN_2_CTRL_OFF_FAST_TRAINING_SEQ_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_GEN_2_CTRL_OFF_SELECTABLE_DEEMPH_BIT_MUX_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_SELECT_DEEMPH_VAR_MUX_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_GEN_1_EI_INFERENCE_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_SEL_DEEMPHASIS_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_TX_COMP_RX_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_CONFIG_PHY_TX_CHANGE_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_DIRECT_SPEED_CHANGE_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_AUTO_LANE_FLIP_CTRL_EN_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_PRE_DET_LANE_RST    0x0
#define PCIE_EP_GEN_2_CTRL_OFF_NUM_OF_LANES_RST    0x1
#define PCIE_EP_GEN_2_CTRL_OFF_FAST_TRAINING_SEQ_RST    0xf

__INLINE void pcie_ep_gen_2_ctrl_off_pack(uint8_t selectable_deemph_bit_mux, uint8_t select_deemph_var_mux, uint8_t gen1_ei_inference, uint8_t sel_deemphasis, uint8_t config_tx_comp_rx, uint8_t config_phy_tx_change, uint8_t direct_speed_change, uint8_t auto_lane_flip_ctrl_en, uint8_t pre_det_lane, uint8_t num_of_lanes, uint8_t fast_training_seq)
{
	ASSERT_ERR((((uint32_t)selectable_deemph_bit_mux << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)select_deemph_var_mux << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)gen1_ei_inference << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)sel_deemphasis << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)config_tx_comp_rx << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)config_phy_tx_change << 18) & ~((uint32_t)0x00040000)) == 0);
	ASSERT_ERR((((uint32_t)direct_speed_change << 17) & ~((uint32_t)0x00020000)) == 0);
	ASSERT_ERR((((uint32_t)auto_lane_flip_ctrl_en << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)pre_det_lane << 13) & ~((uint32_t)0x0000E000)) == 0);
	ASSERT_ERR((((uint32_t)num_of_lanes << 8) & ~((uint32_t)0x00001F00)) == 0);
	ASSERT_ERR((((uint32_t)fast_training_seq << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR,  ((uint32_t)selectable_deemph_bit_mux << 23) |((uint32_t)select_deemph_var_mux << 22) |((uint32_t)gen1_ei_inference << 21) |((uint32_t)sel_deemphasis << 20) |((uint32_t)config_tx_comp_rx << 19) |((uint32_t)config_phy_tx_change << 18) |((uint32_t)direct_speed_change << 17) |((uint32_t)auto_lane_flip_ctrl_en << 16) |((uint32_t)pre_det_lane << 13) |((uint32_t)num_of_lanes << 8) |((uint32_t)fast_training_seq << 0));
}

__INLINE void pcie_ep_gen_2_ctrl_off_unpack(uint8_t* selectable_deemph_bit_mux, uint8_t* select_deemph_var_mux, uint8_t* gen1_ei_inference, uint8_t* sel_deemphasis, uint8_t* config_tx_comp_rx, uint8_t* config_phy_tx_change, uint8_t* direct_speed_change, uint8_t* auto_lane_flip_ctrl_en, uint8_t* pre_det_lane, uint8_t* num_of_lanes, uint8_t* fast_training_seq)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);

	*selectable_deemph_bit_mux = (localVal & ((uint32_t)0x00800000)) >>  23;
	*select_deemph_var_mux = (localVal & ((uint32_t)0x00400000)) >>  22;
	*gen1_ei_inference = (localVal & ((uint32_t)0x00200000)) >>  21;
	*sel_deemphasis = (localVal & ((uint32_t)0x00100000)) >>  20;
	*config_tx_comp_rx = (localVal & ((uint32_t)0x00080000)) >>  19;
	*config_phy_tx_change = (localVal & ((uint32_t)0x00040000)) >>  18;
	*direct_speed_change = (localVal & ((uint32_t)0x00020000)) >>  17;
	*auto_lane_flip_ctrl_en = (localVal & ((uint32_t)0x00010000)) >>  16;
	*pre_det_lane = (localVal & ((uint32_t)0x0000E000)) >>  13;
	*num_of_lanes = (localVal & ((uint32_t)0x00001F00)) >>  8;
	*fast_training_seq = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_gen_2_ctrl_off_selectable_deemph_bit_mux_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_gen_2_ctrl_off_selectable_deemph_bit_mux_setf(uint8_t selectabledeemphbitmux)
{
	ASSERT_ERR((((uint32_t)selectabledeemphbitmux << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)selectabledeemphbitmux <<23));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_select_deemph_var_mux_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_gen_2_ctrl_off_select_deemph_var_mux_setf(uint8_t selectdeemphvarmux)
{
	ASSERT_ERR((((uint32_t)selectdeemphvarmux << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)selectdeemphvarmux <<22));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_gen_1_ei_inference_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_gen_2_ctrl_off_gen_1_ei_inference_setf(uint8_t gen1eiinference)
{
	ASSERT_ERR((((uint32_t)gen1eiinference << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)gen1eiinference <<21));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_sel_deemphasis_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_gen_2_ctrl_off_sel_deemphasis_setf(uint8_t seldeemphasis)
{
	ASSERT_ERR((((uint32_t)seldeemphasis << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)seldeemphasis <<20));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_config_tx_comp_rx_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_gen_2_ctrl_off_config_tx_comp_rx_setf(uint8_t configtxcomprx)
{
	ASSERT_ERR((((uint32_t)configtxcomprx << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)configtxcomprx <<19));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_config_phy_tx_change_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00040000)) >> 18);
}
__INLINE void pcie_ep_gen_2_ctrl_off_config_phy_tx_change_setf(uint8_t configphytxchange)
{
	ASSERT_ERR((((uint32_t)configphytxchange << 18) & ~((uint32_t)0x00040000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00040000)) | ((uint32_t)configphytxchange <<18));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_direct_speed_change_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00020000)) >> 17);
}
__INLINE void pcie_ep_gen_2_ctrl_off_direct_speed_change_setf(uint8_t directspeedchange)
{
	ASSERT_ERR((((uint32_t)directspeedchange << 17) & ~((uint32_t)0x00020000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00020000)) | ((uint32_t)directspeedchange <<17));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_auto_lane_flip_ctrl_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_gen_2_ctrl_off_auto_lane_flip_ctrl_en_setf(uint8_t autolaneflipctrlen)
{
	ASSERT_ERR((((uint32_t)autolaneflipctrlen << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)autolaneflipctrlen <<16));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_pre_det_lane_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000E000)) >> 13);
}
__INLINE void pcie_ep_gen_2_ctrl_off_pre_det_lane_setf(uint8_t predetlane)
{
	ASSERT_ERR((((uint32_t)predetlane << 13) & ~((uint32_t)0x0000E000)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x0000E000)) | ((uint32_t)predetlane <<13));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_num_of_lanes_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00001F00)) >> 8);
}
__INLINE void pcie_ep_gen_2_ctrl_off_num_of_lanes_setf(uint8_t numoflanes)
{
	ASSERT_ERR((((uint32_t)numoflanes << 8) & ~((uint32_t)0x00001F00)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x00001F00)) | ((uint32_t)numoflanes <<8));
}
__INLINE uint8_t pcie_ep_gen_2_ctrl_off_fast_training_seq_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_gen_2_ctrl_off_fast_training_seq_setf(uint8_t fasttrainingseq)
{
	ASSERT_ERR((((uint32_t)fasttrainingseq << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_GEN_2_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_GEN_2_CTRL_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)fasttrainingseq <<0));
}

/**
 * @brief PHY_STATUS_OFF register definition
 *  Memory mapped register from phy_cfg_status GPIO input pins. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 PHY_STATUS                0x0
 * </pre>
 */
#define PCIE_EP_PHY_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000810)
#define PCIE_EP_PHY_STATUS_OFF_OFFSET      0x00000810
#define PCIE_EP_PHY_STATUS_OFF_INDEX       0x00000204
#define PCIE_EP_PHY_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_phy_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PHY_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PHY_STATUS_OFF_PHY_STATUS_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PHY_STATUS_OFF_PHY_STATUS_LSB    0
#define PCIE_EP_PHY_STATUS_OFF_PHY_STATUS_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PHY_STATUS_OFF_PHY_STATUS_RST    0x0

__INLINE uint32_t pcie_ep_phy_status_off_phy_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_STATUS_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief PHY_CONTROL_OFF register definition
 *  Memory mapped register to cfg_phy_control GPIO output pins.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 PHY_CONTROL               0x0
 * </pre>
 */
#define PCIE_EP_PHY_CONTROL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000814)
#define PCIE_EP_PHY_CONTROL_OFF_OFFSET      0x00000814
#define PCIE_EP_PHY_CONTROL_OFF_INDEX       0x00000205
#define PCIE_EP_PHY_CONTROL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_phy_control_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PHY_CONTROL_OFF_ADDR);
}

__INLINE void pcie_ep_phy_control_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PHY_CONTROL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PHY_CONTROL_OFF_PHY_CONTROL_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PHY_CONTROL_OFF_PHY_CONTROL_LSB    0
#define PCIE_EP_PHY_CONTROL_OFF_PHY_CONTROL_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PHY_CONTROL_OFF_PHY_CONTROL_RST    0x0

__INLINE uint32_t pcie_ep_phy_control_off_phy_control_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_CONTROL_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_phy_control_off_phy_control_setf(uint32_t phycontrol)
{
	ASSERT_ERR((((uint32_t)phycontrol << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_PHY_CONTROL_OFF_ADDR, (uint32_t)phycontrol << 0);
}

/**
 * @brief TRGT_MAP_CTRL_OFF register definition
 *  This register controls the target map. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:21 TARGET_MAP_RESERVED_21_31 0x0
 *    20:16 TARGET_MAP_INDEX          0x0
 *    15:13 TARGET_MAP_RESERVED_13_15 0x0
 *    06    TARGET_MAP_ROM            1              
 *    05:00 TARGET_MAP_PF             0x3f
 * </pre>
 */
#define PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000081C)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_OFFSET      0x0000081C
#define PCIE_EP_TRGT_MAP_CTRL_OFF_INDEX       0x00000207
#define PCIE_EP_TRGT_MAP_CTRL_OFF_RESET       0x0000007F

__INLINE uint32_t  pcie_ep_trgt_map_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_trgt_map_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_21_31_MASK    ((uint32_t)0xFFE00000)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_21_31_LSB    21
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_21_31_WIDTH    ((uint32_t)0x0000000B)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_INDEX_MASK    ((uint32_t)0x001F0000)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_INDEX_LSB    16
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_INDEX_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_13_15_MASK    ((uint32_t)0x0000E000)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_13_15_LSB    13
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_13_15_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_ROM_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_ROM_POS    6
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_PF_MASK    ((uint32_t)0x0000003F)
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_PF_LSB    0
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_PF_WIDTH    ((uint32_t)0x00000006)

#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_21_31_RST    0x0
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_INDEX_RST    0x0
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_RESERVED_13_15_RST    0x0
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_ROM_RST    0x1
#define PCIE_EP_TRGT_MAP_CTRL_OFF_TARGET_MAP_PF_RST    0x3f

__INLINE void pcie_ep_trgt_map_ctrl_off_pack(uint16_t target_map_reserved_21_31, uint8_t target_map_index, uint8_t target_map_reserved_13_15, uint8_t target_map_rom, uint8_t target_map_pf)
{
	ASSERT_ERR((((uint32_t)target_map_reserved_21_31 << 21) & ~((uint32_t)0xFFE00000)) == 0);
	ASSERT_ERR((((uint32_t)target_map_index << 16) & ~((uint32_t)0x001F0000)) == 0);
	ASSERT_ERR((((uint32_t)target_map_reserved_13_15 << 13) & ~((uint32_t)0x0000E000)) == 0);
	ASSERT_ERR((((uint32_t)target_map_rom << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)target_map_pf << 0) & ~((uint32_t)0x0000003F)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR,  ((uint32_t)target_map_reserved_21_31 << 21) |((uint32_t)target_map_index << 16) |((uint32_t)target_map_reserved_13_15 << 13) |((uint32_t)target_map_rom << 6) |((uint32_t)target_map_pf << 0));
}

__INLINE void pcie_ep_trgt_map_ctrl_off_unpack(uint16_t* target_map_reserved_21_31, uint8_t* target_map_index, uint8_t* target_map_reserved_13_15, uint8_t* target_map_rom, uint8_t* target_map_pf)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);

	*target_map_reserved_21_31 = (localVal & ((uint32_t)0xFFE00000)) >>  21;
	*target_map_index = (localVal & ((uint32_t)0x001F0000)) >>  16;
	*target_map_reserved_13_15 = (localVal & ((uint32_t)0x0000E000)) >>  13;
	*target_map_rom = (localVal & ((uint32_t)0x00000040)) >>  6;
	*target_map_pf = (localVal & ((uint32_t)0x0000003F)) >>  0;
}

__INLINE uint16_t pcie_ep_trgt_map_ctrl_off_target_map_reserved_21_31_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFE00000)) >> 21);
}
__INLINE uint8_t pcie_ep_trgt_map_ctrl_off_target_map_index_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x001F0000)) >> 16);
}
__INLINE void pcie_ep_trgt_map_ctrl_off_target_map_index_setf(uint8_t targetmapindex)
{
	ASSERT_ERR((((uint32_t)targetmapindex << 16) & ~((uint32_t)0x001F0000)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR) & ~((uint32_t)0x001F0000)) | ((uint32_t)targetmapindex <<16));
}
__INLINE uint8_t pcie_ep_trgt_map_ctrl_off_target_map_reserved_13_15_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000E000)) >> 13);
}
__INLINE uint8_t pcie_ep_trgt_map_ctrl_off_target_map_rom_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_trgt_map_ctrl_off_target_map_rom_setf(uint8_t targetmaprom)
{
	ASSERT_ERR((((uint32_t)targetmaprom << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)targetmaprom <<6));
}
__INLINE uint8_t pcie_ep_trgt_map_ctrl_off_target_map_pf_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000003F)) >> 0);
}
__INLINE void pcie_ep_trgt_map_ctrl_off_target_map_pf_setf(uint8_t targetmappf)
{
	ASSERT_ERR((((uint32_t)targetmappf << 0) & ~((uint32_t)0x0000003F)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_TRGT_MAP_CTRL_OFF_ADDR) & ~((uint32_t)0x0000003F)) | ((uint32_t)targetmappf <<0));
}

/**
 * @brief CLOCK_GATING_CTRL_OFF register definition
 *  This register enables you to disable dynamic clock gating. By default dynamic clock gating is on, allowing the controller to autonomously enable and disable its clocks. The clock gating is performed in the clock and reset module, DWC_pcie_clk_rst.v, and is initiated by the controllers clock enable signals. The following modules support dynamic clock gating:  - AXI Bridge  - RADM register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 RSVDP_2                   0x0
 *    01    AXI_CLK_GATING_EN         1              
 *    00    RADM_CLK_GATING_EN        1              
 * </pre>
 */
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000088C)
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_OFFSET      0x0000088C
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_INDEX       0x00000223
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RESET       0x00000003

__INLINE uint32_t  pcie_ep_clock_gating_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_clock_gating_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RSVDP_2_MASK    ((uint32_t)0xFFFFFFFC)
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RSVDP_2_LSB    2
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RSVDP_2_WIDTH    ((uint32_t)0x0000001E)
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_POS    1
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_POS    0

#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RSVDP_2_RST    0x0
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_AXI_CLK_GATING_EN_RST    0x1
#define PCIE_EP_CLOCK_GATING_CTRL_OFF_RADM_CLK_GATING_EN_RST    0x1

__INLINE void pcie_ep_clock_gating_ctrl_off_pack(uint32_t rsvdp_2, uint8_t axi_clk_gating_en, uint8_t radm_clk_gating_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_2 << 2) & ~((uint32_t)0xFFFFFFFC)) == 0);
	ASSERT_ERR((((uint32_t)axi_clk_gating_en << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)radm_clk_gating_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_2 << 2) |((uint32_t)axi_clk_gating_en << 1) |((uint32_t)radm_clk_gating_en << 0));
}

__INLINE void pcie_ep_clock_gating_ctrl_off_unpack(uint32_t* rsvdp_2, uint8_t* axi_clk_gating_en, uint8_t* radm_clk_gating_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR);

	*rsvdp_2 = (localVal & ((uint32_t)0xFFFFFFFC)) >>  2;
	*axi_clk_gating_en = (localVal & ((uint32_t)0x00000002)) >>  1;
	*radm_clk_gating_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_clock_gating_ctrl_off_rsvdp_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFC)) >> 2);
}
__INLINE uint8_t pcie_ep_clock_gating_ctrl_off_axi_clk_gating_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_clock_gating_ctrl_off_axi_clk_gating_en_setf(uint8_t axiclkgatingen)
{
	ASSERT_ERR((((uint32_t)axiclkgatingen << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)axiclkgatingen <<1));
}
__INLINE uint8_t pcie_ep_clock_gating_ctrl_off_radm_clk_gating_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_clock_gating_ctrl_off_radm_clk_gating_en_setf(uint8_t radmclkgatingen)
{
	ASSERT_ERR((((uint32_t)radmclkgatingen << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_CLOCK_GATING_CTRL_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)radmclkgatingen <<0));
}

/**
 * @brief ORDER_RULE_CTRL_OFF register definition
 *  This register controls the order rule. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15:08 CPL_PASS_P                0x0
 *    07:00 NP_PASS_P                 0x0
 * </pre>
 */
#define PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008B4)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_OFFSET      0x000008B4
#define PCIE_EP_ORDER_RULE_CTRL_OFF_INDEX       0x0000022D
#define PCIE_EP_ORDER_RULE_CTRL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_order_rule_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_order_rule_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_ORDER_RULE_CTRL_OFF_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_RSVDP_16_LSB    16
#define PCIE_EP_ORDER_RULE_CTRL_OFF_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_CPL_PASS_P_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_CPL_PASS_P_LSB    8
#define PCIE_EP_ORDER_RULE_CTRL_OFF_CPL_PASS_P_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_NP_PASS_P_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_ORDER_RULE_CTRL_OFF_NP_PASS_P_LSB    0
#define PCIE_EP_ORDER_RULE_CTRL_OFF_NP_PASS_P_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_ORDER_RULE_CTRL_OFF_RSVDP_16_RST    0x0
#define PCIE_EP_ORDER_RULE_CTRL_OFF_CPL_PASS_P_RST    0x0
#define PCIE_EP_ORDER_RULE_CTRL_OFF_NP_PASS_P_RST    0x0

__INLINE void pcie_ep_order_rule_ctrl_off_pack(uint16_t rsvdp_16, uint8_t cpl_pass_p, uint8_t np_pass_p)
{
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)cpl_pass_p << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)np_pass_p << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_16 << 16) |((uint32_t)cpl_pass_p << 8) |((uint32_t)np_pass_p << 0));
}

__INLINE void pcie_ep_order_rule_ctrl_off_unpack(uint16_t* rsvdp_16, uint8_t* cpl_pass_p, uint8_t* np_pass_p)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*cpl_pass_p = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*np_pass_p = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint16_t pcie_ep_order_rule_ctrl_off_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_order_rule_ctrl_off_cpl_pass_p_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_order_rule_ctrl_off_cpl_pass_p_setf(uint8_t cplpassp)
{
	ASSERT_ERR((((uint32_t)cplpassp << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)cplpassp <<8));
}
__INLINE uint8_t pcie_ep_order_rule_ctrl_off_np_pass_p_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_order_rule_ctrl_off_np_pass_p_setf(uint8_t nppassp)
{
	ASSERT_ERR((((uint32_t)nppassp << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_ORDER_RULE_CTRL_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)nppassp <<0));
}

/**
 * @brief PIPE_LOOPBACK_CONTROL_OFF register definition
 *  This register controls the PIPE Loopback. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    PIPE_LOOPBACK             0              
 *    30:27 RSVDP_27                  0x0
 *    26:24 RXSTATUS_VALUE            0x0
 *    23:22 RSVDP_22                  0x0
 *    21:16 RXSTATUS_LANE             0x0
 *    15:00 LPBK_RXVALID              0x1
 * </pre>
 */
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008B8)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_OFFSET      0x000008B8
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_INDEX       0x0000022E
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RESET       0x00000001

__INLINE uint32_t  pcie_ep_pipe_loopback_control_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
}

__INLINE void pcie_ep_pipe_loopback_control_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_PIPE_LOOPBACK_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_PIPE_LOOPBACK_POS    31
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_27_MASK    ((uint32_t)0x78000000)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_27_LSB    27
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_27_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_VALUE_MASK    ((uint32_t)0x07000000)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_VALUE_LSB    24
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_VALUE_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_22_MASK    ((uint32_t)0x00C00000)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_22_LSB    22
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_22_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_LANE_MASK    ((uint32_t)0x003F0000)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_LANE_LSB    16
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_LANE_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_LPBK_RXVALID_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_LPBK_RXVALID_LSB    0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_LPBK_RXVALID_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_PIPE_LOOPBACK_RST    0x0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_27_RST    0x0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_VALUE_RST    0x0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RSVDP_22_RST    0x0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_RXSTATUS_LANE_RST    0x0
#define PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_LPBK_RXVALID_RST    0x1

__INLINE void pcie_ep_pipe_loopback_control_off_pack(uint8_t pipe_loopback, uint8_t rsvdp_27, uint8_t rxstatus_value, uint8_t rsvdp_22, uint8_t rxstatus_lane, uint16_t lpbk_rxvalid)
{
	ASSERT_ERR((((uint32_t)pipe_loopback << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_27 << 27) & ~((uint32_t)0x78000000)) == 0);
	ASSERT_ERR((((uint32_t)rxstatus_value << 24) & ~((uint32_t)0x07000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_22 << 22) & ~((uint32_t)0x00C00000)) == 0);
	ASSERT_ERR((((uint32_t)rxstatus_lane << 16) & ~((uint32_t)0x003F0000)) == 0);
	ASSERT_ERR((((uint32_t)lpbk_rxvalid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR,  ((uint32_t)pipe_loopback << 31) |((uint32_t)rsvdp_27 << 27) |((uint32_t)rxstatus_value << 24) |((uint32_t)rsvdp_22 << 22) |((uint32_t)rxstatus_lane << 16) |((uint32_t)lpbk_rxvalid << 0));
}

__INLINE void pcie_ep_pipe_loopback_control_off_unpack(uint8_t* pipe_loopback, uint8_t* rsvdp_27, uint8_t* rxstatus_value, uint8_t* rsvdp_22, uint8_t* rxstatus_lane, uint16_t* lpbk_rxvalid)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);

	*pipe_loopback = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_27 = (localVal & ((uint32_t)0x78000000)) >>  27;
	*rxstatus_value = (localVal & ((uint32_t)0x07000000)) >>  24;
	*rsvdp_22 = (localVal & ((uint32_t)0x00C00000)) >>  22;
	*rxstatus_lane = (localVal & ((uint32_t)0x003F0000)) >>  16;
	*lpbk_rxvalid = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint8_t pcie_ep_pipe_loopback_control_off_pipe_loopback_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_pipe_loopback_control_off_pipe_loopback_setf(uint8_t pipeloopback)
{
	ASSERT_ERR((((uint32_t)pipeloopback << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)pipeloopback <<31));
}
__INLINE uint8_t pcie_ep_pipe_loopback_control_off_rsvdp_27_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x78000000)) >> 27);
}
__INLINE void pcie_ep_pipe_loopback_control_off_rxstatus_value_setf(uint8_t rxstatusvalue)
{
	ASSERT_ERR((((uint32_t)rxstatusvalue << 24) & ~((uint32_t)0x07000000)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR) & ~((uint32_t)0x07000000)) | ((uint32_t)rxstatusvalue <<24));
}
__INLINE uint8_t pcie_ep_pipe_loopback_control_off_rsvdp_22_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00C00000)) >> 22);
}
__INLINE uint8_t pcie_ep_pipe_loopback_control_off_rxstatus_lane_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x003F0000)) >> 16);
}
__INLINE void pcie_ep_pipe_loopback_control_off_rxstatus_lane_setf(uint8_t rxstatuslane)
{
	ASSERT_ERR((((uint32_t)rxstatuslane << 16) & ~((uint32_t)0x003F0000)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR) & ~((uint32_t)0x003F0000)) | ((uint32_t)rxstatuslane <<16));
}
__INLINE uint16_t pcie_ep_pipe_loopback_control_off_lpbk_rxvalid_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_pipe_loopback_control_off_lpbk_rxvalid_setf(uint16_t lpbkrxvalid)
{
	ASSERT_ERR((((uint32_t)lpbkrxvalid << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PIPE_LOOPBACK_CONTROL_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)lpbkrxvalid <<0));
}

/**
 * @brief MISC_CONTROL_1_OFF register definition
 *  This is the DBI Read-Only write enable register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:23 RSVDP_23                  0x0
 *    22    PORT_LOGIC_WR_DISABLE     0              
 *    21    P2_P_ERR_RPT_CTRL         0              
 *    20    P2_P_TRACK_CPL_TO_REG     0              
 *    19:18 TARGET_ABOVE_CONFIG_LIMIT_REG 0x2
 *    17:08 CONFIG_LIMIT_REG          0x3ff
 *    07    CFG_TLP_BYPASS_EN_REG     0              
 *    06    CPLQ_MNG_EN               1              
 *    05    ARI_DEVICE_NUMBER         0              
 *    03    SIMPLIFIED_REPLAY_TIMER   0              
 *    02    UR_CA_MASK_4_TRGT1        0              
 *    01    DEFAULT_TARGET            0              
 *    00    DBI_RO_WR_EN              1              
 * </pre>
 */
#define PCIE_EP_MISC_CONTROL_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008BC)
#define PCIE_EP_MISC_CONTROL_1_OFF_OFFSET      0x000008BC
#define PCIE_EP_MISC_CONTROL_1_OFF_INDEX       0x0000022F
#define PCIE_EP_MISC_CONTROL_1_OFF_RESET       0x000BFF41

__INLINE uint32_t  pcie_ep_misc_control_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
}

__INLINE void pcie_ep_misc_control_1_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_MISC_CONTROL_1_OFF_RSVDP_23_MASK    ((uint32_t)0xFF800000)
#define PCIE_EP_MISC_CONTROL_1_OFF_RSVDP_23_LSB    23
#define PCIE_EP_MISC_CONTROL_1_OFF_RSVDP_23_WIDTH    ((uint32_t)0x00000009)
#define PCIE_EP_MISC_CONTROL_1_OFF_PORT_LOGIC_WR_DISABLE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_MISC_CONTROL_1_OFF_PORT_LOGIC_WR_DISABLE_POS    22
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_ERR_RPT_CTRL_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_ERR_RPT_CTRL_POS    21
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_TRACK_CPL_TO_REG_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_TRACK_CPL_TO_REG_POS    20
#define PCIE_EP_MISC_CONTROL_1_OFF_TARGET_ABOVE_CONFIG_LIMIT_REG_MASK    ((uint32_t)0x000C0000)
#define PCIE_EP_MISC_CONTROL_1_OFF_TARGET_ABOVE_CONFIG_LIMIT_REG_LSB    18
#define PCIE_EP_MISC_CONTROL_1_OFF_TARGET_ABOVE_CONFIG_LIMIT_REG_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_MISC_CONTROL_1_OFF_CONFIG_LIMIT_REG_MASK    ((uint32_t)0x0003FF00)
#define PCIE_EP_MISC_CONTROL_1_OFF_CONFIG_LIMIT_REG_LSB    8
#define PCIE_EP_MISC_CONTROL_1_OFF_CONFIG_LIMIT_REG_WIDTH    ((uint32_t)0x0000000A)
#define PCIE_EP_MISC_CONTROL_1_OFF_CFG_TLP_BYPASS_EN_REG_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_MISC_CONTROL_1_OFF_CFG_TLP_BYPASS_EN_REG_POS    7
#define PCIE_EP_MISC_CONTROL_1_OFF_CPLQ_MNG_EN_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_MISC_CONTROL_1_OFF_CPLQ_MNG_EN_POS    6
#define PCIE_EP_MISC_CONTROL_1_OFF_ARI_DEVICE_NUMBER_BIT    ((uint32_t)0x00000020)
#define PCIE_EP_MISC_CONTROL_1_OFF_ARI_DEVICE_NUMBER_POS    5
#define PCIE_EP_MISC_CONTROL_1_OFF_SIMPLIFIED_REPLAY_TIMER_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_MISC_CONTROL_1_OFF_SIMPLIFIED_REPLAY_TIMER_POS    3
#define PCIE_EP_MISC_CONTROL_1_OFF_UR_CA_MASK_4_TRGT_1_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_MISC_CONTROL_1_OFF_UR_CA_MASK_4_TRGT_1_POS    2
#define PCIE_EP_MISC_CONTROL_1_OFF_DEFAULT_TARGET_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_MISC_CONTROL_1_OFF_DEFAULT_TARGET_POS    1
#define PCIE_EP_MISC_CONTROL_1_OFF_DBI_RO_WR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_MISC_CONTROL_1_OFF_DBI_RO_WR_EN_POS    0

#define PCIE_EP_MISC_CONTROL_1_OFF_RSVDP_23_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_PORT_LOGIC_WR_DISABLE_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_ERR_RPT_CTRL_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_P_2_P_TRACK_CPL_TO_REG_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_TARGET_ABOVE_CONFIG_LIMIT_REG_RST    0x2
#define PCIE_EP_MISC_CONTROL_1_OFF_CONFIG_LIMIT_REG_RST    0x3ff
#define PCIE_EP_MISC_CONTROL_1_OFF_CFG_TLP_BYPASS_EN_REG_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_CPLQ_MNG_EN_RST    0x1
#define PCIE_EP_MISC_CONTROL_1_OFF_ARI_DEVICE_NUMBER_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_SIMPLIFIED_REPLAY_TIMER_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_UR_CA_MASK_4_TRGT_1_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_DEFAULT_TARGET_RST    0x0
#define PCIE_EP_MISC_CONTROL_1_OFF_DBI_RO_WR_EN_RST    0x1

__INLINE void pcie_ep_misc_control_1_off_pack(uint16_t rsvdp_23, uint8_t port_logic_wr_disable, uint8_t p2_p_err_rpt_ctrl, uint8_t p2_p_track_cpl_to_reg, uint8_t target_above_config_limit_reg, uint16_t config_limit_reg, uint8_t cfg_tlp_bypass_en_reg, uint8_t cplq_mng_en, uint8_t ari_device_number, uint8_t simplified_replay_timer, uint8_t ur_ca_mask_4_trgt1, uint8_t default_target, uint8_t dbi_ro_wr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_23 << 23) & ~((uint32_t)0xFF800000)) == 0);
	ASSERT_ERR((((uint32_t)port_logic_wr_disable << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)p2_p_err_rpt_ctrl << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)p2_p_track_cpl_to_reg << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)target_above_config_limit_reg << 18) & ~((uint32_t)0x000C0000)) == 0);
	ASSERT_ERR((((uint32_t)config_limit_reg << 8) & ~((uint32_t)0x0003FF00)) == 0);
	ASSERT_ERR((((uint32_t)cfg_tlp_bypass_en_reg << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cplq_mng_en << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)ari_device_number << 5) & ~((uint32_t)0x00000020)) == 0);
	ASSERT_ERR((((uint32_t)simplified_replay_timer << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)ur_ca_mask_4_trgt1 << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)default_target << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)dbi_ro_wr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR,  ((uint32_t)rsvdp_23 << 23) |((uint32_t)port_logic_wr_disable << 22) |((uint32_t)p2_p_err_rpt_ctrl << 21) |((uint32_t)p2_p_track_cpl_to_reg << 20) |((uint32_t)target_above_config_limit_reg << 18) |((uint32_t)config_limit_reg << 8) |((uint32_t)cfg_tlp_bypass_en_reg << 7) |((uint32_t)cplq_mng_en << 6) |((uint32_t)ari_device_number << 5) |((uint32_t)simplified_replay_timer << 3) |((uint32_t)ur_ca_mask_4_trgt1 << 2) |((uint32_t)default_target << 1) |((uint32_t)dbi_ro_wr_en << 0));
}

__INLINE void pcie_ep_misc_control_1_off_unpack(uint16_t* rsvdp_23, uint8_t* port_logic_wr_disable, uint8_t* p2_p_err_rpt_ctrl, uint8_t* p2_p_track_cpl_to_reg, uint8_t* target_above_config_limit_reg, uint16_t* config_limit_reg, uint8_t* cfg_tlp_bypass_en_reg, uint8_t* cplq_mng_en, uint8_t* ari_device_number, uint8_t* simplified_replay_timer, uint8_t* ur_ca_mask_4_trgt1, uint8_t* default_target, uint8_t* dbi_ro_wr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);

	*rsvdp_23 = (localVal & ((uint32_t)0xFF800000)) >>  23;
	*port_logic_wr_disable = (localVal & ((uint32_t)0x00400000)) >>  22;
	*p2_p_err_rpt_ctrl = (localVal & ((uint32_t)0x00200000)) >>  21;
	*p2_p_track_cpl_to_reg = (localVal & ((uint32_t)0x00100000)) >>  20;
	*target_above_config_limit_reg = (localVal & ((uint32_t)0x000C0000)) >>  18;
	*config_limit_reg = (localVal & ((uint32_t)0x0003FF00)) >>  8;
	*cfg_tlp_bypass_en_reg = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cplq_mng_en = (localVal & ((uint32_t)0x00000040)) >>  6;
	*ari_device_number = (localVal & ((uint32_t)0x00000020)) >>  5;
	*simplified_replay_timer = (localVal & ((uint32_t)0x00000008)) >>  3;
	*ur_ca_mask_4_trgt1 = (localVal & ((uint32_t)0x00000004)) >>  2;
	*default_target = (localVal & ((uint32_t)0x00000002)) >>  1;
	*dbi_ro_wr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_misc_control_1_off_rsvdp_23_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFF800000)) >> 23);
}
__INLINE uint8_t pcie_ep_misc_control_1_off_port_logic_wr_disable_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_misc_control_1_off_port_logic_wr_disable_setf(uint8_t portlogicwrdisable)
{
	ASSERT_ERR((((uint32_t)portlogicwrdisable << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)portlogicwrdisable <<22));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_p_2_p_err_rpt_ctrl_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_misc_control_1_off_p_2_p_err_rpt_ctrl_setf(uint8_t p2perrrptctrl)
{
	ASSERT_ERR((((uint32_t)p2perrrptctrl << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)p2perrrptctrl <<21));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_p_2_p_track_cpl_to_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_misc_control_1_off_p_2_p_track_cpl_to_reg_setf(uint8_t p2ptrackcpltoreg)
{
	ASSERT_ERR((((uint32_t)p2ptrackcpltoreg << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)p2ptrackcpltoreg <<20));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_target_above_config_limit_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000C0000)) >> 18);
}
__INLINE void pcie_ep_misc_control_1_off_target_above_config_limit_reg_setf(uint8_t targetaboveconfiglimitreg)
{
	ASSERT_ERR((((uint32_t)targetaboveconfiglimitreg << 18) & ~((uint32_t)0x000C0000)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x000C0000)) | ((uint32_t)targetaboveconfiglimitreg <<18));
}
__INLINE uint16_t pcie_ep_misc_control_1_off_config_limit_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0003FF00)) >> 8);
}
__INLINE void pcie_ep_misc_control_1_off_config_limit_reg_setf(uint16_t configlimitreg)
{
	ASSERT_ERR((((uint32_t)configlimitreg << 8) & ~((uint32_t)0x0003FF00)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x0003FF00)) | ((uint32_t)configlimitreg <<8));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_cfg_tlp_bypass_en_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_misc_control_1_off_cfg_tlp_bypass_en_reg_setf(uint8_t cfgtlpbypassenreg)
{
	ASSERT_ERR((((uint32_t)cfgtlpbypassenreg << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)cfgtlpbypassenreg <<7));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_cplq_mng_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_misc_control_1_off_cplq_mng_en_setf(uint8_t cplqmngen)
{
	ASSERT_ERR((((uint32_t)cplqmngen << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)cplqmngen <<6));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_ari_device_number_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000020)) >> 5);
}
__INLINE void pcie_ep_misc_control_1_off_ari_device_number_setf(uint8_t aridevicenumber)
{
	ASSERT_ERR((((uint32_t)aridevicenumber << 5) & ~((uint32_t)0x00000020)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000020)) | ((uint32_t)aridevicenumber <<5));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_simplified_replay_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_misc_control_1_off_simplified_replay_timer_setf(uint8_t simplifiedreplaytimer)
{
	ASSERT_ERR((((uint32_t)simplifiedreplaytimer << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)simplifiedreplaytimer <<3));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_ur_ca_mask_4_trgt_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_misc_control_1_off_ur_ca_mask_4_trgt_1_setf(uint8_t urcamask4trgt1)
{
	ASSERT_ERR((((uint32_t)urcamask4trgt1 << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)urcamask4trgt1 <<2));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_default_target_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_misc_control_1_off_default_target_setf(uint8_t defaulttarget)
{
	ASSERT_ERR((((uint32_t)defaulttarget << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)defaulttarget <<1));
}
__INLINE uint8_t pcie_ep_misc_control_1_off_dbi_ro_wr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_misc_control_1_off_dbi_ro_wr_en_setf(uint8_t dbirowren)
{
	ASSERT_ERR((((uint32_t)dbirowren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_MISC_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_MISC_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dbirowren <<0));
}

/**
 * @brief MULTI_LANE_CONTROL_OFF register definition
 *  Used when upsizing or downsizing the link width through Configuration state without bringing the link down. For more information, see the  Link Establishment  section in the  Controller Operations  chapter of the Databook. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:08 RSVDP_8                   0x0
 *    07    UPCONFIGURE_SUPPORT       0              
 *    06    DIRECT_LINK_WIDTH_CHANGE  0              
 *    05:00 TARGET_LINK_WIDTH         0x0
 * </pre>
 */
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008C0)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_OFFSET      0x000008C0
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_INDEX       0x00000230
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_multi_lane_control_off_get(void)
{
	return REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);
}

__INLINE void pcie_ep_multi_lane_control_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_RSVDP_8_MASK    ((uint32_t)0xFFFFFF00)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_RSVDP_8_LSB    8
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000018)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_UPCONFIGURE_SUPPORT_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_UPCONFIGURE_SUPPORT_POS    7
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_DIRECT_LINK_WIDTH_CHANGE_BIT    ((uint32_t)0x00000040)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_DIRECT_LINK_WIDTH_CHANGE_POS    6
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_TARGET_LINK_WIDTH_MASK    ((uint32_t)0x0000003F)
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_TARGET_LINK_WIDTH_LSB    0
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_TARGET_LINK_WIDTH_WIDTH    ((uint32_t)0x00000006)

#define PCIE_EP_MULTI_LANE_CONTROL_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_UPCONFIGURE_SUPPORT_RST    0x0
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_DIRECT_LINK_WIDTH_CHANGE_RST    0x0
#define PCIE_EP_MULTI_LANE_CONTROL_OFF_TARGET_LINK_WIDTH_RST    0x0

__INLINE void pcie_ep_multi_lane_control_off_pack(uint32_t rsvdp_8, uint8_t upconfigure_support, uint8_t direct_link_width_change, uint8_t target_link_width)
{
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0xFFFFFF00)) == 0);
	ASSERT_ERR((((uint32_t)upconfigure_support << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)direct_link_width_change << 6) & ~((uint32_t)0x00000040)) == 0);
	ASSERT_ERR((((uint32_t)target_link_width << 0) & ~((uint32_t)0x0000003F)) == 0);
	REG_PL_WR(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR,  ((uint32_t)rsvdp_8 << 8) |((uint32_t)upconfigure_support << 7) |((uint32_t)direct_link_width_change << 6) |((uint32_t)target_link_width << 0));
}

__INLINE void pcie_ep_multi_lane_control_off_unpack(uint32_t* rsvdp_8, uint8_t* upconfigure_support, uint8_t* direct_link_width_change, uint8_t* target_link_width)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);

	*rsvdp_8 = (localVal & ((uint32_t)0xFFFFFF00)) >>  8;
	*upconfigure_support = (localVal & ((uint32_t)0x00000080)) >>  7;
	*direct_link_width_change = (localVal & ((uint32_t)0x00000040)) >>  6;
	*target_link_width = (localVal & ((uint32_t)0x0000003F)) >>  0;
}

__INLINE uint32_t pcie_ep_multi_lane_control_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFF00)) >> 8);
}
__INLINE uint8_t pcie_ep_multi_lane_control_off_upconfigure_support_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_multi_lane_control_off_upconfigure_support_setf(uint8_t upconfiguresupport)
{
	ASSERT_ERR((((uint32_t)upconfiguresupport << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)upconfiguresupport <<7));
}
__INLINE uint8_t pcie_ep_multi_lane_control_off_direct_link_width_change_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000040)) >> 6);
}
__INLINE void pcie_ep_multi_lane_control_off_direct_link_width_change_setf(uint8_t directlinkwidthchange)
{
	ASSERT_ERR((((uint32_t)directlinkwidthchange << 6) & ~((uint32_t)0x00000040)) == 0);
	REG_PL_WR(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR) & ~((uint32_t)0x00000040)) | ((uint32_t)directlinkwidthchange <<6));
}
__INLINE uint8_t pcie_ep_multi_lane_control_off_target_link_width_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000003F)) >> 0);
}
__INLINE void pcie_ep_multi_lane_control_off_target_link_width_setf(uint8_t targetlinkwidth)
{
	ASSERT_ERR((((uint32_t)targetlinkwidth << 0) & ~((uint32_t)0x0000003F)) == 0);
	REG_PL_WR(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_MULTI_LANE_CONTROL_OFF_ADDR) & ~((uint32_t)0x0000003F)) | ((uint32_t)targetlinkwidth <<0));
}

/**
 * @brief PHY_INTEROP_CTRL_OFF register definition
 *  This register controls the PHY interoperability. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:18 RSVDP_18                  0x0
 *    17:12 PHY_RST_TIMER             0x1e
 *    10    L1_CLK_SEL                0              
 *    09    L1_NOWAIT_P1              0              
 *    07    RSVDP_7                   0              
 *    06:00 RXSTANDBY_CONTROL         0x7f
 * </pre>
 */
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008C4)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_OFFSET      0x000008C4
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_INDEX       0x00000231
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RESET       0x0001E07F

__INLINE uint32_t  pcie_ep_phy_interop_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_phy_interop_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_18_MASK    ((uint32_t)0x7FFC0000)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_18_LSB    18
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_18_WIDTH    ((uint32_t)0x0000000D)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_MASK    ((uint32_t)0x0003F000)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_LSB    12
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_CLK_SEL_BIT    ((uint32_t)0x00000400)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_CLK_SEL_POS    10
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_NOWAIT_P_1_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_NOWAIT_P_1_POS    9
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_7_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_7_POS    7
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CONTROL_MASK    ((uint32_t)0x0000007F)
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CONTROL_LSB    0
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CONTROL_WIDTH    ((uint32_t)0x00000007)

#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_18_RST    0x0
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_PHY_RST_TIMER_RST    0x1e
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_CLK_SEL_RST    0x0
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_L_1_NOWAIT_P_1_RST    0x0
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RSVDP_7_RST    0x0
#define PCIE_EP_PHY_INTEROP_CTRL_OFF_RXSTANDBY_CONTROL_RST    0x7f

__INLINE void pcie_ep_phy_interop_ctrl_off_pack(uint16_t rsvdp_18, uint8_t phy_rst_timer, uint8_t l1_clk_sel, uint8_t l1_nowait_p1, uint8_t rsvdp_7, uint8_t rxstandby_control)
{
	ASSERT_ERR((((uint32_t)rsvdp_18 << 18) & ~((uint32_t)0x7FFC0000)) == 0);
	ASSERT_ERR((((uint32_t)phy_rst_timer << 12) & ~((uint32_t)0x0003F000)) == 0);
	ASSERT_ERR((((uint32_t)l1_clk_sel << 10) & ~((uint32_t)0x00000400)) == 0);
	ASSERT_ERR((((uint32_t)l1_nowait_p1 << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_7 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)rxstandby_control << 0) & ~((uint32_t)0x0000007F)) == 0);
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_18 << 18) |((uint32_t)phy_rst_timer << 12) |((uint32_t)l1_clk_sel << 10) |((uint32_t)l1_nowait_p1 << 9) |((uint32_t)rsvdp_7 << 7) |((uint32_t)rxstandby_control << 0));
}

__INLINE void pcie_ep_phy_interop_ctrl_off_unpack(uint16_t* rsvdp_18, uint8_t* phy_rst_timer, uint8_t* l1_clk_sel, uint8_t* l1_nowait_p1, uint8_t* rsvdp_7, uint8_t* rxstandby_control)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);

	*rsvdp_18 = (localVal & ((uint32_t)0x7FFC0000)) >>  18;
	*phy_rst_timer = (localVal & ((uint32_t)0x0003F000)) >>  12;
	*l1_clk_sel = (localVal & ((uint32_t)0x00000400)) >>  10;
	*l1_nowait_p1 = (localVal & ((uint32_t)0x00000200)) >>  9;
	*rsvdp_7 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*rxstandby_control = (localVal & ((uint32_t)0x0000007F)) >>  0;
}

__INLINE uint16_t pcie_ep_phy_interop_ctrl_off_rsvdp_18_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x7FFC0000)) >> 18);
}
__INLINE uint8_t pcie_ep_phy_interop_ctrl_off_phy_rst_timer_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0003F000)) >> 12);
}
__INLINE void pcie_ep_phy_interop_ctrl_off_phy_rst_timer_setf(uint8_t phyrsttimer)
{
	ASSERT_ERR((((uint32_t)phyrsttimer << 12) & ~((uint32_t)0x0003F000)) == 0);
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR) & ~((uint32_t)0x0003F000)) | ((uint32_t)phyrsttimer <<12));
}
__INLINE uint8_t pcie_ep_phy_interop_ctrl_off_l_1_clk_sel_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000400)) >> 10);
}
__INLINE void pcie_ep_phy_interop_ctrl_off_l_1_clk_sel_setf(uint8_t l1clksel)
{
	ASSERT_ERR((((uint32_t)l1clksel << 10) & ~((uint32_t)0x00000400)) == 0);
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR) & ~((uint32_t)0x00000400)) | ((uint32_t)l1clksel <<10));
}
__INLINE uint8_t pcie_ep_phy_interop_ctrl_off_l_1_nowait_p_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_phy_interop_ctrl_off_l_1_nowait_p_1_setf(uint8_t l1nowaitp1)
{
	ASSERT_ERR((((uint32_t)l1nowaitp1 << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)l1nowaitp1 <<9));
}
__INLINE uint8_t pcie_ep_phy_interop_ctrl_off_rsvdp_7_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE uint8_t pcie_ep_phy_interop_ctrl_off_rxstandby_control_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000007F)) >> 0);
}
__INLINE void pcie_ep_phy_interop_ctrl_off_rxstandby_control_setf(uint8_t rxstandbycontrol)
{
	ASSERT_ERR((((uint32_t)rxstandbycontrol << 0) & ~((uint32_t)0x0000007F)) == 0);
	REG_PL_WR(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PHY_INTEROP_CTRL_OFF_ADDR) & ~((uint32_t)0x0000007F)) | ((uint32_t)rxstandbycontrol <<0));
}

/**
 * @brief TRGT_CPL_LUT_DELETE_ENTRY_OFF register definition
 *  Using this register you can delete one entry in the target completion LUT. You should only use this register when you know that your application will never send the completion because of an FLR or any other reason.  Note:: The target completion LUT (and associated target completion timeout event) is watching for completions (from your application on XALI0/1/2 or AXI master read channel) corresponding to previously received non-posted requests from the PCIe wire. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    DELETE_EN                 0              
 *    30:00 LOOK_UP_ID                0x0
 * </pre>
 */
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008C8)
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_OFFSET      0x000008C8
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_INDEX       0x00000232
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_trgt_cpl_lut_delete_entry_off_get(void)
{
	return REG_PL_RD(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR);
}

__INLINE void pcie_ep_trgt_cpl_lut_delete_entry_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_POS    31
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_MASK    ((uint32_t)0x7FFFFFFF)
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_LSB    0
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_WIDTH    ((uint32_t)0x0000001F)

#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_DELETE_EN_RST    0x0
#define PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_LOOK_UP_ID_RST    0x0

__INLINE void pcie_ep_trgt_cpl_lut_delete_entry_off_pack(uint8_t delete_en, uint32_t look_up_id)
{
	ASSERT_ERR((((uint32_t)delete_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)look_up_id << 0) & ~((uint32_t)0x7FFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR,  ((uint32_t)delete_en << 31) |((uint32_t)look_up_id << 0));
}

__INLINE void pcie_ep_trgt_cpl_lut_delete_entry_off_unpack(uint8_t* delete_en, uint32_t* look_up_id)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR);

	*delete_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*look_up_id = (localVal & ((uint32_t)0x7FFFFFFF)) >>  0;
}

__INLINE void pcie_ep_trgt_cpl_lut_delete_entry_off_delete_en_setf(uint8_t deleteen)
{
	ASSERT_ERR((((uint32_t)deleteen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR, (REG_PL_RD(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)deleteen <<31));
}
__INLINE uint32_t pcie_ep_trgt_cpl_lut_delete_entry_off_look_up_id_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x7FFFFFFF)) >> 0);
}
__INLINE void pcie_ep_trgt_cpl_lut_delete_entry_off_look_up_id_setf(uint32_t lookupid)
{
	ASSERT_ERR((((uint32_t)lookupid << 0) & ~((uint32_t)0x7FFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR, (REG_PL_RD(PCIE_EP_TRGT_CPL_LUT_DELETE_ENTRY_OFF_ADDR) & ~((uint32_t)0x7FFFFFFF)) | ((uint32_t)lookupid <<0));
}

/**
 * @brief LINK_FLUSH_CONTROL_OFF register definition
 *  This register controls link reset request flush behaviour. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVD_I_8                  0xff
 *    23:01 RSVDP_1                   0x0
 *    00    AUTO_FLUSH_EN             1              
 * </pre>
 */
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008CC)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_OFFSET      0x000008CC
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_INDEX       0x00000233
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RESET       0xFF000001

__INLINE uint32_t  pcie_ep_link_flush_control_off_get(void)
{
	return REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR);
}

__INLINE void pcie_ep_link_flush_control_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVD_I_8_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVD_I_8_LSB    24
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVD_I_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVDP_1_MASK    ((uint32_t)0x00FFFFFE)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVDP_1_LSB    1
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVDP_1_WIDTH    ((uint32_t)0x00000017)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_AUTO_FLUSH_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_AUTO_FLUSH_EN_POS    0

#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVD_I_8_RST    0xff
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_LINK_FLUSH_CONTROL_OFF_AUTO_FLUSH_EN_RST    0x1

__INLINE void pcie_ep_link_flush_control_off_pack(uint8_t rsvd_i_8, uint32_t rsvdp_1, uint8_t auto_flush_en)
{
	ASSERT_ERR((((uint32_t)rsvd_i_8 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x00FFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)auto_flush_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR,  ((uint32_t)rsvd_i_8 << 24) |((uint32_t)rsvdp_1 << 1) |((uint32_t)auto_flush_en << 0));
}

__INLINE void pcie_ep_link_flush_control_off_unpack(uint8_t* rsvd_i_8, uint32_t* rsvdp_1, uint8_t* auto_flush_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR);

	*rsvd_i_8 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_1 = (localVal & ((uint32_t)0x00FFFFFE)) >>  1;
	*auto_flush_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_link_flush_control_off_rsvd_i_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE void pcie_ep_link_flush_control_off_rsvd_i_8_setf(uint8_t rsvdi8)
{
	ASSERT_ERR((((uint32_t)rsvdi8 << 24) & ~((uint32_t)0xFF000000)) == 0);
	REG_PL_WR(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR) & ~((uint32_t)0xFF000000)) | ((uint32_t)rsvdi8 <<24));
}
__INLINE uint32_t pcie_ep_link_flush_control_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x00FFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_link_flush_control_off_auto_flush_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_link_flush_control_off_auto_flush_en_setf(uint8_t autoflushen)
{
	ASSERT_ERR((((uint32_t)autoflushen << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR, (REG_PL_RD(PCIE_EP_LINK_FLUSH_CONTROL_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)autoflushen <<0));
}

/**
 * @brief AMBA_ERROR_RESPONSE_DEFAULT_OFF register definition
 *  This register holds the AXI bridge slave error responses. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15:10 AMBA_ERROR_RESPONSE_MAP   0x27
 *    09:05 RSVDP_5                   0x0
 *    04:03 AMBA_ERROR_RESPONSE_CRS   0x0
 *    02    AMBA_ERROR_RESPONSE_VENDORID 0              
 *    01    RSVDP_1                   0              
 *    00    AMBA_ERROR_RESPONSE_GLOBAL 0              
 * </pre>
 */
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008D0)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_OFFSET      0x000008D0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_INDEX       0x00000234
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RESET       0x00009C00

__INLINE uint32_t  pcie_ep_amba_error_response_default_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
}

__INLINE void pcie_ep_amba_error_response_default_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_16_LSB    16
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_MAP_MASK    ((uint32_t)0x0000FC00)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_MAP_LSB    10
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_MAP_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_5_MASK    ((uint32_t)0x000003E0)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_5_LSB    5
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_5_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_CRS_MASK    ((uint32_t)0x00000018)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_CRS_LSB    3
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_CRS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_VENDORID_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_VENDORID_POS    2
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_1_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_1_POS    1
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_GLOBAL_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_GLOBAL_POS    0

#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_16_RST    0x0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_MAP_RST    0x27
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_5_RST    0x0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_CRS_RST    0x0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_VENDORID_RST    0x0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_AMBA_ERROR_RESPONSE_GLOBAL_RST    0x0

__INLINE void pcie_ep_amba_error_response_default_off_pack(uint16_t rsvdp_16, uint8_t amba_error_response_map, uint8_t rsvdp_5, uint8_t amba_error_response_crs, uint8_t amba_error_response_vendorid, uint8_t rsvdp_1, uint8_t amba_error_response_global)
{
	ASSERT_ERR((((uint32_t)rsvdp_16 << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)amba_error_response_map << 10) & ~((uint32_t)0x0000FC00)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_5 << 5) & ~((uint32_t)0x000003E0)) == 0);
	ASSERT_ERR((((uint32_t)amba_error_response_crs << 3) & ~((uint32_t)0x00000018)) == 0);
	ASSERT_ERR((((uint32_t)amba_error_response_vendorid << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)amba_error_response_global << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR,  ((uint32_t)rsvdp_16 << 16) |((uint32_t)amba_error_response_map << 10) |((uint32_t)rsvdp_5 << 5) |((uint32_t)amba_error_response_crs << 3) |((uint32_t)amba_error_response_vendorid << 2) |((uint32_t)rsvdp_1 << 1) |((uint32_t)amba_error_response_global << 0));
}

__INLINE void pcie_ep_amba_error_response_default_off_unpack(uint16_t* rsvdp_16, uint8_t* amba_error_response_map, uint8_t* rsvdp_5, uint8_t* amba_error_response_crs, uint8_t* amba_error_response_vendorid, uint8_t* rsvdp_1, uint8_t* amba_error_response_global)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*amba_error_response_map = (localVal & ((uint32_t)0x0000FC00)) >>  10;
	*rsvdp_5 = (localVal & ((uint32_t)0x000003E0)) >>  5;
	*amba_error_response_crs = (localVal & ((uint32_t)0x00000018)) >>  3;
	*amba_error_response_vendorid = (localVal & ((uint32_t)0x00000004)) >>  2;
	*rsvdp_1 = (localVal & ((uint32_t)0x00000002)) >>  1;
	*amba_error_response_global = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint16_t pcie_ep_amba_error_response_default_off_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_amba_error_response_map_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FC00)) >> 10);
}
__INLINE void pcie_ep_amba_error_response_default_off_amba_error_response_map_setf(uint8_t ambaerrorresponsemap)
{
	ASSERT_ERR((((uint32_t)ambaerrorresponsemap << 10) & ~((uint32_t)0x0000FC00)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR) & ~((uint32_t)0x0000FC00)) | ((uint32_t)ambaerrorresponsemap <<10));
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_rsvdp_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003E0)) >> 5);
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_amba_error_response_crs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000018)) >> 3);
}
__INLINE void pcie_ep_amba_error_response_default_off_amba_error_response_crs_setf(uint8_t ambaerrorresponsecrs)
{
	ASSERT_ERR((((uint32_t)ambaerrorresponsecrs << 3) & ~((uint32_t)0x00000018)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR) & ~((uint32_t)0x00000018)) | ((uint32_t)ambaerrorresponsecrs <<3));
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_amba_error_response_vendorid_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_amba_error_response_default_off_amba_error_response_vendorid_setf(uint8_t ambaerrorresponsevendorid)
{
	ASSERT_ERR((((uint32_t)ambaerrorresponsevendorid << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)ambaerrorresponsevendorid <<2));
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE uint8_t pcie_ep_amba_error_response_default_off_amba_error_response_global_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_amba_error_response_default_off_amba_error_response_global_setf(uint8_t ambaerrorresponseglobal)
{
	ASSERT_ERR((((uint32_t)ambaerrorresponseglobal << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ERROR_RESPONSE_DEFAULT_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)ambaerrorresponseglobal <<0));
}

/**
 * @brief AMBA_LINK_TIMEOUT_OFF register definition
 *  If your application AXI master issues outbound requests to the AXI bridge slave interface before the PCIe link is operational, the controller starts a  flush  timer. The timeout value of the timer is set by this register. If the timer times out before the PCIe link is operational, the bridge TX request queues are flushed. For more information, see the  AXI Bridge Initialization, Clocking and Reset  section in the AXI chapter of the Databook. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:09 RSVDP_9                   0x0
 *    08    LINK_TIMEOUT_ENABLE_DEFAULT 1              
 *    07:00 LINK_TIMEOUT_PERIOD_DEFAULT 0x32
 * </pre>
 */
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008D4)
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_OFFSET      0x000008D4
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_INDEX       0x00000235
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_RESET       0x00000132

__INLINE uint32_t  pcie_ep_amba_link_timeout_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR);
}

__INLINE void pcie_ep_amba_link_timeout_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_RSVDP_9_MASK    ((uint32_t)0xFFFFFE00)
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_RSVDP_9_LSB    9
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_RSVDP_9_WIDTH    ((uint32_t)0x00000017)
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_ENABLE_DEFAULT_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_ENABLE_DEFAULT_POS    8
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_LSB    0
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_RSVDP_9_RST    0x0
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_ENABLE_DEFAULT_RST    0x1
#define PCIE_EP_AMBA_LINK_TIMEOUT_OFF_LINK_TIMEOUT_PERIOD_DEFAULT_RST    0x32

__INLINE void pcie_ep_amba_link_timeout_off_pack(uint32_t rsvdp_9, uint8_t link_timeout_enable_default, uint8_t link_timeout_period_default)
{
	ASSERT_ERR((((uint32_t)rsvdp_9 << 9) & ~((uint32_t)0xFFFFFE00)) == 0);
	ASSERT_ERR((((uint32_t)link_timeout_enable_default << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)link_timeout_period_default << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR,  ((uint32_t)rsvdp_9 << 9) |((uint32_t)link_timeout_enable_default << 8) |((uint32_t)link_timeout_period_default << 0));
}

__INLINE void pcie_ep_amba_link_timeout_off_unpack(uint32_t* rsvdp_9, uint8_t* link_timeout_enable_default, uint8_t* link_timeout_period_default)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR);

	*rsvdp_9 = (localVal & ((uint32_t)0xFFFFFE00)) >>  9;
	*link_timeout_enable_default = (localVal & ((uint32_t)0x00000100)) >>  8;
	*link_timeout_period_default = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint32_t pcie_ep_amba_link_timeout_off_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFE00)) >> 9);
}
__INLINE uint8_t pcie_ep_amba_link_timeout_off_link_timeout_enable_default_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_amba_link_timeout_off_link_timeout_enable_default_setf(uint8_t linktimeoutenabledefault)
{
	ASSERT_ERR((((uint32_t)linktimeoutenabledefault << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)linktimeoutenabledefault <<8));
}
__INLINE uint8_t pcie_ep_amba_link_timeout_off_link_timeout_period_default_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_amba_link_timeout_off_link_timeout_period_default_setf(uint8_t linktimeoutperioddefault)
{
	ASSERT_ERR((((uint32_t)linktimeoutperioddefault << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_LINK_TIMEOUT_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)linktimeoutperioddefault <<0));
}

/**
 * @brief AMBA_ORDERING_CTRL_OFF register definition
 *  This register controls the AXI Bridge Ordering. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:08 RSVDP_8                   0x0
 *    07    AX_MSTR_ZEROLREAD_FW      0              
 *    06:05 RSVDP_5                   0x0
 *    04:03 AX_MSTR_ORDR_P_EVENT_SEL  0x0
 *    02    RSVDP_2                   0              
 *    01    AX_SNP_EN                 0              
 *    00    RSVDP_0                   0              
 * </pre>
 */
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008D8)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_OFFSET      0x000008D8
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_INDEX       0x00000236
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_amba_ordering_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_amba_ordering_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_8_MASK    ((uint32_t)0xFFFFFF00)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_8_LSB    8
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000018)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_POS    7
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_5_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_5_LSB    5
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_5_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_MASK    ((uint32_t)0x00000018)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_LSB    3
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_2_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_2_POS    2
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_POS    1
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_0_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_0_POS    0

#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ZEROLREAD_FW_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_5_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_MSTR_ORDR_P_EVENT_SEL_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_2_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_AX_SNP_EN_RST    0x0
#define PCIE_EP_AMBA_ORDERING_CTRL_OFF_RSVDP_0_RST    0x0

__INLINE void pcie_ep_amba_ordering_ctrl_off_pack(uint32_t rsvdp_8, uint8_t ax_mstr_zerolread_fw, uint8_t rsvdp_5, uint8_t ax_mstr_ordr_p_event_sel, uint8_t rsvdp_2, uint8_t ax_snp_en, uint8_t rsvdp_0)
{
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0xFFFFFF00)) == 0);
	ASSERT_ERR((((uint32_t)ax_mstr_zerolread_fw << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_5 << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)ax_mstr_ordr_p_event_sel << 3) & ~((uint32_t)0x00000018)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_2 << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)ax_snp_en << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_0 << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_8 << 8) |((uint32_t)ax_mstr_zerolread_fw << 7) |((uint32_t)rsvdp_5 << 5) |((uint32_t)ax_mstr_ordr_p_event_sel << 3) |((uint32_t)rsvdp_2 << 2) |((uint32_t)ax_snp_en << 1) |((uint32_t)rsvdp_0 << 0));
}

__INLINE void pcie_ep_amba_ordering_ctrl_off_unpack(uint32_t* rsvdp_8, uint8_t* ax_mstr_zerolread_fw, uint8_t* rsvdp_5, uint8_t* ax_mstr_ordr_p_event_sel, uint8_t* rsvdp_2, uint8_t* ax_snp_en, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);

	*rsvdp_8 = (localVal & ((uint32_t)0xFFFFFF00)) >>  8;
	*ax_mstr_zerolread_fw = (localVal & ((uint32_t)0x00000080)) >>  7;
	*rsvdp_5 = (localVal & ((uint32_t)0x00000060)) >>  5;
	*ax_mstr_ordr_p_event_sel = (localVal & ((uint32_t)0x00000018)) >>  3;
	*rsvdp_2 = (localVal & ((uint32_t)0x00000004)) >>  2;
	*ax_snp_en = (localVal & ((uint32_t)0x00000002)) >>  1;
	*rsvdp_0 = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_amba_ordering_ctrl_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFF00)) >> 8);
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_ax_mstr_zerolread_fw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_amba_ordering_ctrl_off_ax_mstr_zerolread_fw_setf(uint8_t axmstrzerolreadfw)
{
	ASSERT_ERR((((uint32_t)axmstrzerolreadfw << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)axmstrzerolreadfw <<7));
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_rsvdp_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_ax_mstr_ordr_p_event_sel_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000018)) >> 3);
}
__INLINE void pcie_ep_amba_ordering_ctrl_off_ax_mstr_ordr_p_event_sel_setf(uint8_t axmstrordrpeventsel)
{
	ASSERT_ERR((((uint32_t)axmstrordrpeventsel << 3) & ~((uint32_t)0x00000018)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR) & ~((uint32_t)0x00000018)) | ((uint32_t)axmstrordrpeventsel <<3));
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_rsvdp_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_ax_snp_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_amba_ordering_ctrl_off_ax_snp_en_setf(uint8_t axsnpen)
{
	ASSERT_ERR((((uint32_t)axsnpen << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)axsnpen <<1));
}
__INLINE uint8_t pcie_ep_amba_ordering_ctrl_off_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AMBA_ORDERING_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}

/**
 * @brief COHERENCY_CONTROL_1_OFF register definition
 *  This register controls the cache coherency operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 CFG_MEMTYPE_BOUNDARY_LOW_ADDR 0x0
 *    01    RSVDP_1                   0              
 *    00    CFG_MEMTYPE_VALUE         0              
 * </pre>
 */
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008E0)
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_OFFSET      0x000008E0
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_INDEX       0x00000238
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_coherency_control_1_off_get(void)
{
	return REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR);
}

__INLINE void pcie_ep_coherency_control_1_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_MASK    ((uint32_t)0xFFFFFFFC)
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_LSB    2
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_WIDTH    ((uint32_t)0x0000001E)
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_RSVDP_1_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_RSVDP_1_POS    1
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_VALUE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_VALUE_POS    0

#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_BOUNDARY_LOW_ADDR_RST    0x0
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_COHERENCY_CONTROL_1_OFF_CFG_MEMTYPE_VALUE_RST    0x0

__INLINE void pcie_ep_coherency_control_1_off_pack(uint32_t cfg_memtype_boundary_low_addr, uint8_t rsvdp_1, uint8_t cfg_memtype_value)
{
	ASSERT_ERR((((uint32_t)cfg_memtype_boundary_low_addr << 2) & ~((uint32_t)0xFFFFFFFC)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cfg_memtype_value << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR,  ((uint32_t)cfg_memtype_boundary_low_addr << 2) |((uint32_t)rsvdp_1 << 1) |((uint32_t)cfg_memtype_value << 0));
}

__INLINE void pcie_ep_coherency_control_1_off_unpack(uint32_t* cfg_memtype_boundary_low_addr, uint8_t* rsvdp_1, uint8_t* cfg_memtype_value)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR);

	*cfg_memtype_boundary_low_addr = (localVal & ((uint32_t)0xFFFFFFFC)) >>  2;
	*rsvdp_1 = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cfg_memtype_value = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_coherency_control_1_off_cfg_memtype_boundary_low_addr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFC)) >> 2);
}
__INLINE void pcie_ep_coherency_control_1_off_cfg_memtype_boundary_low_addr_setf(uint32_t cfgmemtypeboundarylowaddr)
{
	ASSERT_ERR((((uint32_t)cfgmemtypeboundarylowaddr << 2) & ~((uint32_t)0xFFFFFFFC)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR) & ~((uint32_t)0xFFFFFFFC)) | ((uint32_t)cfgmemtypeboundarylowaddr <<2));
}
__INLINE uint8_t pcie_ep_coherency_control_1_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE uint8_t pcie_ep_coherency_control_1_off_cfg_memtype_value_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_coherency_control_1_off_cfg_memtype_value_setf(uint8_t cfgmemtypevalue)
{
	ASSERT_ERR((((uint32_t)cfgmemtypevalue << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_1_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cfgmemtypevalue <<0));
}

/**
 * @brief COHERENCY_CONTROL_3_OFF register definition
 *  This register controls the cache coherency operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:27 CFG_MSTR_AWCACHE_VALUE    0x0
 *    22:19 CFG_MSTR_ARCACHE_VALUE    0x0
 *    14:11 CFG_MSTR_AWCACHE_MODE     0x0
 *    06:03 CFG_MSTR_ARCACHE_MODE     0x0
 * </pre>
 */
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008E8)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_OFFSET      0x000008E8
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_INDEX       0x0000023A
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_coherency_control_3_off_get(void)
{
	return REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);
}

__INLINE void pcie_ep_coherency_control_3_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_VALUE_MASK    ((uint32_t)0x78000000)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_VALUE_LSB    27
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_VALUE_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_VALUE_MASK    ((uint32_t)0x00780000)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_VALUE_LSB    19
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_VALUE_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_MODE_MASK    ((uint32_t)0x00007800)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_MODE_LSB    11
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_MODE_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_MODE_MASK    ((uint32_t)0x00000078)
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_MODE_LSB    3
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_MODE_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_VALUE_RST    0x0
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_VALUE_RST    0x0
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_AWCACHE_MODE_RST    0x0
#define PCIE_EP_COHERENCY_CONTROL_3_OFF_CFG_MSTR_ARCACHE_MODE_RST    0x0

__INLINE void pcie_ep_coherency_control_3_off_pack(uint8_t cfg_mstr_awcache_value, uint8_t cfg_mstr_arcache_value, uint8_t cfg_mstr_awcache_mode, uint8_t cfg_mstr_arcache_mode)
{
	ASSERT_ERR((((uint32_t)cfg_mstr_awcache_value << 27) & ~((uint32_t)0x78000000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_mstr_arcache_value << 19) & ~((uint32_t)0x00780000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_mstr_awcache_mode << 11) & ~((uint32_t)0x00007800)) == 0);
	ASSERT_ERR((((uint32_t)cfg_mstr_arcache_mode << 3) & ~((uint32_t)0x00000078)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR,  ((uint32_t)cfg_mstr_awcache_value << 27) |((uint32_t)cfg_mstr_arcache_value << 19) |((uint32_t)cfg_mstr_awcache_mode << 11) |((uint32_t)cfg_mstr_arcache_mode << 3));
}

__INLINE void pcie_ep_coherency_control_3_off_unpack(uint8_t* cfg_mstr_awcache_value, uint8_t* cfg_mstr_arcache_value, uint8_t* cfg_mstr_awcache_mode, uint8_t* cfg_mstr_arcache_mode)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);

	*cfg_mstr_awcache_value = (localVal & ((uint32_t)0x78000000)) >>  27;
	*cfg_mstr_arcache_value = (localVal & ((uint32_t)0x00780000)) >>  19;
	*cfg_mstr_awcache_mode = (localVal & ((uint32_t)0x00007800)) >>  11;
	*cfg_mstr_arcache_mode = (localVal & ((uint32_t)0x00000078)) >>  3;
}

__INLINE uint8_t pcie_ep_coherency_control_3_off_cfg_mstr_awcache_value_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x78000000)) >> 27);
}
__INLINE void pcie_ep_coherency_control_3_off_cfg_mstr_awcache_value_setf(uint8_t cfgmstrawcachevalue)
{
	ASSERT_ERR((((uint32_t)cfgmstrawcachevalue << 27) & ~((uint32_t)0x78000000)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR) & ~((uint32_t)0x78000000)) | ((uint32_t)cfgmstrawcachevalue <<27));
}
__INLINE uint8_t pcie_ep_coherency_control_3_off_cfg_mstr_arcache_value_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00780000)) >> 19);
}
__INLINE void pcie_ep_coherency_control_3_off_cfg_mstr_arcache_value_setf(uint8_t cfgmstrarcachevalue)
{
	ASSERT_ERR((((uint32_t)cfgmstrarcachevalue << 19) & ~((uint32_t)0x00780000)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR) & ~((uint32_t)0x00780000)) | ((uint32_t)cfgmstrarcachevalue <<19));
}
__INLINE uint8_t pcie_ep_coherency_control_3_off_cfg_mstr_awcache_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007800)) >> 11);
}
__INLINE void pcie_ep_coherency_control_3_off_cfg_mstr_awcache_mode_setf(uint8_t cfgmstrawcachemode)
{
	ASSERT_ERR((((uint32_t)cfgmstrawcachemode << 11) & ~((uint32_t)0x00007800)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR) & ~((uint32_t)0x00007800)) | ((uint32_t)cfgmstrawcachemode <<11));
}
__INLINE uint8_t pcie_ep_coherency_control_3_off_cfg_mstr_arcache_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000078)) >> 3);
}
__INLINE void pcie_ep_coherency_control_3_off_cfg_mstr_arcache_mode_setf(uint8_t cfgmstrarcachemode)
{
	ASSERT_ERR((((uint32_t)cfgmstrarcachemode << 3) & ~((uint32_t)0x00000078)) == 0);
	REG_PL_WR(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR, (REG_PL_RD(PCIE_EP_COHERENCY_CONTROL_3_OFF_ADDR) & ~((uint32_t)0x00000078)) | ((uint32_t)cfgmstrarcachemode <<3));
}

/**
 * @brief AXI_MSTR_MSG_ADDR_LOW_OFF register definition
 *  Lower 20 bits of the programmable AXI address to which Messages coming from wire are mapped. Bits [11:0] of the register are tied to zero for the address to be 4k-aligned. In previous releases, the third and fourth DWORDs of a message (Msg/MsgD) TLP header were delivered though the AXI master address bus (mstr_awaddr). These DWORDS are now supplied through the mstr_awmisc_info_hdr_34dw[63:0] output; and the value on mstr_awaddr is driven to the value you have programmed into the AXI_MSTR_MSG_ADDR_LOW_OFF and AXI_MSTR_MSG_ADDR_HIGH_OFF registers. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:12 CFG_AXIMSTR_MSG_ADDR_LOW  0x0
 *    11:00 CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED 0x0
 * </pre>
 */
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008F0)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_OFFSET      0x000008F0
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_INDEX       0x0000023C
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_axi_mstr_msg_addr_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_axi_mstr_msg_addr_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_MASK    ((uint32_t)0xFFFFF000)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_LSB    12
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_WIDTH    ((uint32_t)0x00000014)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_MASK    ((uint32_t)0x00000FFF)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_LSB    0
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_WIDTH    ((uint32_t)0x0000000C)

#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RST    0x0
#define PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_CFG_AXIMSTR_MSG_ADDR_LOW_RESERVED_RST    0x0

__INLINE void pcie_ep_axi_mstr_msg_addr_low_off_pack(uint32_t cfg_aximstr_msg_addr_low, uint16_t cfg_aximstr_msg_addr_low_reserved)
{
	ASSERT_ERR((((uint32_t)cfg_aximstr_msg_addr_low << 12) & ~((uint32_t)0xFFFFF000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_aximstr_msg_addr_low_reserved << 0) & ~((uint32_t)0x00000FFF)) == 0);
	REG_PL_WR(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR,  ((uint32_t)cfg_aximstr_msg_addr_low << 12) |((uint32_t)cfg_aximstr_msg_addr_low_reserved << 0));
}

__INLINE void pcie_ep_axi_mstr_msg_addr_low_off_unpack(uint32_t* cfg_aximstr_msg_addr_low, uint16_t* cfg_aximstr_msg_addr_low_reserved)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR);

	*cfg_aximstr_msg_addr_low = (localVal & ((uint32_t)0xFFFFF000)) >>  12;
	*cfg_aximstr_msg_addr_low_reserved = (localVal & ((uint32_t)0x00000FFF)) >>  0;
}

__INLINE uint32_t pcie_ep_axi_mstr_msg_addr_low_off_cfg_aximstr_msg_addr_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFF000)) >> 12);
}
__INLINE void pcie_ep_axi_mstr_msg_addr_low_off_cfg_aximstr_msg_addr_low_setf(uint32_t cfgaximstrmsgaddrlow)
{
	ASSERT_ERR((((uint32_t)cfgaximstrmsgaddrlow << 12) & ~((uint32_t)0xFFFFF000)) == 0);
	REG_PL_WR(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR) & ~((uint32_t)0xFFFFF000)) | ((uint32_t)cfgaximstrmsgaddrlow <<12));
}
__INLINE uint16_t pcie_ep_axi_mstr_msg_addr_low_off_cfg_aximstr_msg_addr_low_reserved_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_LOW_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x00000FFF)) >> 0);
}

/**
 * @brief AXI_MSTR_MSG_ADDR_HIGH_OFF register definition
 *  Upper 32 bits of the programmable AXI address to which Messages coming from wire are mapped. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CFG_AXIMSTR_MSG_ADDR_HIGH 0x0
 * </pre>
 */
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008F4)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_OFFSET      0x000008F4
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_INDEX       0x0000023D
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_axi_mstr_msg_addr_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_axi_mstr_msg_addr_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_LSB    0
#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_CFG_AXIMSTR_MSG_ADDR_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_axi_mstr_msg_addr_high_off_cfg_aximstr_msg_addr_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_axi_mstr_msg_addr_high_off_cfg_aximstr_msg_addr_high_setf(uint32_t cfgaximstrmsgaddrhigh)
{
	ASSERT_ERR((((uint32_t)cfgaximstrmsgaddrhigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_AXI_MSTR_MSG_ADDR_HIGH_OFF_ADDR, (uint32_t)cfgaximstrmsgaddrhigh << 0);
}

/**
 * @brief PCIE_VERSION_NUMBER_OFF register definition
 *  The version number is given in hex format. You should convert each pair of hex characters to ASCII to interpret.  Using 4.70a (GA) as an example:  - VERSION_NUMBER = 0x3437302a which translates to 470*  - VERSION_TYPE = 0x67612a2a which translates to ga** Using 4.70a-ea01 as an example:  - VERSION_NUMBER = 0x3437302a which translates to 470*  - VERSION_TYPE = 0x65613031 which translates to ea01 GA is a general release available on www.designware.com  EA is an early release available on a per-customer basis. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 VERSION_NUMBER            0x3538302a
 * </pre>
 */
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008F8)
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_OFFSET      0x000008F8
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_INDEX       0x0000023E
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_RESET       0x3538302A

__INLINE uint32_t  pcie_ep_pcie_version_number_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PCIE_VERSION_NUMBER_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_VERSION_NUMBER_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_VERSION_NUMBER_LSB    0
#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_VERSION_NUMBER_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PCIE_VERSION_NUMBER_OFF_VERSION_NUMBER_RST    0x3538302a

__INLINE uint32_t pcie_ep_pcie_version_number_off_version_number_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_VERSION_NUMBER_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief PCIE_VERSION_TYPE_OFF register definition
 *  The type is given in hex format. You should convert each pair of hex characters to ASCII to interpret.  Using 4.70a (GA) as an example:  - VERSION_NUMBER = 0x3437302a which translates to 470*  - VERSION_TYPE = 0x67612a2a which translates to ga** Using 4.70a-ea01 as an example:  - VERSION_NUMBER = 0x3437302a which translates to 470*  - VERSION_TYPE = 0x65613031 which translates to ea01 GA is a general release available on www.designware.com  EA is an early release available on a per-customer basis. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 VERSION_TYPE              0x67612a2a
 * </pre>
 */
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x000008FC)
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_OFFSET      0x000008FC
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_INDEX       0x0000023F
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_RESET       0x67612A2A

__INLINE uint32_t  pcie_ep_pcie_version_type_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PCIE_VERSION_TYPE_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_VERSION_TYPE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_VERSION_TYPE_LSB    0
#define PCIE_EP_PCIE_VERSION_TYPE_OFF_VERSION_TYPE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_PCIE_VERSION_TYPE_OFF_VERSION_TYPE_RST    0x67612a2a

__INLINE uint32_t pcie_ep_pcie_version_type_off_version_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIE_VERSION_TYPE_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}

/**
 * @brief PL_APP_BUS_DEV_NUM_STATUS_OFF register definition
 *  This register reflects the application driven bus and device number.  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RSVDP_16                  0x0
 *    15:08 RC_DSW_BUS_NUM            0x0
 *    07:03 RC_DSW_DEV_NUM            0x0
 *    02:00 RSVDP_0                   0x0
 * </pre>
 */
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000B10)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_OFFSET      0x00000B10
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_INDEX       0x000002C4
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_pl_app_bus_dev_num_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_16_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_16_LSB    16
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_16_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_BUS_NUM_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_BUS_NUM_LSB    8
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_BUS_NUM_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_DEV_NUM_MASK    ((uint32_t)0x000000F8)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_DEV_NUM_LSB    3
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_DEV_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_0_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_0_LSB    0
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_0_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_16_RST    0x0
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_BUS_NUM_RST    0x0
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RC_DSW_DEV_NUM_RST    0x0
#define PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_RSVDP_0_RST    0x0

__INLINE void pcie_ep_pl_app_bus_dev_num_status_off_unpack(uint16_t* rsvdp_16, uint8_t* rc_dsw_bus_num, uint8_t* rc_dsw_dev_num, uint8_t* rsvdp_0)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);

	*rsvdp_16 = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*rc_dsw_bus_num = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*rc_dsw_dev_num = (localVal & ((uint32_t)0x000000F8)) >>  3;
	*rsvdp_0 = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint16_t pcie_ep_pl_app_bus_dev_num_status_off_rsvdp_16_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_pl_app_bus_dev_num_status_off_rc_dsw_bus_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_pl_app_bus_dev_num_status_off_rc_dsw_dev_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F8)) >> 3);
}
__INLINE uint8_t pcie_ep_pl_app_bus_dev_num_status_off_rsvdp_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PL_APP_BUS_DEV_NUM_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}

/**
 * @brief PCIPM_TRAFFIC_CTRL_OFF register definition
 *  This register provides control over TLP Traffic during Non-D0 States. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:08 RSVDP_8                   0x0
 *    07:04 PCIPM_RESERVED_4_7        0x0
 *    03    PCIPM_NEW_TLP_CLIENT2_BLOCKED 1              
 *    02    PCIPM_NEW_TLP_CLIENT1_BLOCKED 1              
 *    01    PCIPM_NEW_TLP_CLIENT0_BLOCKED 1              
 *    00    PCIPM_VDM_TRAFFIC_BLOCKED 0              
 * </pre>
 */
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000B1C)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_OFFSET      0x00000B1C
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_INDEX       0x000002C7
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_RESET       0x0000000E

__INLINE uint32_t  pcie_ep_pcipm_traffic_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_pcipm_traffic_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_RSVDP_8_MASK    ((uint32_t)0xFFFFFF00)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_RSVDP_8_LSB    8
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000018)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_MASK    ((uint32_t)0x000000F0)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_LSB    4
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_2_BLOCKED_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_2_BLOCKED_POS    3
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_1_BLOCKED_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_1_BLOCKED_POS    2
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_0_BLOCKED_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_0_BLOCKED_POS    1
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLOCKED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLOCKED_POS    0

#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_RESERVED_4_7_RST    0x0
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_2_BLOCKED_RST    0x1
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_1_BLOCKED_RST    0x1
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_NEW_TLP_CLIENT_0_BLOCKED_RST    0x1
#define PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_PCIPM_VDM_TRAFFIC_BLOCKED_RST    0x0

__INLINE void pcie_ep_pcipm_traffic_ctrl_off_pack(uint32_t rsvdp_8, uint8_t pcipm_reserved_4_7, uint8_t pcipm_new_tlp_client2_blocked, uint8_t pcipm_new_tlp_client1_blocked, uint8_t pcipm_new_tlp_client0_blocked, uint8_t pcipm_vdm_traffic_blocked)
{
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0xFFFFFF00)) == 0);
	ASSERT_ERR((((uint32_t)pcipm_reserved_4_7 << 4) & ~((uint32_t)0x000000F0)) == 0);
	ASSERT_ERR((((uint32_t)pcipm_new_tlp_client2_blocked << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)pcipm_new_tlp_client1_blocked << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)pcipm_new_tlp_client0_blocked << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)pcipm_vdm_traffic_blocked << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_8 << 8) |((uint32_t)pcipm_reserved_4_7 << 4) |((uint32_t)pcipm_new_tlp_client2_blocked << 3) |((uint32_t)pcipm_new_tlp_client1_blocked << 2) |((uint32_t)pcipm_new_tlp_client0_blocked << 1) |((uint32_t)pcipm_vdm_traffic_blocked << 0));
}

__INLINE void pcie_ep_pcipm_traffic_ctrl_off_unpack(uint32_t* rsvdp_8, uint8_t* pcipm_reserved_4_7, uint8_t* pcipm_new_tlp_client2_blocked, uint8_t* pcipm_new_tlp_client1_blocked, uint8_t* pcipm_new_tlp_client0_blocked, uint8_t* pcipm_vdm_traffic_blocked)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);

	*rsvdp_8 = (localVal & ((uint32_t)0xFFFFFF00)) >>  8;
	*pcipm_reserved_4_7 = (localVal & ((uint32_t)0x000000F0)) >>  4;
	*pcipm_new_tlp_client2_blocked = (localVal & ((uint32_t)0x00000008)) >>  3;
	*pcipm_new_tlp_client1_blocked = (localVal & ((uint32_t)0x00000004)) >>  2;
	*pcipm_new_tlp_client0_blocked = (localVal & ((uint32_t)0x00000002)) >>  1;
	*pcipm_vdm_traffic_blocked = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_pcipm_traffic_ctrl_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFF00)) >> 8);
}
__INLINE uint8_t pcie_ep_pcipm_traffic_ctrl_off_pcipm_reserved_4_7_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE uint8_t pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_2_blocked_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_2_blocked_setf(uint8_t pcipmnewtlpclient2blocked)
{
	ASSERT_ERR((((uint32_t)pcipmnewtlpclient2blocked << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)pcipmnewtlpclient2blocked <<3));
}
__INLINE uint8_t pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_1_blocked_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_1_blocked_setf(uint8_t pcipmnewtlpclient1blocked)
{
	ASSERT_ERR((((uint32_t)pcipmnewtlpclient1blocked << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)pcipmnewtlpclient1blocked <<2));
}
__INLINE uint8_t pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_0_blocked_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_pcipm_traffic_ctrl_off_pcipm_new_tlp_client_0_blocked_setf(uint8_t pcipmnewtlpclient0blocked)
{
	ASSERT_ERR((((uint32_t)pcipmnewtlpclient0blocked << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)pcipmnewtlpclient0blocked <<1));
}
__INLINE uint8_t pcie_ep_pcipm_traffic_ctrl_off_pcipm_vdm_traffic_blocked_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_pcipm_traffic_ctrl_off_pcipm_vdm_traffic_blocked_setf(uint8_t pcipmvdmtrafficblocked)
{
	ASSERT_ERR((((uint32_t)pcipmvdmtrafficblocked << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_PCIPM_TRAFFIC_CTRL_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcipmvdmtrafficblocked <<0));
}

/**
 * @brief AUX_CLK_FREQ_OFF register definition
 *  This register controls the auxiliary clock frequency. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:10 RSVDP_10                  0x0
 *    09:00 AUX_CLK_FREQ              0xa
 * </pre>
 */
#define PCIE_EP_AUX_CLK_FREQ_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000B40)
#define PCIE_EP_AUX_CLK_FREQ_OFF_OFFSET      0x00000B40
#define PCIE_EP_AUX_CLK_FREQ_OFF_INDEX       0x000002D0
#define PCIE_EP_AUX_CLK_FREQ_OFF_RESET       0x0000000A

__INLINE uint32_t  pcie_ep_aux_clk_freq_off_get(void)
{
	return REG_PL_RD(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR);
}

__INLINE void pcie_ep_aux_clk_freq_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_AUX_CLK_FREQ_OFF_RSVDP_10_MASK    ((uint32_t)0xFFFFFC00)
#define PCIE_EP_AUX_CLK_FREQ_OFF_RSVDP_10_LSB    10
#define PCIE_EP_AUX_CLK_FREQ_OFF_RSVDP_10_WIDTH    ((uint32_t)0x00000016)
#define PCIE_EP_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_MASK    ((uint32_t)0x000003FF)
#define PCIE_EP_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_LSB    0
#define PCIE_EP_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_WIDTH    ((uint32_t)0x0000000A)

#define PCIE_EP_AUX_CLK_FREQ_OFF_RSVDP_10_RST    0x0
#define PCIE_EP_AUX_CLK_FREQ_OFF_AUX_CLK_FREQ_RST    0xa

__INLINE void pcie_ep_aux_clk_freq_off_pack(uint32_t rsvdp_10, uint16_t aux_clk_freq)
{
	ASSERT_ERR((((uint32_t)rsvdp_10 << 10) & ~((uint32_t)0xFFFFFC00)) == 0);
	ASSERT_ERR((((uint32_t)aux_clk_freq << 0) & ~((uint32_t)0x000003FF)) == 0);
	REG_PL_WR(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR,  ((uint32_t)rsvdp_10 << 10) |((uint32_t)aux_clk_freq << 0));
}

__INLINE void pcie_ep_aux_clk_freq_off_unpack(uint32_t* rsvdp_10, uint16_t* aux_clk_freq)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR);

	*rsvdp_10 = (localVal & ((uint32_t)0xFFFFFC00)) >>  10;
	*aux_clk_freq = (localVal & ((uint32_t)0x000003FF)) >>  0;
}

__INLINE uint32_t pcie_ep_aux_clk_freq_off_rsvdp_10_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFC00)) >> 10);
}
__INLINE uint16_t pcie_ep_aux_clk_freq_off_aux_clk_freq_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x000003FF)) >> 0);
}
__INLINE void pcie_ep_aux_clk_freq_off_aux_clk_freq_setf(uint16_t auxclkfreq)
{
	ASSERT_ERR((((uint32_t)auxclkfreq << 0) & ~((uint32_t)0x000003FF)) == 0);
	REG_PL_WR(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR, (REG_PL_RD(PCIE_EP_AUX_CLK_FREQ_OFF_ADDR) & ~((uint32_t)0x000003FF)) | ((uint32_t)auxclkfreq <<0));
}

/**
 * @brief POWERDOWN_CTRL_STATUS_OFF register definition
 *  This is the Powerdown Control and Status register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:12 RSVDP_12                  0x0
 *    11:08 POWERDOWN_PHY_POWERDOWN   0x2
 *    07:04 POWERDOWN_MAC_POWERDOWN   0x2
 *    03:02 RSVDP_2                   0x0
 *    01    POWERDOWN_VMAIN_ACK       0              
 *    00    POWERDOWN_FORCE           0              
 * </pre>
 */
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000B48)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_OFFSET      0x00000B48
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_INDEX       0x000002D2
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RESET       0x00000220

__INLINE uint32_t  pcie_ep_powerdown_ctrl_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_powerdown_ctrl_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_12_MASK    ((uint32_t)0xFFFFF000)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_12_LSB    12
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_12_WIDTH    ((uint32_t)0x00000014)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_PHY_POWERDOWN_MASK    ((uint32_t)0x00000F00)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_PHY_POWERDOWN_LSB    8
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_PHY_POWERDOWN_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_MAC_POWERDOWN_MASK    ((uint32_t)0x000000F0)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_MAC_POWERDOWN_LSB    4
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_MAC_POWERDOWN_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_2_MASK    ((uint32_t)0x0000000C)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_2_LSB    2
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_2_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_VMAIN_ACK_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_VMAIN_ACK_POS    1
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_FORCE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_FORCE_POS    0

#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_12_RST    0x0
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_PHY_POWERDOWN_RST    0x2
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_MAC_POWERDOWN_RST    0x2
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_RSVDP_2_RST    0x0
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_VMAIN_ACK_RST    0x0
#define PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_POWERDOWN_FORCE_RST    0x0

__INLINE void pcie_ep_powerdown_ctrl_status_off_pack(uint32_t rsvdp_12, uint8_t powerdown_phy_powerdown, uint8_t powerdown_mac_powerdown, uint8_t rsvdp_2, uint8_t powerdown_vmain_ack, uint8_t powerdown_force)
{
	ASSERT_ERR((((uint32_t)rsvdp_12 << 12) & ~((uint32_t)0xFFFFF000)) == 0);
	ASSERT_ERR((((uint32_t)powerdown_phy_powerdown << 8) & ~((uint32_t)0x00000F00)) == 0);
	ASSERT_ERR((((uint32_t)powerdown_mac_powerdown << 4) & ~((uint32_t)0x000000F0)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_2 << 2) & ~((uint32_t)0x0000000C)) == 0);
	ASSERT_ERR((((uint32_t)powerdown_vmain_ack << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)powerdown_force << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR,  ((uint32_t)rsvdp_12 << 12) |((uint32_t)powerdown_phy_powerdown << 8) |((uint32_t)powerdown_mac_powerdown << 4) |((uint32_t)rsvdp_2 << 2) |((uint32_t)powerdown_vmain_ack << 1) |((uint32_t)powerdown_force << 0));
}

__INLINE void pcie_ep_powerdown_ctrl_status_off_unpack(uint32_t* rsvdp_12, uint8_t* powerdown_phy_powerdown, uint8_t* powerdown_mac_powerdown, uint8_t* rsvdp_2, uint8_t* powerdown_vmain_ack, uint8_t* powerdown_force)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);

	*rsvdp_12 = (localVal & ((uint32_t)0xFFFFF000)) >>  12;
	*powerdown_phy_powerdown = (localVal & ((uint32_t)0x00000F00)) >>  8;
	*powerdown_mac_powerdown = (localVal & ((uint32_t)0x000000F0)) >>  4;
	*rsvdp_2 = (localVal & ((uint32_t)0x0000000C)) >>  2;
	*powerdown_vmain_ack = (localVal & ((uint32_t)0x00000002)) >>  1;
	*powerdown_force = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_powerdown_ctrl_status_off_rsvdp_12_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFF000)) >> 12);
}
__INLINE uint8_t pcie_ep_powerdown_ctrl_status_off_powerdown_phy_powerdown_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000F00)) >> 8);
}
__INLINE uint8_t pcie_ep_powerdown_ctrl_status_off_powerdown_mac_powerdown_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000F0)) >> 4);
}
__INLINE uint8_t pcie_ep_powerdown_ctrl_status_off_rsvdp_2_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000C)) >> 2);
}
__INLINE uint8_t pcie_ep_powerdown_ctrl_status_off_powerdown_vmain_ack_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_powerdown_ctrl_status_off_powerdown_vmain_ack_setf(uint8_t powerdownvmainack)
{
	ASSERT_ERR((((uint32_t)powerdownvmainack << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)powerdownvmainack <<1));
}
__INLINE void pcie_ep_powerdown_ctrl_status_off_powerdown_force_setf(uint8_t powerdownforce)
{
	ASSERT_ERR((((uint32_t)powerdownforce << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_POWERDOWN_CTRL_STATUS_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)powerdownforce <<0));
}

/**
 * @brief PIPE_RELATED_OFF register definition
 *  This register controls the PIPE s capabitity, control, and status parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:09 RSVDP_9                   0x0
 *    08    PIPE_GARBAGE_DATA_MODE    0              
 * </pre>
 */
#define PCIE_EP_PIPE_RELATED_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00000B90)
#define PCIE_EP_PIPE_RELATED_OFF_OFFSET      0x00000B90
#define PCIE_EP_PIPE_RELATED_OFF_INDEX       0x000002E4
#define PCIE_EP_PIPE_RELATED_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_pipe_related_off_get(void)
{
	return REG_PL_RD(PCIE_EP_PIPE_RELATED_OFF_ADDR);
}

__INLINE void pcie_ep_pipe_related_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_PIPE_RELATED_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_PIPE_RELATED_OFF_RSVDP_9_MASK    ((uint32_t)0xFFFFFE00)
#define PCIE_EP_PIPE_RELATED_OFF_RSVDP_9_LSB    9
#define PCIE_EP_PIPE_RELATED_OFF_RSVDP_9_WIDTH    ((uint32_t)0x00000017)
#define PCIE_EP_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_POS    8

#define PCIE_EP_PIPE_RELATED_OFF_RSVDP_9_RST    0x0
#define PCIE_EP_PIPE_RELATED_OFF_PIPE_GARBAGE_DATA_MODE_RST    0x0

__INLINE void pcie_ep_pipe_related_off_pack(uint32_t rsvdp_9, uint8_t pipe_garbage_data_mode)
{
	ASSERT_ERR((((uint32_t)rsvdp_9 << 9) & ~((uint32_t)0xFFFFFE00)) == 0);
	ASSERT_ERR((((uint32_t)pipe_garbage_data_mode << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_RELATED_OFF_ADDR,  ((uint32_t)rsvdp_9 << 9) |((uint32_t)pipe_garbage_data_mode << 8));
}

__INLINE void pcie_ep_pipe_related_off_unpack(uint32_t* rsvdp_9, uint8_t* pipe_garbage_data_mode)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_RELATED_OFF_ADDR);

	*rsvdp_9 = (localVal & ((uint32_t)0xFFFFFE00)) >>  9;
	*pipe_garbage_data_mode = (localVal & ((uint32_t)0x00000100)) >>  8;
}

__INLINE uint32_t pcie_ep_pipe_related_off_rsvdp_9_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_RELATED_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFE00)) >> 9);
}
__INLINE uint8_t pcie_ep_pipe_related_off_pipe_garbage_data_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_PIPE_RELATED_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_pipe_related_off_pipe_garbage_data_mode_setf(uint8_t pipegarbagedatamode)
{
	ASSERT_ERR((((uint32_t)pipegarbagedatamode << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_PIPE_RELATED_OFF_ADDR, (REG_PL_RD(PCIE_EP_PIPE_RELATED_OFF_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)pipegarbagedatamode <<8));
}

/**
 * @brief IATU_REGION_CTRL_1_OFF_OUTBOUND_0 register definition
 *  This register controls the iATU outbound region access based on the optional iATU outbound features enabled using iATU Region Control 2 Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    22:20 CTRL_1_FUNC_NUM           0x0
 *    13    INCREASE_REGION_SIZE      0              
 *    10:09 ATTR                      0x0
 *    08    TD                        0              
 *    07:05 TC                        0x0
 *    04:00 TYPE                      0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_OFFSET      0x00004000
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INDEX       0x00001000
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_1_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_LSB    20
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_MASK    ((uint32_t)0x00000600)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_LSB    9
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_POS    8
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_MASK    ((uint32_t)0x000000E0)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_LSB    5
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_CTRL_1_FUNC_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_INCREASE_REGION_SIZE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ATTR_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TC_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_TYPE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_pack(uint8_t ctrl_1_func_num, uint8_t increase_region_size, uint8_t attr, uint8_t td, uint8_t tc, uint8_t type)
{
	ASSERT_ERR((((uint32_t)ctrl_1_func_num << 20) & ~((uint32_t)0x00700000)) == 0);
	ASSERT_ERR((((uint32_t)increase_region_size << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR,  ((uint32_t)ctrl_1_func_num << 20) |((uint32_t)increase_region_size << 13) |((uint32_t)attr << 9) |((uint32_t)td << 8) |((uint32_t)tc << 5) |((uint32_t)type << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_unpack(uint8_t* ctrl_1_func_num, uint8_t* increase_region_size, uint8_t* attr, uint8_t* td, uint8_t* tc, uint8_t* type)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);

	*ctrl_1_func_num = (localVal & ((uint32_t)0x00700000)) >>  20;
	*increase_region_size = (localVal & ((uint32_t)0x00002000)) >>  13;
	*attr = (localVal & ((uint32_t)0x00000600)) >>  9;
	*td = (localVal & ((uint32_t)0x00000100)) >>  8;
	*tc = (localVal & ((uint32_t)0x000000E0)) >>  5;
	*type = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_ctrl_1_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_ctrl_1_func_num_setf(uint8_t ctrl1funcnum)
{
	ASSERT_ERR((((uint32_t)ctrl1funcnum << 20) & ~((uint32_t)0x00700000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00700000)) | ((uint32_t)ctrl1funcnum <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_increase_region_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_increase_region_size_setf(uint8_t increaseregionsize)
{
	ASSERT_ERR((((uint32_t)increaseregionsize << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)increaseregionsize <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_attr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_attr_setf(uint8_t attr)
{
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00000600)) | ((uint32_t)attr <<9));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_td_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_td_setf(uint8_t td)
{
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)td <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000E0)) >> 5);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_tc_setf(uint8_t tc)
{
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x000000E0)) | ((uint32_t)tc <<5));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_0_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_0_type_setf(uint8_t type)
{
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)type <<0));
}

/**
 * @brief IATU_REGION_CTRL_2_OFF_OUTBOUND_0 register definition
 *  Using this register you can enable/disable the outbound iATU optional features. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    REGION_EN                 0              
 *    29    INVERT_MODE               0              
 *    28    CFG_SHIFT_MODE            0              
 *    27    DMA_BYPASS                0              
 *    23    HEADER_SUBSTITUTE_EN      0              
 *    22    INHIBIT_PAYLOAD           0              
 *    21    TLP_HEADER_FIELDS_BYPASS  0              
 *    20    SNP                       0              
 *    19    FUNC_BYPASS               0              
 *    16    TAG_SUBSTITUTE_EN         0              
 *    15:08 TAG                       0x0
 *    07:00 MSG_CODE                  0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004004)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_OFFSET      0x00004004
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INDEX       0x00001001
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_2_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_POS    31
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_POS    29
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_POS    28
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYPASS_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYPASS_POS    27
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_POS    23
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_POS    22
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYPASS_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYPASS_POS    21
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_POS    20
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYPASS_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYPASS_POS    19
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_POS    16
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_LSB    8
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_REGION_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INVERT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_CFG_SHIFT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_DMA_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_HEADER_SUBSTITUTE_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_INHIBIT_PAYLOAD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TLP_HEADER_FIELDS_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_SNP_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_FUNC_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_SUBSTITUTE_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_TAG_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_MSG_CODE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_pack(uint8_t region_en, uint8_t invert_mode, uint8_t cfg_shift_mode, uint8_t dma_bypass, uint8_t header_substitute_en, uint8_t inhibit_payload, uint8_t tlp_header_fields_bypass, uint8_t snp, uint8_t func_bypass, uint8_t tag_substitute_en, uint8_t tag, uint8_t msg_code)
{
	ASSERT_ERR((((uint32_t)region_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)invert_mode << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_shift_mode << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_bypass << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)header_substitute_en << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)inhibit_payload << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_header_fields_bypass << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)snp << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)func_bypass << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)tag_substitute_en << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)tag << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)msg_code << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR,  ((uint32_t)region_en << 31) |((uint32_t)invert_mode << 29) |((uint32_t)cfg_shift_mode << 28) |((uint32_t)dma_bypass << 27) |((uint32_t)header_substitute_en << 23) |((uint32_t)inhibit_payload << 22) |((uint32_t)tlp_header_fields_bypass << 21) |((uint32_t)snp << 20) |((uint32_t)func_bypass << 19) |((uint32_t)tag_substitute_en << 16) |((uint32_t)tag << 8) |((uint32_t)msg_code << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_unpack(uint8_t* region_en, uint8_t* invert_mode, uint8_t* cfg_shift_mode, uint8_t* dma_bypass, uint8_t* header_substitute_en, uint8_t* inhibit_payload, uint8_t* tlp_header_fields_bypass, uint8_t* snp, uint8_t* func_bypass, uint8_t* tag_substitute_en, uint8_t* tag, uint8_t* msg_code)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);

	*region_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*invert_mode = (localVal & ((uint32_t)0x20000000)) >>  29;
	*cfg_shift_mode = (localVal & ((uint32_t)0x10000000)) >>  28;
	*dma_bypass = (localVal & ((uint32_t)0x08000000)) >>  27;
	*header_substitute_en = (localVal & ((uint32_t)0x00800000)) >>  23;
	*inhibit_payload = (localVal & ((uint32_t)0x00400000)) >>  22;
	*tlp_header_fields_bypass = (localVal & ((uint32_t)0x00200000)) >>  21;
	*snp = (localVal & ((uint32_t)0x00100000)) >>  20;
	*func_bypass = (localVal & ((uint32_t)0x00080000)) >>  19;
	*tag_substitute_en = (localVal & ((uint32_t)0x00010000)) >>  16;
	*tag = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*msg_code = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_region_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_region_en_setf(uint8_t regionen)
{
	ASSERT_ERR((((uint32_t)regionen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)regionen <<31));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_invert_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_invert_mode_setf(uint8_t invertmode)
{
	ASSERT_ERR((((uint32_t)invertmode << 29) & ~((uint32_t)0x20000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)invertmode <<29));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_cfg_shift_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_cfg_shift_mode_setf(uint8_t cfgshiftmode)
{
	ASSERT_ERR((((uint32_t)cfgshiftmode << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)cfgshiftmode <<28));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_dma_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_dma_bypass_setf(uint8_t dmabypass)
{
	ASSERT_ERR((((uint32_t)dmabypass << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)dmabypass <<27));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_header_substitute_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_header_substitute_en_setf(uint8_t headersubstituteen)
{
	ASSERT_ERR((((uint32_t)headersubstituteen << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)headersubstituteen <<23));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_inhibit_payload_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_inhibit_payload_setf(uint8_t inhibitpayload)
{
	ASSERT_ERR((((uint32_t)inhibitpayload << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)inhibitpayload <<22));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_tlp_header_fields_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_tlp_header_fields_bypass_setf(uint8_t tlpheaderfieldsbypass)
{
	ASSERT_ERR((((uint32_t)tlpheaderfieldsbypass << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)tlpheaderfieldsbypass <<21));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_snp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_snp_setf(uint8_t snp)
{
	ASSERT_ERR((((uint32_t)snp << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)snp <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_func_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_func_bypass_setf(uint8_t funcbypass)
{
	ASSERT_ERR((((uint32_t)funcbypass << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)funcbypass <<19));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_tag_substitute_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_tag_substitute_en_setf(uint8_t tagsubstituteen)
{
	ASSERT_ERR((((uint32_t)tagsubstituteen << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)tagsubstituteen <<16));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_tag_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_tag_setf(uint8_t tag)
{
	ASSERT_ERR((((uint32_t)tag << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)tag <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_0_msg_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_0_msg_code_setf(uint8_t msgcode)
{
	ASSERT_ERR((((uint32_t)msgcode << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)msgcode <<0));
}

/**
 * @brief IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0 register definition
 *  The CX_ATU_MIN_REGION_SIZE configuration parameter (Value Range: 4 kB, 8 kB, 16 kB, 32 kB, 64 kB defaults to 64 kB) specifies the minimum size of an address translation region. For example, if set to 64 kB; the lower 16 bits of the Base, Limit and Target registers are zero and all address regions are aligned on 64 kB boundaries. More precisely, the lower log2(CX_ATU_MIN_REGION_SIZE) bits are zero. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_BASE_RW               0x0
 *    15:00 LWR_BASE_HW               0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004008)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_OFFSET      0x00004008
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_INDEX       0x00001002
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_base_addr_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_LSB    16
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_LSB    0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_RW_RST    0x0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_LWR_BASE_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_0_pack(uint16_t lwr_base_rw, uint16_t lwr_base_hw)
{
	ASSERT_ERR((((uint32_t)lwr_base_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_base_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR,  ((uint32_t)lwr_base_rw << 16) |((uint32_t)lwr_base_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_0_unpack(uint16_t* lwr_base_rw, uint16_t* lwr_base_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR);

	*lwr_base_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_base_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_outbound_0_lwr_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_0_lwr_base_rw_setf(uint16_t lwrbaserw)
{
	ASSERT_ERR((((uint32_t)lwrbaserw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrbaserw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_outbound_0_lwr_base_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0 register definition
 *  This register holds the upper 32-bits of the start (and end) address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_BASE_RW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000400C)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_OFFSET      0x0000400C
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_INDEX       0x00001003
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_base_addr_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_upper_base_addr_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_LSB    0
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_UPPER_BASE_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_base_addr_off_outbound_0_upper_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_base_addr_off_outbound_0_upper_base_rw_setf(uint32_t upperbaserw)
{
	ASSERT_ERR((((uint32_t)upperbaserw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_0_ADDR, (uint32_t)upperbaserw << 0);
}

/**
 * @brief IATU_LIMIT_ADDR_OFF_OUTBOUND_0 register definition
 *  This register holds the end address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LIMIT_ADDR_RW             0x0
 *    15:04 LIMIT_ADDR_HW             0xfff
 *    03:00 CBUF_INCR                 0xf
 * </pre>
 */
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004010)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_OFFSET      0x00004010
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_INDEX       0x00001004
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_RESET       0x0000FFFF

__INLINE uint32_t  pcie_ep_iatu_limit_addr_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_LSB    16
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_LSB    4
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_LSB    0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_RW_RST    0x0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_LIMIT_ADDR_HW_RST    0xfff
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_CBUF_INCR_RST    0xf

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_0_pack(uint16_t limit_addr_rw, uint16_t limit_addr_hw, uint8_t cbuf_incr)
{
	ASSERT_ERR((((uint32_t)limit_addr_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)limit_addr_hw << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)cbuf_incr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR,  ((uint32_t)limit_addr_rw << 16) |((uint32_t)limit_addr_hw << 4) |((uint32_t)cbuf_incr << 0));
}

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_0_unpack(uint16_t* limit_addr_rw, uint16_t* limit_addr_hw, uint8_t* cbuf_incr)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR);

	*limit_addr_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*limit_addr_hw = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*cbuf_incr = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_limit_addr_off_outbound_0_limit_addr_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_limit_addr_off_outbound_0_limit_addr_rw_setf(uint16_t limitaddrrw)
{
	ASSERT_ERR((((uint32_t)limitaddrrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)limitaddrrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_limit_addr_off_outbound_0_limit_addr_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_iatu_limit_addr_off_outbound_0_cbuf_incr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0 register definition
 *  This register holds the Lower Target part of the new address of the translated region, or the outbound TLP header information, depending on the setting  of HEADER_SUBSTITUTE_EN field of IATU_REGION_CTRL_2_VIEWPORT_OFF_OUTBOUND_i register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LWR_TARGET_RW_OUTBOUND    0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004014)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET      0x00004014
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_INDEX       0x00001005
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_target_addr_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_LSB    0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_LWR_TARGET_RW_OUTBOUND_RST    0x0

__INLINE uint32_t pcie_ep_iatu_lwr_target_addr_off_outbound_0_lwr_target_rw_outbound_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_lwr_target_addr_off_outbound_0_lwr_target_rw_outbound_setf(uint32_t lwrtargetrwoutbound)
{
	ASSERT_ERR((((uint32_t)lwrtargetrwoutbound << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_0_ADDR, (uint32_t)lwrtargetrwoutbound << 0);
}

/**
 * @brief IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0 register definition
 *  This register holds the upper 32 bits of the start address (Upper Target part) of the new address of the translated region. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_TARGET_RW           0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004018)
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_OFFSET      0x00004018
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_INDEX       0x00001006
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_target_addr_off_outbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_upper_target_addr_off_outbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_LSB    0
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_UPPER_TARGET_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_target_addr_off_outbound_0_upper_target_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_target_addr_off_outbound_0_upper_target_rw_setf(uint32_t uppertargetrw)
{
	ASSERT_ERR((((uint32_t)uppertargetrw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_0_ADDR, (uint32_t)uppertargetrw << 0);
}

/**
 * @brief IATU_REGION_CTRL_1_OFF_INBOUND_0 register definition
 *  This register controls the iATU inbound region access based on the optional iATU inbound features enabled using iATU Region Control 2 Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    22:20 CTRL_1_FUNC_NUM           0x0
 *    13    INCREASE_REGION_SIZE      0              
 *    10:09 ATTR                      0x0
 *    08    TD                        0              
 *    07:05 TC                        0x0
 *    04:00 TYPE                      0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004100)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_OFFSET      0x00004100
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INDEX       0x00001040
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_1_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_LSB    20
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_MASK    ((uint32_t)0x00000600)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_LSB    9
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_POS    8
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_MASK    ((uint32_t)0x000000E0)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_LSB    5
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_CTRL_1_FUNC_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_INCREASE_REGION_SIZE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ATTR_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TC_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_TYPE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_pack(uint8_t ctrl_1_func_num, uint8_t increase_region_size, uint8_t attr, uint8_t td, uint8_t tc, uint8_t type)
{
	ASSERT_ERR((((uint32_t)ctrl_1_func_num << 20) & ~((uint32_t)0x00700000)) == 0);
	ASSERT_ERR((((uint32_t)increase_region_size << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR,  ((uint32_t)ctrl_1_func_num << 20) |((uint32_t)increase_region_size << 13) |((uint32_t)attr << 9) |((uint32_t)td << 8) |((uint32_t)tc << 5) |((uint32_t)type << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_unpack(uint8_t* ctrl_1_func_num, uint8_t* increase_region_size, uint8_t* attr, uint8_t* td, uint8_t* tc, uint8_t* type)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);

	*ctrl_1_func_num = (localVal & ((uint32_t)0x00700000)) >>  20;
	*increase_region_size = (localVal & ((uint32_t)0x00002000)) >>  13;
	*attr = (localVal & ((uint32_t)0x00000600)) >>  9;
	*td = (localVal & ((uint32_t)0x00000100)) >>  8;
	*tc = (localVal & ((uint32_t)0x000000E0)) >>  5;
	*type = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_ctrl_1_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_ctrl_1_func_num_setf(uint8_t ctrl1funcnum)
{
	ASSERT_ERR((((uint32_t)ctrl1funcnum << 20) & ~((uint32_t)0x00700000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00700000)) | ((uint32_t)ctrl1funcnum <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_increase_region_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_increase_region_size_setf(uint8_t increaseregionsize)
{
	ASSERT_ERR((((uint32_t)increaseregionsize << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)increaseregionsize <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_attr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_attr_setf(uint8_t attr)
{
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00000600)) | ((uint32_t)attr <<9));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_td_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_td_setf(uint8_t td)
{
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)td <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000E0)) >> 5);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_tc_setf(uint8_t tc)
{
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x000000E0)) | ((uint32_t)tc <<5));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_0_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_0_type_setf(uint8_t type)
{
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)type <<0));
}

/**
 * @brief IATU_REGION_CTRL_2_OFF_INBOUND_0 register definition
 *  Using this register you can enable/disable the inbound iATU optional features. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    REGION_EN                 0              
 *    30    MATCH_MODE                0              
 *    29    INVERT_MODE               0              
 *    28    CFG_SHIFT_MODE            0              
 *    27    FUZZY_TYPE_MATCH_CODE     0              
 *    25:24 RESPONSE_CODE             0x0
 *    23    SINGLE_ADDR_LOC_TRANS_EN  0              
 *    21    MSG_CODE_MATCH_EN         0              
 *    19    FUNC_NUM_MATCH_EN         0              
 *    16    ATTR_MATCH_EN             0              
 *    15    TD_MATCH_EN               0              
 *    14    TC_MATCH_EN               0              
 *    13    MSG_TYPE_MATCH_MODE       0              
 *    10:08 BAR_NUM                   0x0
 *    07:00 MSG_CODE                  0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004104)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_OFFSET      0x00004104
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INDEX       0x00001041
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_2_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_POS    31
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_POS    30
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_POS    29
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_POS    28
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_POS    27
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RESPONSE_CODE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RESPONSE_CODE_LSB    24
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RESPONSE_CODE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_POS    23
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_POS    21
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_POS    19
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_POS    16
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_POS    15
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_POS    14
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_MASK    ((uint32_t)0x00000700)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_LSB    8
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_REGION_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MATCH_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_INVERT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_CFG_SHIFT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUZZY_TYPE_MATCH_CODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_RESPONSE_CODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_SINGLE_ADDR_LOC_TRANS_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_FUNC_NUM_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ATTR_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TD_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_TC_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_TYPE_MATCH_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_BAR_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_MSG_CODE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_pack(uint8_t region_en, uint8_t match_mode, uint8_t invert_mode, uint8_t cfg_shift_mode, uint8_t fuzzy_type_match_code, uint8_t response_code, uint8_t single_addr_loc_trans_en, uint8_t msg_code_match_en, uint8_t func_num_match_en, uint8_t attr_match_en, uint8_t td_match_en, uint8_t tc_match_en, uint8_t msg_type_match_mode, uint8_t bar_num, uint8_t msg_code)
{
	ASSERT_ERR((((uint32_t)region_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)match_mode << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)invert_mode << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_shift_mode << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)fuzzy_type_match_code << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)response_code << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)single_addr_loc_trans_en << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)msg_code_match_en << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)func_num_match_en << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)attr_match_en << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)td_match_en << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)tc_match_en << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)msg_type_match_mode << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)bar_num << 8) & ~((uint32_t)0x00000700)) == 0);
	ASSERT_ERR((((uint32_t)msg_code << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR,  ((uint32_t)region_en << 31) |((uint32_t)match_mode << 30) |((uint32_t)invert_mode << 29) |((uint32_t)cfg_shift_mode << 28) |((uint32_t)fuzzy_type_match_code << 27) |((uint32_t)response_code << 24) |((uint32_t)single_addr_loc_trans_en << 23) |((uint32_t)msg_code_match_en << 21) |((uint32_t)func_num_match_en << 19) |((uint32_t)attr_match_en << 16) |((uint32_t)td_match_en << 15) |((uint32_t)tc_match_en << 14) |((uint32_t)msg_type_match_mode << 13) |((uint32_t)bar_num << 8) |((uint32_t)msg_code << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_unpack(uint8_t* region_en, uint8_t* match_mode, uint8_t* invert_mode, uint8_t* cfg_shift_mode, uint8_t* fuzzy_type_match_code, uint8_t* response_code, uint8_t* single_addr_loc_trans_en, uint8_t* msg_code_match_en, uint8_t* func_num_match_en, uint8_t* attr_match_en, uint8_t* td_match_en, uint8_t* tc_match_en, uint8_t* msg_type_match_mode, uint8_t* bar_num, uint8_t* msg_code)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);

	*region_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*match_mode = (localVal & ((uint32_t)0x40000000)) >>  30;
	*invert_mode = (localVal & ((uint32_t)0x20000000)) >>  29;
	*cfg_shift_mode = (localVal & ((uint32_t)0x10000000)) >>  28;
	*fuzzy_type_match_code = (localVal & ((uint32_t)0x08000000)) >>  27;
	*response_code = (localVal & ((uint32_t)0x03000000)) >>  24;
	*single_addr_loc_trans_en = (localVal & ((uint32_t)0x00800000)) >>  23;
	*msg_code_match_en = (localVal & ((uint32_t)0x00200000)) >>  21;
	*func_num_match_en = (localVal & ((uint32_t)0x00080000)) >>  19;
	*attr_match_en = (localVal & ((uint32_t)0x00010000)) >>  16;
	*td_match_en = (localVal & ((uint32_t)0x00008000)) >>  15;
	*tc_match_en = (localVal & ((uint32_t)0x00004000)) >>  14;
	*msg_type_match_mode = (localVal & ((uint32_t)0x00002000)) >>  13;
	*bar_num = (localVal & ((uint32_t)0x00000700)) >>  8;
	*msg_code = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_region_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_region_en_setf(uint8_t regionen)
{
	ASSERT_ERR((((uint32_t)regionen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)regionen <<31));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_match_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_match_mode_setf(uint8_t matchmode)
{
	ASSERT_ERR((((uint32_t)matchmode << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)matchmode <<30));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_invert_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_invert_mode_setf(uint8_t invertmode)
{
	ASSERT_ERR((((uint32_t)invertmode << 29) & ~((uint32_t)0x20000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)invertmode <<29));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_cfg_shift_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_cfg_shift_mode_setf(uint8_t cfgshiftmode)
{
	ASSERT_ERR((((uint32_t)cfgshiftmode << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)cfgshiftmode <<28));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_fuzzy_type_match_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_fuzzy_type_match_code_setf(uint8_t fuzzytypematchcode)
{
	ASSERT_ERR((((uint32_t)fuzzytypematchcode << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)fuzzytypematchcode <<27));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_response_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_response_code_setf(uint8_t responsecode)
{
	ASSERT_ERR((((uint32_t)responsecode << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)responsecode <<24));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_single_addr_loc_trans_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_single_addr_loc_trans_en_setf(uint8_t singleaddrloctransen)
{
	ASSERT_ERR((((uint32_t)singleaddrloctransen << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)singleaddrloctransen <<23));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_code_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_code_match_en_setf(uint8_t msgcodematchen)
{
	ASSERT_ERR((((uint32_t)msgcodematchen << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)msgcodematchen <<21));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_func_num_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_func_num_match_en_setf(uint8_t funcnummatchen)
{
	ASSERT_ERR((((uint32_t)funcnummatchen << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)funcnummatchen <<19));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_attr_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_attr_match_en_setf(uint8_t attrmatchen)
{
	ASSERT_ERR((((uint32_t)attrmatchen << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)attrmatchen <<16));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_td_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_td_match_en_setf(uint8_t tdmatchen)
{
	ASSERT_ERR((((uint32_t)tdmatchen << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)tdmatchen <<15));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_tc_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_tc_match_en_setf(uint8_t tcmatchen)
{
	ASSERT_ERR((((uint32_t)tcmatchen << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)tcmatchen <<14));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_type_match_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_type_match_mode_setf(uint8_t msgtypematchmode)
{
	ASSERT_ERR((((uint32_t)msgtypematchmode << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)msgtypematchmode <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_bar_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000700)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_bar_num_setf(uint8_t barnum)
{
	ASSERT_ERR((((uint32_t)barnum << 8) & ~((uint32_t)0x00000700)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x00000700)) | ((uint32_t)barnum <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_0_msg_code_setf(uint8_t msgcode)
{
	ASSERT_ERR((((uint32_t)msgcode << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)msgcode <<0));
}

/**
 * @brief IATU_LWR_BASE_ADDR_OFF_INBOUND_0 register definition
 *  The CX_ATU_MIN_REGION_SIZE configuration parameter (Value Range: 4 kB, 8 kB, 16 kB, 32 kB, 64 kB defaults to 64 kB) specifies the minimum size of an address translation region. For example, if set to 64 kB; the lower 16 bits of the Base, Limit and Target registers are zero and all address regions are aligned on 64 kB boundaries. More precisely, the lower log2(CX_ATU_MIN_REGION_SIZE) bits are zero. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_BASE_RW               0x0
 *    15:00 LWR_BASE_HW               0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004108)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_OFFSET      0x00004108
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_INDEX       0x00001042
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_base_addr_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_LSB    16
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_LSB    0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_RW_RST    0x0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_LWR_BASE_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_0_pack(uint16_t lwr_base_rw, uint16_t lwr_base_hw)
{
	ASSERT_ERR((((uint32_t)lwr_base_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_base_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR,  ((uint32_t)lwr_base_rw << 16) |((uint32_t)lwr_base_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_0_unpack(uint16_t* lwr_base_rw, uint16_t* lwr_base_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR);

	*lwr_base_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_base_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_inbound_0_lwr_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_0_lwr_base_rw_setf(uint16_t lwrbaserw)
{
	ASSERT_ERR((((uint32_t)lwrbaserw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrbaserw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_inbound_0_lwr_base_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief IATU_UPPER_BASE_ADDR_OFF_INBOUND_0 register definition
 *  This register holds the upper 32 bits of the start (and end) address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_BASE_RW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000410C)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_OFFSET      0x0000410C
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_INDEX       0x00001043
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_base_addr_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_upper_base_addr_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_LSB    0
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_UPPER_BASE_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_base_addr_off_inbound_0_upper_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_base_addr_off_inbound_0_upper_base_rw_setf(uint32_t upperbaserw)
{
	ASSERT_ERR((((uint32_t)upperbaserw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_0_ADDR, (uint32_t)upperbaserw << 0);
}

/**
 * @brief IATU_LIMIT_ADDR_OFF_INBOUND_0 register definition
 *  This register holds the end address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LIMIT_ADDR_RW             0x0
 *    15:04 LIMIT_ADDR_HW             0xfff
 *    03:00 CBUF_INCR                 0x0
 * </pre>
 */
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004110)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_OFFSET      0x00004110
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_INDEX       0x00001044
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_RESET       0x0000FFF0

__INLINE uint32_t  pcie_ep_iatu_limit_addr_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_LSB    16
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_LSB    4
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_LSB    0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_RW_RST    0x0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_LIMIT_ADDR_HW_RST    0xfff
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_CBUF_INCR_RST    0x0

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_0_pack(uint16_t limit_addr_rw, uint16_t limit_addr_hw, uint8_t cbuf_incr)
{
	ASSERT_ERR((((uint32_t)limit_addr_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)limit_addr_hw << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)cbuf_incr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR,  ((uint32_t)limit_addr_rw << 16) |((uint32_t)limit_addr_hw << 4) |((uint32_t)cbuf_incr << 0));
}

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_0_unpack(uint16_t* limit_addr_rw, uint16_t* limit_addr_hw, uint8_t* cbuf_incr)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR);

	*limit_addr_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*limit_addr_hw = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*cbuf_incr = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_limit_addr_off_inbound_0_limit_addr_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_limit_addr_off_inbound_0_limit_addr_rw_setf(uint16_t limitaddrrw)
{
	ASSERT_ERR((((uint32_t)limitaddrrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)limitaddrrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_limit_addr_off_inbound_0_limit_addr_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_iatu_limit_addr_off_inbound_0_cbuf_incr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void pcie_ep_iatu_limit_addr_off_inbound_0_cbuf_incr_setf(uint8_t cbufincr)
{
	ASSERT_ERR((((uint32_t)cbufincr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_0_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)cbufincr <<0));
}

/**
 * @brief IATU_LWR_TARGET_ADDR_OFF_INBOUND_0 register definition
 *  This register holds the Lower Target part of the new address of the translated region. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_TARGET_RW             0x0
 *    15:00 LWR_TARGET_HW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004114)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_OFFSET      0x00004114
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_INDEX       0x00001045
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_target_addr_off_inbound_0_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_LSB    16
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_LSB    0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_RW_RST    0x0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_LWR_TARGET_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_0_pack(uint16_t lwr_target_rw, uint16_t lwr_target_hw)
{
	ASSERT_ERR((((uint32_t)lwr_target_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_target_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR,  ((uint32_t)lwr_target_rw << 16) |((uint32_t)lwr_target_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_0_unpack(uint16_t* lwr_target_rw, uint16_t* lwr_target_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR);

	*lwr_target_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_target_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_target_addr_off_inbound_0_lwr_target_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_0_lwr_target_rw_setf(uint16_t lwrtargetrw)
{
	ASSERT_ERR((((uint32_t)lwrtargetrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrtargetrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_target_addr_off_inbound_0_lwr_target_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_0_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief IATU_REGION_CTRL_1_OFF_OUTBOUND_1 register definition
 *  This register controls the iATU outbound region access based on the optional iATU outbound features enabled using iATU Region Control 2 Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    22:20 CTRL_1_FUNC_NUM           0x0
 *    13    INCREASE_REGION_SIZE      0              
 *    10:09 ATTR                      0x0
 *    08    TD                        0              
 *    07:05 TC                        0x0
 *    04:00 TYPE                      0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004200)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_OFFSET      0x00004200
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INDEX       0x00001080
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_1_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_LSB    20
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_MASK    ((uint32_t)0x00000600)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_LSB    9
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_POS    8
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_MASK    ((uint32_t)0x000000E0)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_LSB    5
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_CTRL_1_FUNC_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_INCREASE_REGION_SIZE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ATTR_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TC_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_TYPE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_pack(uint8_t ctrl_1_func_num, uint8_t increase_region_size, uint8_t attr, uint8_t td, uint8_t tc, uint8_t type)
{
	ASSERT_ERR((((uint32_t)ctrl_1_func_num << 20) & ~((uint32_t)0x00700000)) == 0);
	ASSERT_ERR((((uint32_t)increase_region_size << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR,  ((uint32_t)ctrl_1_func_num << 20) |((uint32_t)increase_region_size << 13) |((uint32_t)attr << 9) |((uint32_t)td << 8) |((uint32_t)tc << 5) |((uint32_t)type << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_unpack(uint8_t* ctrl_1_func_num, uint8_t* increase_region_size, uint8_t* attr, uint8_t* td, uint8_t* tc, uint8_t* type)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);

	*ctrl_1_func_num = (localVal & ((uint32_t)0x00700000)) >>  20;
	*increase_region_size = (localVal & ((uint32_t)0x00002000)) >>  13;
	*attr = (localVal & ((uint32_t)0x00000600)) >>  9;
	*td = (localVal & ((uint32_t)0x00000100)) >>  8;
	*tc = (localVal & ((uint32_t)0x000000E0)) >>  5;
	*type = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_ctrl_1_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_ctrl_1_func_num_setf(uint8_t ctrl1funcnum)
{
	ASSERT_ERR((((uint32_t)ctrl1funcnum << 20) & ~((uint32_t)0x00700000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00700000)) | ((uint32_t)ctrl1funcnum <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_increase_region_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_increase_region_size_setf(uint8_t increaseregionsize)
{
	ASSERT_ERR((((uint32_t)increaseregionsize << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)increaseregionsize <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_attr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_attr_setf(uint8_t attr)
{
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00000600)) | ((uint32_t)attr <<9));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_td_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_td_setf(uint8_t td)
{
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)td <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000E0)) >> 5);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_tc_setf(uint8_t tc)
{
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x000000E0)) | ((uint32_t)tc <<5));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_outbound_1_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_outbound_1_type_setf(uint8_t type)
{
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)type <<0));
}

/**
 * @brief IATU_REGION_CTRL_2_OFF_OUTBOUND_1 register definition
 *  Using this register you can enable/disable the outbound iATU optional features. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    REGION_EN                 0              
 *    29    INVERT_MODE               0              
 *    28    CFG_SHIFT_MODE            0              
 *    27    DMA_BYPASS                0              
 *    23    HEADER_SUBSTITUTE_EN      0              
 *    22    INHIBIT_PAYLOAD           0              
 *    21    TLP_HEADER_FIELDS_BYPASS  0              
 *    20    SNP                       0              
 *    19    FUNC_BYPASS               0              
 *    16    TAG_SUBSTITUTE_EN         0              
 *    15:08 TAG                       0x0
 *    07:00 MSG_CODE                  0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004204)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_OFFSET      0x00004204
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INDEX       0x00001081
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_2_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_POS    31
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_POS    29
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_POS    28
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYPASS_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYPASS_POS    27
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_POS    23
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_POS    22
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYPASS_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYPASS_POS    21
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_BIT    ((uint32_t)0x00100000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_POS    20
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYPASS_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYPASS_POS    19
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_POS    16
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_LSB    8
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_REGION_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INVERT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_CFG_SHIFT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_DMA_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_HEADER_SUBSTITUTE_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_INHIBIT_PAYLOAD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TLP_HEADER_FIELDS_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_SNP_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_FUNC_BYPASS_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_SUBSTITUTE_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_TAG_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_MSG_CODE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_pack(uint8_t region_en, uint8_t invert_mode, uint8_t cfg_shift_mode, uint8_t dma_bypass, uint8_t header_substitute_en, uint8_t inhibit_payload, uint8_t tlp_header_fields_bypass, uint8_t snp, uint8_t func_bypass, uint8_t tag_substitute_en, uint8_t tag, uint8_t msg_code)
{
	ASSERT_ERR((((uint32_t)region_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)invert_mode << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_shift_mode << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_bypass << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)header_substitute_en << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)inhibit_payload << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)tlp_header_fields_bypass << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)snp << 20) & ~((uint32_t)0x00100000)) == 0);
	ASSERT_ERR((((uint32_t)func_bypass << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)tag_substitute_en << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)tag << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)msg_code << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR,  ((uint32_t)region_en << 31) |((uint32_t)invert_mode << 29) |((uint32_t)cfg_shift_mode << 28) |((uint32_t)dma_bypass << 27) |((uint32_t)header_substitute_en << 23) |((uint32_t)inhibit_payload << 22) |((uint32_t)tlp_header_fields_bypass << 21) |((uint32_t)snp << 20) |((uint32_t)func_bypass << 19) |((uint32_t)tag_substitute_en << 16) |((uint32_t)tag << 8) |((uint32_t)msg_code << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_unpack(uint8_t* region_en, uint8_t* invert_mode, uint8_t* cfg_shift_mode, uint8_t* dma_bypass, uint8_t* header_substitute_en, uint8_t* inhibit_payload, uint8_t* tlp_header_fields_bypass, uint8_t* snp, uint8_t* func_bypass, uint8_t* tag_substitute_en, uint8_t* tag, uint8_t* msg_code)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);

	*region_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*invert_mode = (localVal & ((uint32_t)0x20000000)) >>  29;
	*cfg_shift_mode = (localVal & ((uint32_t)0x10000000)) >>  28;
	*dma_bypass = (localVal & ((uint32_t)0x08000000)) >>  27;
	*header_substitute_en = (localVal & ((uint32_t)0x00800000)) >>  23;
	*inhibit_payload = (localVal & ((uint32_t)0x00400000)) >>  22;
	*tlp_header_fields_bypass = (localVal & ((uint32_t)0x00200000)) >>  21;
	*snp = (localVal & ((uint32_t)0x00100000)) >>  20;
	*func_bypass = (localVal & ((uint32_t)0x00080000)) >>  19;
	*tag_substitute_en = (localVal & ((uint32_t)0x00010000)) >>  16;
	*tag = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*msg_code = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_region_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_region_en_setf(uint8_t regionen)
{
	ASSERT_ERR((((uint32_t)regionen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)regionen <<31));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_invert_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_invert_mode_setf(uint8_t invertmode)
{
	ASSERT_ERR((((uint32_t)invertmode << 29) & ~((uint32_t)0x20000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)invertmode <<29));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_cfg_shift_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_cfg_shift_mode_setf(uint8_t cfgshiftmode)
{
	ASSERT_ERR((((uint32_t)cfgshiftmode << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)cfgshiftmode <<28));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_dma_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_dma_bypass_setf(uint8_t dmabypass)
{
	ASSERT_ERR((((uint32_t)dmabypass << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)dmabypass <<27));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_header_substitute_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_header_substitute_en_setf(uint8_t headersubstituteen)
{
	ASSERT_ERR((((uint32_t)headersubstituteen << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)headersubstituteen <<23));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_inhibit_payload_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_inhibit_payload_setf(uint8_t inhibitpayload)
{
	ASSERT_ERR((((uint32_t)inhibitpayload << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)inhibitpayload <<22));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_tlp_header_fields_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_tlp_header_fields_bypass_setf(uint8_t tlpheaderfieldsbypass)
{
	ASSERT_ERR((((uint32_t)tlpheaderfieldsbypass << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)tlpheaderfieldsbypass <<21));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_snp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00100000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_snp_setf(uint8_t snp)
{
	ASSERT_ERR((((uint32_t)snp << 20) & ~((uint32_t)0x00100000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00100000)) | ((uint32_t)snp <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_func_bypass_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_func_bypass_setf(uint8_t funcbypass)
{
	ASSERT_ERR((((uint32_t)funcbypass << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)funcbypass <<19));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_tag_substitute_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_tag_substitute_en_setf(uint8_t tagsubstituteen)
{
	ASSERT_ERR((((uint32_t)tagsubstituteen << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)tagsubstituteen <<16));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_tag_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_tag_setf(uint8_t tag)
{
	ASSERT_ERR((((uint32_t)tag << 8) & ~((uint32_t)0x0000FF00)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x0000FF00)) | ((uint32_t)tag <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_outbound_1_msg_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_outbound_1_msg_code_setf(uint8_t msgcode)
{
	ASSERT_ERR((((uint32_t)msgcode << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)msgcode <<0));
}

/**
 * @brief IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1 register definition
 *  The CX_ATU_MIN_REGION_SIZE configuration parameter (Value Range: 4 kB, 8 kB, 16 kB, 32 kB, 64 kB defaults to 64 kB) specifies the minimum size of an address translation region. For example, if set to 64 kB; the lower 16 bits of the Base, Limit and Target registers are zero and all address regions are aligned on 64 kB boundaries. More precisely, the lower log2(CX_ATU_MIN_REGION_SIZE) bits are zero. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_BASE_RW               0x0
 *    15:00 LWR_BASE_HW               0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004208)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_OFFSET      0x00004208
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_INDEX       0x00001082
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_base_addr_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_LSB    16
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_LSB    0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_RW_RST    0x0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_LWR_BASE_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_1_pack(uint16_t lwr_base_rw, uint16_t lwr_base_hw)
{
	ASSERT_ERR((((uint32_t)lwr_base_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_base_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR,  ((uint32_t)lwr_base_rw << 16) |((uint32_t)lwr_base_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_1_unpack(uint16_t* lwr_base_rw, uint16_t* lwr_base_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR);

	*lwr_base_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_base_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_outbound_1_lwr_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_base_addr_off_outbound_1_lwr_base_rw_setf(uint16_t lwrbaserw)
{
	ASSERT_ERR((((uint32_t)lwrbaserw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrbaserw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_outbound_1_lwr_base_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1 register definition
 *  This register holds the upper 32-bits of the start (and end) address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_BASE_RW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000420C)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_OFFSET      0x0000420C
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_INDEX       0x00001083
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_base_addr_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_upper_base_addr_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_LSB    0
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_UPPER_BASE_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_base_addr_off_outbound_1_upper_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_base_addr_off_outbound_1_upper_base_rw_setf(uint32_t upperbaserw)
{
	ASSERT_ERR((((uint32_t)upperbaserw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_OUTBOUND_1_ADDR, (uint32_t)upperbaserw << 0);
}

/**
 * @brief IATU_LIMIT_ADDR_OFF_OUTBOUND_1 register definition
 *  This register holds the end address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LIMIT_ADDR_RW             0x0
 *    15:04 LIMIT_ADDR_HW             0xfff
 *    03:00 CBUF_INCR                 0xf
 * </pre>
 */
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004210)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_OFFSET      0x00004210
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_INDEX       0x00001084
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_RESET       0x0000FFFF

__INLINE uint32_t  pcie_ep_iatu_limit_addr_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_LSB    16
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_LSB    4
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_LSB    0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_RW_RST    0x0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_LIMIT_ADDR_HW_RST    0xfff
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_CBUF_INCR_RST    0xf

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_1_pack(uint16_t limit_addr_rw, uint16_t limit_addr_hw, uint8_t cbuf_incr)
{
	ASSERT_ERR((((uint32_t)limit_addr_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)limit_addr_hw << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)cbuf_incr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR,  ((uint32_t)limit_addr_rw << 16) |((uint32_t)limit_addr_hw << 4) |((uint32_t)cbuf_incr << 0));
}

__INLINE void pcie_ep_iatu_limit_addr_off_outbound_1_unpack(uint16_t* limit_addr_rw, uint16_t* limit_addr_hw, uint8_t* cbuf_incr)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR);

	*limit_addr_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*limit_addr_hw = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*cbuf_incr = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_limit_addr_off_outbound_1_limit_addr_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_limit_addr_off_outbound_1_limit_addr_rw_setf(uint16_t limitaddrrw)
{
	ASSERT_ERR((((uint32_t)limitaddrrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)limitaddrrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_limit_addr_off_outbound_1_limit_addr_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_iatu_limit_addr_off_outbound_1_cbuf_incr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1 register definition
 *  This register holds the Lower Target part of the new address of the translated region, or the outbound TLP header information, depending on the setting  of HEADER_SUBSTITUTE_EN field of IATU_REGION_CTRL_2_VIEWPORT_OFF_OUTBOUND_i register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LWR_TARGET_RW_OUTBOUND    0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004214)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET      0x00004214
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_INDEX       0x00001085
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_target_addr_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_LSB    0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_LWR_TARGET_RW_OUTBOUND_RST    0x0

__INLINE uint32_t pcie_ep_iatu_lwr_target_addr_off_outbound_1_lwr_target_rw_outbound_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_lwr_target_addr_off_outbound_1_lwr_target_rw_outbound_setf(uint32_t lwrtargetrwoutbound)
{
	ASSERT_ERR((((uint32_t)lwrtargetrwoutbound << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_OUTBOUND_1_ADDR, (uint32_t)lwrtargetrwoutbound << 0);
}

/**
 * @brief IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1 register definition
 *  This register holds the upper 32 bits of the start address (Upper Target part) of the new address of the translated region. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_TARGET_RW           0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004218)
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_OFFSET      0x00004218
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_INDEX       0x00001086
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_target_addr_off_outbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_upper_target_addr_off_outbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_LSB    0
#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_UPPER_TARGET_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_target_addr_off_outbound_1_upper_target_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_target_addr_off_outbound_1_upper_target_rw_setf(uint32_t uppertargetrw)
{
	ASSERT_ERR((((uint32_t)uppertargetrw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_TARGET_ADDR_OFF_OUTBOUND_1_ADDR, (uint32_t)uppertargetrw << 0);
}

/**
 * @brief IATU_REGION_CTRL_1_OFF_INBOUND_1 register definition
 *  This register controls the iATU inbound region access based on the optional iATU inbound features enabled using iATU Region Control 2 Register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    22:20 CTRL_1_FUNC_NUM           0x0
 *    13    INCREASE_REGION_SIZE      0              
 *    10:09 ATTR                      0x0
 *    08    TD                        0              
 *    07:05 TC                        0x0
 *    04:00 TYPE                      0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004300)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_OFFSET      0x00004300
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INDEX       0x000010C0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_1_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_MASK    ((uint32_t)0x00700000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_LSB    20
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_MASK    ((uint32_t)0x00000600)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_LSB    9
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_POS    8
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_MASK    ((uint32_t)0x000000E0)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_LSB    5
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_CTRL_1_FUNC_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_INCREASE_REGION_SIZE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ATTR_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TD_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TC_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_TYPE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_pack(uint8_t ctrl_1_func_num, uint8_t increase_region_size, uint8_t attr, uint8_t td, uint8_t tc, uint8_t type)
{
	ASSERT_ERR((((uint32_t)ctrl_1_func_num << 20) & ~((uint32_t)0x00700000)) == 0);
	ASSERT_ERR((((uint32_t)increase_region_size << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR,  ((uint32_t)ctrl_1_func_num << 20) |((uint32_t)increase_region_size << 13) |((uint32_t)attr << 9) |((uint32_t)td << 8) |((uint32_t)tc << 5) |((uint32_t)type << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_unpack(uint8_t* ctrl_1_func_num, uint8_t* increase_region_size, uint8_t* attr, uint8_t* td, uint8_t* tc, uint8_t* type)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);

	*ctrl_1_func_num = (localVal & ((uint32_t)0x00700000)) >>  20;
	*increase_region_size = (localVal & ((uint32_t)0x00002000)) >>  13;
	*attr = (localVal & ((uint32_t)0x00000600)) >>  9;
	*td = (localVal & ((uint32_t)0x00000100)) >>  8;
	*tc = (localVal & ((uint32_t)0x000000E0)) >>  5;
	*type = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_ctrl_1_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00700000)) >> 20);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_ctrl_1_func_num_setf(uint8_t ctrl1funcnum)
{
	ASSERT_ERR((((uint32_t)ctrl1funcnum << 20) & ~((uint32_t)0x00700000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00700000)) | ((uint32_t)ctrl1funcnum <<20));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_increase_region_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_increase_region_size_setf(uint8_t increaseregionsize)
{
	ASSERT_ERR((((uint32_t)increaseregionsize << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)increaseregionsize <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_attr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000600)) >> 9);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_attr_setf(uint8_t attr)
{
	ASSERT_ERR((((uint32_t)attr << 9) & ~((uint32_t)0x00000600)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00000600)) | ((uint32_t)attr <<9));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_td_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_td_setf(uint8_t td)
{
	ASSERT_ERR((((uint32_t)td << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)td <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000E0)) >> 5);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_tc_setf(uint8_t tc)
{
	ASSERT_ERR((((uint32_t)tc << 5) & ~((uint32_t)0x000000E0)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x000000E0)) | ((uint32_t)tc <<5));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_1_off_inbound_1_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_1_off_inbound_1_type_setf(uint8_t type)
{
	ASSERT_ERR((((uint32_t)type << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_1_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)type <<0));
}

/**
 * @brief IATU_REGION_CTRL_2_OFF_INBOUND_1 register definition
 *  Using this register you can enable/disable the inbound iATU optional features. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    REGION_EN                 0              
 *    30    MATCH_MODE                0              
 *    29    INVERT_MODE               0              
 *    28    CFG_SHIFT_MODE            0              
 *    27    FUZZY_TYPE_MATCH_CODE     0              
 *    25:24 RESPONSE_CODE             0x0
 *    23    SINGLE_ADDR_LOC_TRANS_EN  0              
 *    21    MSG_CODE_MATCH_EN         0              
 *    19    FUNC_NUM_MATCH_EN         0              
 *    16    ATTR_MATCH_EN             0              
 *    15    TD_MATCH_EN               0              
 *    14    TC_MATCH_EN               0              
 *    13    MSG_TYPE_MATCH_MODE       0              
 *    10:08 BAR_NUM                   0x0
 *    07:00 MSG_CODE                  0x0
 * </pre>
 */
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004304)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_OFFSET      0x00004304
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INDEX       0x000010C1
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_region_ctrl_2_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_POS    31
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_BIT    ((uint32_t)0x40000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_POS    30
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_BIT    ((uint32_t)0x20000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_POS    29
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_BIT    ((uint32_t)0x10000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_POS    28
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_BIT    ((uint32_t)0x08000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_POS    27
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RESPONSE_CODE_MASK    ((uint32_t)0x03000000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RESPONSE_CODE_LSB    24
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RESPONSE_CODE_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_POS    23
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_BIT    ((uint32_t)0x00200000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_POS    21
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_BIT    ((uint32_t)0x00080000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_POS    19
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_BIT    ((uint32_t)0x00010000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_POS    16
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_BIT    ((uint32_t)0x00008000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_POS    15
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_BIT    ((uint32_t)0x00004000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_POS    14
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_BIT    ((uint32_t)0x00002000)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_POS    13
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_MASK    ((uint32_t)0x00000700)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_LSB    8
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_LSB    0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_REGION_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MATCH_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_INVERT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_CFG_SHIFT_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUZZY_TYPE_MATCH_CODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_RESPONSE_CODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_SINGLE_ADDR_LOC_TRANS_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_FUNC_NUM_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ATTR_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TD_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_TC_MATCH_EN_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_TYPE_MATCH_MODE_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_BAR_NUM_RST    0x0
#define PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_MSG_CODE_RST    0x0

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_pack(uint8_t region_en, uint8_t match_mode, uint8_t invert_mode, uint8_t cfg_shift_mode, uint8_t fuzzy_type_match_code, uint8_t response_code, uint8_t single_addr_loc_trans_en, uint8_t msg_code_match_en, uint8_t func_num_match_en, uint8_t attr_match_en, uint8_t td_match_en, uint8_t tc_match_en, uint8_t msg_type_match_mode, uint8_t bar_num, uint8_t msg_code)
{
	ASSERT_ERR((((uint32_t)region_en << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)match_mode << 30) & ~((uint32_t)0x40000000)) == 0);
	ASSERT_ERR((((uint32_t)invert_mode << 29) & ~((uint32_t)0x20000000)) == 0);
	ASSERT_ERR((((uint32_t)cfg_shift_mode << 28) & ~((uint32_t)0x10000000)) == 0);
	ASSERT_ERR((((uint32_t)fuzzy_type_match_code << 27) & ~((uint32_t)0x08000000)) == 0);
	ASSERT_ERR((((uint32_t)response_code << 24) & ~((uint32_t)0x03000000)) == 0);
	ASSERT_ERR((((uint32_t)single_addr_loc_trans_en << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)msg_code_match_en << 21) & ~((uint32_t)0x00200000)) == 0);
	ASSERT_ERR((((uint32_t)func_num_match_en << 19) & ~((uint32_t)0x00080000)) == 0);
	ASSERT_ERR((((uint32_t)attr_match_en << 16) & ~((uint32_t)0x00010000)) == 0);
	ASSERT_ERR((((uint32_t)td_match_en << 15) & ~((uint32_t)0x00008000)) == 0);
	ASSERT_ERR((((uint32_t)tc_match_en << 14) & ~((uint32_t)0x00004000)) == 0);
	ASSERT_ERR((((uint32_t)msg_type_match_mode << 13) & ~((uint32_t)0x00002000)) == 0);
	ASSERT_ERR((((uint32_t)bar_num << 8) & ~((uint32_t)0x00000700)) == 0);
	ASSERT_ERR((((uint32_t)msg_code << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR,  ((uint32_t)region_en << 31) |((uint32_t)match_mode << 30) |((uint32_t)invert_mode << 29) |((uint32_t)cfg_shift_mode << 28) |((uint32_t)fuzzy_type_match_code << 27) |((uint32_t)response_code << 24) |((uint32_t)single_addr_loc_trans_en << 23) |((uint32_t)msg_code_match_en << 21) |((uint32_t)func_num_match_en << 19) |((uint32_t)attr_match_en << 16) |((uint32_t)td_match_en << 15) |((uint32_t)tc_match_en << 14) |((uint32_t)msg_type_match_mode << 13) |((uint32_t)bar_num << 8) |((uint32_t)msg_code << 0));
}

__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_unpack(uint8_t* region_en, uint8_t* match_mode, uint8_t* invert_mode, uint8_t* cfg_shift_mode, uint8_t* fuzzy_type_match_code, uint8_t* response_code, uint8_t* single_addr_loc_trans_en, uint8_t* msg_code_match_en, uint8_t* func_num_match_en, uint8_t* attr_match_en, uint8_t* td_match_en, uint8_t* tc_match_en, uint8_t* msg_type_match_mode, uint8_t* bar_num, uint8_t* msg_code)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);

	*region_en = (localVal & ((uint32_t)0x80000000)) >>  31;
	*match_mode = (localVal & ((uint32_t)0x40000000)) >>  30;
	*invert_mode = (localVal & ((uint32_t)0x20000000)) >>  29;
	*cfg_shift_mode = (localVal & ((uint32_t)0x10000000)) >>  28;
	*fuzzy_type_match_code = (localVal & ((uint32_t)0x08000000)) >>  27;
	*response_code = (localVal & ((uint32_t)0x03000000)) >>  24;
	*single_addr_loc_trans_en = (localVal & ((uint32_t)0x00800000)) >>  23;
	*msg_code_match_en = (localVal & ((uint32_t)0x00200000)) >>  21;
	*func_num_match_en = (localVal & ((uint32_t)0x00080000)) >>  19;
	*attr_match_en = (localVal & ((uint32_t)0x00010000)) >>  16;
	*td_match_en = (localVal & ((uint32_t)0x00008000)) >>  15;
	*tc_match_en = (localVal & ((uint32_t)0x00004000)) >>  14;
	*msg_type_match_mode = (localVal & ((uint32_t)0x00002000)) >>  13;
	*bar_num = (localVal & ((uint32_t)0x00000700)) >>  8;
	*msg_code = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_region_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_region_en_setf(uint8_t regionen)
{
	ASSERT_ERR((((uint32_t)regionen << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)regionen <<31));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_match_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x40000000)) >> 30);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_match_mode_setf(uint8_t matchmode)
{
	ASSERT_ERR((((uint32_t)matchmode << 30) & ~((uint32_t)0x40000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x40000000)) | ((uint32_t)matchmode <<30));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_invert_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x20000000)) >> 29);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_invert_mode_setf(uint8_t invertmode)
{
	ASSERT_ERR((((uint32_t)invertmode << 29) & ~((uint32_t)0x20000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x20000000)) | ((uint32_t)invertmode <<29));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_cfg_shift_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x10000000)) >> 28);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_cfg_shift_mode_setf(uint8_t cfgshiftmode)
{
	ASSERT_ERR((((uint32_t)cfgshiftmode << 28) & ~((uint32_t)0x10000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x10000000)) | ((uint32_t)cfgshiftmode <<28));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_fuzzy_type_match_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x08000000)) >> 27);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_fuzzy_type_match_code_setf(uint8_t fuzzytypematchcode)
{
	ASSERT_ERR((((uint32_t)fuzzytypematchcode << 27) & ~((uint32_t)0x08000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x08000000)) | ((uint32_t)fuzzytypematchcode <<27));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_response_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x03000000)) >> 24);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_response_code_setf(uint8_t responsecode)
{
	ASSERT_ERR((((uint32_t)responsecode << 24) & ~((uint32_t)0x03000000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x03000000)) | ((uint32_t)responsecode <<24));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_single_addr_loc_trans_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_single_addr_loc_trans_en_setf(uint8_t singleaddrloctransen)
{
	ASSERT_ERR((((uint32_t)singleaddrloctransen << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)singleaddrloctransen <<23));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_code_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00200000)) >> 21);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_code_match_en_setf(uint8_t msgcodematchen)
{
	ASSERT_ERR((((uint32_t)msgcodematchen << 21) & ~((uint32_t)0x00200000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00200000)) | ((uint32_t)msgcodematchen <<21));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_func_num_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00080000)) >> 19);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_func_num_match_en_setf(uint8_t funcnummatchen)
{
	ASSERT_ERR((((uint32_t)funcnummatchen << 19) & ~((uint32_t)0x00080000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00080000)) | ((uint32_t)funcnummatchen <<19));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_attr_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00010000)) >> 16);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_attr_match_en_setf(uint8_t attrmatchen)
{
	ASSERT_ERR((((uint32_t)attrmatchen << 16) & ~((uint32_t)0x00010000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00010000)) | ((uint32_t)attrmatchen <<16));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_td_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00008000)) >> 15);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_td_match_en_setf(uint8_t tdmatchen)
{
	ASSERT_ERR((((uint32_t)tdmatchen << 15) & ~((uint32_t)0x00008000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00008000)) | ((uint32_t)tdmatchen <<15));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_tc_match_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00004000)) >> 14);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_tc_match_en_setf(uint8_t tcmatchen)
{
	ASSERT_ERR((((uint32_t)tcmatchen << 14) & ~((uint32_t)0x00004000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00004000)) | ((uint32_t)tcmatchen <<14));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_type_match_mode_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00002000)) >> 13);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_type_match_mode_setf(uint8_t msgtypematchmode)
{
	ASSERT_ERR((((uint32_t)msgtypematchmode << 13) & ~((uint32_t)0x00002000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00002000)) | ((uint32_t)msgtypematchmode <<13));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_bar_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000700)) >> 8);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_bar_num_setf(uint8_t barnum)
{
	ASSERT_ERR((((uint32_t)barnum << 8) & ~((uint32_t)0x00000700)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x00000700)) | ((uint32_t)barnum <<8));
}
__INLINE uint8_t pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_code_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_iatu_region_ctrl_2_off_inbound_1_msg_code_setf(uint8_t msgcode)
{
	ASSERT_ERR((((uint32_t)msgcode << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_REGION_CTRL_2_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)msgcode <<0));
}

/**
 * @brief IATU_LWR_BASE_ADDR_OFF_INBOUND_1 register definition
 *  The CX_ATU_MIN_REGION_SIZE configuration parameter (Value Range: 4 kB, 8 kB, 16 kB, 32 kB, 64 kB defaults to 64 kB) specifies the minimum size of an address translation region. For example, if set to 64 kB; the lower 16 bits of the Base, Limit and Target registers are zero and all address regions are aligned on 64 kB boundaries. More precisely, the lower log2(CX_ATU_MIN_REGION_SIZE) bits are zero. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_BASE_RW               0x0
 *    15:00 LWR_BASE_HW               0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004308)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_OFFSET      0x00004308
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_INDEX       0x000010C2
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_base_addr_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_LSB    16
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_LSB    0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_RW_RST    0x0
#define PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_LWR_BASE_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_1_pack(uint16_t lwr_base_rw, uint16_t lwr_base_hw)
{
	ASSERT_ERR((((uint32_t)lwr_base_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_base_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR,  ((uint32_t)lwr_base_rw << 16) |((uint32_t)lwr_base_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_1_unpack(uint16_t* lwr_base_rw, uint16_t* lwr_base_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR);

	*lwr_base_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_base_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_inbound_1_lwr_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_base_addr_off_inbound_1_lwr_base_rw_setf(uint16_t lwrbaserw)
{
	ASSERT_ERR((((uint32_t)lwrbaserw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrbaserw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_base_addr_off_inbound_1_lwr_base_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_BASE_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief IATU_UPPER_BASE_ADDR_OFF_INBOUND_1 register definition
 *  This register holds the upper 32 bits of the start (and end) address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPPER_BASE_RW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000430C)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_OFFSET      0x0000430C
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_INDEX       0x000010C3
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_upper_base_addr_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_upper_base_addr_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_LSB    0
#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_UPPER_BASE_RW_RST    0x0

__INLINE uint32_t pcie_ep_iatu_upper_base_addr_off_inbound_1_upper_base_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_iatu_upper_base_addr_off_inbound_1_upper_base_rw_setf(uint32_t upperbaserw)
{
	ASSERT_ERR((((uint32_t)upperbaserw << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_UPPER_BASE_ADDR_OFF_INBOUND_1_ADDR, (uint32_t)upperbaserw << 0);
}

/**
 * @brief IATU_LIMIT_ADDR_OFF_INBOUND_1 register definition
 *  This register holds the end address of the address region to be translated. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LIMIT_ADDR_RW             0x0
 *    15:04 LIMIT_ADDR_HW             0xfff
 *    03:00 CBUF_INCR                 0x0
 * </pre>
 */
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004310)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_OFFSET      0x00004310
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_INDEX       0x000010C4
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_RESET       0x0000FFF0

__INLINE uint32_t  pcie_ep_iatu_limit_addr_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_LSB    16
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_LSB    4
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_LSB    0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_RW_RST    0x0
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_LIMIT_ADDR_HW_RST    0xfff
#define PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_CBUF_INCR_RST    0x0

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_1_pack(uint16_t limit_addr_rw, uint16_t limit_addr_hw, uint8_t cbuf_incr)
{
	ASSERT_ERR((((uint32_t)limit_addr_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)limit_addr_hw << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)cbuf_incr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR,  ((uint32_t)limit_addr_rw << 16) |((uint32_t)limit_addr_hw << 4) |((uint32_t)cbuf_incr << 0));
}

__INLINE void pcie_ep_iatu_limit_addr_off_inbound_1_unpack(uint16_t* limit_addr_rw, uint16_t* limit_addr_hw, uint8_t* cbuf_incr)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR);

	*limit_addr_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*limit_addr_hw = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*cbuf_incr = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_limit_addr_off_inbound_1_limit_addr_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_limit_addr_off_inbound_1_limit_addr_rw_setf(uint16_t limitaddrrw)
{
	ASSERT_ERR((((uint32_t)limitaddrrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)limitaddrrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_limit_addr_off_inbound_1_limit_addr_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_iatu_limit_addr_off_inbound_1_cbuf_incr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}
__INLINE void pcie_ep_iatu_limit_addr_off_inbound_1_cbuf_incr_setf(uint8_t cbufincr)
{
	ASSERT_ERR((((uint32_t)cbufincr << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LIMIT_ADDR_OFF_INBOUND_1_ADDR) & ~((uint32_t)0x0000000F)) | ((uint32_t)cbufincr <<0));
}

/**
 * @brief IATU_LWR_TARGET_ADDR_OFF_INBOUND_1 register definition
 *  This register holds the Lower Target part of the new address of the translated region. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 LWR_TARGET_RW             0x0
 *    15:00 LWR_TARGET_HW             0x0
 * </pre>
 */
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00004314)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_OFFSET      0x00004314
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_INDEX       0x000010C5
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_iatu_lwr_target_addr_off_inbound_1_get(void)
{
	return REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR);
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR, value);
}

// field definitions
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_LSB    16
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_LSB    0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_RW_RST    0x0
#define PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_LWR_TARGET_HW_RST    0x0

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_1_pack(uint16_t lwr_target_rw, uint16_t lwr_target_hw)
{
	ASSERT_ERR((((uint32_t)lwr_target_rw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)lwr_target_hw << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR,  ((uint32_t)lwr_target_rw << 16) |((uint32_t)lwr_target_hw << 0));
}

__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_1_unpack(uint16_t* lwr_target_rw, uint16_t* lwr_target_hw)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR);

	*lwr_target_rw = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*lwr_target_hw = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_iatu_lwr_target_addr_off_inbound_1_lwr_target_rw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_iatu_lwr_target_addr_off_inbound_1_lwr_target_rw_setf(uint16_t lwrtargetrw)
{
	ASSERT_ERR((((uint32_t)lwrtargetrw << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR, (REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)lwrtargetrw <<16));
}
__INLINE uint16_t pcie_ep_iatu_lwr_target_addr_off_inbound_1_lwr_target_hw_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_IATU_LWR_TARGET_ADDR_OFF_INBOUND_1_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}

/**
 * @brief BAR_0_MASK_REG register definition
 *  This register is the mask for BAR0_REG. If implemented, it exists as a shadow register at the BAR0_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR0_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR0_ENABLED    1              
 * </pre>
 */
#define PCIE_EP_BAR_0_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008010)
#define PCIE_EP_BAR_0_MASK_REG_OFFSET      0x00008010
#define PCIE_EP_BAR_0_MASK_REG_INDEX       0x00002004
#define PCIE_EP_BAR_0_MASK_REG_RESET       0xFFFFFFFF

__INLINE void pcie_ep_bar_0_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_0_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_MASK_LSB    1
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_ENABLED_POS    0

#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_0_MASK_REG_PCI_TYPE_0_BAR_0_ENABLED_RST    0x1

__INLINE void pcie_ep_bar_0_mask_reg_pack(uint32_t pci_type0_bar0_mask, uint8_t pci_type0_bar0_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar0_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar0_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar0_mask << 1) |((uint32_t)pci_type0_bar0_enabled << 0));
}

__INLINE void pcie_ep_bar_0_mask_reg_pci_type_0_bar_0_mask_setf(uint32_t pcitype0bar0mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar0mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar0mask <<1));
}
__INLINE void pcie_ep_bar_0_mask_reg_pci_type_0_bar_0_enabled_setf(uint8_t pcitype0bar0enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar0enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_0_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_0_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar0enabled <<0));
}

/**
 * @brief BAR_1_MASK_REG register definition
 *  This register is the mask for BAR1_REG. If implemented, it exists as a shadow register at the BAR1_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR1_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR1_ENABLED    0              
 * </pre>
 */
#define PCIE_EP_BAR_1_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008014)
#define PCIE_EP_BAR_1_MASK_REG_OFFSET      0x00008014
#define PCIE_EP_BAR_1_MASK_REG_INDEX       0x00002005
#define PCIE_EP_BAR_1_MASK_REG_RESET       0xFFFFFFFE

__INLINE void pcie_ep_bar_1_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_1_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_MASK_LSB    1
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_ENABLED_POS    0

#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_1_MASK_REG_PCI_TYPE_0_BAR_1_ENABLED_RST    0x0

__INLINE void pcie_ep_bar_1_mask_reg_pack(uint32_t pci_type0_bar1_mask, uint8_t pci_type0_bar1_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar1_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar1_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar1_mask << 1) |((uint32_t)pci_type0_bar1_enabled << 0));
}

__INLINE void pcie_ep_bar_1_mask_reg_pci_type_0_bar_1_mask_setf(uint32_t pcitype0bar1mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar1mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar1mask <<1));
}
__INLINE void pcie_ep_bar_1_mask_reg_pci_type_0_bar_1_enabled_setf(uint8_t pcitype0bar1enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar1enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_1_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_1_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar1enabled <<0));
}

/**
 * @brief BAR_2_MASK_REG register definition
 *  This register is the mask for BAR2_REG. If implemented, it exists as a shadow register at the BAR2_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR2_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR2_ENABLED    0              
 * </pre>
 */
#define PCIE_EP_BAR_2_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008018)
#define PCIE_EP_BAR_2_MASK_REG_OFFSET      0x00008018
#define PCIE_EP_BAR_2_MASK_REG_INDEX       0x00002006
#define PCIE_EP_BAR_2_MASK_REG_RESET       0xFFFFFFFE

__INLINE void pcie_ep_bar_2_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_2_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_MASK_LSB    1
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_ENABLED_POS    0

#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_2_MASK_REG_PCI_TYPE_0_BAR_2_ENABLED_RST    0x0

__INLINE void pcie_ep_bar_2_mask_reg_pack(uint32_t pci_type0_bar2_mask, uint8_t pci_type0_bar2_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar2_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar2_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_2_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar2_mask << 1) |((uint32_t)pci_type0_bar2_enabled << 0));
}

__INLINE void pcie_ep_bar_2_mask_reg_pci_type_0_bar_2_mask_setf(uint32_t pcitype0bar2mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar2mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_2_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_2_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar2mask <<1));
}
__INLINE void pcie_ep_bar_2_mask_reg_pci_type_0_bar_2_enabled_setf(uint8_t pcitype0bar2enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar2enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_2_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_2_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar2enabled <<0));
}

/**
 * @brief BAR_3_MASK_REG register definition
 *  This register is the mask for BAR3_REG. If implemented, it exists as a shadow register at the BAR3_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR3_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR3_ENABLED    0              
 * </pre>
 */
#define PCIE_EP_BAR_3_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000801C)
#define PCIE_EP_BAR_3_MASK_REG_OFFSET      0x0000801C
#define PCIE_EP_BAR_3_MASK_REG_INDEX       0x00002007
#define PCIE_EP_BAR_3_MASK_REG_RESET       0xFFFFFFFE

__INLINE void pcie_ep_bar_3_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_3_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_MASK_LSB    1
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_ENABLED_POS    0

#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_3_MASK_REG_PCI_TYPE_0_BAR_3_ENABLED_RST    0x0

__INLINE void pcie_ep_bar_3_mask_reg_pack(uint32_t pci_type0_bar3_mask, uint8_t pci_type0_bar3_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar3_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar3_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_3_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar3_mask << 1) |((uint32_t)pci_type0_bar3_enabled << 0));
}

__INLINE void pcie_ep_bar_3_mask_reg_pci_type_0_bar_3_mask_setf(uint32_t pcitype0bar3mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar3mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_3_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_3_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar3mask <<1));
}
__INLINE void pcie_ep_bar_3_mask_reg_pci_type_0_bar_3_enabled_setf(uint8_t pcitype0bar3enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar3enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_3_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_3_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar3enabled <<0));
}

/**
 * @brief BAR_4_MASK_REG register definition
 *  This register is the mask for BAR4_REG. If implemented, it exists as a shadow register at the BAR4_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR4_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR4_ENABLED    0              
 * </pre>
 */
#define PCIE_EP_BAR_4_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008020)
#define PCIE_EP_BAR_4_MASK_REG_OFFSET      0x00008020
#define PCIE_EP_BAR_4_MASK_REG_INDEX       0x00002008
#define PCIE_EP_BAR_4_MASK_REG_RESET       0xFFFFFFFE

__INLINE void pcie_ep_bar_4_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_4_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_MASK_LSB    1
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_ENABLED_POS    0

#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_4_MASK_REG_PCI_TYPE_0_BAR_4_ENABLED_RST    0x0

__INLINE void pcie_ep_bar_4_mask_reg_pack(uint32_t pci_type0_bar4_mask, uint8_t pci_type0_bar4_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar4_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar4_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_4_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar4_mask << 1) |((uint32_t)pci_type0_bar4_enabled << 0));
}

__INLINE void pcie_ep_bar_4_mask_reg_pci_type_0_bar_4_mask_setf(uint32_t pcitype0bar4mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar4mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_4_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_4_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar4mask <<1));
}
__INLINE void pcie_ep_bar_4_mask_reg_pci_type_0_bar_4_enabled_setf(uint8_t pcitype0bar4enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar4enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_4_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_4_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar4enabled <<0));
}

/**
 * @brief BAR_5_MASK_REG register definition
 *  This register is the mask for BAR5_REG. If implemented, it exists as a shadow register at the BAR5_REG address. Normally, the BAR masks are used for indicating the amount of address space that each BAR requests from host software. The BAR masks determine which bits in each BAR are non-writable by host software, which determines the size of the address space claimed by each BAR. The BAR mask values indicate the range of low-order bits, in each implemented BAR, not to use for address matching. The BAR mask value also indicates the range of low-order bits in the BAR that cannot be written from the host. The application can write to all BAR bits to allow setting of memory, I/O, and other standard BAR options.  Your local CPU can change the mask at runtime using the DBI. The mask register is invisible to the PCIe wire but visible to your local CPU through the DBI. You cannot read the mask register but you can write to it. It is accessed by asserting dbi_cs2 and dbi_cs. If you only assert dbi_cs then you will access the BAR which is the primary register at that location. Use CS2 instead of dbi_cs2 when you are using the AHB/AXI bridge. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 PCI_TYPE0_BAR5_MASK       0x7fffffff
 *    00    PCI_TYPE0_BAR5_ENABLED    0              
 * </pre>
 */
#define PCIE_EP_BAR_5_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008024)
#define PCIE_EP_BAR_5_MASK_REG_OFFSET      0x00008024
#define PCIE_EP_BAR_5_MASK_REG_INDEX       0x00002009
#define PCIE_EP_BAR_5_MASK_REG_RESET       0xFFFFFFFE

__INLINE void pcie_ep_bar_5_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_BAR_5_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_MASK_LSB    1
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_ENABLED_POS    0

#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_MASK_RST    0x7fffffff
#define PCIE_EP_BAR_5_MASK_REG_PCI_TYPE_0_BAR_5_ENABLED_RST    0x0

__INLINE void pcie_ep_bar_5_mask_reg_pack(uint32_t pci_type0_bar5_mask, uint8_t pci_type0_bar5_enabled)
{
	ASSERT_ERR((((uint32_t)pci_type0_bar5_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)pci_type0_bar5_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_5_MASK_REG_ADDR,  ((uint32_t)pci_type0_bar5_mask << 1) |((uint32_t)pci_type0_bar5_enabled << 0));
}

__INLINE void pcie_ep_bar_5_mask_reg_pci_type_0_bar_5_mask_setf(uint32_t pcitype0bar5mask)
{
	ASSERT_ERR((((uint32_t)pcitype0bar5mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_BAR_5_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_5_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)pcitype0bar5mask <<1));
}
__INLINE void pcie_ep_bar_5_mask_reg_pci_type_0_bar_5_enabled_setf(uint8_t pcitype0bar5enabled)
{
	ASSERT_ERR((((uint32_t)pcitype0bar5enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_BAR_5_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_BAR_5_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)pcitype0bar5enabled <<0));
}

/**
 * @brief EXP_ROM_BAR_MASK_REG register definition
 *  This register is the mask for EXP_ROM_BASE_ADDR_REG register. If implemented, it exists as a shadow register at EXP_ROM_BAR_MASK_REG address. The assertion of CS2 (that is, assert the dbi_cs2 input, or the CS2 address bit for the AXI bridge) is required to write to this register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 ROM_MASK                  0xffff
 *    00    ROM_BAR_ENABLED           0              
 * </pre>
 */
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR        (REG_PCIE_EP_BASE_ADDR+0x00008030)
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_OFFSET      0x00008030
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_INDEX       0x0000200C
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_RESET       0x0001FFFE

__INLINE void pcie_ep_exp_rom_bar_mask_reg_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR, value);
}

// field definitions
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_MASK_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_MASK_LSB    1
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_MASK_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_BAR_ENABLED_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_BAR_ENABLED_POS    0

#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_MASK_RST    0xffff
#define PCIE_EP_EXP_ROM_BAR_MASK_REG_ROM_BAR_ENABLED_RST    0x0

__INLINE void pcie_ep_exp_rom_bar_mask_reg_pack(uint32_t rom_mask, uint8_t rom_bar_enabled)
{
	ASSERT_ERR((((uint32_t)rom_mask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)rom_bar_enabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR,  ((uint32_t)rom_mask << 1) |((uint32_t)rom_bar_enabled << 0));
}

__INLINE void pcie_ep_exp_rom_bar_mask_reg_rom_mask_setf(uint32_t rommask)
{
	ASSERT_ERR((((uint32_t)rommask << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR) & ~((uint32_t)0xFFFFFFFE)) | ((uint32_t)rommask <<1));
}
__INLINE void pcie_ep_exp_rom_bar_mask_reg_rom_bar_enabled_setf(uint8_t rombarenabled)
{
	ASSERT_ERR((((uint32_t)rombarenabled << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR, (REG_PL_RD(PCIE_EP_EXP_ROM_BAR_MASK_REG_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)rombarenabled <<0));
}

/**
 * @brief DMA_CTRL_DATA_ARB_PRIOR_OFF register definition
 *  This register is used to control traffic priorities among various sources that are delivered to your application through TRGT1 where 0x0 represents the highest priority.  - Non-DMA Rx Requests  - DMA Write Channel MRd Requests (DMA data requests and LL element/descriptor access)  - DMA Read Channel MRd Requests (LL element/descriptor access)  - DMA Read Channel MWr Requests Concurrent traffic from channels with same priority are sorted according to Round-Robin arbitration rules. The arbitration priority defaults to Non-DMA requests (highest), Write Channel MRd, Read Channel MRd, Read Channel MWr. For more information, see the  Internal Architecture  section in the DMA chapter of the Databook. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:17 RSVDP_17                  0x0
 *    16:12 VERSION                   0x0
 *    11:09 RDBUFF_TRGT_WEIGHT        0x3
 *    08:06 RD_CTRL_TRGT_WEIGHT       0x2
 *    05:03 WR_CTRL_TRGT_WEIGHT       0x1
 *    02:00 RTRGT1_WEIGHT             0x0
 * </pre>
 */
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C000)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_OFFSET      0x0000C000
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_INDEX       0x00003000
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RESET       0x00000688

__INLINE uint32_t  pcie_ep_dma_ctrl_data_arb_prior_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
}

__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RSVDP_17_MASK    ((uint32_t)0xFFFE0000)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RSVDP_17_LSB    17
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RSVDP_17_WIDTH    ((uint32_t)0x0000000F)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_VERSION_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_VERSION_LSB    12
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_VERSION_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RDBUFF_TRGT_WEIGHT_MASK    ((uint32_t)0x00000E00)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RDBUFF_TRGT_WEIGHT_LSB    9
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RDBUFF_TRGT_WEIGHT_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RD_CTRL_TRGT_WEIGHT_MASK    ((uint32_t)0x000001C0)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RD_CTRL_TRGT_WEIGHT_LSB    6
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RD_CTRL_TRGT_WEIGHT_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_WR_CTRL_TRGT_WEIGHT_MASK    ((uint32_t)0x00000038)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_WR_CTRL_TRGT_WEIGHT_LSB    3
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_WR_CTRL_TRGT_WEIGHT_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RTRGT_1_WEIGHT_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RTRGT_1_WEIGHT_LSB    0
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RTRGT_1_WEIGHT_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RSVDP_17_RST    0x0
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_VERSION_RST    0x0
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RDBUFF_TRGT_WEIGHT_RST    0x3
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RD_CTRL_TRGT_WEIGHT_RST    0x2
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_WR_CTRL_TRGT_WEIGHT_RST    0x1
#define PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_RTRGT_1_WEIGHT_RST    0x0

__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_pack(uint16_t rsvdp_17, uint8_t version, uint8_t rdbuff_trgt_weight, uint8_t rd_ctrl_trgt_weight, uint8_t wr_ctrl_trgt_weight, uint8_t rtrgt1_weight)
{
	ASSERT_ERR((((uint32_t)rsvdp_17 << 17) & ~((uint32_t)0xFFFE0000)) == 0);
	ASSERT_ERR((((uint32_t)version << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)rdbuff_trgt_weight << 9) & ~((uint32_t)0x00000E00)) == 0);
	ASSERT_ERR((((uint32_t)rd_ctrl_trgt_weight << 6) & ~((uint32_t)0x000001C0)) == 0);
	ASSERT_ERR((((uint32_t)wr_ctrl_trgt_weight << 3) & ~((uint32_t)0x00000038)) == 0);
	ASSERT_ERR((((uint32_t)rtrgt1_weight << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR,  ((uint32_t)rsvdp_17 << 17) |((uint32_t)version << 12) |((uint32_t)rdbuff_trgt_weight << 9) |((uint32_t)rd_ctrl_trgt_weight << 6) |((uint32_t)wr_ctrl_trgt_weight << 3) |((uint32_t)rtrgt1_weight << 0));
}

__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_unpack(uint16_t* rsvdp_17, uint8_t* version, uint8_t* rdbuff_trgt_weight, uint8_t* rd_ctrl_trgt_weight, uint8_t* wr_ctrl_trgt_weight, uint8_t* rtrgt1_weight)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);

	*rsvdp_17 = (localVal & ((uint32_t)0xFFFE0000)) >>  17;
	*version = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*rdbuff_trgt_weight = (localVal & ((uint32_t)0x00000E00)) >>  9;
	*rd_ctrl_trgt_weight = (localVal & ((uint32_t)0x000001C0)) >>  6;
	*wr_ctrl_trgt_weight = (localVal & ((uint32_t)0x00000038)) >>  3;
	*rtrgt1_weight = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_ctrl_data_arb_prior_off_rsvdp_17_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFE0000)) >> 17);
}
__INLINE uint8_t pcie_ep_dma_ctrl_data_arb_prior_off_version_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE uint8_t pcie_ep_dma_ctrl_data_arb_prior_off_rdbuff_trgt_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000E00)) >> 9);
}
__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_rdbuff_trgt_weight_setf(uint8_t rdbufftrgtweight)
{
	ASSERT_ERR((((uint32_t)rdbufftrgtweight << 9) & ~((uint32_t)0x00000E00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR) & ~((uint32_t)0x00000E00)) | ((uint32_t)rdbufftrgtweight <<9));
}
__INLINE uint8_t pcie_ep_dma_ctrl_data_arb_prior_off_rd_ctrl_trgt_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000001C0)) >> 6);
}
__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_rd_ctrl_trgt_weight_setf(uint8_t rdctrltrgtweight)
{
	ASSERT_ERR((((uint32_t)rdctrltrgtweight << 6) & ~((uint32_t)0x000001C0)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR) & ~((uint32_t)0x000001C0)) | ((uint32_t)rdctrltrgtweight <<6));
}
__INLINE uint8_t pcie_ep_dma_ctrl_data_arb_prior_off_wr_ctrl_trgt_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000038)) >> 3);
}
__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_wr_ctrl_trgt_weight_setf(uint8_t wrctrltrgtweight)
{
	ASSERT_ERR((((uint32_t)wrctrltrgtweight << 3) & ~((uint32_t)0x00000038)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR) & ~((uint32_t)0x00000038)) | ((uint32_t)wrctrltrgtweight <<3));
}
__INLINE uint8_t pcie_ep_dma_ctrl_data_arb_prior_off_rtrgt_1_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE void pcie_ep_dma_ctrl_data_arb_prior_off_rtrgt_1_weight_setf(uint8_t rtrgt1weight)
{
	ASSERT_ERR((((uint32_t)rtrgt1weight << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_DATA_ARB_PRIOR_OFF_ADDR) & ~((uint32_t)0x00000007)) | ((uint32_t)rtrgt1weight <<0));
}

/**
 * @brief DMA_CTRL_OFF register definition
 *  This register provides information regarding the number of configured DMA read and write channels.  Note: When this register does not exist, value is fixed to 32 hFFFF_FFFF. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:26 RSVDP_26                  0x0
 *    25    DIS_C2_W_CACHE_RD         0              
 *    24    DIS_C2_W_CACHE_WR         0              
 *    23:20 RSVDP_20                  0x0
 *    19:16 NUM_DMA_RD_CHAN           0x8
 *    15:04 RSVDP_4                   0x0
 *    03:00 NUM_DMA_WR_CHAN           0x8
 * </pre>
 */
#define PCIE_EP_DMA_CTRL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C008)
#define PCIE_EP_DMA_CTRL_OFF_OFFSET      0x0000C008
#define PCIE_EP_DMA_CTRL_OFF_INDEX       0x00003002
#define PCIE_EP_DMA_CTRL_OFF_RESET       0x00080008

__INLINE uint32_t  pcie_ep_dma_ctrl_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
}

__INLINE void pcie_ep_dma_ctrl_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CTRL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_26_MASK    ((uint32_t)0xFC000000)
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_26_LSB    26
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_26_WIDTH    ((uint32_t)0x00000006)
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_RD_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_RD_POS    25
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_WR_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_WR_POS    24
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_20_MASK    ((uint32_t)0x00F00000)
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_20_LSB    20
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_20_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_RD_CHAN_MASK    ((uint32_t)0x000F0000)
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_RD_CHAN_LSB    16
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_RD_CHAN_WIDTH    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_4_MASK    ((uint32_t)0x0000FFF0)
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_4_LSB    4
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_4_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_WR_CHAN_MASK    ((uint32_t)0x0000000F)
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_WR_CHAN_LSB    0
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_WR_CHAN_WIDTH    ((uint32_t)0x00000004)

#define PCIE_EP_DMA_CTRL_OFF_RSVDP_26_RST    0x0
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_RD_RST    0x0
#define PCIE_EP_DMA_CTRL_OFF_DIS_C_2_W_CACHE_WR_RST    0x0
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_20_RST    0x0
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_RD_CHAN_RST    0x8
#define PCIE_EP_DMA_CTRL_OFF_RSVDP_4_RST    0x0
#define PCIE_EP_DMA_CTRL_OFF_NUM_DMA_WR_CHAN_RST    0x8

__INLINE void pcie_ep_dma_ctrl_off_pack(uint8_t rsvdp_26, uint8_t dis_c2_w_cache_rd, uint8_t dis_c2_w_cache_wr, uint8_t rsvdp_20, uint8_t num_dma_rd_chan, uint16_t rsvdp_4, uint8_t num_dma_wr_chan)
{
	ASSERT_ERR((((uint32_t)rsvdp_26 << 26) & ~((uint32_t)0xFC000000)) == 0);
	ASSERT_ERR((((uint32_t)dis_c2_w_cache_rd << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dis_c2_w_cache_wr << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0x00F00000)) == 0);
	ASSERT_ERR((((uint32_t)num_dma_rd_chan << 16) & ~((uint32_t)0x000F0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_4 << 4) & ~((uint32_t)0x0000FFF0)) == 0);
	ASSERT_ERR((((uint32_t)num_dma_wr_chan << 0) & ~((uint32_t)0x0000000F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_OFF_ADDR,  ((uint32_t)rsvdp_26 << 26) |((uint32_t)dis_c2_w_cache_rd << 25) |((uint32_t)dis_c2_w_cache_wr << 24) |((uint32_t)rsvdp_20 << 20) |((uint32_t)num_dma_rd_chan << 16) |((uint32_t)rsvdp_4 << 4) |((uint32_t)num_dma_wr_chan << 0));
}

__INLINE void pcie_ep_dma_ctrl_off_unpack(uint8_t* rsvdp_26, uint8_t* dis_c2_w_cache_rd, uint8_t* dis_c2_w_cache_wr, uint8_t* rsvdp_20, uint8_t* num_dma_rd_chan, uint16_t* rsvdp_4, uint8_t* num_dma_wr_chan)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);

	*rsvdp_26 = (localVal & ((uint32_t)0xFC000000)) >>  26;
	*dis_c2_w_cache_rd = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dis_c2_w_cache_wr = (localVal & ((uint32_t)0x01000000)) >>  24;
	*rsvdp_20 = (localVal & ((uint32_t)0x00F00000)) >>  20;
	*num_dma_rd_chan = (localVal & ((uint32_t)0x000F0000)) >>  16;
	*rsvdp_4 = (localVal & ((uint32_t)0x0000FFF0)) >>  4;
	*num_dma_wr_chan = (localVal & ((uint32_t)0x0000000F)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ctrl_off_rsvdp_26_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFC000000)) >> 26);
}
__INLINE uint8_t pcie_ep_dma_ctrl_off_dis_c_2_w_cache_rd_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ctrl_off_dis_c_2_w_cache_rd_setf(uint8_t disc2wcacherd)
{
	ASSERT_ERR((((uint32_t)disc2wcacherd << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)disc2wcacherd <<25));
}
__INLINE uint8_t pcie_ep_dma_ctrl_off_dis_c_2_w_cache_wr_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ctrl_off_dis_c_2_w_cache_wr_setf(uint8_t disc2wcachewr)
{
	ASSERT_ERR((((uint32_t)disc2wcachewr << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CTRL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)disc2wcachewr <<24));
}
__INLINE uint8_t pcie_ep_dma_ctrl_off_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00F00000)) >> 20);
}
__INLINE uint8_t pcie_ep_dma_ctrl_off_num_dma_rd_chan_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F0000)) >> 16);
}
__INLINE uint16_t pcie_ep_dma_ctrl_off_rsvdp_4_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFF0)) >> 4);
}
__INLINE uint8_t pcie_ep_dma_ctrl_off_num_dma_wr_chan_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CTRL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000000F)) >> 0);
}

/**
 * @brief DMA_WRITE_ENGINE_EN_OFF register definition
 *  This register indicates the status of DMA write engine and the status of DMA write engine handshake feature (per-channel). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    15:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_ENGINE          0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C00C)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_OFFSET      0x0000C00C
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_INDEX       0x00003003
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_engine_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_engine_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_1_MASK    ((uint32_t)0x0000FFFE)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000000F)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_DMA_WRITE_ENGINE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_DMA_WRITE_ENGINE_POS    0

#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_DMA_WRITE_ENGINE_RST    0x0

__INLINE void pcie_ep_dma_write_engine_en_off_pack(uint8_t rsvdp_24, uint16_t rsvdp_1, uint8_t dma_write_engine)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x0000FFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_engine << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_engine << 0));
}

__INLINE void pcie_ep_dma_write_engine_en_off_unpack(uint8_t* rsvdp_24, uint16_t* rsvdp_1, uint8_t* dma_write_engine)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_1 = (localVal & ((uint32_t)0x0000FFFE)) >>  1;
	*dma_write_engine = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_engine_en_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint16_t pcie_ep_dma_write_engine_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_engine_en_off_dma_write_engine_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_engine_en_off_dma_write_engine_setf(uint8_t dmawriteengine)
{
	ASSERT_ERR((((uint32_t)dmawriteengine << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_ENGINE_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawriteengine <<0));
}

/**
 * @brief DMA_WRITE_DOORBELL_OFF register definition
 *  This register controls the DMA write channel doorbell. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    WR_STOP                   0              
 *    30:03 RSVDP_3                   0x0
 *    02:00 WR_DOORBELL_NUM           0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C010)
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_OFFSET      0x0000C010
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_INDEX       0x00003004
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_doorbell_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_doorbell_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_STOP_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_STOP_POS    31
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_RSVDP_3_MASK    ((uint32_t)0x7FFFFFF8)
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_RSVDP_3_LSB    3
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_RSVDP_3_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_DOORBELL_NUM_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_DOORBELL_NUM_LSB    0
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_DOORBELL_NUM_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_STOP_RST    0x0
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_RSVDP_3_RST    0x0
#define PCIE_EP_DMA_WRITE_DOORBELL_OFF_WR_DOORBELL_NUM_RST    0x0

__INLINE void pcie_ep_dma_write_doorbell_off_pack(uint8_t wr_stop, uint32_t rsvdp_3, uint8_t wr_doorbell_num)
{
	ASSERT_ERR((((uint32_t)wr_stop << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_3 << 3) & ~((uint32_t)0x7FFFFFF8)) == 0);
	ASSERT_ERR((((uint32_t)wr_doorbell_num << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR,  ((uint32_t)wr_stop << 31) |((uint32_t)rsvdp_3 << 3) |((uint32_t)wr_doorbell_num << 0));
}

__INLINE void pcie_ep_dma_write_doorbell_off_unpack(uint8_t* wr_stop, uint32_t* rsvdp_3, uint8_t* wr_doorbell_num)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR);

	*wr_stop = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_3 = (localVal & ((uint32_t)0x7FFFFFF8)) >>  3;
	*wr_doorbell_num = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_doorbell_off_wr_stop_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_dma_write_doorbell_off_wr_stop_setf(uint8_t wrstop)
{
	ASSERT_ERR((((uint32_t)wrstop << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)wrstop <<31));
}
__INLINE uint32_t pcie_ep_dma_write_doorbell_off_rsvdp_3_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x7FFFFFF8)) >> 3);
}
__INLINE uint8_t pcie_ep_dma_write_doorbell_off_wr_doorbell_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE void pcie_ep_dma_write_doorbell_off_wr_doorbell_num_setf(uint8_t wrdoorbellnum)
{
	ASSERT_ERR((((uint32_t)wrdoorbellnum << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_DOORBELL_OFF_ADDR) & ~((uint32_t)0x00000007)) | ((uint32_t)wrdoorbellnum <<0));
}

/**
 * @brief DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF register definition
 *  The 5-bit channel weight (for write channels 0-3) specifies the maximum number of TLP requests that the DMA can issue for that channel before it must return to the arbitration routine. When the channel weight count is reached or DMA channel request transfer size reaches zero, the WWR arbiter selects the next channel to be processed. Your software must initialize this register before ringing the doorbell. For more information, see  Multichannel Arbitration .  Value range is (0-0x1F) corresponding to (1-32) transaction requests. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_20                  0x0
 *    19:15 WRITE_CHANNEL3_WEIGHT     0x1
 *    14:10 WRITE_CHANNEL2_WEIGHT     0x1
 *    09:05 WRITE_CHANNEL1_WEIGHT     0x1
 *    04:00 WRITE_CHANNEL0_WEIGHT     0x1
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C018)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_OFFSET      0x0000C018
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_INDEX       0x00003006
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_RESET       0x00008421

__INLINE uint32_t  pcie_ep_dma_write_channel_arb_weight_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_LSB    20
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_3_WEIGHT_MASK    ((uint32_t)0x000F8000)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_3_WEIGHT_LSB    15
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_3_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_2_WEIGHT_MASK    ((uint32_t)0x00007C00)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_2_WEIGHT_LSB    10
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_2_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_1_WEIGHT_MASK    ((uint32_t)0x000003E0)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_1_WEIGHT_LSB    5
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_1_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_0_WEIGHT_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_0_WEIGHT_LSB    0
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_0_WEIGHT_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_RST    0x0
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_3_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_2_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_1_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_WRITE_CHANNEL_0_WEIGHT_RST    0x1

__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_pack(uint16_t rsvdp_20, uint8_t write_channel3_weight, uint8_t write_channel2_weight, uint8_t write_channel1_weight, uint8_t write_channel0_weight)
{
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)write_channel3_weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	ASSERT_ERR((((uint32_t)write_channel2_weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	ASSERT_ERR((((uint32_t)write_channel1_weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	ASSERT_ERR((((uint32_t)write_channel0_weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR,  ((uint32_t)rsvdp_20 << 20) |((uint32_t)write_channel3_weight << 15) |((uint32_t)write_channel2_weight << 10) |((uint32_t)write_channel1_weight << 5) |((uint32_t)write_channel0_weight << 0));
}

__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_unpack(uint16_t* rsvdp_20, uint8_t* write_channel3_weight, uint8_t* write_channel2_weight, uint8_t* write_channel1_weight, uint8_t* write_channel0_weight)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);

	*rsvdp_20 = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*write_channel3_weight = (localVal & ((uint32_t)0x000F8000)) >>  15;
	*write_channel2_weight = (localVal & ((uint32_t)0x00007C00)) >>  10;
	*write_channel1_weight = (localVal & ((uint32_t)0x000003E0)) >>  5;
	*write_channel0_weight = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_channel_arb_weight_low_off_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_3_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F8000)) >> 15);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_3_weight_setf(uint8_t writechannel3weight)
{
	ASSERT_ERR((((uint32_t)writechannel3weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x000F8000)) | ((uint32_t)writechannel3weight <<15));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_2_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007C00)) >> 10);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_2_weight_setf(uint8_t writechannel2weight)
{
	ASSERT_ERR((((uint32_t)writechannel2weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x00007C00)) | ((uint32_t)writechannel2weight <<10));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_1_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003E0)) >> 5);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_1_weight_setf(uint8_t writechannel1weight)
{
	ASSERT_ERR((((uint32_t)writechannel1weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x000003E0)) | ((uint32_t)writechannel1weight <<5));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_0_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_low_off_write_channel_0_weight_setf(uint8_t writechannel0weight)
{
	ASSERT_ERR((((uint32_t)writechannel0weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)writechannel0weight <<0));
}

/**
 * @brief DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF register definition
 *  The 5-bit channel weight (for write channels 4-7) specifies the maximum number of TLP requests that the DMA can issue for that channel before it must return to the arbitration routine. When the channel weight count is reached or DMA channel request transfer size reaches zero, the WWR arbiter selects the next channel to be processed. Your software must initialize this register before ringing the doorbell. For more information, see  Multichannel Arbitration .  Value range is (0-0x1F) corresponding to (1-32) transaction requests. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_20                  0x0
 *    19:15 WRITE_CHANNEL7_WEIGHT     0x1
 *    14:10 WRITE_CHANNEL6_WEIGHT     0x1
 *    09:05 WRITE_CHANNEL5_WEIGHT     0x1
 *    04:00 WRITE_CHANNEL4_WEIGHT     0x1
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C01C)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_OFFSET      0x0000C01C
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_INDEX       0x00003007
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_RESET       0x00008421

__INLINE uint32_t  pcie_ep_dma_write_channel_arb_weight_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_LSB    20
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_7_WEIGHT_MASK    ((uint32_t)0x000F8000)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_7_WEIGHT_LSB    15
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_7_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_6_WEIGHT_MASK    ((uint32_t)0x00007C00)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_6_WEIGHT_LSB    10
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_6_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_5_WEIGHT_MASK    ((uint32_t)0x000003E0)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_5_WEIGHT_LSB    5
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_5_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_4_WEIGHT_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_4_WEIGHT_LSB    0
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_4_WEIGHT_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_RST    0x0
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_7_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_6_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_5_WEIGHT_RST    0x1
#define PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_WRITE_CHANNEL_4_WEIGHT_RST    0x1

__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_pack(uint16_t rsvdp_20, uint8_t write_channel7_weight, uint8_t write_channel6_weight, uint8_t write_channel5_weight, uint8_t write_channel4_weight)
{
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)write_channel7_weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	ASSERT_ERR((((uint32_t)write_channel6_weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	ASSERT_ERR((((uint32_t)write_channel5_weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	ASSERT_ERR((((uint32_t)write_channel4_weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR,  ((uint32_t)rsvdp_20 << 20) |((uint32_t)write_channel7_weight << 15) |((uint32_t)write_channel6_weight << 10) |((uint32_t)write_channel5_weight << 5) |((uint32_t)write_channel4_weight << 0));
}

__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_unpack(uint16_t* rsvdp_20, uint8_t* write_channel7_weight, uint8_t* write_channel6_weight, uint8_t* write_channel5_weight, uint8_t* write_channel4_weight)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);

	*rsvdp_20 = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*write_channel7_weight = (localVal & ((uint32_t)0x000F8000)) >>  15;
	*write_channel6_weight = (localVal & ((uint32_t)0x00007C00)) >>  10;
	*write_channel5_weight = (localVal & ((uint32_t)0x000003E0)) >>  5;
	*write_channel4_weight = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_channel_arb_weight_high_off_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_7_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F8000)) >> 15);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_7_weight_setf(uint8_t writechannel7weight)
{
	ASSERT_ERR((((uint32_t)writechannel7weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x000F8000)) | ((uint32_t)writechannel7weight <<15));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_6_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007C00)) >> 10);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_6_weight_setf(uint8_t writechannel6weight)
{
	ASSERT_ERR((((uint32_t)writechannel6weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x00007C00)) | ((uint32_t)writechannel6weight <<10));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_5_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003E0)) >> 5);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_5_weight_setf(uint8_t writechannel5weight)
{
	ASSERT_ERR((((uint32_t)writechannel5weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x000003E0)) | ((uint32_t)writechannel5weight <<5));
}
__INLINE uint8_t pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_4_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_dma_write_channel_arb_weight_high_off_write_channel_4_weight_setf(uint8_t writechannel4weight)
{
	ASSERT_ERR((((uint32_t)writechannel4weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)writechannel4weight <<0));
}

/**
 * @brief DMA_READ_ENGINE_EN_OFF register definition
 *  This register indicates the status of DMA read engine and the status of DMA read engine handshake feature (per-channel). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    15:01 RSVDP_1                   0x0
 *    00    DMA_READ_ENGINE           0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C02C)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_OFFSET      0x0000C02C
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_INDEX       0x0000300B
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_engine_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_engine_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_1_MASK    ((uint32_t)0x0000FFFE)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000000F)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_DMA_READ_ENGINE_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_DMA_READ_ENGINE_POS    0

#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_ENGINE_EN_OFF_DMA_READ_ENGINE_RST    0x0

__INLINE void pcie_ep_dma_read_engine_en_off_pack(uint8_t rsvdp_24, uint16_t rsvdp_1, uint8_t dma_read_engine)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0x0000FFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_engine << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_engine << 0));
}

__INLINE void pcie_ep_dma_read_engine_en_off_unpack(uint8_t* rsvdp_24, uint16_t* rsvdp_1, uint8_t* dma_read_engine)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rsvdp_1 = (localVal & ((uint32_t)0x0000FFFE)) >>  1;
	*dma_read_engine = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_engine_en_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint16_t pcie_ep_dma_read_engine_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_engine_en_off_dma_read_engine_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_engine_en_off_dma_read_engine_setf(uint8_t dmareadengine)
{
	ASSERT_ERR((((uint32_t)dmareadengine << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_ENGINE_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadengine <<0));
}

/**
 * @brief DMA_READ_DOORBELL_OFF register definition
 *  This register controls the DMA read channel doorbell. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RD_STOP                   0              
 *    30:03 RSVDP_3                   0x0
 *    02:00 RD_DOORBELL_NUM           0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C030)
#define PCIE_EP_DMA_READ_DOORBELL_OFF_OFFSET      0x0000C030
#define PCIE_EP_DMA_READ_DOORBELL_OFF_INDEX       0x0000300C
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_doorbell_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_doorbell_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_STOP_BIT    ((uint32_t)0x80000000)
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_STOP_POS    31
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RSVDP_3_MASK    ((uint32_t)0x7FFFFFF8)
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RSVDP_3_LSB    3
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RSVDP_3_WIDTH    ((uint32_t)0x0000001C)
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_DOORBELL_NUM_MASK    ((uint32_t)0x00000007)
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_DOORBELL_NUM_LSB    0
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_DOORBELL_NUM_WIDTH    ((uint32_t)0x00000003)

#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_STOP_RST    0x0
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RSVDP_3_RST    0x0
#define PCIE_EP_DMA_READ_DOORBELL_OFF_RD_DOORBELL_NUM_RST    0x0

__INLINE void pcie_ep_dma_read_doorbell_off_pack(uint8_t rd_stop, uint32_t rsvdp_3, uint8_t rd_doorbell_num)
{
	ASSERT_ERR((((uint32_t)rd_stop << 31) & ~((uint32_t)0x80000000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_3 << 3) & ~((uint32_t)0x7FFFFFF8)) == 0);
	ASSERT_ERR((((uint32_t)rd_doorbell_num << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR,  ((uint32_t)rd_stop << 31) |((uint32_t)rsvdp_3 << 3) |((uint32_t)rd_doorbell_num << 0));
}

__INLINE void pcie_ep_dma_read_doorbell_off_unpack(uint8_t* rd_stop, uint32_t* rsvdp_3, uint8_t* rd_doorbell_num)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR);

	*rd_stop = (localVal & ((uint32_t)0x80000000)) >>  31;
	*rsvdp_3 = (localVal & ((uint32_t)0x7FFFFFF8)) >>  3;
	*rd_doorbell_num = (localVal & ((uint32_t)0x00000007)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_doorbell_off_rd_stop_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x80000000)) >> 31);
}
__INLINE void pcie_ep_dma_read_doorbell_off_rd_stop_setf(uint8_t rdstop)
{
	ASSERT_ERR((((uint32_t)rdstop << 31) & ~((uint32_t)0x80000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR) & ~((uint32_t)0x80000000)) | ((uint32_t)rdstop <<31));
}
__INLINE uint32_t pcie_ep_dma_read_doorbell_off_rsvdp_3_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0x7FFFFFF8)) >> 3);
}
__INLINE uint8_t pcie_ep_dma_read_doorbell_off_rd_doorbell_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000007)) >> 0);
}
__INLINE void pcie_ep_dma_read_doorbell_off_rd_doorbell_num_setf(uint8_t rddoorbellnum)
{
	ASSERT_ERR((((uint32_t)rddoorbellnum << 0) & ~((uint32_t)0x00000007)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_DOORBELL_OFF_ADDR) & ~((uint32_t)0x00000007)) | ((uint32_t)rddoorbellnum <<0));
}

/**
 * @brief DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF register definition
 *  The 5-bit channel weight (for read channels 0-3) specifies the maximum number of TLP requests that the DMA can issue for that channel before it must return to the arbitration routine. When the channel weight count is reached or DMA channel request transfer size reaches zero, the WWR arbiter selects the next channel to be processed. Your software must initialize this register before ringing the doorbell. For more information, see  Multichannel Arbitration . Value range is (0-0x1F) corresponding to (1-32) transaction requests. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_20                  0x0
 *    19:15 READ_CHANNEL3_WEIGHT      0x1
 *    14:10 READ_CHANNEL2_WEIGHT      0x1
 *    09:05 READ_CHANNEL1_WEIGHT      0x1
 *    04:00 READ_CHANNEL0_WEIGHT      0x1
 * </pre>
 */
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C038)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_OFFSET      0x0000C038
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_INDEX       0x0000300E
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_RESET       0x00008421

__INLINE uint32_t  pcie_ep_dma_read_channel_arb_weight_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_LSB    20
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_3_WEIGHT_MASK    ((uint32_t)0x000F8000)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_3_WEIGHT_LSB    15
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_3_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_2_WEIGHT_MASK    ((uint32_t)0x00007C00)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_2_WEIGHT_LSB    10
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_2_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_1_WEIGHT_MASK    ((uint32_t)0x000003E0)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_1_WEIGHT_LSB    5
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_1_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_0_WEIGHT_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_0_WEIGHT_LSB    0
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_0_WEIGHT_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_RSVDP_20_RST    0x0
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_3_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_2_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_1_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_READ_CHANNEL_0_WEIGHT_RST    0x1

__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_pack(uint16_t rsvdp_20, uint8_t read_channel3_weight, uint8_t read_channel2_weight, uint8_t read_channel1_weight, uint8_t read_channel0_weight)
{
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)read_channel3_weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	ASSERT_ERR((((uint32_t)read_channel2_weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	ASSERT_ERR((((uint32_t)read_channel1_weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	ASSERT_ERR((((uint32_t)read_channel0_weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR,  ((uint32_t)rsvdp_20 << 20) |((uint32_t)read_channel3_weight << 15) |((uint32_t)read_channel2_weight << 10) |((uint32_t)read_channel1_weight << 5) |((uint32_t)read_channel0_weight << 0));
}

__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_unpack(uint16_t* rsvdp_20, uint8_t* read_channel3_weight, uint8_t* read_channel2_weight, uint8_t* read_channel1_weight, uint8_t* read_channel0_weight)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);

	*rsvdp_20 = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*read_channel3_weight = (localVal & ((uint32_t)0x000F8000)) >>  15;
	*read_channel2_weight = (localVal & ((uint32_t)0x00007C00)) >>  10;
	*read_channel1_weight = (localVal & ((uint32_t)0x000003E0)) >>  5;
	*read_channel0_weight = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_channel_arb_weight_low_off_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_3_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F8000)) >> 15);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_3_weight_setf(uint8_t readchannel3weight)
{
	ASSERT_ERR((((uint32_t)readchannel3weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x000F8000)) | ((uint32_t)readchannel3weight <<15));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_2_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007C00)) >> 10);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_2_weight_setf(uint8_t readchannel2weight)
{
	ASSERT_ERR((((uint32_t)readchannel2weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x00007C00)) | ((uint32_t)readchannel2weight <<10));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_1_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003E0)) >> 5);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_1_weight_setf(uint8_t readchannel1weight)
{
	ASSERT_ERR((((uint32_t)readchannel1weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x000003E0)) | ((uint32_t)readchannel1weight <<5));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_0_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_low_off_read_channel_0_weight_setf(uint8_t readchannel0weight)
{
	ASSERT_ERR((((uint32_t)readchannel0weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_LOW_OFF_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)readchannel0weight <<0));
}

/**
 * @brief DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF register definition
 *  The 5-bit channel weight (for read channels 4-7) specifies the maximum number of TLP requests that the DMA can issue for that channel before it must return to the arbitration routine. When the channel weight count is reached or DMA channel request transfer size reaches zero, the WWR arbiter selects the next channel to be processed. Your software must initialize this register before ringing the doorbell. For more information, see  Multichannel Arbitration . Value range is (0-0x1F) corresponding to (1-32) transaction requests. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RSVDP_20                  0x0
 *    19:15 READ_CHANNEL7_WEIGHT      0x1
 *    14:10 READ_CHANNEL6_WEIGHT      0x1
 *    09:05 READ_CHANNEL5_WEIGHT      0x1
 *    04:00 READ_CHANNEL4_WEIGHT      0x1
 * </pre>
 */
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C03C)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_OFFSET      0x0000C03C
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_INDEX       0x0000300F
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_RESET       0x00008421

__INLINE uint32_t  pcie_ep_dma_read_channel_arb_weight_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_MASK    ((uint32_t)0xFFF00000)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_LSB    20
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_WIDTH    ((uint32_t)0x0000000C)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_7_WEIGHT_MASK    ((uint32_t)0x000F8000)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_7_WEIGHT_LSB    15
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_7_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_6_WEIGHT_MASK    ((uint32_t)0x00007C00)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_6_WEIGHT_LSB    10
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_6_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_5_WEIGHT_MASK    ((uint32_t)0x000003E0)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_5_WEIGHT_LSB    5
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_5_WEIGHT_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_4_WEIGHT_MASK    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_4_WEIGHT_LSB    0
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_4_WEIGHT_WIDTH    ((uint32_t)0x00000005)

#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_RSVDP_20_RST    0x0
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_7_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_6_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_5_WEIGHT_RST    0x1
#define PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_READ_CHANNEL_4_WEIGHT_RST    0x1

__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_pack(uint16_t rsvdp_20, uint8_t read_channel7_weight, uint8_t read_channel6_weight, uint8_t read_channel5_weight, uint8_t read_channel4_weight)
{
	ASSERT_ERR((((uint32_t)rsvdp_20 << 20) & ~((uint32_t)0xFFF00000)) == 0);
	ASSERT_ERR((((uint32_t)read_channel7_weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	ASSERT_ERR((((uint32_t)read_channel6_weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	ASSERT_ERR((((uint32_t)read_channel5_weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	ASSERT_ERR((((uint32_t)read_channel4_weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR,  ((uint32_t)rsvdp_20 << 20) |((uint32_t)read_channel7_weight << 15) |((uint32_t)read_channel6_weight << 10) |((uint32_t)read_channel5_weight << 5) |((uint32_t)read_channel4_weight << 0));
}

__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_unpack(uint16_t* rsvdp_20, uint8_t* read_channel7_weight, uint8_t* read_channel6_weight, uint8_t* read_channel5_weight, uint8_t* read_channel4_weight)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);

	*rsvdp_20 = (localVal & ((uint32_t)0xFFF00000)) >>  20;
	*read_channel7_weight = (localVal & ((uint32_t)0x000F8000)) >>  15;
	*read_channel6_weight = (localVal & ((uint32_t)0x00007C00)) >>  10;
	*read_channel5_weight = (localVal & ((uint32_t)0x000003E0)) >>  5;
	*read_channel4_weight = (localVal & ((uint32_t)0x0000001F)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_channel_arb_weight_high_off_rsvdp_20_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFF00000)) >> 20);
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_7_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000F8000)) >> 15);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_7_weight_setf(uint8_t readchannel7weight)
{
	ASSERT_ERR((((uint32_t)readchannel7weight << 15) & ~((uint32_t)0x000F8000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x000F8000)) | ((uint32_t)readchannel7weight <<15));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_6_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00007C00)) >> 10);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_6_weight_setf(uint8_t readchannel6weight)
{
	ASSERT_ERR((((uint32_t)readchannel6weight << 10) & ~((uint32_t)0x00007C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x00007C00)) | ((uint32_t)readchannel6weight <<10));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_5_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000003E0)) >> 5);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_5_weight_setf(uint8_t readchannel5weight)
{
	ASSERT_ERR((((uint32_t)readchannel5weight << 5) & ~((uint32_t)0x000003E0)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x000003E0)) | ((uint32_t)readchannel5weight <<5));
}
__INLINE uint8_t pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_4_weight_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000001F)) >> 0);
}
__INLINE void pcie_ep_dma_read_channel_arb_weight_high_off_read_channel_4_weight_setf(uint8_t readchannel4weight)
{
	ASSERT_ERR((((uint32_t)readchannel4weight << 0) & ~((uint32_t)0x0000001F)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CHANNEL_ARB_WEIGHT_HIGH_OFF_ADDR) & ~((uint32_t)0x0000001F)) | ((uint32_t)readchannel4weight <<0));
}

/**
 * @brief DMA_WRITE_INT_STATUS_OFF register definition
 *  This register indicates the status of Abort and Done interrupts for the DMA write channels. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 WR_ABORT_INT_STATUS       0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 WR_DONE_INT_STATUS        0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C04C)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_OFFSET      0x0000C04C
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_INDEX       0x00003013
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_int_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_int_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_ABORT_INT_STATUS_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_ABORT_INT_STATUS_LSB    16
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_ABORT_INT_STATUS_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_DONE_INT_STATUS_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_DONE_INT_STATUS_LSB    0
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_DONE_INT_STATUS_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_ABORT_INT_STATUS_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_STATUS_OFF_WR_DONE_INT_STATUS_RST    0x0

__INLINE void pcie_ep_dma_write_int_status_off_pack(uint8_t rsvdp_24, uint8_t wr_abort_int_status, uint8_t rsvdp_8, uint8_t wr_done_int_status)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)wr_abort_int_status << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)wr_done_int_status << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)wr_abort_int_status << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)wr_done_int_status << 0));
}

__INLINE void pcie_ep_dma_write_int_status_off_unpack(uint8_t* rsvdp_24, uint8_t* wr_abort_int_status, uint8_t* rsvdp_8, uint8_t* wr_done_int_status)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wr_abort_int_status = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wr_done_int_status = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_int_status_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_write_int_status_off_wr_abort_int_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_int_status_off_wr_abort_int_status_setf(uint8_t wrabortintstatus)
{
	ASSERT_ERR((((uint32_t)wrabortintstatus << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)wrabortintstatus <<16));
}
__INLINE uint8_t pcie_ep_dma_write_int_status_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_write_int_status_off_wr_done_int_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_write_int_status_off_wr_done_int_status_setf(uint8_t wrdoneintstatus)
{
	ASSERT_ERR((((uint32_t)wrdoneintstatus << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_STATUS_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)wrdoneintstatus <<0));
}

/**
 * @brief DMA_WRITE_INT_MASK_OFF register definition
 *  This register holds the Abort and Done DMA write interrupt mask. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 WR_ABORT_INT_MASK         0xff
 *    15:08 RSVDP_8                   0x0
 *    07:00 WR_DONE_INT_MASK          0xff
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C054)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_OFFSET      0x0000C054
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_INDEX       0x00003015
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RESET       0x00FF00FF

__INLINE uint32_t  pcie_ep_dma_write_int_mask_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_int_mask_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_ABORT_INT_MASK_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_ABORT_INT_MASK_LSB    16
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_ABORT_INT_MASK_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_DONE_INT_MASK_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_DONE_INT_MASK_LSB    0
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_DONE_INT_MASK_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_ABORT_INT_MASK_RST    0xff
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_MASK_OFF_WR_DONE_INT_MASK_RST    0xff

__INLINE void pcie_ep_dma_write_int_mask_off_pack(uint8_t rsvdp_24, uint8_t wr_abort_int_mask, uint8_t rsvdp_8, uint8_t wr_done_int_mask)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)wr_abort_int_mask << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)wr_done_int_mask << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)wr_abort_int_mask << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)wr_done_int_mask << 0));
}

__INLINE void pcie_ep_dma_write_int_mask_off_unpack(uint8_t* rsvdp_24, uint8_t* wr_abort_int_mask, uint8_t* rsvdp_8, uint8_t* wr_done_int_mask)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wr_abort_int_mask = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wr_done_int_mask = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_int_mask_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_write_int_mask_off_wr_abort_int_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_int_mask_off_wr_abort_int_mask_setf(uint8_t wrabortintmask)
{
	ASSERT_ERR((((uint32_t)wrabortintmask << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)wrabortintmask <<16));
}
__INLINE uint8_t pcie_ep_dma_write_int_mask_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_write_int_mask_off_wr_done_int_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_write_int_mask_off_wr_done_int_mask_setf(uint8_t wrdoneintmask)
{
	ASSERT_ERR((((uint32_t)wrdoneintmask << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_MASK_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)wrdoneintmask <<0));
}

/**
 * @brief DMA_WRITE_INT_CLEAR_OFF register definition
 *  You can write to this register to clear the Abort and Done write interrupts. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 WR_ABORT_INT_CLEAR        0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 WR_DONE_INT_CLEAR         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C058)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_OFFSET      0x0000C058
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_INDEX       0x00003016
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_int_clear_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_int_clear_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_ABORT_INT_CLEAR_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_ABORT_INT_CLEAR_LSB    16
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_ABORT_INT_CLEAR_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_DONE_INT_CLEAR_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_DONE_INT_CLEAR_LSB    0
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_DONE_INT_CLEAR_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_ABORT_INT_CLEAR_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_WR_DONE_INT_CLEAR_RST    0x0

__INLINE void pcie_ep_dma_write_int_clear_off_pack(uint8_t rsvdp_24, uint8_t wr_abort_int_clear, uint8_t rsvdp_8, uint8_t wr_done_int_clear)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)wr_abort_int_clear << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)wr_done_int_clear << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)wr_abort_int_clear << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)wr_done_int_clear << 0));
}

__INLINE void pcie_ep_dma_write_int_clear_off_unpack(uint8_t* rsvdp_24, uint8_t* wr_abort_int_clear, uint8_t* rsvdp_8, uint8_t* wr_done_int_clear)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wr_abort_int_clear = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wr_done_int_clear = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_int_clear_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE void pcie_ep_dma_write_int_clear_off_wr_abort_int_clear_setf(uint8_t wrabortintclear)
{
	ASSERT_ERR((((uint32_t)wrabortintclear << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)wrabortintclear <<16));
}
__INLINE uint8_t pcie_ep_dma_write_int_clear_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_dma_write_int_clear_off_wr_done_int_clear_setf(uint8_t wrdoneintclear)
{
	ASSERT_ERR((((uint32_t)wrdoneintclear << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_INT_CLEAR_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)wrdoneintclear <<0));
}

/**
 * @brief DMA_WRITE_ERR_STATUS_OFF register definition
 *  This register provides information pertaining to errors incurred during write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 LINKLIST_ELEMENT_FETCH_ERR_DETECT 0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 APP_READ_ERR_DETECT       0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C05C)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_OFFSET      0x0000C05C
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_INDEX       0x00003017
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_err_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);
}

// field definitions
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_LINKLIST_ELEMENT_FETCH_ERR_DETECT_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_LINKLIST_ELEMENT_FETCH_ERR_DETECT_LSB    16
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_LINKLIST_ELEMENT_FETCH_ERR_DETECT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_APP_READ_ERR_DETECT_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_APP_READ_ERR_DETECT_LSB    0
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_APP_READ_ERR_DETECT_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_LINKLIST_ELEMENT_FETCH_ERR_DETECT_RST    0x0
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_APP_READ_ERR_DETECT_RST    0x0

__INLINE void pcie_ep_dma_write_err_status_off_unpack(uint8_t* rsvdp_24, uint8_t* linklist_element_fetch_err_detect, uint8_t* rsvdp_8, uint8_t* app_read_err_detect)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*linklist_element_fetch_err_detect = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*app_read_err_detect = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_err_status_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_write_err_status_off_linklist_element_fetch_err_detect_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_dma_write_err_status_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_write_err_status_off_app_read_err_detect_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ERR_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief DMA_WRITE_DONE_IMWR_LOW_OFF register definition
 *  This register holds the lower 32 bits of the Done IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_WRITE_DONE_LOW_REG    0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C060)
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_OFFSET      0x0000C060
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_INDEX       0x00003018
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_done_imwr_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_done_imwr_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_DMA_WRITE_DONE_LOW_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_DMA_WRITE_DONE_LOW_REG_LSB    0
#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_DMA_WRITE_DONE_LOW_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_DMA_WRITE_DONE_LOW_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_write_done_imwr_low_off_dma_write_done_low_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_write_done_imwr_low_off_dma_write_done_low_reg_setf(uint32_t dmawritedonelowreg)
{
	ASSERT_ERR((((uint32_t)dmawritedonelowreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_DONE_IMWR_LOW_OFF_ADDR, (uint32_t)dmawritedonelowreg << 0);
}

/**
 * @brief DMA_WRITE_DONE_IMWR_HIGH_OFF register definition
 *  This register holds the higher 32 bits of the Done IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_WRITE_DONE_HIGH_REG   0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C064)
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_OFFSET      0x0000C064
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_INDEX       0x00003019
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_done_imwr_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_done_imwr_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_DMA_WRITE_DONE_HIGH_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_DMA_WRITE_DONE_HIGH_REG_LSB    0
#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_DMA_WRITE_DONE_HIGH_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_DMA_WRITE_DONE_HIGH_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_write_done_imwr_high_off_dma_write_done_high_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_write_done_imwr_high_off_dma_write_done_high_reg_setf(uint32_t dmawritedonehighreg)
{
	ASSERT_ERR((((uint32_t)dmawritedonehighreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_DONE_IMWR_HIGH_OFF_ADDR, (uint32_t)dmawritedonehighreg << 0);
}

/**
 * @brief DMA_WRITE_ABORT_IMWR_LOW_OFF register definition
 *  This register holds the lower 32 bits of Abort IMWr TLP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_WRITE_ABORT_LOW_REG   0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C068)
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_OFFSET      0x0000C068
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_INDEX       0x0000301A
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_abort_imwr_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_abort_imwr_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_DMA_WRITE_ABORT_LOW_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_DMA_WRITE_ABORT_LOW_REG_LSB    0
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_DMA_WRITE_ABORT_LOW_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_DMA_WRITE_ABORT_LOW_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_write_abort_imwr_low_off_dma_write_abort_low_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_write_abort_imwr_low_off_dma_write_abort_low_reg_setf(uint32_t dmawriteabortlowreg)
{
	ASSERT_ERR((((uint32_t)dmawriteabortlowreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_ABORT_IMWR_LOW_OFF_ADDR, (uint32_t)dmawriteabortlowreg << 0);
}

/**
 * @brief DMA_WRITE_ABORT_IMWR_HIGH_OFF register definition
 *  This register holds the higher 32 bits of Abort IMWr TLP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_WRITE_ABORT_HIGH_REG  0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C06C)
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_OFFSET      0x0000C06C
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_INDEX       0x0000301B
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_abort_imwr_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_abort_imwr_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_DMA_WRITE_ABORT_HIGH_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_DMA_WRITE_ABORT_HIGH_REG_LSB    0
#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_DMA_WRITE_ABORT_HIGH_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_DMA_WRITE_ABORT_HIGH_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_write_abort_imwr_high_off_dma_write_abort_high_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_write_abort_imwr_high_off_dma_write_abort_high_reg_setf(uint32_t dmawriteaborthighreg)
{
	ASSERT_ERR((((uint32_t)dmawriteaborthighreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_ABORT_IMWR_HIGH_OFF_ADDR, (uint32_t)dmawriteaborthighreg << 0);
}

/**
 * @brief DMA_WRITE_CH_01_IMWR_DATA_OFF register definition
 *  This register holds the Channel 1 and 0 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 WR_CHANNEL_1_DATA         0x0
 *    15:00 WR_CHANNEL_0_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C070)
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_OFFSET      0x0000C070
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_INDEX       0x0000301C
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_01_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_01_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_1_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_1_DATA_LSB    16
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_1_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_0_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_0_DATA_LSB    0
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_0_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_1_DATA_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_WR_CHANNEL_0_DATA_RST    0x0

__INLINE void pcie_ep_dma_write_ch_01_imwr_data_off_pack(uint16_t wr_channel_1_data, uint16_t wr_channel_0_data)
{
	ASSERT_ERR((((uint32_t)wr_channel_1_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_0_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR,  ((uint32_t)wr_channel_1_data << 16) |((uint32_t)wr_channel_0_data << 0));
}

__INLINE void pcie_ep_dma_write_ch_01_imwr_data_off_unpack(uint16_t* wr_channel_1_data, uint16_t* wr_channel_0_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR);

	*wr_channel_1_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*wr_channel_0_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_ch_01_imwr_data_off_wr_channel_1_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_ch_01_imwr_data_off_wr_channel_1_data_setf(uint16_t wrchannel1data)
{
	ASSERT_ERR((((uint32_t)wrchannel1data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)wrchannel1data <<16));
}
__INLINE uint16_t pcie_ep_dma_write_ch_01_imwr_data_off_wr_channel_0_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_01_imwr_data_off_wr_channel_0_data_setf(uint16_t wrchannel0data)
{
	ASSERT_ERR((((uint32_t)wrchannel0data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_01_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)wrchannel0data <<0));
}

/**
 * @brief DMA_WRITE_CH_23_IMWR_DATA_OFF register definition
 *  This register holds the Channel 3 and 2 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 WR_CHANNEL_3_DATA         0x0
 *    15:00 WR_CHANNEL_2_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C074)
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_OFFSET      0x0000C074
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_INDEX       0x0000301D
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_23_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_23_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_3_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_3_DATA_LSB    16
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_3_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_2_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_2_DATA_LSB    0
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_2_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_3_DATA_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_WR_CHANNEL_2_DATA_RST    0x0

__INLINE void pcie_ep_dma_write_ch_23_imwr_data_off_pack(uint16_t wr_channel_3_data, uint16_t wr_channel_2_data)
{
	ASSERT_ERR((((uint32_t)wr_channel_3_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_2_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR,  ((uint32_t)wr_channel_3_data << 16) |((uint32_t)wr_channel_2_data << 0));
}

__INLINE void pcie_ep_dma_write_ch_23_imwr_data_off_unpack(uint16_t* wr_channel_3_data, uint16_t* wr_channel_2_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR);

	*wr_channel_3_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*wr_channel_2_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_ch_23_imwr_data_off_wr_channel_3_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_ch_23_imwr_data_off_wr_channel_3_data_setf(uint16_t wrchannel3data)
{
	ASSERT_ERR((((uint32_t)wrchannel3data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)wrchannel3data <<16));
}
__INLINE uint16_t pcie_ep_dma_write_ch_23_imwr_data_off_wr_channel_2_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_23_imwr_data_off_wr_channel_2_data_setf(uint16_t wrchannel2data)
{
	ASSERT_ERR((((uint32_t)wrchannel2data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_23_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)wrchannel2data <<0));
}

/**
 * @brief DMA_WRITE_CH_45_IMWR_DATA_OFF register definition
 *  This register holds the Channel 5 and 4 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 WR_CHANNEL_5_DATA         0x0
 *    15:00 WR_CHANNEL_4_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C078)
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_OFFSET      0x0000C078
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_INDEX       0x0000301E
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_45_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_45_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_5_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_5_DATA_LSB    16
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_5_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_4_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_4_DATA_LSB    0
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_4_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_5_DATA_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_WR_CHANNEL_4_DATA_RST    0x0

__INLINE void pcie_ep_dma_write_ch_45_imwr_data_off_pack(uint16_t wr_channel_5_data, uint16_t wr_channel_4_data)
{
	ASSERT_ERR((((uint32_t)wr_channel_5_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_4_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR,  ((uint32_t)wr_channel_5_data << 16) |((uint32_t)wr_channel_4_data << 0));
}

__INLINE void pcie_ep_dma_write_ch_45_imwr_data_off_unpack(uint16_t* wr_channel_5_data, uint16_t* wr_channel_4_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR);

	*wr_channel_5_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*wr_channel_4_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_ch_45_imwr_data_off_wr_channel_5_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_ch_45_imwr_data_off_wr_channel_5_data_setf(uint16_t wrchannel5data)
{
	ASSERT_ERR((((uint32_t)wrchannel5data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)wrchannel5data <<16));
}
__INLINE uint16_t pcie_ep_dma_write_ch_45_imwr_data_off_wr_channel_4_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_45_imwr_data_off_wr_channel_4_data_setf(uint16_t wrchannel4data)
{
	ASSERT_ERR((((uint32_t)wrchannel4data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_45_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)wrchannel4data <<0));
}

/**
 * @brief DMA_WRITE_CH_67_IMWR_DATA_OFF register definition
 *  This register holds the Channel 7 and 6 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 WR_CHANNEL_7_DATA         0x0
 *    15:00 WR_CHANNEL_6_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C07C)
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_OFFSET      0x0000C07C
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_INDEX       0x0000301F
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_67_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_67_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_7_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_7_DATA_LSB    16
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_7_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_6_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_6_DATA_LSB    0
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_6_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_7_DATA_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_WR_CHANNEL_6_DATA_RST    0x0

__INLINE void pcie_ep_dma_write_ch_67_imwr_data_off_pack(uint16_t wr_channel_7_data, uint16_t wr_channel_6_data)
{
	ASSERT_ERR((((uint32_t)wr_channel_7_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_6_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR,  ((uint32_t)wr_channel_7_data << 16) |((uint32_t)wr_channel_6_data << 0));
}

__INLINE void pcie_ep_dma_write_ch_67_imwr_data_off_unpack(uint16_t* wr_channel_7_data, uint16_t* wr_channel_6_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR);

	*wr_channel_7_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*wr_channel_6_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_write_ch_67_imwr_data_off_wr_channel_7_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_ch_67_imwr_data_off_wr_channel_7_data_setf(uint16_t wrchannel7data)
{
	ASSERT_ERR((((uint32_t)wrchannel7data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)wrchannel7data <<16));
}
__INLINE uint16_t pcie_ep_dma_write_ch_67_imwr_data_off_wr_channel_6_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_67_imwr_data_off_wr_channel_6_data_setf(uint16_t wrchannel6data)
{
	ASSERT_ERR((((uint32_t)wrchannel6data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_67_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)wrchannel6data <<0));
}

/**
 * @brief DMA_WRITE_LINKED_LIST_ERR_EN_OFF register definition
 *  The LIE and RIE bits in the LL element enable the channel  done  interrupts (local and remote). The LLLAIE and LLRAIE bits enable the channel  abort  interrupts (local and remote). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 WR_CHANNEL_LLLAIE         0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 WR_CHANNEL_LLRAIE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C090)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_OFFSET      0x0000C090
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_INDEX       0x00003024
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_linked_list_err_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_linked_list_err_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLLAIE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLLAIE_LSB    16
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLLAIE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLRAIE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLRAIE_LSB    0
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLRAIE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLLAIE_RST    0x0
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_WR_CHANNEL_LLRAIE_RST    0x0

__INLINE void pcie_ep_dma_write_linked_list_err_en_off_pack(uint8_t rsvdp_24, uint8_t wr_channel_lllaie, uint8_t rsvdp_8, uint8_t wr_channel_llraie)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_lllaie << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)wr_channel_llraie << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)wr_channel_lllaie << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)wr_channel_llraie << 0));
}

__INLINE void pcie_ep_dma_write_linked_list_err_en_off_unpack(uint8_t* rsvdp_24, uint8_t* wr_channel_lllaie, uint8_t* rsvdp_8, uint8_t* wr_channel_llraie)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*wr_channel_lllaie = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*wr_channel_llraie = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_write_linked_list_err_en_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_write_linked_list_err_en_off_wr_channel_lllaie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_write_linked_list_err_en_off_wr_channel_lllaie_setf(uint8_t wrchannellllaie)
{
	ASSERT_ERR((((uint32_t)wrchannellllaie << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)wrchannellllaie <<16));
}
__INLINE uint8_t pcie_ep_dma_write_linked_list_err_en_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_write_linked_list_err_en_off_wr_channel_llraie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_write_linked_list_err_en_off_wr_channel_llraie_setf(uint8_t wrchannelllraie)
{
	ASSERT_ERR((((uint32_t)wrchannelllraie << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_LINKED_LIST_ERR_EN_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)wrchannelllraie <<0));
}

/**
 * @brief DMA_READ_INT_STATUS_OFF register definition
 *  This register indicates the status of Abort and Done interrupts for the DMA read channels. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 RD_ABORT_INT_STATUS       0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 RD_DONE_INT_STATUS        0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0A0)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_OFFSET      0x0000C0A0
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_INDEX       0x00003028
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_int_status_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_int_status_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_ABORT_INT_STATUS_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_ABORT_INT_STATUS_LSB    16
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_ABORT_INT_STATUS_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_DONE_INT_STATUS_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_DONE_INT_STATUS_LSB    0
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_DONE_INT_STATUS_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_ABORT_INT_STATUS_RST    0x0
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_READ_INT_STATUS_OFF_RD_DONE_INT_STATUS_RST    0x0

__INLINE void pcie_ep_dma_read_int_status_off_pack(uint8_t rsvdp_24, uint8_t rd_abort_int_status, uint8_t rsvdp_8, uint8_t rd_done_int_status)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rd_abort_int_status << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)rd_done_int_status << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rd_abort_int_status << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)rd_done_int_status << 0));
}

__INLINE void pcie_ep_dma_read_int_status_off_unpack(uint8_t* rsvdp_24, uint8_t* rd_abort_int_status, uint8_t* rsvdp_8, uint8_t* rd_done_int_status)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rd_abort_int_status = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*rd_done_int_status = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_int_status_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_read_int_status_off_rd_abort_int_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_int_status_off_rd_abort_int_status_setf(uint8_t rdabortintstatus)
{
	ASSERT_ERR((((uint32_t)rdabortintstatus << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)rdabortintstatus <<16));
}
__INLINE uint8_t pcie_ep_dma_read_int_status_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_read_int_status_off_rd_done_int_status_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_read_int_status_off_rd_done_int_status_setf(uint8_t rddoneintstatus)
{
	ASSERT_ERR((((uint32_t)rddoneintstatus << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_STATUS_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)rddoneintstatus <<0));
}

/**
 * @brief DMA_READ_INT_MASK_OFF register definition
 *  This register holds the Abort and Done DMA read interrupt mask. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 RD_ABORT_INT_MASK         0xff
 *    15:08 RSVDP_8                   0x0
 *    07:00 RD_DONE_INT_MASK          0xff
 * </pre>
 */
#define PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0A8)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_OFFSET      0x0000C0A8
#define PCIE_EP_DMA_READ_INT_MASK_OFF_INDEX       0x0000302A
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RESET       0x00FF00FF

__INLINE uint32_t  pcie_ep_dma_read_int_mask_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_int_mask_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_ABORT_INT_MASK_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_ABORT_INT_MASK_LSB    16
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_ABORT_INT_MASK_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_DONE_INT_MASK_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_DONE_INT_MASK_LSB    0
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_DONE_INT_MASK_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_ABORT_INT_MASK_RST    0xff
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_READ_INT_MASK_OFF_RD_DONE_INT_MASK_RST    0xff

__INLINE void pcie_ep_dma_read_int_mask_off_pack(uint8_t rsvdp_24, uint8_t rd_abort_int_mask, uint8_t rsvdp_8, uint8_t rd_done_int_mask)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rd_abort_int_mask << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)rd_done_int_mask << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rd_abort_int_mask << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)rd_done_int_mask << 0));
}

__INLINE void pcie_ep_dma_read_int_mask_off_unpack(uint8_t* rsvdp_24, uint8_t* rd_abort_int_mask, uint8_t* rsvdp_8, uint8_t* rd_done_int_mask)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rd_abort_int_mask = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*rd_done_int_mask = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_int_mask_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_read_int_mask_off_rd_abort_int_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_int_mask_off_rd_abort_int_mask_setf(uint8_t rdabortintmask)
{
	ASSERT_ERR((((uint32_t)rdabortintmask << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)rdabortintmask <<16));
}
__INLINE uint8_t pcie_ep_dma_read_int_mask_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_read_int_mask_off_rd_done_int_mask_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_read_int_mask_off_rd_done_int_mask_setf(uint8_t rddoneintmask)
{
	ASSERT_ERR((((uint32_t)rddoneintmask << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_MASK_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)rddoneintmask <<0));
}

/**
 * @brief DMA_READ_INT_CLEAR_OFF register definition
 *  You can write to this register to clear the Abort and Done read interrupts. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 RD_ABORT_INT_CLEAR        0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 RD_DONE_INT_CLEAR         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0AC)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_OFFSET      0x0000C0AC
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_INDEX       0x0000302B
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_int_clear_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_int_clear_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_ABORT_INT_CLEAR_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_ABORT_INT_CLEAR_LSB    16
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_ABORT_INT_CLEAR_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_DONE_INT_CLEAR_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_DONE_INT_CLEAR_LSB    0
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_DONE_INT_CLEAR_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_ABORT_INT_CLEAR_RST    0x0
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_READ_INT_CLEAR_OFF_RD_DONE_INT_CLEAR_RST    0x0

__INLINE void pcie_ep_dma_read_int_clear_off_pack(uint8_t rsvdp_24, uint8_t rd_abort_int_clear, uint8_t rsvdp_8, uint8_t rd_done_int_clear)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rd_abort_int_clear << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)rd_done_int_clear << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rd_abort_int_clear << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)rd_done_int_clear << 0));
}

__INLINE void pcie_ep_dma_read_int_clear_off_unpack(uint8_t* rsvdp_24, uint8_t* rd_abort_int_clear, uint8_t* rsvdp_8, uint8_t* rd_done_int_clear)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rd_abort_int_clear = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*rd_done_int_clear = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_int_clear_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE void pcie_ep_dma_read_int_clear_off_rd_abort_int_clear_setf(uint8_t rdabortintclear)
{
	ASSERT_ERR((((uint32_t)rdabortintclear << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)rdabortintclear <<16));
}
__INLINE uint8_t pcie_ep_dma_read_int_clear_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE void pcie_ep_dma_read_int_clear_off_rd_done_int_clear_setf(uint8_t rddoneintclear)
{
	ASSERT_ERR((((uint32_t)rddoneintclear << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_INT_CLEAR_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)rddoneintclear <<0));
}

/**
 * @brief DMA_READ_ERR_STATUS_LOW_OFF register definition
 *  This register provides information pertaining to linked list element fetch error and application write error. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 LINK_LIST_ELEMENT_FETCH_ERR_DETECT 0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 APP_WR_ERR_DETECT         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0B4)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_OFFSET      0x0000C0B4
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_INDEX       0x0000302D
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_err_status_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);
}

// field definitions
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_LINK_LIST_ELEMENT_FETCH_ERR_DETECT_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_LINK_LIST_ELEMENT_FETCH_ERR_DETECT_LSB    16
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_LINK_LIST_ELEMENT_FETCH_ERR_DETECT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_APP_WR_ERR_DETECT_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_APP_WR_ERR_DETECT_LSB    0
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_APP_WR_ERR_DETECT_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_LINK_LIST_ELEMENT_FETCH_ERR_DETECT_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_APP_WR_ERR_DETECT_RST    0x0

__INLINE void pcie_ep_dma_read_err_status_low_off_unpack(uint8_t* rsvdp_24, uint8_t* link_list_element_fetch_err_detect, uint8_t* rsvdp_8, uint8_t* app_wr_err_detect)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*link_list_element_fetch_err_detect = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*app_wr_err_detect = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_err_status_low_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_low_off_link_list_element_fetch_err_detect_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_low_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_low_off_app_wr_err_detect_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_LOW_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief DMA_READ_ERR_STATUS_HIGH_OFF register definition
 *  This register provides information pertaining to completion errors. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 DATA_POISIONING           0x0
 *    23:16 CPL_TIMEOUT               0x0
 *    15:08 CPL_ABORT                 0x0
 *    07:00 UNSUPPORTED_REQ           0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0B8)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_OFFSET      0x0000C0B8
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_INDEX       0x0000302E
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_err_status_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);
}

// field definitions
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_DATA_POISIONING_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_DATA_POISIONING_LSB    24
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_DATA_POISIONING_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_TIMEOUT_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_TIMEOUT_LSB    16
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_TIMEOUT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_ABORT_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_ABORT_LSB    8
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_ABORT_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_UNSUPPORTED_REQ_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_UNSUPPORTED_REQ_LSB    0
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_UNSUPPORTED_REQ_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_DATA_POISIONING_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_TIMEOUT_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_CPL_ABORT_RST    0x0
#define PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_UNSUPPORTED_REQ_RST    0x0

__INLINE void pcie_ep_dma_read_err_status_high_off_unpack(uint8_t* data_poisioning, uint8_t* cpl_timeout, uint8_t* cpl_abort, uint8_t* unsupported_req)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);

	*data_poisioning = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*cpl_timeout = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*cpl_abort = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*unsupported_req = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_err_status_high_off_data_poisioning_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_high_off_cpl_timeout_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_high_off_cpl_abort_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_read_err_status_high_off_unsupported_req_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ERR_STATUS_HIGH_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}

/**
 * @brief DMA_READ_LINKED_LIST_ERR_EN_OFF register definition
 *  The LIE and RIE bits in the LL element enable the channel  done  interrupts (local and remote). The LLLAIE and LLRAIE bits enable the channel  abort  interrupts (local and remote). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RSVDP_24                  0x0
 *    23:16 RD_CHANNEL_LLLAIE         0x0
 *    15:08 RSVDP_8                   0x0
 *    07:00 RD_CHANNEL_LLRAIE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0C4)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_OFFSET      0x0000C0C4
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_INDEX       0x00003031
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_linked_list_err_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_linked_list_err_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_24_MASK    ((uint32_t)0xFF000000)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_24_LSB    24
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_24_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLLAIE_MASK    ((uint32_t)0x00FF0000)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLLAIE_LSB    16
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLLAIE_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_8_MASK    ((uint32_t)0x0000FF00)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_8_LSB    8
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_8_WIDTH    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLRAIE_MASK    ((uint32_t)0x000000FF)
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLRAIE_LSB    0
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLRAIE_WIDTH    ((uint32_t)0x00000008)

#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_24_RST    0x0
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLLAIE_RST    0x0
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RSVDP_8_RST    0x0
#define PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_RD_CHANNEL_LLRAIE_RST    0x0

__INLINE void pcie_ep_dma_read_linked_list_err_en_off_pack(uint8_t rsvdp_24, uint8_t rd_channel_lllaie, uint8_t rsvdp_8, uint8_t rd_channel_llraie)
{
	ASSERT_ERR((((uint32_t)rsvdp_24 << 24) & ~((uint32_t)0xFF000000)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_lllaie << 16) & ~((uint32_t)0x00FF0000)) == 0);
	ASSERT_ERR((((uint32_t)rsvdp_8 << 8) & ~((uint32_t)0x0000FF00)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_llraie << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR,  ((uint32_t)rsvdp_24 << 24) |((uint32_t)rd_channel_lllaie << 16) |((uint32_t)rsvdp_8 << 8) |((uint32_t)rd_channel_llraie << 0));
}

__INLINE void pcie_ep_dma_read_linked_list_err_en_off_unpack(uint8_t* rsvdp_24, uint8_t* rd_channel_lllaie, uint8_t* rsvdp_8, uint8_t* rd_channel_llraie)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);

	*rsvdp_24 = (localVal & ((uint32_t)0xFF000000)) >>  24;
	*rd_channel_lllaie = (localVal & ((uint32_t)0x00FF0000)) >>  16;
	*rsvdp_8 = (localVal & ((uint32_t)0x0000FF00)) >>  8;
	*rd_channel_llraie = (localVal & ((uint32_t)0x000000FF)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_read_linked_list_err_en_off_rsvdp_24_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xFF000000)) >> 24);
}
__INLINE uint8_t pcie_ep_dma_read_linked_list_err_en_off_rd_channel_lllaie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00FF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_linked_list_err_en_off_rd_channel_lllaie_setf(uint8_t rdchannellllaie)
{
	ASSERT_ERR((((uint32_t)rdchannellllaie << 16) & ~((uint32_t)0x00FF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR) & ~((uint32_t)0x00FF0000)) | ((uint32_t)rdchannellllaie <<16));
}
__INLINE uint8_t pcie_ep_dma_read_linked_list_err_en_off_rsvdp_8_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0000FF00)) >> 8);
}
__INLINE uint8_t pcie_ep_dma_read_linked_list_err_en_off_rd_channel_llraie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x000000FF)) >> 0);
}
__INLINE void pcie_ep_dma_read_linked_list_err_en_off_rd_channel_llraie_setf(uint8_t rdchannelllraie)
{
	ASSERT_ERR((((uint32_t)rdchannelllraie << 0) & ~((uint32_t)0x000000FF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_LINKED_LIST_ERR_EN_OFF_ADDR) & ~((uint32_t)0x000000FF)) | ((uint32_t)rdchannelllraie <<0));
}

/**
 * @brief DMA_READ_DONE_IMWR_LOW_OFF register definition
 *  This register holds the lower 32 bits of the Done IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_READ_DONE_LOW_REG     0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0CC)
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_OFFSET      0x0000C0CC
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_INDEX       0x00003033
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_done_imwr_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_done_imwr_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_DMA_READ_DONE_LOW_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_DMA_READ_DONE_LOW_REG_LSB    0
#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_DMA_READ_DONE_LOW_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_DMA_READ_DONE_LOW_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_read_done_imwr_low_off_dma_read_done_low_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_read_done_imwr_low_off_dma_read_done_low_reg_setf(uint32_t dmareaddonelowreg)
{
	ASSERT_ERR((((uint32_t)dmareaddonelowreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_DONE_IMWR_LOW_OFF_ADDR, (uint32_t)dmareaddonelowreg << 0);
}

/**
 * @brief DMA_READ_DONE_IMWR_HIGH_OFF register definition
 *  This register holds the higher 32 bits of the Done IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_READ_DONE_HIGH_REG    0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0D0)
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_OFFSET      0x0000C0D0
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_INDEX       0x00003034
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_done_imwr_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_done_imwr_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_DMA_READ_DONE_HIGH_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_DMA_READ_DONE_HIGH_REG_LSB    0
#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_DMA_READ_DONE_HIGH_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_DMA_READ_DONE_HIGH_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_read_done_imwr_high_off_dma_read_done_high_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_read_done_imwr_high_off_dma_read_done_high_reg_setf(uint32_t dmareaddonehighreg)
{
	ASSERT_ERR((((uint32_t)dmareaddonehighreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_DONE_IMWR_HIGH_OFF_ADDR, (uint32_t)dmareaddonehighreg << 0);
}

/**
 * @brief DMA_READ_ABORT_IMWR_LOW_OFF register definition
 *  This register holds the lower 32 bits of the Abort IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_READ_ABORT_LOW_REG    0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0D4)
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_OFFSET      0x0000C0D4
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_INDEX       0x00003035
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_abort_imwr_low_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_abort_imwr_low_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_DMA_READ_ABORT_LOW_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_DMA_READ_ABORT_LOW_REG_LSB    0
#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_DMA_READ_ABORT_LOW_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_DMA_READ_ABORT_LOW_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_read_abort_imwr_low_off_dma_read_abort_low_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_read_abort_imwr_low_off_dma_read_abort_low_reg_setf(uint32_t dmareadabortlowreg)
{
	ASSERT_ERR((((uint32_t)dmareadabortlowreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_ABORT_IMWR_LOW_OFF_ADDR, (uint32_t)dmareadabortlowreg << 0);
}

/**
 * @brief DMA_READ_ABORT_IMWR_HIGH_OFF register definition
 *  This register holds the higher 32 bits of the Abort IMWr TLP address. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_READ_ABORT_HIGH_REG   0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0D8)
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_OFFSET      0x0000C0D8
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_INDEX       0x00003036
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_abort_imwr_high_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_abort_imwr_high_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_DMA_READ_ABORT_HIGH_REG_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_DMA_READ_ABORT_HIGH_REG_LSB    0
#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_DMA_READ_ABORT_HIGH_REG_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_DMA_READ_ABORT_HIGH_REG_RST    0x0

__INLINE uint32_t pcie_ep_dma_read_abort_imwr_high_off_dma_read_abort_high_reg_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_read_abort_imwr_high_off_dma_read_abort_high_reg_setf(uint32_t dmareadaborthighreg)
{
	ASSERT_ERR((((uint32_t)dmareadaborthighreg << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_ABORT_IMWR_HIGH_OFF_ADDR, (uint32_t)dmareadaborthighreg << 0);
}

/**
 * @brief DMA_READ_CH_01_IMWR_DATA_OFF register definition
 *  This register holds the Channel 1 and 0 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RD_CHANNEL_1_DATA         0x0
 *    15:00 RD_CHANNEL_0_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0DC)
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_OFFSET      0x0000C0DC
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_INDEX       0x00003037
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_01_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_01_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_1_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_1_DATA_LSB    16
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_1_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_0_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_0_DATA_LSB    0
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_0_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_1_DATA_RST    0x0
#define PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_RD_CHANNEL_0_DATA_RST    0x0

__INLINE void pcie_ep_dma_read_ch_01_imwr_data_off_pack(uint16_t rd_channel_1_data, uint16_t rd_channel_0_data)
{
	ASSERT_ERR((((uint32_t)rd_channel_1_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_0_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR,  ((uint32_t)rd_channel_1_data << 16) |((uint32_t)rd_channel_0_data << 0));
}

__INLINE void pcie_ep_dma_read_ch_01_imwr_data_off_unpack(uint16_t* rd_channel_1_data, uint16_t* rd_channel_0_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR);

	*rd_channel_1_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*rd_channel_0_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_ch_01_imwr_data_off_rd_channel_1_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_ch_01_imwr_data_off_rd_channel_1_data_setf(uint16_t rdchannel1data)
{
	ASSERT_ERR((((uint32_t)rdchannel1data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)rdchannel1data <<16));
}
__INLINE uint16_t pcie_ep_dma_read_ch_01_imwr_data_off_rd_channel_0_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_01_imwr_data_off_rd_channel_0_data_setf(uint16_t rdchannel0data)
{
	ASSERT_ERR((((uint32_t)rdchannel0data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_01_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)rdchannel0data <<0));
}

/**
 * @brief DMA_READ_CH_23_IMWR_DATA_OFF register definition
 *  This register holds the Channel 3 and 2 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RD_CHANNEL_3_DATA         0x0
 *    15:00 RD_CHANNEL_2_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0E0)
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_OFFSET      0x0000C0E0
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_INDEX       0x00003038
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_23_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_23_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_3_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_3_DATA_LSB    16
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_3_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_2_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_2_DATA_LSB    0
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_2_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_3_DATA_RST    0x0
#define PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_RD_CHANNEL_2_DATA_RST    0x0

__INLINE void pcie_ep_dma_read_ch_23_imwr_data_off_pack(uint16_t rd_channel_3_data, uint16_t rd_channel_2_data)
{
	ASSERT_ERR((((uint32_t)rd_channel_3_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_2_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR,  ((uint32_t)rd_channel_3_data << 16) |((uint32_t)rd_channel_2_data << 0));
}

__INLINE void pcie_ep_dma_read_ch_23_imwr_data_off_unpack(uint16_t* rd_channel_3_data, uint16_t* rd_channel_2_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR);

	*rd_channel_3_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*rd_channel_2_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_ch_23_imwr_data_off_rd_channel_3_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_ch_23_imwr_data_off_rd_channel_3_data_setf(uint16_t rdchannel3data)
{
	ASSERT_ERR((((uint32_t)rdchannel3data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)rdchannel3data <<16));
}
__INLINE uint16_t pcie_ep_dma_read_ch_23_imwr_data_off_rd_channel_2_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_23_imwr_data_off_rd_channel_2_data_setf(uint16_t rdchannel2data)
{
	ASSERT_ERR((((uint32_t)rdchannel2data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_23_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)rdchannel2data <<0));
}

/**
 * @brief DMA_READ_CH_45_IMWR_DATA_OFF register definition
 *  This register holds the Channel 5 and 4 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RD_CHANNEL_5_DATA         0x0
 *    15:00 RD_CHANNEL_4_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0E4)
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_OFFSET      0x0000C0E4
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_INDEX       0x00003039
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_45_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_45_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_5_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_5_DATA_LSB    16
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_5_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_4_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_4_DATA_LSB    0
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_4_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_5_DATA_RST    0x0
#define PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_RD_CHANNEL_4_DATA_RST    0x0

__INLINE void pcie_ep_dma_read_ch_45_imwr_data_off_pack(uint16_t rd_channel_5_data, uint16_t rd_channel_4_data)
{
	ASSERT_ERR((((uint32_t)rd_channel_5_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_4_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR,  ((uint32_t)rd_channel_5_data << 16) |((uint32_t)rd_channel_4_data << 0));
}

__INLINE void pcie_ep_dma_read_ch_45_imwr_data_off_unpack(uint16_t* rd_channel_5_data, uint16_t* rd_channel_4_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR);

	*rd_channel_5_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*rd_channel_4_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_ch_45_imwr_data_off_rd_channel_5_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_ch_45_imwr_data_off_rd_channel_5_data_setf(uint16_t rdchannel5data)
{
	ASSERT_ERR((((uint32_t)rdchannel5data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)rdchannel5data <<16));
}
__INLINE uint16_t pcie_ep_dma_read_ch_45_imwr_data_off_rd_channel_4_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_45_imwr_data_off_rd_channel_4_data_setf(uint16_t rdchannel4data)
{
	ASSERT_ERR((((uint32_t)rdchannel4data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_45_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)rdchannel4data <<0));
}

/**
 * @brief DMA_READ_CH_67_IMWR_DATA_OFF register definition
 *  This register holds the Channel 7 and 6 IMWr Done or Abort TLP Data. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RD_CHANNEL_7_DATA         0x0
 *    15:00 RD_CHANNEL_6_DATA         0x0
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C0E8)
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_OFFSET      0x0000C0E8
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_INDEX       0x0000303A
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_67_imwr_data_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_67_imwr_data_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_7_DATA_MASK    ((uint32_t)0xFFFF0000)
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_7_DATA_LSB    16
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_7_DATA_WIDTH    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_6_DATA_MASK    ((uint32_t)0x0000FFFF)
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_6_DATA_LSB    0
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_6_DATA_WIDTH    ((uint32_t)0x00000010)

#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_7_DATA_RST    0x0
#define PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_RD_CHANNEL_6_DATA_RST    0x0

__INLINE void pcie_ep_dma_read_ch_67_imwr_data_off_pack(uint16_t rd_channel_7_data, uint16_t rd_channel_6_data)
{
	ASSERT_ERR((((uint32_t)rd_channel_7_data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	ASSERT_ERR((((uint32_t)rd_channel_6_data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR,  ((uint32_t)rd_channel_7_data << 16) |((uint32_t)rd_channel_6_data << 0));
}

__INLINE void pcie_ep_dma_read_ch_67_imwr_data_off_unpack(uint16_t* rd_channel_7_data, uint16_t* rd_channel_6_data)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR);

	*rd_channel_7_data = (localVal & ((uint32_t)0xFFFF0000)) >>  16;
	*rd_channel_6_data = (localVal & ((uint32_t)0x0000FFFF)) >>  0;
}

__INLINE uint16_t pcie_ep_dma_read_ch_67_imwr_data_off_rd_channel_7_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0xFFFF0000)) >> 16);
}
__INLINE void pcie_ep_dma_read_ch_67_imwr_data_off_rd_channel_7_data_setf(uint16_t rdchannel7data)
{
	ASSERT_ERR((((uint32_t)rdchannel7data << 16) & ~((uint32_t)0xFFFF0000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0xFFFF0000)) | ((uint32_t)rdchannel7data <<16));
}
__INLINE uint16_t pcie_ep_dma_read_ch_67_imwr_data_off_rd_channel_6_data_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR);
	return (uint16_t)((localVal & ((uint32_t)0x0000FFFF)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_67_imwr_data_off_rd_channel_6_data_setf(uint16_t rdchannel6data)
{
	ASSERT_ERR((((uint32_t)rdchannel6data << 0) & ~((uint32_t)0x0000FFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_67_IMWR_DATA_OFF_ADDR) & ~((uint32_t)0x0000FFFF)) | ((uint32_t)rdchannel6data <<0));
}

/**
 * @brief DMA_WRITE_CH_0_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 0 . register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH0_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C128)
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_OFFSET      0x0000C128
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_INDEX       0x0000304A
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_0_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_0_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_DMA_WRITE_CH_0_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_DMA_WRITE_CH_0_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_DMA_WRITE_CH_0_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_0_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch0_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch0_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch0_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_0_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch0_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch0_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_0_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_0_pwr_en_off_dma_write_ch_0_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_0_pwr_en_off_dma_write_ch_0_pwr_en_setf(uint8_t dmawritech0pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech0pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_0_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech0pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_1_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 1. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH1_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C12C)
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_OFFSET      0x0000C12C
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_INDEX       0x0000304B
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_1_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_1_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_DMA_WRITE_CH_1_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_DMA_WRITE_CH_1_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_DMA_WRITE_CH_1_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_1_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch1_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch1_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch1_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_1_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch1_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch1_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_1_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_1_pwr_en_off_dma_write_ch_1_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_1_pwr_en_off_dma_write_ch_1_pwr_en_setf(uint8_t dmawritech1pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech1pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_1_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech1pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_2_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 2. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH2_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C130)
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_OFFSET      0x0000C130
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_INDEX       0x0000304C
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_2_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_2_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_DMA_WRITE_CH_2_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_DMA_WRITE_CH_2_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_DMA_WRITE_CH_2_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_2_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch2_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch2_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch2_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_2_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch2_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch2_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_2_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_2_pwr_en_off_dma_write_ch_2_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_2_pwr_en_off_dma_write_ch_2_pwr_en_setf(uint8_t dmawritech2pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech2pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_2_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech2pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_3_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 3. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH3_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C134)
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_OFFSET      0x0000C134
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_INDEX       0x0000304D
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_3_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_3_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_DMA_WRITE_CH_3_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_DMA_WRITE_CH_3_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_DMA_WRITE_CH_3_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_3_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch3_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch3_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch3_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_3_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch3_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch3_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_3_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_3_pwr_en_off_dma_write_ch_3_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_3_pwr_en_off_dma_write_ch_3_pwr_en_setf(uint8_t dmawritech3pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech3pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_3_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech3pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_4_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 4. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH4_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C138)
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_OFFSET      0x0000C138
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_INDEX       0x0000304E
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_4_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_4_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_DMA_WRITE_CH_4_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_DMA_WRITE_CH_4_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_DMA_WRITE_CH_4_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_4_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch4_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch4_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch4_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_4_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch4_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch4_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_4_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_4_pwr_en_off_dma_write_ch_4_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_4_pwr_en_off_dma_write_ch_4_pwr_en_setf(uint8_t dmawritech4pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech4pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_4_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech4pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_5_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 5. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH5_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C13C)
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_OFFSET      0x0000C13C
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_INDEX       0x0000304F
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_5_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_5_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_DMA_WRITE_CH_5_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_DMA_WRITE_CH_5_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_DMA_WRITE_CH_5_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_5_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch5_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch5_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch5_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_5_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch5_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch5_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_5_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_5_pwr_en_off_dma_write_ch_5_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_5_pwr_en_off_dma_write_ch_5_pwr_en_setf(uint8_t dmawritech5pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech5pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_5_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech5pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_6_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 6. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH6_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C140)
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_OFFSET      0x0000C140
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_INDEX       0x00003050
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_6_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_6_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_DMA_WRITE_CH_6_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_DMA_WRITE_CH_6_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_DMA_WRITE_CH_6_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_6_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch6_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch6_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch6_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_6_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch6_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch6_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_6_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_6_pwr_en_off_dma_write_ch_6_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_6_pwr_en_off_dma_write_ch_6_pwr_en_setf(uint8_t dmawritech6pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech6pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_6_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech6pwren <<0));
}

/**
 * @brief DMA_WRITE_CH_7_PWR_EN_OFF register definition
 *  This register controls power enable/disable for write channel 7. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_WRITE_CH7_PWR_EN      0              
 * </pre>
 */
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C144)
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_OFFSET      0x0000C144
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_INDEX       0x00003051
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_write_ch_7_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_write_ch_7_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_DMA_WRITE_CH_7_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_DMA_WRITE_CH_7_PWR_EN_POS    0

#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_DMA_WRITE_CH_7_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_write_ch_7_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_write_ch7_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_write_ch7_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_write_ch7_pwr_en << 0));
}

__INLINE void pcie_ep_dma_write_ch_7_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_write_ch7_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_write_ch7_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_write_ch_7_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_write_ch_7_pwr_en_off_dma_write_ch_7_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_write_ch_7_pwr_en_off_dma_write_ch_7_pwr_en_setf(uint8_t dmawritech7pwren)
{
	ASSERT_ERR((((uint32_t)dmawritech7pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_WRITE_CH_7_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmawritech7pwren <<0));
}

/**
 * @brief DMA_READ_CH_0_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 0. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH0_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C168)
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_OFFSET      0x0000C168
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_INDEX       0x0000305A
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_0_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_0_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_DMA_READ_CH_0_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_DMA_READ_CH_0_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_DMA_READ_CH_0_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_0_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch0_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch0_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch0_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_0_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch0_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch0_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_0_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_0_pwr_en_off_dma_read_ch_0_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_0_pwr_en_off_dma_read_ch_0_pwr_en_setf(uint8_t dmareadch0pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch0pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_0_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch0pwren <<0));
}

/**
 * @brief DMA_READ_CH_1_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 1. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH1_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C16C)
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_OFFSET      0x0000C16C
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_INDEX       0x0000305B
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_1_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_1_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_DMA_READ_CH_1_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_DMA_READ_CH_1_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_DMA_READ_CH_1_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_1_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch1_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch1_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch1_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_1_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch1_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch1_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_1_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_1_pwr_en_off_dma_read_ch_1_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_1_pwr_en_off_dma_read_ch_1_pwr_en_setf(uint8_t dmareadch1pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch1pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_1_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch1pwren <<0));
}

/**
 * @brief DMA_READ_CH_2_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 2. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH2_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C170)
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_OFFSET      0x0000C170
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_INDEX       0x0000305C
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_2_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_2_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_DMA_READ_CH_2_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_DMA_READ_CH_2_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_DMA_READ_CH_2_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_2_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch2_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch2_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch2_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_2_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch2_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch2_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_2_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_2_pwr_en_off_dma_read_ch_2_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_2_pwr_en_off_dma_read_ch_2_pwr_en_setf(uint8_t dmareadch2pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch2pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_2_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch2pwren <<0));
}

/**
 * @brief DMA_READ_CH_3_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 3. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH3_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C174)
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_OFFSET      0x0000C174
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_INDEX       0x0000305D
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_3_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_3_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_DMA_READ_CH_3_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_DMA_READ_CH_3_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_DMA_READ_CH_3_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_3_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch3_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch3_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch3_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_3_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch3_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch3_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_3_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_3_pwr_en_off_dma_read_ch_3_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_3_pwr_en_off_dma_read_ch_3_pwr_en_setf(uint8_t dmareadch3pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch3pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_3_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch3pwren <<0));
}

/**
 * @brief DMA_READ_CH_4_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 4. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH4_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C178)
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_OFFSET      0x0000C178
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_INDEX       0x0000305E
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_4_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_4_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_DMA_READ_CH_4_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_DMA_READ_CH_4_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_DMA_READ_CH_4_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_4_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch4_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch4_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch4_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_4_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch4_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch4_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_4_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_4_pwr_en_off_dma_read_ch_4_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_4_pwr_en_off_dma_read_ch_4_pwr_en_setf(uint8_t dmareadch4pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch4pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_4_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch4pwren <<0));
}

/**
 * @brief DMA_READ_CH_5_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 5. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH5_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C17C)
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_OFFSET      0x0000C17C
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_INDEX       0x0000305F
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_5_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_5_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_DMA_READ_CH_5_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_DMA_READ_CH_5_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_DMA_READ_CH_5_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_5_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch5_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch5_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch5_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_5_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch5_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch5_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_5_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_5_pwr_en_off_dma_read_ch_5_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_5_pwr_en_off_dma_read_ch_5_pwr_en_setf(uint8_t dmareadch5pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch5pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_5_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch5pwren <<0));
}

/**
 * @brief DMA_READ_CH_6_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 6. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH6_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C180)
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_OFFSET      0x0000C180
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_INDEX       0x00003060
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_6_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_6_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_DMA_READ_CH_6_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_DMA_READ_CH_6_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_DMA_READ_CH_6_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_6_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch6_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch6_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch6_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_6_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch6_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch6_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_6_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_6_pwr_en_off_dma_read_ch_6_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_6_pwr_en_off_dma_read_ch_6_pwr_en_setf(uint8_t dmareadch6pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch6pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_6_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch6pwren <<0));
}

/**
 * @brief DMA_READ_CH_7_PWR_EN_OFF register definition
 *  This register controls power enable/disable for read channel 7. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:01 RSVDP_1                   0x0
 *    00    DMA_READ_CH7_PWR_EN       0              
 * </pre>
 */
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C184)
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_OFFSET      0x0000C184
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_INDEX       0x00003061
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_read_ch_7_pwr_en_off_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR);
}

__INLINE void pcie_ep_dma_read_ch_7_pwr_en_off_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_RSVDP_1_MASK    ((uint32_t)0xFFFFFFFE)
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_RSVDP_1_LSB    1
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_RSVDP_1_WIDTH    ((uint32_t)0x0000001F)
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_DMA_READ_CH_7_PWR_EN_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_DMA_READ_CH_7_PWR_EN_POS    0

#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_RSVDP_1_RST    0x0
#define PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_DMA_READ_CH_7_PWR_EN_RST    0x0

__INLINE void pcie_ep_dma_read_ch_7_pwr_en_off_pack(uint32_t rsvdp_1, uint8_t dma_read_ch7_pwr_en)
{
	ASSERT_ERR((((uint32_t)rsvdp_1 << 1) & ~((uint32_t)0xFFFFFFFE)) == 0);
	ASSERT_ERR((((uint32_t)dma_read_ch7_pwr_en << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR,  ((uint32_t)rsvdp_1 << 1) |((uint32_t)dma_read_ch7_pwr_en << 0));
}

__INLINE void pcie_ep_dma_read_ch_7_pwr_en_off_unpack(uint32_t* rsvdp_1, uint8_t* dma_read_ch7_pwr_en)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR);

	*rsvdp_1 = (localVal & ((uint32_t)0xFFFFFFFE)) >>  1;
	*dma_read_ch7_pwr_en = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint32_t pcie_ep_dma_read_ch_7_pwr_en_off_rsvdp_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR);
	return (uint32_t)((localVal & ((uint32_t)0xFFFFFFFE)) >> 1);
}
__INLINE uint8_t pcie_ep_dma_read_ch_7_pwr_en_off_dma_read_ch_7_pwr_en_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_read_ch_7_pwr_en_off_dma_read_ch_7_pwr_en_setf(uint8_t dmareadch7pwren)
{
	ASSERT_ERR((((uint32_t)dmareadch7pwren << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR, (REG_PL_RD(PCIE_EP_DMA_READ_CH_7_PWR_EN_OFF_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)dmareadch7pwren <<0));
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_0 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_OFFSET      0x0000C200
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_INDEX       0x00003080
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_0_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_0_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_0_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_0 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C208)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_OFFSET      0x0000C208
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_INDEX       0x00003082
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_0_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_0_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_0_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_0 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C20C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_OFFSET      0x0000C20C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_INDEX       0x00003083
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_0_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_0_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_0_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_0 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C210)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_OFFSET      0x0000C210
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_INDEX       0x00003084
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_0_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_0_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_0_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_0 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C214)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_OFFSET      0x0000C214
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_INDEX       0x00003085
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_0_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_0_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_0_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_0 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C218)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_OFFSET      0x0000C218
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_INDEX       0x00003086
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_0_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_0_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_0_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_0 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C21C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_OFFSET      0x0000C21C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_INDEX       0x00003087
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_0_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_0_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_0_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_0 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C220)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_OFFSET      0x0000C220
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_INDEX       0x00003088
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_0_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_0_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_0_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_0 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C300)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_OFFSET      0x0000C300
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_INDEX       0x000030C0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_0_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_0_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_0_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_0 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C308)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_OFFSET      0x0000C308
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_INDEX       0x000030C2
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_0_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_0_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_0_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_0 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C30C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_OFFSET      0x0000C30C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_INDEX       0x000030C3
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_0_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_0_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_0_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_0 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C310)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_OFFSET      0x0000C310
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_INDEX       0x000030C4
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_0_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_0_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_0_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_0 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C314)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_OFFSET      0x0000C314
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_INDEX       0x000030C5
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_0_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_0_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_0_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_0 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C318)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_OFFSET      0x0000C318
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_INDEX       0x000030C6
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_0_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_0_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_0_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_0 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C31C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_OFFSET      0x0000C31C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_INDEX       0x000030C7
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_0_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_0_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_0_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_0 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C320)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_OFFSET      0x0000C320
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_INDEX       0x000030C8
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_0_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_0_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_0_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_0_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_0_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_1 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C400)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_OFFSET      0x0000C400
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_INDEX       0x00003100
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_1_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_1_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_1_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_1 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C408)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_OFFSET      0x0000C408
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_INDEX       0x00003102
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_1_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_1_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_1_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_1 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C40C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_OFFSET      0x0000C40C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_INDEX       0x00003103
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_1_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_1_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_1_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_1 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C410)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_OFFSET      0x0000C410
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_INDEX       0x00003104
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_1_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_1_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_1_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_1 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C414)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_OFFSET      0x0000C414
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_INDEX       0x00003105
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_1_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_1_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_1_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_1 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C418)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_OFFSET      0x0000C418
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_INDEX       0x00003106
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_1_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_1_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_1_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_1 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C41C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_OFFSET      0x0000C41C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_INDEX       0x00003107
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_1_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_1_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_1_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_1 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C420)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_OFFSET      0x0000C420
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_INDEX       0x00003108
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_1_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_1_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_1_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_1 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C500)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_OFFSET      0x0000C500
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_INDEX       0x00003140
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_1_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_1_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_1_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_1 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C508)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_OFFSET      0x0000C508
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_INDEX       0x00003142
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_1_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_1_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_1_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_1 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C50C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_OFFSET      0x0000C50C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_INDEX       0x00003143
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_1_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_1_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_1_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_1 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C510)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_OFFSET      0x0000C510
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_INDEX       0x00003144
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_1_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_1_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_1_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_1 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C514)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_OFFSET      0x0000C514
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_INDEX       0x00003145
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_1_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_1_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_1_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_1 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C518)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_OFFSET      0x0000C518
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_INDEX       0x00003146
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_1_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_1_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_1_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_1 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C51C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_OFFSET      0x0000C51C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_INDEX       0x00003147
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_1_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_1_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_1_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_1 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C520)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_OFFSET      0x0000C520
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_INDEX       0x00003148
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_1_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_1_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_1_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_1_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_1_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_2 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C600)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_OFFSET      0x0000C600
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_INDEX       0x00003180
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_2_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_2_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_2_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_2 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C608)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_OFFSET      0x0000C608
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_INDEX       0x00003182
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_2_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_2_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_2_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_2 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C60C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_OFFSET      0x0000C60C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_INDEX       0x00003183
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_2_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_2_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_2_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_2 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C610)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_OFFSET      0x0000C610
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_INDEX       0x00003184
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_2_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_2_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_2_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_2 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C614)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_OFFSET      0x0000C614
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_INDEX       0x00003185
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_2_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_2_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_2_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_2 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C618)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_OFFSET      0x0000C618
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_INDEX       0x00003186
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_2_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_2_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_2_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_2 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C61C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_OFFSET      0x0000C61C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_INDEX       0x00003187
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_2_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_2_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_2_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_2 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C620)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_OFFSET      0x0000C620
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_INDEX       0x00003188
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_2_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_2_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_2_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_2 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C700)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_OFFSET      0x0000C700
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_INDEX       0x000031C0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_2_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_2_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_2_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_2 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C708)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_OFFSET      0x0000C708
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_INDEX       0x000031C2
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_2_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_2_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_2_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_2 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C70C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_OFFSET      0x0000C70C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_INDEX       0x000031C3
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_2_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_2_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_2_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_2 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C710)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_OFFSET      0x0000C710
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_INDEX       0x000031C4
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_2_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_2_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_2_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_2 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C714)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_OFFSET      0x0000C714
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_INDEX       0x000031C5
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_2_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_2_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_2_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_2 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C718)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_OFFSET      0x0000C718
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_INDEX       0x000031C6
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_2_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_2_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_2_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_2 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C71C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_OFFSET      0x0000C71C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_INDEX       0x000031C7
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_2_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_2_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_2_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_2 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C720)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_OFFSET      0x0000C720
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_INDEX       0x000031C8
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_2_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_2_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_2_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_2_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_2_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_3 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C800)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_OFFSET      0x0000C800
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_INDEX       0x00003200
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_3_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_3_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_3_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_3 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C808)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_OFFSET      0x0000C808
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_INDEX       0x00003202
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_3_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_3_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_3_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_3 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C80C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_OFFSET      0x0000C80C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_INDEX       0x00003203
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_3_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_3_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_3_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_3 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C810)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_OFFSET      0x0000C810
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_INDEX       0x00003204
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_3_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_3_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_3_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_3 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C814)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_OFFSET      0x0000C814
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_INDEX       0x00003205
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_3_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_3_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_3_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_3 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C818)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_OFFSET      0x0000C818
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_INDEX       0x00003206
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_3_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_3_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_3_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_3 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C81C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_OFFSET      0x0000C81C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_INDEX       0x00003207
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_3_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_3_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_3_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_3 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C820)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_OFFSET      0x0000C820
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_INDEX       0x00003208
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_3_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_3_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_3_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_3 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C900)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_OFFSET      0x0000C900
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_INDEX       0x00003240
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_3_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_3_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_3_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_3 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C908)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_OFFSET      0x0000C908
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_INDEX       0x00003242
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_3_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_3_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_3_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_3 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C90C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_OFFSET      0x0000C90C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_INDEX       0x00003243
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_3_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_3_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_3_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_3 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C910)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_OFFSET      0x0000C910
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_INDEX       0x00003244
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_3_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_3_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_3_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_3 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C914)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_OFFSET      0x0000C914
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_INDEX       0x00003245
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_3_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_3_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_3_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_3 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C918)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_OFFSET      0x0000C918
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_INDEX       0x00003246
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_3_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_3_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_3_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_3 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C91C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_OFFSET      0x0000C91C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_INDEX       0x00003247
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_3_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_3_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_3_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_3 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000C920)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_OFFSET      0x0000C920
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_INDEX       0x00003248
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_3_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_3_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_3_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_3_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_3_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_4 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_OFFSET      0x0000CA00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_INDEX       0x00003280
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_4_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_4_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_4_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_4 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_OFFSET      0x0000CA08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_INDEX       0x00003282
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_4_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_4_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_4_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_4 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_OFFSET      0x0000CA0C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_INDEX       0x00003283
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_4_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_4_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_4_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_4 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_OFFSET      0x0000CA10
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_INDEX       0x00003284
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_4_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_4_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_4_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_4 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA14)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_OFFSET      0x0000CA14
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_INDEX       0x00003285
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_4_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_4_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_4_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_4 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_OFFSET      0x0000CA18
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_INDEX       0x00003286
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_4_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_4_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_4_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_4 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_OFFSET      0x0000CA1C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_INDEX       0x00003287
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_4_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_4_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_4_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_4 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CA20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_OFFSET      0x0000CA20
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_INDEX       0x00003288
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_4_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_4_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_4_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_4 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_OFFSET      0x0000CB00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_INDEX       0x000032C0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_4_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_4_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_4_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_4 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_OFFSET      0x0000CB08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_INDEX       0x000032C2
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_4_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_4_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_4_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_4 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_OFFSET      0x0000CB0C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_INDEX       0x000032C3
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_4_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_4_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_4_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_4 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_OFFSET      0x0000CB10
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_INDEX       0x000032C4
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_4_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_4_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_4_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_4 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB14)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_OFFSET      0x0000CB14
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_INDEX       0x000032C5
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_4_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_4_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_4_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_4 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_OFFSET      0x0000CB18
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_INDEX       0x000032C6
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_4_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_4_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_4_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_4 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_OFFSET      0x0000CB1C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_INDEX       0x000032C7
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_4_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_4_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_4_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_4 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CB20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_OFFSET      0x0000CB20
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_INDEX       0x000032C8
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_4_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_4_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_4_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_4_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_4_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_5 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_OFFSET      0x0000CC00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_INDEX       0x00003300
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_5_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_5_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_5_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_5 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_OFFSET      0x0000CC08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_INDEX       0x00003302
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_5_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_5_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_5_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_5 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_OFFSET      0x0000CC0C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_INDEX       0x00003303
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_5_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_5_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_5_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_5 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_OFFSET      0x0000CC10
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_INDEX       0x00003304
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_5_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_5_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_5_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_5 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC14)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_OFFSET      0x0000CC14
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_INDEX       0x00003305
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_5_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_5_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_5_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_5 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_OFFSET      0x0000CC18
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_INDEX       0x00003306
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_5_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_5_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_5_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_5 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_OFFSET      0x0000CC1C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_INDEX       0x00003307
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_5_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_5_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_5_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_5 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CC20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_OFFSET      0x0000CC20
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_INDEX       0x00003308
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_5_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_5_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_5_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_5 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_OFFSET      0x0000CD00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_INDEX       0x00003340
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_5_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_5_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_5_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_5 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_OFFSET      0x0000CD08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_INDEX       0x00003342
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_5_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_5_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_5_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_5 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_OFFSET      0x0000CD0C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_INDEX       0x00003343
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_5_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_5_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_5_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_5 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_OFFSET      0x0000CD10
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_INDEX       0x00003344
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_5_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_5_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_5_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_5 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD14)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_OFFSET      0x0000CD14
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_INDEX       0x00003345
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_5_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_5_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_5_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_5 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_OFFSET      0x0000CD18
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_INDEX       0x00003346
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_5_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_5_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_5_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_5 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_OFFSET      0x0000CD1C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_INDEX       0x00003347
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_5_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_5_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_5_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_5 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CD20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_OFFSET      0x0000CD20
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_INDEX       0x00003348
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_5_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_5_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_5_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_5_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_5_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_6 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_OFFSET      0x0000CE00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_INDEX       0x00003380
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_6_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_6_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_6_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_6 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_OFFSET      0x0000CE08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_INDEX       0x00003382
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_6_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_6_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_6_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_6 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_OFFSET      0x0000CE0C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_INDEX       0x00003383
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_6_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_6_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_6_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_6 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_OFFSET      0x0000CE10
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_INDEX       0x00003384
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_6_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_6_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_6_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_6 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE14)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_OFFSET      0x0000CE14
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_INDEX       0x00003385
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_6_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_6_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_6_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_6 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_OFFSET      0x0000CE18
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_INDEX       0x00003386
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_6_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_6_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_6_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_6 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_OFFSET      0x0000CE1C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_INDEX       0x00003387
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_6_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_6_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_6_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_6 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CE20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_OFFSET      0x0000CE20
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_INDEX       0x00003388
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_6_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_6_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_6_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_6 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_OFFSET      0x0000CF00
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_INDEX       0x000033C0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_6_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_6_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_6_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_6 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF08)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_OFFSET      0x0000CF08
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_INDEX       0x000033C2
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_6_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_6_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_6_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_6 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF0C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_OFFSET      0x0000CF0C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_INDEX       0x000033C3
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_6_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_6_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_6_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_6 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF10)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_OFFSET      0x0000CF10
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_INDEX       0x000033C4
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_6_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_6_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_6_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_6 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF14)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_OFFSET      0x0000CF14
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_INDEX       0x000033C5
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_6_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_6_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_6_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_6 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF18)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_OFFSET      0x0000CF18
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_INDEX       0x000033C6
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_6_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_6_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_6_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_6 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF1C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_OFFSET      0x0000CF1C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_INDEX       0x000033C7
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_6_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_6_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_6_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_6 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000CF20)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_OFFSET      0x0000CF20
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_INDEX       0x000033C8
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_6_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_6_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_6_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_6_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_6_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_WRCH_7 register definition
 *  This register controls the DMA write channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_OFFSET      0x0000D000
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_INDEX       0x00003400
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_wrch_7_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_wrch_7_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_WRCH_7_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_WRCH_7 register definition
 *  This register holds the DMA write transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D008)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_OFFSET      0x0000D008
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_INDEX       0x00003402
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_wrch_7_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_wrch_7_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_WRCH_7_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_WRCH_7 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D00C)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_OFFSET      0x0000D00C
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_INDEX       0x00003403
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_wrch_7_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_wrch_7_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_WRCH_7_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_WRCH_7 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D010)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_OFFSET      0x0000D010
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_INDEX       0x00003404
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_wrch_7_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_wrch_7_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_WRCH_7_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_WRCH_7 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D014)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_OFFSET      0x0000D014
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_INDEX       0x00003405
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_wrch_7_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_wrch_7_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_WRCH_7_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_WRCH_7 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D018)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_OFFSET      0x0000D018
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_INDEX       0x00003406
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_wrch_7_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_wrch_7_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_WRCH_7_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_WRCH_7 register definition
 *  This register holds the lower 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D01C)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_OFFSET      0x0000D01C
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_INDEX       0x00003407
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_wrch_7_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_wrch_7_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_WRCH_7_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_WRCH_7 register definition
 *  This register holds the higher 32 bits of the DMA write linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D020)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_OFFSET      0x0000D020
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_INDEX       0x00003408
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_wrch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_wrch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_wrch_7_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_wrch_7_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_WRCH_7_ADDR, (uint32_t)llphigh << 0);
}

/**
 * @brief DMA_CH_CONTROL_1_OFF_RDCH_7 register definition
 *  This register controls the DMA read channel operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 DMA_AT                    0x0
 *    29:27 DMA_TC                    0x0
 *    26    DMA_RESERVED5             0              
 *    25    DMA_RO                    0              
 *    24    DMA_NS_SRC                0              
 *    23    DMA_NS_DST                0              
 *    22    DMA_MEM_TYPE              0              
 *    16:12 DMA_FUNC_NUM              0x0
 *    11:10 DMA_RESERVED1             0x0
 *    09    LLE                       0              
 *    08    CCS                       0              
 *    07    DMA_RESERVED0             0              
 *    06:05 CS                        0x0
 *    04    RIE                       0              
 *    03    LIE                       0              
 *    02    LLP                       0              
 *    01    TCB                       0              
 *    00    CB                        0              
 * </pre>
 */
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_OFFSET      0x0000D100
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_INDEX       0x00003440
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_ch_control_1_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_AT_MASK    ((uint32_t)0xC0000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_AT_LSB    30
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_AT_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_TC_MASK    ((uint32_t)0x38000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_TC_LSB    27
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_TC_WIDTH    ((uint32_t)0x00000003)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_5_BIT    ((uint32_t)0x04000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_5_POS    26
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RO_BIT    ((uint32_t)0x02000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RO_POS    25
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_SRC_BIT    ((uint32_t)0x01000000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_SRC_POS    24
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_DST_BIT    ((uint32_t)0x00800000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_DST_POS    23
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_MEM_TYPE_BIT    ((uint32_t)0x00400000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_MEM_TYPE_POS    22
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_FUNC_NUM_MASK    ((uint32_t)0x0001F000)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_FUNC_NUM_LSB    12
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_FUNC_NUM_WIDTH    ((uint32_t)0x00000005)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_1_MASK    ((uint32_t)0x00000C00)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_1_LSB    10
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_1_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLE_BIT    ((uint32_t)0x00000200)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLE_POS    9
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CCS_BIT    ((uint32_t)0x00000100)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CCS_POS    8
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_0_BIT    ((uint32_t)0x00000080)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_0_POS    7
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CS_MASK    ((uint32_t)0x00000060)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CS_LSB    5
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CS_WIDTH    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_RIE_BIT    ((uint32_t)0x00000010)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_RIE_POS    4
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LIE_BIT    ((uint32_t)0x00000008)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LIE_POS    3
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLP_BIT    ((uint32_t)0x00000004)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLP_POS    2
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_TCB_BIT    ((uint32_t)0x00000002)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_TCB_POS    1
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CB_BIT    ((uint32_t)0x00000001)
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CB_POS    0

#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_AT_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_TC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_5_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RO_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_SRC_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_NS_DST_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_MEM_TYPE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_FUNC_NUM_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_1_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CCS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_DMA_RESERVED_0_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CS_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_RIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LIE_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_LLP_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_TCB_RST    0x0
#define PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_CB_RST    0x0

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_pack(uint8_t dma_at, uint8_t dma_tc, uint8_t dma_reserved5, uint8_t dma_ro, uint8_t dma_ns_src, uint8_t dma_ns_dst, uint8_t dma_mem_type, uint8_t dma_func_num, uint8_t dma_reserved1, uint8_t lle, uint8_t ccs, uint8_t dma_reserved0, uint8_t cs, uint8_t rie, uint8_t lie, uint8_t llp, uint8_t tcb, uint8_t cb)
{
	ASSERT_ERR((((uint32_t)dma_at << 30) & ~((uint32_t)0xC0000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_tc << 27) & ~((uint32_t)0x38000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ro << 25) & ~((uint32_t)0x02000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_src << 24) & ~((uint32_t)0x01000000)) == 0);
	ASSERT_ERR((((uint32_t)dma_ns_dst << 23) & ~((uint32_t)0x00800000)) == 0);
	ASSERT_ERR((((uint32_t)dma_mem_type << 22) & ~((uint32_t)0x00400000)) == 0);
	ASSERT_ERR((((uint32_t)dma_func_num << 12) & ~((uint32_t)0x0001F000)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	ASSERT_ERR((((uint32_t)dma_reserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR,  ((uint32_t)dma_at << 30) |((uint32_t)dma_tc << 27) |((uint32_t)dma_reserved5 << 26) |((uint32_t)dma_ro << 25) |((uint32_t)dma_ns_src << 24) |((uint32_t)dma_ns_dst << 23) |((uint32_t)dma_mem_type << 22) |((uint32_t)dma_func_num << 12) |((uint32_t)dma_reserved1 << 10) |((uint32_t)lle << 9) |((uint32_t)ccs << 8) |((uint32_t)dma_reserved0 << 7) |((uint32_t)cs << 5) |((uint32_t)rie << 4) |((uint32_t)lie << 3) |((uint32_t)llp << 2) |((uint32_t)tcb << 1) |((uint32_t)cb << 0));
}

__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_unpack(uint8_t* dma_at, uint8_t* dma_tc, uint8_t* dma_reserved5, uint8_t* dma_ro, uint8_t* dma_ns_src, uint8_t* dma_ns_dst, uint8_t* dma_mem_type, uint8_t* dma_func_num, uint8_t* dma_reserved1, uint8_t* lle, uint8_t* ccs, uint8_t* dma_reserved0, uint8_t* cs, uint8_t* rie, uint8_t* lie, uint8_t* llp, uint8_t* tcb, uint8_t* cb)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);

	*dma_at = (localVal & ((uint32_t)0xC0000000)) >>  30;
	*dma_tc = (localVal & ((uint32_t)0x38000000)) >>  27;
	*dma_reserved5 = (localVal & ((uint32_t)0x04000000)) >>  26;
	*dma_ro = (localVal & ((uint32_t)0x02000000)) >>  25;
	*dma_ns_src = (localVal & ((uint32_t)0x01000000)) >>  24;
	*dma_ns_dst = (localVal & ((uint32_t)0x00800000)) >>  23;
	*dma_mem_type = (localVal & ((uint32_t)0x00400000)) >>  22;
	*dma_func_num = (localVal & ((uint32_t)0x0001F000)) >>  12;
	*dma_reserved1 = (localVal & ((uint32_t)0x00000C00)) >>  10;
	*lle = (localVal & ((uint32_t)0x00000200)) >>  9;
	*ccs = (localVal & ((uint32_t)0x00000100)) >>  8;
	*dma_reserved0 = (localVal & ((uint32_t)0x00000080)) >>  7;
	*cs = (localVal & ((uint32_t)0x00000060)) >>  5;
	*rie = (localVal & ((uint32_t)0x00000010)) >>  4;
	*lie = (localVal & ((uint32_t)0x00000008)) >>  3;
	*llp = (localVal & ((uint32_t)0x00000004)) >>  2;
	*tcb = (localVal & ((uint32_t)0x00000002)) >>  1;
	*cb = (localVal & ((uint32_t)0x00000001)) >>  0;
}

__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_at_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0xC0000000)) >> 30);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_at_setf(uint8_t dmaat)
{
	ASSERT_ERR((((uint32_t)dmaat << 30) & ~((uint32_t)0xC0000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0xC0000000)) | ((uint32_t)dmaat <<30));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_tc_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x38000000)) >> 27);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_tc_setf(uint8_t dmatc)
{
	ASSERT_ERR((((uint32_t)dmatc << 27) & ~((uint32_t)0x38000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x38000000)) | ((uint32_t)dmatc <<27));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_5_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x04000000)) >> 26);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_5_setf(uint8_t dmareserved5)
{
	ASSERT_ERR((((uint32_t)dmareserved5 << 26) & ~((uint32_t)0x04000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x04000000)) | ((uint32_t)dmareserved5 <<26));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_ro_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x02000000)) >> 25);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_ro_setf(uint8_t dmaro)
{
	ASSERT_ERR((((uint32_t)dmaro << 25) & ~((uint32_t)0x02000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x02000000)) | ((uint32_t)dmaro <<25));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_ns_src_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x01000000)) >> 24);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_ns_src_setf(uint8_t dmanssrc)
{
	ASSERT_ERR((((uint32_t)dmanssrc << 24) & ~((uint32_t)0x01000000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x01000000)) | ((uint32_t)dmanssrc <<24));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_ns_dst_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00800000)) >> 23);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_ns_dst_setf(uint8_t dmansdst)
{
	ASSERT_ERR((((uint32_t)dmansdst << 23) & ~((uint32_t)0x00800000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00800000)) | ((uint32_t)dmansdst <<23));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_mem_type_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00400000)) >> 22);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_mem_type_setf(uint8_t dmamemtype)
{
	ASSERT_ERR((((uint32_t)dmamemtype << 22) & ~((uint32_t)0x00400000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00400000)) | ((uint32_t)dmamemtype <<22));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_func_num_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x0001F000)) >> 12);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_func_num_setf(uint8_t dmafuncnum)
{
	ASSERT_ERR((((uint32_t)dmafuncnum << 12) & ~((uint32_t)0x0001F000)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x0001F000)) | ((uint32_t)dmafuncnum <<12));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_1_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000C00)) >> 10);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_1_setf(uint8_t dmareserved1)
{
	ASSERT_ERR((((uint32_t)dmareserved1 << 10) & ~((uint32_t)0x00000C00)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000C00)) | ((uint32_t)dmareserved1 <<10));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_lle_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000200)) >> 9);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_lle_setf(uint8_t lle)
{
	ASSERT_ERR((((uint32_t)lle << 9) & ~((uint32_t)0x00000200)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000200)) | ((uint32_t)lle <<9));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_ccs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000100)) >> 8);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_ccs_setf(uint8_t ccs)
{
	ASSERT_ERR((((uint32_t)ccs << 8) & ~((uint32_t)0x00000100)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000100)) | ((uint32_t)ccs <<8));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_0_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000080)) >> 7);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_dma_reserved_0_setf(uint8_t dmareserved0)
{
	ASSERT_ERR((((uint32_t)dmareserved0 << 7) & ~((uint32_t)0x00000080)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000080)) | ((uint32_t)dmareserved0 <<7));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_cs_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000060)) >> 5);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_cs_setf(uint8_t cs)
{
	ASSERT_ERR((((uint32_t)cs << 5) & ~((uint32_t)0x00000060)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000060)) | ((uint32_t)cs <<5));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_rie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000010)) >> 4);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_rie_setf(uint8_t rie)
{
	ASSERT_ERR((((uint32_t)rie << 4) & ~((uint32_t)0x00000010)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000010)) | ((uint32_t)rie <<4));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_lie_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000008)) >> 3);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_lie_setf(uint8_t lie)
{
	ASSERT_ERR((((uint32_t)lie << 3) & ~((uint32_t)0x00000008)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000008)) | ((uint32_t)lie <<3));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_llp_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000004)) >> 2);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_llp_setf(uint8_t llp)
{
	ASSERT_ERR((((uint32_t)llp << 2) & ~((uint32_t)0x00000004)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000004)) | ((uint32_t)llp <<2));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_tcb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000002)) >> 1);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_tcb_setf(uint8_t tcb)
{
	ASSERT_ERR((((uint32_t)tcb << 1) & ~((uint32_t)0x00000002)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000002)) | ((uint32_t)tcb <<1));
}
__INLINE uint8_t pcie_ep_dma_ch_control_1_off_rdch_7_cb_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR);
	return (uint8_t)((localVal & ((uint32_t)0x00000001)) >> 0);
}
__INLINE void pcie_ep_dma_ch_control_1_off_rdch_7_cb_setf(uint8_t cb)
{
	ASSERT_ERR((((uint32_t)cb << 0) & ~((uint32_t)0x00000001)) == 0);
	REG_PL_WR(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR, (REG_PL_RD(PCIE_EP_DMA_CH_CONTROL_1_OFF_RDCH_7_ADDR) & ~((uint32_t)0x00000001)) | ((uint32_t)cb <<0));
}

/**
 * @brief DMA_TRANSFER_SIZE_OFF_RDCH_7 register definition
 *  This register holds the DMA read transfer size. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DMA_TRANSFER_SIZE         0x0
 * </pre>
 */
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D108)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_OFFSET      0x0000D108
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_INDEX       0x00003442
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_transfer_size_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_transfer_size_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_DMA_TRANSFER_SIZE_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_DMA_TRANSFER_SIZE_LSB    0
#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_DMA_TRANSFER_SIZE_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_DMA_TRANSFER_SIZE_RST    0x0

__INLINE uint32_t pcie_ep_dma_transfer_size_off_rdch_7_dma_transfer_size_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_transfer_size_off_rdch_7_dma_transfer_size_setf(uint32_t dmatransfersize)
{
	ASSERT_ERR((((uint32_t)dmatransfersize << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_TRANSFER_SIZE_OFF_RDCH_7_ADDR, (uint32_t)dmatransfersize << 0);
}

/**
 * @brief DMA_SAR_LOW_OFF_RDCH_7 register definition
 *  This register holds the lower 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D10C)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_OFFSET      0x0000D10C
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_INDEX       0x00003443
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_low_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_sar_low_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_SRC_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_SRC_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_SRC_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_SRC_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_low_off_rdch_7_src_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_low_off_rdch_7_src_addr_reg_low_setf(uint32_t srcaddrreglow)
{
	ASSERT_ERR((((uint32_t)srcaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_LOW_OFF_RDCH_7_ADDR, (uint32_t)srcaddrreglow << 0);
}

/**
 * @brief DMA_SAR_HIGH_OFF_RDCH_7 register definition
 *  This register holds the higher 32 bits of the Source Address Register (SAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SRC_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D110)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_OFFSET      0x0000D110
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_INDEX       0x00003444
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_sar_high_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_sar_high_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_SRC_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_SRC_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_SRC_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_SRC_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_sar_high_off_rdch_7_src_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_sar_high_off_rdch_7_src_addr_reg_high_setf(uint32_t srcaddrreghigh)
{
	ASSERT_ERR((((uint32_t)srcaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_SAR_HIGH_OFF_RDCH_7_ADDR, (uint32_t)srcaddrreghigh << 0);
}

/**
 * @brief DMA_DAR_LOW_OFF_RDCH_7 register definition
 *  This register holds the lower 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_LOW          0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D114)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_OFFSET      0x0000D114
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_INDEX       0x00003445
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_low_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_dar_low_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_DST_ADDR_REG_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_DST_ADDR_REG_LOW_LSB    0
#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_DST_ADDR_REG_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_DST_ADDR_REG_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_low_off_rdch_7_dst_addr_reg_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_low_off_rdch_7_dst_addr_reg_low_setf(uint32_t dstaddrreglow)
{
	ASSERT_ERR((((uint32_t)dstaddrreglow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_LOW_OFF_RDCH_7_ADDR, (uint32_t)dstaddrreglow << 0);
}

/**
 * @brief DMA_DAR_HIGH_OFF_RDCH_7 register definition
 *  This register holds the higher 32 bits of the Destination Address Register (DAR). register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DST_ADDR_REG_HIGH         0x0
 * </pre>
 */
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D118)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_OFFSET      0x0000D118
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_INDEX       0x00003446
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_dar_high_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_dar_high_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_DST_ADDR_REG_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_DST_ADDR_REG_HIGH_LSB    0
#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_DST_ADDR_REG_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_DST_ADDR_REG_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_dar_high_off_rdch_7_dst_addr_reg_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_dar_high_off_rdch_7_dst_addr_reg_high_setf(uint32_t dstaddrreghigh)
{
	ASSERT_ERR((((uint32_t)dstaddrreghigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_DAR_HIGH_OFF_RDCH_7_ADDR, (uint32_t)dstaddrreghigh << 0);
}

/**
 * @brief DMA_LLP_LOW_OFF_RDCH_7 register definition
 *  This register holds the lower 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_LOW                   0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D11C)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_OFFSET      0x0000D11C
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_INDEX       0x00003447
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_low_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_llp_low_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_LLP_LOW_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_LLP_LOW_LSB    0
#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_LLP_LOW_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_LLP_LOW_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_low_off_rdch_7_llp_low_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_low_off_rdch_7_llp_low_setf(uint32_t llplow)
{
	ASSERT_ERR((((uint32_t)llplow << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_LOW_OFF_RDCH_7_ADDR, (uint32_t)llplow << 0);
}

/**
 * @brief DMA_LLP_HIGH_OFF_RDCH_7 register definition
 *  This register holds the higher 32 bits of the DMA read linked list pointer. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 LLP_HIGH                  0x0
 * </pre>
 */
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_ADDR        (REG_PCIE_EP_BASE_ADDR+0x0000D120)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_OFFSET      0x0000D120
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_INDEX       0x00003448
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_RESET       0x00000000

__INLINE uint32_t  pcie_ep_dma_llp_high_off_rdch_7_get(void)
{
	return REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_ADDR);
}

__INLINE void pcie_ep_dma_llp_high_off_rdch_7_set(uint32_t value)
{
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_ADDR, value);
}

// field definitions
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_LLP_HIGH_MASK    ((uint32_t)0xFFFFFFFF)
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_LLP_HIGH_LSB    0
#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_LLP_HIGH_WIDTH    ((uint32_t)0x00000020)

#define PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_LLP_HIGH_RST    0x0

__INLINE uint32_t pcie_ep_dma_llp_high_off_rdch_7_llp_high_getf(void)
{
	uint32_t localVal = REG_PL_RD(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_ADDR);
	return (uint32_t)(localVal >> 0);
}
__INLINE void pcie_ep_dma_llp_high_off_rdch_7_llp_high_setf(uint32_t llphigh)
{
	ASSERT_ERR((((uint32_t)llphigh << 0) & ~((uint32_t)0xFFFFFFFF)) == 0);
	REG_PL_WR(PCIE_EP_DMA_LLP_HIGH_OFF_RDCH_7_ADDR, (uint32_t)llphigh << 0);
}


#undef DBG_FILEID
#endif //_REG_PCIE_EP_H_
