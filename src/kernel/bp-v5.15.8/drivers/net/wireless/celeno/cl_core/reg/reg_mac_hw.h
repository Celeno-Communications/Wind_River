/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
/* Copyright(c) 2019-2021, Celeno Communications Ltd. */

#ifndef REG_MAC_HW_H
#define REG_MAC_HW_H

#include "reg_access.h"
#include "chip.h"

/**
 * @brief SIGNATURE register definition
 *  Contains the Signature string register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SIGNATURE                 0x5
 * </pre>
 */
#define MAC_HW_SIGNATURE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000000)
#define MAC_HW_SIGNATURE_OFFSET      0x00000000
#define MAC_HW_SIGNATURE_INDEX       0x00000000
#define MAC_HW_SIGNATURE_RESET       0x00000005

static inline u32 mac_hw_signature_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SIGNATURE_ADDR);
}

/* Field definitions */
#define MAC_HW_SIGNATURE_SIGNATURE_MASK     ((u32)0xFFFFFFFF)
#define MAC_HW_SIGNATURE_SIGNATURE_LSB      0
#define MAC_HW_SIGNATURE_SIGNATURE_WIDTH    ((u32)0x00000020)

#define MAC_HW_SIGNATURE_SIGNATURE_RST      0x5

static inline u32 mac_hw_signature_signature_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SIGNATURE_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief VERSION_1 register definition
 *  Contains the Version String for this hardware build register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    18    BFMER                     0
 *    17    BFMEE                     0
 *    16    MAC_80211_MH_FORMAT       1
 *    14    COEX                      0
 *    13    WAPI                      1
 *    12    TPC                       0
 *    11    VHT                       1
 *    10    HT                        1
 *    08    RCE                       1
 *    07    CCMP                      1
 *    06    TKIP                      1
 *    05    WEP                       1
 *    04    SECURITY                  1
 *    03    SME                       1
 *    02    HCCA                      0
 *    01    EDCA                      1
 *    00    QOS                       1
 * </pre>
 */
#define MAC_HW_VERSION_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000004)
#define MAC_HW_VERSION_1_OFFSET      0x00000004
#define MAC_HW_VERSION_1_INDEX       0x00000001
#define MAC_HW_VERSION_1_RESET       0x00012DFB

static inline u32 mac_hw_version_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);
}

/* Field definitions */
#define MAC_HW_VERSION_1_BFMER_BIT          ((u32)0x00040000)
#define MAC_HW_VERSION_1_BFMER_POS          18
#define MAC_HW_VERSION_1_BFMEE_BIT          ((u32)0x00020000)
#define MAC_HW_VERSION_1_BFMEE_POS          17
#define MAC_HW_VERSION_1_MAC_80211_MH_FORMAT_BIT    ((u32)0x00010000)
#define MAC_HW_VERSION_1_MAC_80211_MH_FORMAT_POS    16
#define MAC_HW_VERSION_1_COEX_BIT           ((u32)0x00004000)
#define MAC_HW_VERSION_1_COEX_POS           14
#define MAC_HW_VERSION_1_WAPI_BIT           ((u32)0x00002000)
#define MAC_HW_VERSION_1_WAPI_POS           13
#define MAC_HW_VERSION_1_TPC_BIT            ((u32)0x00001000)
#define MAC_HW_VERSION_1_TPC_POS            12
#define MAC_HW_VERSION_1_VHT_BIT            ((u32)0x00000800)
#define MAC_HW_VERSION_1_VHT_POS            11
#define MAC_HW_VERSION_1_HT_BIT             ((u32)0x00000400)
#define MAC_HW_VERSION_1_HT_POS             10
#define MAC_HW_VERSION_1_RCE_BIT            ((u32)0x00000100)
#define MAC_HW_VERSION_1_RCE_POS            8
#define MAC_HW_VERSION_1_CCMP_BIT           ((u32)0x00000080)
#define MAC_HW_VERSION_1_CCMP_POS           7
#define MAC_HW_VERSION_1_TKIP_BIT           ((u32)0x00000040)
#define MAC_HW_VERSION_1_TKIP_POS           6
#define MAC_HW_VERSION_1_WEP_BIT            ((u32)0x00000020)
#define MAC_HW_VERSION_1_WEP_POS            5
#define MAC_HW_VERSION_1_SECURITY_BIT       ((u32)0x00000010)
#define MAC_HW_VERSION_1_SECURITY_POS       4
#define MAC_HW_VERSION_1_SME_BIT            ((u32)0x00000008)
#define MAC_HW_VERSION_1_SME_POS            3
#define MAC_HW_VERSION_1_HCCA_BIT           ((u32)0x00000004)
#define MAC_HW_VERSION_1_HCCA_POS           2
#define MAC_HW_VERSION_1_EDCA_BIT           ((u32)0x00000002)
#define MAC_HW_VERSION_1_EDCA_POS           1
#define MAC_HW_VERSION_1_QOS_BIT            ((u32)0x00000001)
#define MAC_HW_VERSION_1_QOS_POS            0

#define MAC_HW_VERSION_1_BFMER_RST          0x0
#define MAC_HW_VERSION_1_BFMEE_RST          0x0
#define MAC_HW_VERSION_1_MAC_80211_MH_FORMAT_RST    0x1
#define MAC_HW_VERSION_1_COEX_RST           0x0
#define MAC_HW_VERSION_1_WAPI_RST           0x1
#define MAC_HW_VERSION_1_TPC_RST            0x0
#define MAC_HW_VERSION_1_VHT_RST            0x1
#define MAC_HW_VERSION_1_HT_RST             0x1
#define MAC_HW_VERSION_1_RCE_RST            0x1
#define MAC_HW_VERSION_1_CCMP_RST           0x1
#define MAC_HW_VERSION_1_TKIP_RST           0x1
#define MAC_HW_VERSION_1_WEP_RST            0x1
#define MAC_HW_VERSION_1_SECURITY_RST       0x1
#define MAC_HW_VERSION_1_SME_RST            0x1
#define MAC_HW_VERSION_1_HCCA_RST           0x0
#define MAC_HW_VERSION_1_EDCA_RST           0x1
#define MAC_HW_VERSION_1_QOS_RST            0x1

static inline void mac_hw_version_1_unpack(struct cl_chip *chip, u8 *bfmer, u8 *bfmee, u8 *mac_80211_mh_format, u8 *coex, u8 *wapi, u8 *tpc, u8 *vht, u8 *ht, u8 *rce, u8 *ccmp, u8 *tkip, u8 *wep, u8 *security, u8 *sme, u8 *hcca, u8 *edca, u8 *qos)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	*bfmer = (local_val & ((u32)0x00040000)) >> 18;
	*bfmee = (local_val & ((u32)0x00020000)) >> 17;
	*mac_80211_mh_format = (local_val & ((u32)0x00010000)) >> 16;
	*coex = (local_val & ((u32)0x00004000)) >> 14;
	*wapi = (local_val & ((u32)0x00002000)) >> 13;
	*tpc = (local_val & ((u32)0x00001000)) >> 12;
	*vht = (local_val & ((u32)0x00000800)) >> 11;
	*ht = (local_val & ((u32)0x00000400)) >> 10;
	*rce = (local_val & ((u32)0x00000100)) >> 8;
	*ccmp = (local_val & ((u32)0x00000080)) >> 7;
	*tkip = (local_val & ((u32)0x00000040)) >> 6;
	*wep = (local_val & ((u32)0x00000020)) >> 5;
	*security = (local_val & ((u32)0x00000010)) >> 4;
	*sme = (local_val & ((u32)0x00000008)) >> 3;
	*hcca = (local_val & ((u32)0x00000004)) >> 2;
	*edca = (local_val & ((u32)0x00000002)) >> 1;
	*qos = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_version_1_bfmer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_version_1_bfmee_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_version_1_mac_80211_mh_format_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_version_1_coex_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_version_1_wapi_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_version_1_tpc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_version_1_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_version_1_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_version_1_rce_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_version_1_ccmp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_version_1_tkip_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_version_1_wep_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_version_1_security_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_version_1_sme_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_version_1_hcca_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_version_1_edca_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_version_1_qos_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_1_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief VERSION_2 register definition
 *  Contains the Version String for this hardware build register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    16:14 PHASE_NUMBER              0x2
 *    13:08 RELEASE_NUMBER            0xc
 *    07    IE_RELEASE                1
 *    06:00 UM_VERSION                0x21
 * </pre>
 */
#define MAC_HW_VERSION_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000008)
#define MAC_HW_VERSION_2_OFFSET      0x00000008
#define MAC_HW_VERSION_2_INDEX       0x00000002
#define MAC_HW_VERSION_2_RESET       0x00008CA1

static inline u32 mac_hw_version_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);
}

/* Field definitions */
#define MAC_HW_VERSION_2_PHASE_NUMBER_MASK    ((u32)0x0001C000)
#define MAC_HW_VERSION_2_PHASE_NUMBER_LSB    14
#define MAC_HW_VERSION_2_PHASE_NUMBER_WIDTH    ((u32)0x00000003)
#define MAC_HW_VERSION_2_RELEASE_NUMBER_MASK    ((u32)0x00003F00)
#define MAC_HW_VERSION_2_RELEASE_NUMBER_LSB    8
#define MAC_HW_VERSION_2_RELEASE_NUMBER_WIDTH    ((u32)0x00000006)
#define MAC_HW_VERSION_2_IE_RELEASE_BIT     ((u32)0x00000080)
#define MAC_HW_VERSION_2_IE_RELEASE_POS     7
#define MAC_HW_VERSION_2_UM_VERSION_MASK    ((u32)0x0000007F)
#define MAC_HW_VERSION_2_UM_VERSION_LSB     0
#define MAC_HW_VERSION_2_UM_VERSION_WIDTH    ((u32)0x00000007)

#define MAC_HW_VERSION_2_PHASE_NUMBER_RST    0x2
#define MAC_HW_VERSION_2_RELEASE_NUMBER_RST    0xc
#define MAC_HW_VERSION_2_IE_RELEASE_RST     0x1
#define MAC_HW_VERSION_2_UM_VERSION_RST     0x21

static inline void mac_hw_version_2_unpack(struct cl_chip *chip, u8 *phase_number, u8 *release_number, u8 *ie_release, u8 *um_version)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);

	*phase_number = (local_val & ((u32)0x0001C000)) >> 14;
	*release_number = (local_val & ((u32)0x00003F00)) >> 8;
	*ie_release = (local_val & ((u32)0x00000080)) >> 7;
	*um_version = (local_val & ((u32)0x0000007F)) >> 0;
}

static inline u8 mac_hw_version_2_phase_number_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);

	return (u8)((local_val & ((u32)0x0001C000)) >> 14);
}

static inline u8 mac_hw_version_2_release_number_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);

	return (u8)((local_val & ((u32)0x00003F00)) >> 8);
}

static inline u8 mac_hw_version_2_ie_release_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_version_2_um_version_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VERSION_2_ADDR);

	return (u8)((local_val & ((u32)0x0000007F)) >> 0);
}

/**
 * @brief BITMAP_CNT register definition
 *  This indicates the current Bitmap number. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 BITMAP_CNT                0x1
 * </pre>
 */
#define MAC_HW_BITMAP_CNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000000C)
#define MAC_HW_BITMAP_CNT_OFFSET      0x0000000C
#define MAC_HW_BITMAP_CNT_INDEX       0x00000003
#define MAC_HW_BITMAP_CNT_RESET       0x00000001

static inline u32 mac_hw_bitmap_cnt_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BITMAP_CNT_ADDR);
}

/* Field definitions */
#define MAC_HW_BITMAP_CNT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BITMAP_CNT_LSB    0
#define MAC_HW_BITMAP_CNT_WIDTH    ((u32)0x00000010)

#define MAC_HW_BITMAP_CNT_BITMAP_CNT_RST    0x1

static inline u16 mac_hw_bitmap_cnt_bitmap_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BITMAP_CNT_ADDR);

	return (u16)(local_val >> 0);
}

/**
 * @brief MAC_ADDR_LOW register definition
 *  This device's MAC address is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MAC_ADDR_LOW              0x0
 * </pre>
 */
#define MAC_HW_MAC_ADDR_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000010)
#define MAC_HW_MAC_ADDR_LOW_OFFSET      0x00000010
#define MAC_HW_MAC_ADDR_LOW_INDEX       0x00000004
#define MAC_HW_MAC_ADDR_LOW_RESET       0x00000000

static inline u32 mac_hw_mac_addr_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_ADDR_LOW_ADDR);
}

static inline void mac_hw_mac_addr_low_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ADDR_LOW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ADDR_LOW_MAC_ADDR_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_MAC_ADDR_LOW_MAC_ADDR_LOW_LSB    0
#define MAC_HW_MAC_ADDR_LOW_MAC_ADDR_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_MAC_ADDR_LOW_MAC_ADDR_LOW_RST    0x0

static inline u32 mac_hw_mac_addr_low_mac_addr_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ADDR_LOW_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_mac_addr_low_mac_addr_low_setf(struct cl_chip *chip, u32 macaddrlow)
{
	ASSERT_ERR_CHIP((((u32)macaddrlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ADDR_LOW_ADDR, (u32)macaddrlow << 0);
}

/**
 * @brief MAC_ADDR_HI register definition
 *  This device's MAC address is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 MAC_ADDR_HIGH             0x0
 * </pre>
 */
#define MAC_HW_MAC_ADDR_HI_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000014)
#define MAC_HW_MAC_ADDR_HI_OFFSET      0x00000014
#define MAC_HW_MAC_ADDR_HI_INDEX       0x00000005
#define MAC_HW_MAC_ADDR_HI_RESET       0x00000000

static inline u32 mac_hw_mac_addr_hi_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_ADDR_HI_ADDR);
}

static inline void mac_hw_mac_addr_hi_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ADDR_HI_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ADDR_HI_MAC_ADDR_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_MAC_ADDR_HI_MAC_ADDR_HIGH_LSB    0
#define MAC_HW_MAC_ADDR_HI_MAC_ADDR_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_MAC_ADDR_HI_MAC_ADDR_HIGH_RST    0x0

static inline u16 mac_hw_mac_addr_hi_mac_addr_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ADDR_HI_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_mac_addr_hi_mac_addr_high_setf(struct cl_chip *chip, u16 macaddrhigh)
{
	ASSERT_ERR_CHIP((((u32)macaddrhigh << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ADDR_HI_ADDR, (u32)macaddrhigh << 0);
}

/**
 * @brief MAC_ADDR_LOW_MASK register definition
 *  This device's MAC address mask is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MAC_ADDR_LOW_MASK         0x0
 * </pre>
 */
#define MAC_HW_MAC_ADDR_LOW_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000018)
#define MAC_HW_MAC_ADDR_LOW_MASK_OFFSET      0x00000018
#define MAC_HW_MAC_ADDR_LOW_MASK_INDEX       0x00000006
#define MAC_HW_MAC_ADDR_LOW_MASK_RESET       0x00000000

static inline u32 mac_hw_mac_addr_low_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_ADDR_LOW_MASK_ADDR);
}

static inline void mac_hw_mac_addr_low_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ADDR_LOW_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ADDR_LOW_MASK_MAC_ADDR_LOW_MASK_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_MAC_ADDR_LOW_MASK_MAC_ADDR_LOW_MASK_LSB    0
#define MAC_HW_MAC_ADDR_LOW_MASK_MAC_ADDR_LOW_MASK_WIDTH    ((u32)0x00000020)

#define MAC_HW_MAC_ADDR_LOW_MASK_MAC_ADDR_LOW_MASK_RST    0x0

static inline u32 mac_hw_mac_addr_low_mask_mac_addr_low_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ADDR_LOW_MASK_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_mac_addr_low_mask_mac_addr_low_mask_setf(struct cl_chip *chip, u32 macaddrlowmask)
{
	ASSERT_ERR_CHIP((((u32)macaddrlowmask << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ADDR_LOW_MASK_ADDR, (u32)macaddrlowmask << 0);
}

/**
 * @brief MAC_ADDR_HI_MASK register definition
 *  This device's MAC address mask is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 MAC_ADDR_HIGH_MASK        0x0
 * </pre>
 */
#define MAC_HW_MAC_ADDR_HI_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000001C)
#define MAC_HW_MAC_ADDR_HI_MASK_OFFSET      0x0000001C
#define MAC_HW_MAC_ADDR_HI_MASK_INDEX       0x00000007
#define MAC_HW_MAC_ADDR_HI_MASK_RESET       0x00000000

static inline u32 mac_hw_mac_addr_hi_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_ADDR_HI_MASK_ADDR);
}

static inline void mac_hw_mac_addr_hi_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ADDR_HI_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ADDR_HI_MASK_MAC_ADDR_HIGH_MASK_MASK    ((u32)0x0000FFFF)
#define MAC_HW_MAC_ADDR_HI_MASK_MAC_ADDR_HIGH_MASK_LSB    0
#define MAC_HW_MAC_ADDR_HI_MASK_MAC_ADDR_HIGH_MASK_WIDTH    ((u32)0x00000010)

#define MAC_HW_MAC_ADDR_HI_MASK_MAC_ADDR_HIGH_MASK_RST    0x0

static inline u16 mac_hw_mac_addr_hi_mask_mac_addr_high_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ADDR_HI_MASK_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_mac_addr_hi_mask_mac_addr_high_mask_setf(struct cl_chip *chip, u16 macaddrhighmask)
{
	ASSERT_ERR_CHIP((((u32)macaddrhighmask << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ADDR_HI_MASK_ADDR, (u32)macaddrhighmask << 0);
}

/**
 * @brief BSS_ID_LOW register definition
 *  The BSSID of this BSS/IBSS is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 BSS_ID_LOW                0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000020)
#define MAC_HW_BSS_ID_LOW_OFFSET      0x00000020
#define MAC_HW_BSS_ID_LOW_INDEX       0x00000008
#define MAC_HW_BSS_ID_LOW_RESET       0x00000000

static inline u32 mac_hw_bss_id_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_LOW_ADDR);
}

static inline void mac_hw_bss_id_low_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_LOW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_LOW_BSS_ID_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_BSS_ID_LOW_BSS_ID_LOW_LSB    0
#define MAC_HW_BSS_ID_LOW_BSS_ID_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_BSS_ID_LOW_BSS_ID_LOW_RST    0x0

static inline u32 mac_hw_bss_id_low_bss_id_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_LOW_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_bss_id_low_bss_id_low_setf(struct cl_chip *chip, u32 bssidlow)
{
	ASSERT_ERR_CHIP((((u32)bssidlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_LOW_ADDR, (u32)bssidlow << 0);
}

/**
 * @brief BSS_ID_HI register definition
 *  The BSSID of this BSS/IBSS is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 MY_BSS_COLOR              0x0
 *    15:00 BSS_ID_HIGH               0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_HI_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000024)
#define MAC_HW_BSS_ID_HI_OFFSET      0x00000024
#define MAC_HW_BSS_ID_HI_INDEX       0x00000009
#define MAC_HW_BSS_ID_HI_RESET       0x00000000

static inline u32 mac_hw_bss_id_hi_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR);
}

static inline void mac_hw_bss_id_hi_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_HI_MY_BSS_COLOR_MASK    ((u32)0x003F0000)
#define MAC_HW_BSS_ID_HI_MY_BSS_COLOR_LSB    16
#define MAC_HW_BSS_ID_HI_MY_BSS_COLOR_WIDTH    ((u32)0x00000006)
#define MAC_HW_BSS_ID_HI_BSS_ID_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BSS_ID_HI_BSS_ID_HIGH_LSB    0
#define MAC_HW_BSS_ID_HI_BSS_ID_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_BSS_ID_HI_MY_BSS_COLOR_RST    0x0
#define MAC_HW_BSS_ID_HI_BSS_ID_HIGH_RST    0x0

static inline void mac_hw_bss_id_hi_pack(struct cl_chip *chip, u8 my_bss_color, u16 bss_id_high)
{
	ASSERT_ERR_CHIP((((u32)my_bss_color << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_id_high << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_ADDR, ((u32)my_bss_color << 16) | ((u32)bss_id_high << 0));
}

static inline void mac_hw_bss_id_hi_unpack(struct cl_chip *chip, u8 *my_bss_color, u16 *bss_id_high)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR);

	*my_bss_color = (local_val & ((u32)0x003F0000)) >> 16;
	*bss_id_high = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bss_id_hi_my_bss_color_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_bss_id_hi_my_bss_color_setf(struct cl_chip *chip, u8 mybsscolor)
{
	ASSERT_ERR_CHIP((((u32)mybsscolor << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_ADDR, (cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR) & ~((u32)0x003F0000)) | ((u32)mybsscolor << 16));
}

static inline u16 mac_hw_bss_id_hi_bss_id_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bss_id_hi_bss_id_high_setf(struct cl_chip *chip, u16 bssidhigh)
{
	ASSERT_ERR_CHIP((((u32)bssidhigh << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_ADDR, (cl_reg_read(chip, MAC_HW_BSS_ID_HI_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bssidhigh << 0));
}

/**
 * @brief BSS_ID_LOW_MASK register definition
 *  The mask pattern for the BSSID of this BSS/IBSS is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 BSS_ID_LOW_MASK           0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_LOW_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000028)
#define MAC_HW_BSS_ID_LOW_MASK_OFFSET      0x00000028
#define MAC_HW_BSS_ID_LOW_MASK_INDEX       0x0000000A
#define MAC_HW_BSS_ID_LOW_MASK_RESET       0x00000000

static inline u32 mac_hw_bss_id_low_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_LOW_MASK_ADDR);
}

static inline void mac_hw_bss_id_low_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_LOW_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_LOW_MASK_BSS_ID_LOW_MASK_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_BSS_ID_LOW_MASK_BSS_ID_LOW_MASK_LSB    0
#define MAC_HW_BSS_ID_LOW_MASK_BSS_ID_LOW_MASK_WIDTH    ((u32)0x00000020)

#define MAC_HW_BSS_ID_LOW_MASK_BSS_ID_LOW_MASK_RST    0x0

static inline u32 mac_hw_bss_id_low_mask_bss_id_low_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_LOW_MASK_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_bss_id_low_mask_bss_id_low_mask_setf(struct cl_chip *chip, u32 bssidlowmask)
{
	ASSERT_ERR_CHIP((((u32)bssidlowmask << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_LOW_MASK_ADDR, (u32)bssidlowmask << 0);
}

/**
 * @brief BSS_ID_HI_MASK register definition
 *  The mask pattern for the BSSID of this BSS/IBSS is loaded here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 MY_BSS_COLOR_MASK         0x0
 *    15:00 BSS_ID_HIGH_MASK          0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_HI_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000002C)
#define MAC_HW_BSS_ID_HI_MASK_OFFSET      0x0000002C
#define MAC_HW_BSS_ID_HI_MASK_INDEX       0x0000000B
#define MAC_HW_BSS_ID_HI_MASK_RESET       0x00000000

static inline u32 mac_hw_bss_id_hi_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR);
}

static inline void mac_hw_bss_id_hi_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_HI_MASK_MY_BSS_COLOR_MASK_MASK    ((u32)0x003F0000)
#define MAC_HW_BSS_ID_HI_MASK_MY_BSS_COLOR_MASK_LSB    16
#define MAC_HW_BSS_ID_HI_MASK_MY_BSS_COLOR_MASK_WIDTH    ((u32)0x00000006)
#define MAC_HW_BSS_ID_HI_MASK_BSS_ID_HIGH_MASK_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BSS_ID_HI_MASK_BSS_ID_HIGH_MASK_LSB    0
#define MAC_HW_BSS_ID_HI_MASK_BSS_ID_HIGH_MASK_WIDTH    ((u32)0x00000010)

#define MAC_HW_BSS_ID_HI_MASK_MY_BSS_COLOR_MASK_RST    0x0
#define MAC_HW_BSS_ID_HI_MASK_BSS_ID_HIGH_MASK_RST    0x0

static inline void mac_hw_bss_id_hi_mask_pack(struct cl_chip *chip, u8 my_bss_color_mask, u16 bss_id_high_mask)
{
	ASSERT_ERR_CHIP((((u32)my_bss_color_mask << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_id_high_mask << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_MASK_ADDR, ((u32)my_bss_color_mask << 16) | ((u32)bss_id_high_mask << 0));
}

static inline void mac_hw_bss_id_hi_mask_unpack(struct cl_chip *chip, u8 *my_bss_color_mask, u16 *bss_id_high_mask)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR);

	*my_bss_color_mask = (local_val & ((u32)0x003F0000)) >> 16;
	*bss_id_high_mask = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bss_id_hi_mask_my_bss_color_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_bss_id_hi_mask_my_bss_color_mask_setf(struct cl_chip *chip, u8 mybsscolormask)
{
	ASSERT_ERR_CHIP((((u32)mybsscolormask << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_MASK_ADDR, (cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR) & ~((u32)0x003F0000)) | ((u32)mybsscolormask << 16));
}

static inline u16 mac_hw_bss_id_hi_mask_bss_id_high_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bss_id_hi_mask_bss_id_high_mask_setf(struct cl_chip *chip, u16 bssidhighmask)
{
	ASSERT_ERR_CHIP((((u32)bssidhighmask << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_HI_MASK_ADDR, (cl_reg_read(chip, MAC_HW_BSS_ID_HI_MASK_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bssidhighmask << 0));
}

/**
 * @brief MBSS_SPACE register definition
 *  Multi BSS space register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    09:00 MBSS_BEACON_SPACE         0x0
 * </pre>
 */
#define MAC_HW_MBSS_SPACE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000030)
#define MAC_HW_MBSS_SPACE_OFFSET      0x00000030
#define MAC_HW_MBSS_SPACE_INDEX       0x0000000C
#define MAC_HW_MBSS_SPACE_RESET       0x00000000

static inline u32 mac_hw_mbss_space_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MBSS_SPACE_ADDR);
}

static inline void mac_hw_mbss_space_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MBSS_SPACE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MBSS_SPACE_MBSS_BEACON_SPACE_MASK    ((u32)0x000003FF)
#define MAC_HW_MBSS_SPACE_MBSS_BEACON_SPACE_LSB    0
#define MAC_HW_MBSS_SPACE_MBSS_BEACON_SPACE_WIDTH    ((u32)0x0000000A)

#define MAC_HW_MBSS_SPACE_MBSS_BEACON_SPACE_RST    0x0

static inline u16 mac_hw_mbss_space_mbss_beacon_space_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_SPACE_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_mbss_space_mbss_beacon_space_setf(struct cl_chip *chip, u16 mbssbeaconspace)
{
	ASSERT_ERR_CHIP((((u32)mbssbeaconspace << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_SPACE_ADDR, (u32)mbssbeaconspace << 0);
}

/**
 * @brief MBSS_ADDR_2_SEL register definition
 *  Multi BSS address select register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:24 MBSS_A2_SEL4              0x0
 *    21:16 MBSS_A2_SEL3              0x0
 *    13:08 MBSS_A2_SEL2              0x0
 *    05:00 MBSS_A2_SEL1              0x0
 * </pre>
 */
#define MAC_HW_MBSS_ADDR_2_SEL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000034)
#define MAC_HW_MBSS_ADDR_2_SEL_OFFSET      0x00000034
#define MAC_HW_MBSS_ADDR_2_SEL_INDEX       0x0000000D
#define MAC_HW_MBSS_ADDR_2_SEL_RESET       0x00000000

static inline u32 mac_hw_mbss_addr_2_sel_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);
}

static inline void mac_hw_mbss_addr_2_sel_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_4_MASK    ((u32)0x3F000000)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_4_LSB    24
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_4_WIDTH    ((u32)0x00000006)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_3_MASK    ((u32)0x003F0000)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_3_LSB    16
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_3_WIDTH    ((u32)0x00000006)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_2_MASK    ((u32)0x00003F00)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_2_LSB    8
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_2_WIDTH    ((u32)0x00000006)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_1_MASK    ((u32)0x0000003F)
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_1_LSB    0
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_1_WIDTH    ((u32)0x00000006)

#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_4_RST    0x0
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_3_RST    0x0
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_2_RST    0x0
#define MAC_HW_MBSS_ADDR_2_SEL_MBSS_A_2_SEL_1_RST    0x0

static inline void mac_hw_mbss_addr_2_sel_pack(struct cl_chip *chip, u8 mbss_a2_sel4, u8 mbss_a2_sel3, u8 mbss_a2_sel2, u8 mbss_a2_sel1)
{
	ASSERT_ERR_CHIP((((u32)mbss_a2_sel4 << 24) & ~((u32)0x3F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)mbss_a2_sel3 << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)mbss_a2_sel2 << 8) & ~((u32)0x00003F00)) == 0);
	ASSERT_ERR_CHIP((((u32)mbss_a2_sel1 << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, ((u32)mbss_a2_sel4 << 24) | ((u32)mbss_a2_sel3 << 16) | ((u32)mbss_a2_sel2 << 8) | ((u32)mbss_a2_sel1 << 0));
}

static inline void mac_hw_mbss_addr_2_sel_unpack(struct cl_chip *chip, u8 *mbss_a2_sel4, u8 *mbss_a2_sel3, u8 *mbss_a2_sel2, u8 *mbss_a2_sel1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);

	*mbss_a2_sel4 = (local_val & ((u32)0x3F000000)) >> 24;
	*mbss_a2_sel3 = (local_val & ((u32)0x003F0000)) >> 16;
	*mbss_a2_sel2 = (local_val & ((u32)0x00003F00)) >> 8;
	*mbss_a2_sel1 = (local_val & ((u32)0x0000003F)) >> 0;
}

static inline u8 mac_hw_mbss_addr_2_sel_mbss_a_2_sel_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);

	return (u8)((local_val & ((u32)0x3F000000)) >> 24);
}

static inline void mac_hw_mbss_addr_2_sel_mbss_a_2_sel_4_setf(struct cl_chip *chip, u8 mbssa2sel4)
{
	ASSERT_ERR_CHIP((((u32)mbssa2sel4 << 24) & ~((u32)0x3F000000)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, (cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR) & ~((u32)0x3F000000)) | ((u32)mbssa2sel4 << 24));
}

static inline u8 mac_hw_mbss_addr_2_sel_mbss_a_2_sel_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_mbss_addr_2_sel_mbss_a_2_sel_3_setf(struct cl_chip *chip, u8 mbssa2sel3)
{
	ASSERT_ERR_CHIP((((u32)mbssa2sel3 << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, (cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR) & ~((u32)0x003F0000)) | ((u32)mbssa2sel3 << 16));
}

static inline u8 mac_hw_mbss_addr_2_sel_mbss_a_2_sel_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);

	return (u8)((local_val & ((u32)0x00003F00)) >> 8);
}

static inline void mac_hw_mbss_addr_2_sel_mbss_a_2_sel_2_setf(struct cl_chip *chip, u8 mbssa2sel2)
{
	ASSERT_ERR_CHIP((((u32)mbssa2sel2 << 8) & ~((u32)0x00003F00)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, (cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR) & ~((u32)0x00003F00)) | ((u32)mbssa2sel2 << 8));
}

static inline u8 mac_hw_mbss_addr_2_sel_mbss_a_2_sel_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR);

	return (u8)((local_val & ((u32)0x0000003F)) >> 0);
}

static inline void mac_hw_mbss_addr_2_sel_mbss_a_2_sel_1_setf(struct cl_chip *chip, u8 mbssa2sel1)
{
	ASSERT_ERR_CHIP((((u32)mbssa2sel1 << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR, (cl_reg_read(chip, MAC_HW_MBSS_ADDR_2_SEL_ADDR) & ~((u32)0x0000003F)) | ((u32)mbssa2sel1 << 0));
}

/**
 * @brief STATE_CNTRL register definition
 *  This register controls the core'state transitions. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:04 NEXT_STATE                0x0
 *    03:00 CURRENT_STATE             0x0
 * </pre>
 */
#define MAC_HW_STATE_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000038)
#define MAC_HW_STATE_CNTRL_OFFSET      0x00000038
#define MAC_HW_STATE_CNTRL_INDEX       0x0000000E
#define MAC_HW_STATE_CNTRL_RESET       0x00000000

static inline u32 mac_hw_state_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_STATE_CNTRL_ADDR);
}

static inline void mac_hw_state_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_STATE_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_STATE_CNTRL_NEXT_STATE_MASK    ((u32)0x000000F0)
#define MAC_HW_STATE_CNTRL_NEXT_STATE_LSB    4
#define MAC_HW_STATE_CNTRL_NEXT_STATE_WIDTH    ((u32)0x00000004)
#define MAC_HW_STATE_CNTRL_CURRENT_STATE_MASK    ((u32)0x0000000F)
#define MAC_HW_STATE_CNTRL_CURRENT_STATE_LSB    0
#define MAC_HW_STATE_CNTRL_CURRENT_STATE_WIDTH    ((u32)0x00000004)

#define MAC_HW_STATE_CNTRL_NEXT_STATE_RST    0x0
#define MAC_HW_STATE_CNTRL_CURRENT_STATE_RST    0x0

static inline void mac_hw_state_cntrl_pack(struct cl_chip *chip, u8 next_state, u8 current_state)
{
	ASSERT_ERR_CHIP((((u32)next_state << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)current_state << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_STATE_CNTRL_ADDR, ((u32)next_state << 4) | ((u32)current_state << 0));
}

static inline void mac_hw_state_cntrl_unpack(struct cl_chip *chip, u8 *next_state, u8 *current_state)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STATE_CNTRL_ADDR);

	*next_state = (local_val & ((u32)0x000000F0)) >> 4;
	*current_state = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_state_cntrl_next_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STATE_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_state_cntrl_next_state_setf(struct cl_chip *chip, u8 nextstate)
{
	ASSERT_ERR_CHIP((((u32)nextstate << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_STATE_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_STATE_CNTRL_ADDR) & ~((u32)0x000000F0)) | ((u32)nextstate << 4));
}

static inline u8 mac_hw_state_cntrl_current_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STATE_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

/**
 * @brief SCAN_CNTRL register definition
 *  Contains settings for controlling SCAN state. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 PROBE_DELAY               0x0
 * </pre>
 */
#define MAC_HW_SCAN_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000003C)
#define MAC_HW_SCAN_CNTRL_OFFSET      0x0000003C
#define MAC_HW_SCAN_CNTRL_INDEX       0x0000000F
#define MAC_HW_SCAN_CNTRL_RESET       0x00000000

static inline u32 mac_hw_scan_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SCAN_CNTRL_ADDR);
}

static inline void mac_hw_scan_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SCAN_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SCAN_CNTRL_PROBE_DELAY_MASK    ((u32)0x0000FFFF)
#define MAC_HW_SCAN_CNTRL_PROBE_DELAY_LSB    0
#define MAC_HW_SCAN_CNTRL_PROBE_DELAY_WIDTH    ((u32)0x00000010)

#define MAC_HW_SCAN_CNTRL_PROBE_DELAY_RST    0x0

static inline u16 mac_hw_scan_cntrl_probe_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SCAN_CNTRL_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_scan_cntrl_probe_delay_setf(struct cl_chip *chip, u16 probedelay)
{
	ASSERT_ERR_CHIP((((u32)probedelay << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SCAN_CNTRL_ADDR, (u32)probedelay << 0);
}

/**
 * @brief BSS_ID_FOR_CF_END_LOW register definition
 *  Contains TA for CFEND frame   register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 BSS_ID_FOR_CF_END_LOW     0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000040)
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_OFFSET      0x00000040
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_INDEX       0x00000010
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_RESET       0x00000000

static inline u32 mac_hw_bss_id_for_cf_end_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_FOR_CF_END_LOW_ADDR);
}

static inline void mac_hw_bss_id_for_cf_end_low_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_FOR_CF_END_LOW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_BSS_ID_FOR_CF_END_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_BSS_ID_FOR_CF_END_LOW_LSB    0
#define MAC_HW_BSS_ID_FOR_CF_END_LOW_BSS_ID_FOR_CF_END_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_BSS_ID_FOR_CF_END_LOW_BSS_ID_FOR_CF_END_LOW_RST    0x0

static inline u32 mac_hw_bss_id_for_cf_end_low_bss_id_for_cf_end_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_FOR_CF_END_LOW_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_bss_id_for_cf_end_low_bss_id_for_cf_end_low_setf(struct cl_chip *chip, u32 bssidforcfendlow)
{
	ASSERT_ERR_CHIP((((u32)bssidforcfendlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_FOR_CF_END_LOW_ADDR, (u32)bssidforcfendlow << 0);
}

/**
 * @brief DOZE_CNTRL_1 register definition
 *  Contains settings for controlling DOZE state. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:17 ATIM_W                    0x0
 *    16    WAKEUP_DTIM               0
 *    15:00 LISTEN_INTERVAL           0x0
 * </pre>
 */
#define MAC_HW_DOZE_CNTRL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000044)
#define MAC_HW_DOZE_CNTRL_1_OFFSET      0x00000044
#define MAC_HW_DOZE_CNTRL_1_INDEX       0x00000011
#define MAC_HW_DOZE_CNTRL_1_RESET       0x00000000

static inline u32 mac_hw_doze_cntrl_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR);
}

static inline void mac_hw_doze_cntrl_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DOZE_CNTRL_1_ATIM_W_MASK     ((u32)0xFFFE0000)
#define MAC_HW_DOZE_CNTRL_1_ATIM_W_LSB      17
#define MAC_HW_DOZE_CNTRL_1_ATIM_W_WIDTH    ((u32)0x0000000F)
#define MAC_HW_DOZE_CNTRL_1_WAKEUP_DTIM_BIT    ((u32)0x00010000)
#define MAC_HW_DOZE_CNTRL_1_WAKEUP_DTIM_POS    16
#define MAC_HW_DOZE_CNTRL_1_LISTEN_INTERVAL_MASK    ((u32)0x0000FFFF)
#define MAC_HW_DOZE_CNTRL_1_LISTEN_INTERVAL_LSB    0
#define MAC_HW_DOZE_CNTRL_1_LISTEN_INTERVAL_WIDTH    ((u32)0x00000010)

#define MAC_HW_DOZE_CNTRL_1_ATIM_W_RST      0x0
#define MAC_HW_DOZE_CNTRL_1_WAKEUP_DTIM_RST    0x0
#define MAC_HW_DOZE_CNTRL_1_LISTEN_INTERVAL_RST    0x0

static inline void mac_hw_doze_cntrl_1_pack(struct cl_chip *chip, u16 atim_w, u8 wakeup_dtim, u16 listen_interval)
{
	ASSERT_ERR_CHIP((((u32)atim_w << 17) & ~((u32)0xFFFE0000)) == 0);
	ASSERT_ERR_CHIP((((u32)wakeup_dtim << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)listen_interval << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_1_ADDR, ((u32)atim_w << 17) | ((u32)wakeup_dtim << 16) | ((u32)listen_interval << 0));
}

static inline void mac_hw_doze_cntrl_1_unpack(struct cl_chip *chip, u16 *atim_w, u8 *wakeup_dtim, u16 *listen_interval)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR);

	*atim_w = (local_val & ((u32)0xFFFE0000)) >> 17;
	*wakeup_dtim = (local_val & ((u32)0x00010000)) >> 16;
	*listen_interval = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_doze_cntrl_1_atim_w_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR);

	return (u16)((local_val & ((u32)0xFFFE0000)) >> 17);
}

static inline void mac_hw_doze_cntrl_1_atim_w_setf(struct cl_chip *chip, u16 atimw)
{
	ASSERT_ERR_CHIP((((u32)atimw << 17) & ~((u32)0xFFFE0000)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR) & ~((u32)0xFFFE0000)) | ((u32)atimw << 17));
}

static inline u8 mac_hw_doze_cntrl_1_wakeup_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_doze_cntrl_1_wakeup_dtim_setf(struct cl_chip *chip, u8 wakeupdtim)
{
	ASSERT_ERR_CHIP((((u32)wakeupdtim << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR) & ~((u32)0x00010000)) | ((u32)wakeupdtim << 16));
}

static inline u16 mac_hw_doze_cntrl_1_listen_interval_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_doze_cntrl_1_listen_interval_setf(struct cl_chip *chip, u16 listeninterval)
{
	ASSERT_ERR_CHIP((((u32)listeninterval << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_DOZE_CNTRL_1_ADDR) & ~((u32)0x0000FFFF)) | ((u32)listeninterval << 0));
}

/**
 * @brief BSS_ID_FOR_CF_END_HIGH register definition
 *  Contains TA for CFEND frame register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 BSS_ID_FOR_CF_END_HIGH    0x0
 * </pre>
 */
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000048)
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_OFFSET      0x00000048
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_INDEX       0x00000012
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_RESET       0x00000000

static inline u32 mac_hw_bss_id_for_cf_end_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSS_ID_FOR_CF_END_HIGH_ADDR);
}

static inline void mac_hw_bss_id_for_cf_end_high_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSS_ID_FOR_CF_END_HIGH_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_LSB    0
#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_BSS_ID_FOR_CF_END_HIGH_BSS_ID_FOR_CF_END_HIGH_RST    0x0

static inline u16 mac_hw_bss_id_for_cf_end_high_bss_id_for_cf_end_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSS_ID_FOR_CF_END_HIGH_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bss_id_for_cf_end_high_bss_id_for_cf_end_high_setf(struct cl_chip *chip, u16 bssidforcfendhigh)
{
	ASSERT_ERR_CHIP((((u32)bssidforcfendhigh << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSS_ID_FOR_CF_END_HIGH_ADDR, (u32)bssidforcfendhigh << 0);
}

/**
 * @brief MAC_CNTRL_1 register definition
 *  Contains various settings for controlling the operation of the core. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EOF_PAD_FOR_HE            1
 *    30    EOF_PAD_FOR_VHT           0
 *    29:28 IMPLICIT_BF_INT_CONF      0x0
 *    27    DISABLE_BFR_RESP          0
 *    26    RX_RIFS_EN                0
 *    25    TSF_MGT_DISABLE           0
 *    24    TSF_UPDATED_BY_SW         0
 *    22    MAC_DETECT_UNDERRUN_EN    0
 *    21    DISABLE_MU_CTS_RESP       0
 *    20    BQRP_RESP_BY_FW           0
 *    19    BSRP_RESP_BY_FW           0
 *    18    ENABLE_NORMAL_ACK_RESP_IN_HE_MU_W_TRIG 0
 *    17    DISABLE_NORMAL_ACK_RESP_IN_HE_MU_WO_TRIG 0
 *    16:14 ABGN_MODE                 0x3
 *    13    KEY_STO_RAM_RESET         0
 *    12    MIB_TABLE_RESET           0
 *    11    RATE_CONTROLLER_MPIF      1
 *    10    DISABLE_BA_RESP           0
 *    09    DISABLE_CTS_RESP          0
 *    08    DISABLE_ACK_RESP          0
 *    07    ACTIVE_CLK_GATING         1
 *    06    ENABLE_LP_CLK_SWITCH      0
 *    05    FORCE_MSTA_BA             0
 *    04    DISABLE_FAST_COMPARE      0
 *    03    CFP_AWARE                 0
 *    02    PWR_MGT                   0
 *    01    AP                        0
 *    00    BSS_TYPE                  1
 * </pre>
 */
#define MAC_HW_MAC_CNTRL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000004C)
#define MAC_HW_MAC_CNTRL_1_OFFSET      0x0000004C
#define MAC_HW_MAC_CNTRL_1_INDEX       0x00000013
#define MAC_HW_MAC_CNTRL_1_RESET       0x8000C881

static inline u32 mac_hw_mac_cntrl_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);
}

static inline void mac_hw_mac_cntrl_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_HE_BIT    ((u32)0x80000000)
#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_HE_POS    31
#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_VHT_BIT    ((u32)0x40000000)
#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_VHT_POS    30
#define MAC_HW_MAC_CNTRL_1_IMPLICIT_BF_INT_CONF_MASK    ((u32)0x30000000)
#define MAC_HW_MAC_CNTRL_1_IMPLICIT_BF_INT_CONF_LSB    28
#define MAC_HW_MAC_CNTRL_1_IMPLICIT_BF_INT_CONF_WIDTH    ((u32)0x00000002)
#define MAC_HW_MAC_CNTRL_1_DISABLE_BFR_RESP_BIT    ((u32)0x08000000)
#define MAC_HW_MAC_CNTRL_1_DISABLE_BFR_RESP_POS    27
#define MAC_HW_MAC_CNTRL_1_RX_RIFS_EN_BIT    ((u32)0x04000000)
#define MAC_HW_MAC_CNTRL_1_RX_RIFS_EN_POS    26
#define MAC_HW_MAC_CNTRL_1_TSF_MGT_DISABLE_BIT    ((u32)0x02000000)
#define MAC_HW_MAC_CNTRL_1_TSF_MGT_DISABLE_POS    25
#define MAC_HW_MAC_CNTRL_1_TSF_UPDATED_BY_SW_BIT    ((u32)0x01000000)
#define MAC_HW_MAC_CNTRL_1_TSF_UPDATED_BY_SW_POS    24
#define MAC_HW_MAC_CNTRL_1_MAC_DETECT_UNDERRUN_EN_BIT    ((u32)0x00400000)
#define MAC_HW_MAC_CNTRL_1_MAC_DETECT_UNDERRUN_EN_POS    22
#define MAC_HW_MAC_CNTRL_1_DISABLE_MU_CTS_RESP_BIT    ((u32)0x00200000)
#define MAC_HW_MAC_CNTRL_1_DISABLE_MU_CTS_RESP_POS    21
#define MAC_HW_MAC_CNTRL_1_BQRP_RESP_BY_FW_BIT    ((u32)0x00100000)
#define MAC_HW_MAC_CNTRL_1_BQRP_RESP_BY_FW_POS    20
#define MAC_HW_MAC_CNTRL_1_BSRP_RESP_BY_FW_BIT    ((u32)0x00080000)
#define MAC_HW_MAC_CNTRL_1_BSRP_RESP_BY_FW_POS    19
#define MAC_HW_MAC_CNTRL_1_ENABLE_NORMAL_ACK_RESP_IN_HE_MU_W_TRIG_BIT    ((u32)0x00040000)
#define MAC_HW_MAC_CNTRL_1_ENABLE_NORMAL_ACK_RESP_IN_HE_MU_W_TRIG_POS    18
#define MAC_HW_MAC_CNTRL_1_DISABLE_NORMAL_ACK_RESP_IN_HE_MU_WO_TRIG_BIT    ((u32)0x00020000)
#define MAC_HW_MAC_CNTRL_1_DISABLE_NORMAL_ACK_RESP_IN_HE_MU_WO_TRIG_POS    17
#define MAC_HW_MAC_CNTRL_1_ABGN_MODE_MASK    ((u32)0x0001C000)
#define MAC_HW_MAC_CNTRL_1_ABGN_MODE_LSB    14
#define MAC_HW_MAC_CNTRL_1_ABGN_MODE_WIDTH    ((u32)0x00000003)
#define MAC_HW_MAC_CNTRL_1_KEY_STO_RAM_RESET_BIT    ((u32)0x00002000)
#define MAC_HW_MAC_CNTRL_1_KEY_STO_RAM_RESET_POS    13
#define MAC_HW_MAC_CNTRL_1_MIB_TABLE_RESET_BIT    ((u32)0x00001000)
#define MAC_HW_MAC_CNTRL_1_MIB_TABLE_RESET_POS    12
#define MAC_HW_MAC_CNTRL_1_RATE_CONTROLLER_MPIF_BIT    ((u32)0x00000800)
#define MAC_HW_MAC_CNTRL_1_RATE_CONTROLLER_MPIF_POS    11
#define MAC_HW_MAC_CNTRL_1_DISABLE_BA_RESP_BIT    ((u32)0x00000400)
#define MAC_HW_MAC_CNTRL_1_DISABLE_BA_RESP_POS    10
#define MAC_HW_MAC_CNTRL_1_DISABLE_CTS_RESP_BIT    ((u32)0x00000200)
#define MAC_HW_MAC_CNTRL_1_DISABLE_CTS_RESP_POS    9
#define MAC_HW_MAC_CNTRL_1_DISABLE_ACK_RESP_BIT    ((u32)0x00000100)
#define MAC_HW_MAC_CNTRL_1_DISABLE_ACK_RESP_POS    8
#define MAC_HW_MAC_CNTRL_1_ACTIVE_CLK_GATING_BIT    ((u32)0x00000080)
#define MAC_HW_MAC_CNTRL_1_ACTIVE_CLK_GATING_POS    7
#define MAC_HW_MAC_CNTRL_1_ENABLE_LP_CLK_SWITCH_BIT    ((u32)0x00000040)
#define MAC_HW_MAC_CNTRL_1_ENABLE_LP_CLK_SWITCH_POS    6
#define MAC_HW_MAC_CNTRL_1_FORCE_MSTA_BA_BIT    ((u32)0x00000020)
#define MAC_HW_MAC_CNTRL_1_FORCE_MSTA_BA_POS    5
#define MAC_HW_MAC_CNTRL_1_DISABLE_FAST_COMPARE_BIT    ((u32)0x00000010)
#define MAC_HW_MAC_CNTRL_1_DISABLE_FAST_COMPARE_POS    4
#define MAC_HW_MAC_CNTRL_1_CFP_AWARE_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_CNTRL_1_CFP_AWARE_POS    3
#define MAC_HW_MAC_CNTRL_1_PWR_MGT_BIT      ((u32)0x00000004)
#define MAC_HW_MAC_CNTRL_1_PWR_MGT_POS      2
#define MAC_HW_MAC_CNTRL_1_AP_BIT           ((u32)0x00000002)
#define MAC_HW_MAC_CNTRL_1_AP_POS           1
#define MAC_HW_MAC_CNTRL_1_BSS_TYPE_BIT     ((u32)0x00000001)
#define MAC_HW_MAC_CNTRL_1_BSS_TYPE_POS     0

#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_HE_RST    0x1
#define MAC_HW_MAC_CNTRL_1_EOF_PAD_FOR_VHT_RST    0x0
#define MAC_HW_MAC_CNTRL_1_IMPLICIT_BF_INT_CONF_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_BFR_RESP_RST    0x0
#define MAC_HW_MAC_CNTRL_1_RX_RIFS_EN_RST    0x0
#define MAC_HW_MAC_CNTRL_1_TSF_MGT_DISABLE_RST    0x0
#define MAC_HW_MAC_CNTRL_1_TSF_UPDATED_BY_SW_RST    0x0
#define MAC_HW_MAC_CNTRL_1_MAC_DETECT_UNDERRUN_EN_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_MU_CTS_RESP_RST    0x0
#define MAC_HW_MAC_CNTRL_1_BQRP_RESP_BY_FW_RST    0x0
#define MAC_HW_MAC_CNTRL_1_BSRP_RESP_BY_FW_RST    0x0
#define MAC_HW_MAC_CNTRL_1_ENABLE_NORMAL_ACK_RESP_IN_HE_MU_W_TRIG_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_NORMAL_ACK_RESP_IN_HE_MU_WO_TRIG_RST    0x0
#define MAC_HW_MAC_CNTRL_1_ABGN_MODE_RST    0x3
#define MAC_HW_MAC_CNTRL_1_KEY_STO_RAM_RESET_RST    0x0
#define MAC_HW_MAC_CNTRL_1_MIB_TABLE_RESET_RST    0x0
#define MAC_HW_MAC_CNTRL_1_RATE_CONTROLLER_MPIF_RST    0x1
#define MAC_HW_MAC_CNTRL_1_DISABLE_BA_RESP_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_CTS_RESP_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_ACK_RESP_RST    0x0
#define MAC_HW_MAC_CNTRL_1_ACTIVE_CLK_GATING_RST    0x1
#define MAC_HW_MAC_CNTRL_1_ENABLE_LP_CLK_SWITCH_RST    0x0
#define MAC_HW_MAC_CNTRL_1_FORCE_MSTA_BA_RST    0x0
#define MAC_HW_MAC_CNTRL_1_DISABLE_FAST_COMPARE_RST    0x0
#define MAC_HW_MAC_CNTRL_1_CFP_AWARE_RST    0x0
#define MAC_HW_MAC_CNTRL_1_PWR_MGT_RST      0x0
#define MAC_HW_MAC_CNTRL_1_AP_RST           0x0
#define MAC_HW_MAC_CNTRL_1_BSS_TYPE_RST     0x1

static inline void mac_hw_mac_cntrl_1_pack(struct cl_chip *chip, u8 eof_pad_for_he, u8 eof_pad_for_vht, u8 implicit_bf_int_conf, u8 disable_bfr_resp, u8 rx_rifs_en, u8 tsf_mgt_disable, u8 tsf_updated_by_sw, u8 mac_detect_underrun_en, u8 disable_mu_cts_resp, u8 bqrp_resp_by_fw, u8 bsrp_resp_by_fw, u8 enable_normal_ack_resp_in_he_mu_w_trig, u8 disable_normal_ack_resp_in_he_mu_wo_trig, u8 abgn_mode, u8 key_sto_ram_reset, u8 mib_table_reset, u8 rate_controller_mpif, u8 disable_ba_resp, u8 disable_cts_resp, u8 disable_ack_resp, u8 active_clk_gating, u8 enable_lp_clk_switch, u8 force_msta_ba, u8 disable_fast_compare, u8 cfp_aware, u8 pwr_mgt, u8 ap, u8 bss_type)
{
	ASSERT_ERR_CHIP((((u32)eof_pad_for_he << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)eof_pad_for_vht << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)implicit_bf_int_conf << 28) & ~((u32)0x30000000)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_bfr_resp << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_rifs_en << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tsf_mgt_disable << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tsf_updated_by_sw << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_detect_underrun_en << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_mu_cts_resp << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)bqrp_resp_by_fw << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)bsrp_resp_by_fw << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_normal_ack_resp_in_he_mu_w_trig << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_normal_ack_resp_in_he_mu_wo_trig << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)abgn_mode << 14) & ~((u32)0x0001C000)) == 0);
	ASSERT_ERR_CHIP((((u32)key_sto_ram_reset << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)mib_table_reset << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)rate_controller_mpif << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_ba_resp << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_cts_resp << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_ack_resp << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)active_clk_gating << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_lp_clk_switch << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)force_msta_ba << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_fast_compare << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)cfp_aware << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)pwr_mgt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ap << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_type << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, ((u32)eof_pad_for_he << 31) | ((u32)eof_pad_for_vht << 30) | ((u32)implicit_bf_int_conf << 28) | ((u32)disable_bfr_resp << 27) | ((u32)rx_rifs_en << 26) | ((u32)tsf_mgt_disable << 25) | ((u32)tsf_updated_by_sw << 24) | ((u32)mac_detect_underrun_en << 22) | ((u32)disable_mu_cts_resp << 21) | ((u32)bqrp_resp_by_fw << 20) | ((u32)bsrp_resp_by_fw << 19) | ((u32)enable_normal_ack_resp_in_he_mu_w_trig << 18) | ((u32)disable_normal_ack_resp_in_he_mu_wo_trig << 17) | ((u32)abgn_mode << 14) | ((u32)key_sto_ram_reset << 13) | ((u32)mib_table_reset << 12) | ((u32)rate_controller_mpif << 11) | ((u32)disable_ba_resp << 10) | ((u32)disable_cts_resp << 9) | ((u32)disable_ack_resp << 8) | ((u32)active_clk_gating << 7) | ((u32)enable_lp_clk_switch << 6) | ((u32)force_msta_ba << 5) | ((u32)disable_fast_compare << 4) | ((u32)cfp_aware << 3) | ((u32)pwr_mgt << 2) | ((u32)ap << 1) | ((u32)bss_type << 0));
}

static inline void mac_hw_mac_cntrl_1_unpack(struct cl_chip *chip, u8 *eof_pad_for_he, u8 *eof_pad_for_vht, u8 *implicit_bf_int_conf, u8 *disable_bfr_resp, u8 *rx_rifs_en, u8 *tsf_mgt_disable, u8 *tsf_updated_by_sw, u8 *mac_detect_underrun_en, u8 *disable_mu_cts_resp, u8 *bqrp_resp_by_fw, u8 *bsrp_resp_by_fw, u8 *enable_normal_ack_resp_in_he_mu_w_trig, u8 *disable_normal_ack_resp_in_he_mu_wo_trig, u8 *abgn_mode, u8 *key_sto_ram_reset, u8 *mib_table_reset, u8 *rate_controller_mpif, u8 *disable_ba_resp, u8 *disable_cts_resp, u8 *disable_ack_resp, u8 *active_clk_gating, u8 *enable_lp_clk_switch, u8 *force_msta_ba, u8 *disable_fast_compare, u8 *cfp_aware, u8 *pwr_mgt, u8 *ap, u8 *bss_type)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	*eof_pad_for_he = (local_val & ((u32)0x80000000)) >> 31;
	*eof_pad_for_vht = (local_val & ((u32)0x40000000)) >> 30;
	*implicit_bf_int_conf = (local_val & ((u32)0x30000000)) >> 28;
	*disable_bfr_resp = (local_val & ((u32)0x08000000)) >> 27;
	*rx_rifs_en = (local_val & ((u32)0x04000000)) >> 26;
	*tsf_mgt_disable = (local_val & ((u32)0x02000000)) >> 25;
	*tsf_updated_by_sw = (local_val & ((u32)0x01000000)) >> 24;
	*mac_detect_underrun_en = (local_val & ((u32)0x00400000)) >> 22;
	*disable_mu_cts_resp = (local_val & ((u32)0x00200000)) >> 21;
	*bqrp_resp_by_fw = (local_val & ((u32)0x00100000)) >> 20;
	*bsrp_resp_by_fw = (local_val & ((u32)0x00080000)) >> 19;
	*enable_normal_ack_resp_in_he_mu_w_trig = (local_val & ((u32)0x00040000)) >> 18;
	*disable_normal_ack_resp_in_he_mu_wo_trig = (local_val & ((u32)0x00020000)) >> 17;
	*abgn_mode = (local_val & ((u32)0x0001C000)) >> 14;
	*key_sto_ram_reset = (local_val & ((u32)0x00002000)) >> 13;
	*mib_table_reset = (local_val & ((u32)0x00001000)) >> 12;
	*rate_controller_mpif = (local_val & ((u32)0x00000800)) >> 11;
	*disable_ba_resp = (local_val & ((u32)0x00000400)) >> 10;
	*disable_cts_resp = (local_val & ((u32)0x00000200)) >> 9;
	*disable_ack_resp = (local_val & ((u32)0x00000100)) >> 8;
	*active_clk_gating = (local_val & ((u32)0x00000080)) >> 7;
	*enable_lp_clk_switch = (local_val & ((u32)0x00000040)) >> 6;
	*force_msta_ba = (local_val & ((u32)0x00000020)) >> 5;
	*disable_fast_compare = (local_val & ((u32)0x00000010)) >> 4;
	*cfp_aware = (local_val & ((u32)0x00000008)) >> 3;
	*pwr_mgt = (local_val & ((u32)0x00000004)) >> 2;
	*ap = (local_val & ((u32)0x00000002)) >> 1;
	*bss_type = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_mac_cntrl_1_eof_pad_for_he_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_mac_cntrl_1_eof_pad_for_he_setf(struct cl_chip *chip, u8 eofpadforhe)
{
	ASSERT_ERR_CHIP((((u32)eofpadforhe << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x80000000)) | ((u32)eofpadforhe << 31));
}

static inline u8 mac_hw_mac_cntrl_1_eof_pad_for_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_mac_cntrl_1_eof_pad_for_vht_setf(struct cl_chip *chip, u8 eofpadforvht)
{
	ASSERT_ERR_CHIP((((u32)eofpadforvht << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x40000000)) | ((u32)eofpadforvht << 30));
}

static inline u8 mac_hw_mac_cntrl_1_implicit_bf_int_conf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x30000000)) >> 28);
}

static inline void mac_hw_mac_cntrl_1_implicit_bf_int_conf_setf(struct cl_chip *chip, u8 implicitbfintconf)
{
	ASSERT_ERR_CHIP((((u32)implicitbfintconf << 28) & ~((u32)0x30000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x30000000)) | ((u32)implicitbfintconf << 28));
}

static inline u8 mac_hw_mac_cntrl_1_disable_bfr_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_mac_cntrl_1_disable_bfr_resp_setf(struct cl_chip *chip, u8 disablebfrresp)
{
	ASSERT_ERR_CHIP((((u32)disablebfrresp << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x08000000)) | ((u32)disablebfrresp << 27));
}

static inline u8 mac_hw_mac_cntrl_1_rx_rifs_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_mac_cntrl_1_rx_rifs_en_setf(struct cl_chip *chip, u8 rxrifsen)
{
	ASSERT_ERR_CHIP((((u32)rxrifsen << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x04000000)) | ((u32)rxrifsen << 26));
}

static inline u8 mac_hw_mac_cntrl_1_tsf_mgt_disable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_mac_cntrl_1_tsf_mgt_disable_setf(struct cl_chip *chip, u8 tsfmgtdisable)
{
	ASSERT_ERR_CHIP((((u32)tsfmgtdisable << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x02000000)) | ((u32)tsfmgtdisable << 25));
}

static inline u8 mac_hw_mac_cntrl_1_tsf_updated_by_sw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_mac_cntrl_1_tsf_updated_by_sw_setf(struct cl_chip *chip, u8 tsfupdatedbysw)
{
	ASSERT_ERR_CHIP((((u32)tsfupdatedbysw << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x01000000)) | ((u32)tsfupdatedbysw << 24));
}

static inline u8 mac_hw_mac_cntrl_1_mac_detect_underrun_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_mac_cntrl_1_mac_detect_underrun_en_setf(struct cl_chip *chip, u8 macdetectunderrunen)
{
	ASSERT_ERR_CHIP((((u32)macdetectunderrunen << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00400000)) | ((u32)macdetectunderrunen << 22));
}

static inline u8 mac_hw_mac_cntrl_1_disable_mu_cts_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_mac_cntrl_1_disable_mu_cts_resp_setf(struct cl_chip *chip, u8 disablemuctsresp)
{
	ASSERT_ERR_CHIP((((u32)disablemuctsresp << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00200000)) | ((u32)disablemuctsresp << 21));
}

static inline u8 mac_hw_mac_cntrl_1_bqrp_resp_by_fw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_mac_cntrl_1_bqrp_resp_by_fw_setf(struct cl_chip *chip, u8 bqrprespbyfw)
{
	ASSERT_ERR_CHIP((((u32)bqrprespbyfw << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00100000)) | ((u32)bqrprespbyfw << 20));
}

static inline u8 mac_hw_mac_cntrl_1_bsrp_resp_by_fw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_mac_cntrl_1_bsrp_resp_by_fw_setf(struct cl_chip *chip, u8 bsrprespbyfw)
{
	ASSERT_ERR_CHIP((((u32)bsrprespbyfw << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00080000)) | ((u32)bsrprespbyfw << 19));
}

static inline u8 mac_hw_mac_cntrl_1_enable_normal_ack_resp_in_he_mu_w_trig_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_mac_cntrl_1_enable_normal_ack_resp_in_he_mu_w_trig_setf(struct cl_chip *chip, u8 enablenormalackrespinhemuwtrig)
{
	ASSERT_ERR_CHIP((((u32)enablenormalackrespinhemuwtrig << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00040000)) | ((u32)enablenormalackrespinhemuwtrig << 18));
}

static inline u8 mac_hw_mac_cntrl_1_disable_normal_ack_resp_in_he_mu_wo_trig_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_mac_cntrl_1_disable_normal_ack_resp_in_he_mu_wo_trig_setf(struct cl_chip *chip, u8 disablenormalackrespinhemuwotrig)
{
	ASSERT_ERR_CHIP((((u32)disablenormalackrespinhemuwotrig << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00020000)) | ((u32)disablenormalackrespinhemuwotrig << 17));
}

static inline u8 mac_hw_mac_cntrl_1_abgn_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x0001C000)) >> 14);
}

static inline void mac_hw_mac_cntrl_1_abgn_mode_setf(struct cl_chip *chip, u8 abgnmode)
{
	ASSERT_ERR_CHIP((((u32)abgnmode << 14) & ~((u32)0x0001C000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x0001C000)) | ((u32)abgnmode << 14));
}

static inline u8 mac_hw_mac_cntrl_1_key_sto_ram_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_mac_cntrl_1_key_sto_ram_reset_setf(struct cl_chip *chip, u8 keystoramreset)
{
	ASSERT_ERR_CHIP((((u32)keystoramreset << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00002000)) | ((u32)keystoramreset << 13));
}

static inline u8 mac_hw_mac_cntrl_1_mib_table_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_mac_cntrl_1_mib_table_reset_setf(struct cl_chip *chip, u8 mibtablereset)
{
	ASSERT_ERR_CHIP((((u32)mibtablereset << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00001000)) | ((u32)mibtablereset << 12));
}

static inline u8 mac_hw_mac_cntrl_1_rate_controller_mpif_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_mac_cntrl_1_rate_controller_mpif_setf(struct cl_chip *chip, u8 ratecontrollermpif)
{
	ASSERT_ERR_CHIP((((u32)ratecontrollermpif << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000800)) | ((u32)ratecontrollermpif << 11));
}

static inline u8 mac_hw_mac_cntrl_1_disable_ba_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_mac_cntrl_1_disable_ba_resp_setf(struct cl_chip *chip, u8 disablebaresp)
{
	ASSERT_ERR_CHIP((((u32)disablebaresp << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000400)) | ((u32)disablebaresp << 10));
}

static inline u8 mac_hw_mac_cntrl_1_disable_cts_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_mac_cntrl_1_disable_cts_resp_setf(struct cl_chip *chip, u8 disablectsresp)
{
	ASSERT_ERR_CHIP((((u32)disablectsresp << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000200)) | ((u32)disablectsresp << 9));
}

static inline u8 mac_hw_mac_cntrl_1_disable_ack_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_mac_cntrl_1_disable_ack_resp_setf(struct cl_chip *chip, u8 disableackresp)
{
	ASSERT_ERR_CHIP((((u32)disableackresp << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000100)) | ((u32)disableackresp << 8));
}

static inline u8 mac_hw_mac_cntrl_1_active_clk_gating_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_mac_cntrl_1_active_clk_gating_setf(struct cl_chip *chip, u8 activeclkgating)
{
	ASSERT_ERR_CHIP((((u32)activeclkgating << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000080)) | ((u32)activeclkgating << 7));
}

static inline u8 mac_hw_mac_cntrl_1_enable_lp_clk_switch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_mac_cntrl_1_enable_lp_clk_switch_setf(struct cl_chip *chip, u8 enablelpclkswitch)
{
	ASSERT_ERR_CHIP((((u32)enablelpclkswitch << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000040)) | ((u32)enablelpclkswitch << 6));
}

static inline u8 mac_hw_mac_cntrl_1_force_msta_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_mac_cntrl_1_force_msta_ba_setf(struct cl_chip *chip, u8 forcemstaba)
{
	ASSERT_ERR_CHIP((((u32)forcemstaba << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000020)) | ((u32)forcemstaba << 5));
}

static inline u8 mac_hw_mac_cntrl_1_disable_fast_compare_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_mac_cntrl_1_disable_fast_compare_setf(struct cl_chip *chip, u8 disablefastcompare)
{
	ASSERT_ERR_CHIP((((u32)disablefastcompare << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000010)) | ((u32)disablefastcompare << 4));
}

static inline u8 mac_hw_mac_cntrl_1_cfp_aware_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_mac_cntrl_1_cfp_aware_setf(struct cl_chip *chip, u8 cfpaware)
{
	ASSERT_ERR_CHIP((((u32)cfpaware << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000008)) | ((u32)cfpaware << 3));
}

static inline u8 mac_hw_mac_cntrl_1_pwr_mgt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_mac_cntrl_1_pwr_mgt_setf(struct cl_chip *chip, u8 pwrmgt)
{
	ASSERT_ERR_CHIP((((u32)pwrmgt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000004)) | ((u32)pwrmgt << 2));
}

static inline u8 mac_hw_mac_cntrl_1_ap_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_mac_cntrl_1_ap_setf(struct cl_chip *chip, u8 ap)
{
	ASSERT_ERR_CHIP((((u32)ap << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000002)) | ((u32)ap << 1));
}

static inline u8 mac_hw_mac_cntrl_1_bss_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_mac_cntrl_1_bss_type_setf(struct cl_chip *chip, u8 bsstype)
{
	ASSERT_ERR_CHIP((((u32)bsstype << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_1_ADDR) & ~((u32)0x00000001)) | ((u32)bsstype << 0));
}

/**
 * @brief MAC_CNTRL_3 register definition
 *  Controls trigger response register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    20    SENSING_MODE              0
 *    19    ADD_TO_UL_LENGTH          0
 *    18    ENABLE_NAV_Update_from_quiet_element 0
 *    17    ENABLE_RXM_INTERFACE      0
 *    16    ENABLE_BAU_INTERFACE      0
 *    15    Enable_NAV_Update_From_CFP_element 0
 *    14    Enable_NAV_Update_From_RXV_case2 0
 *    13    Enable_NAV_Update_From_RXV_case1 0
 *    12    IGNORE_VIR_CS_REQUIRED    0
 *    11    CALC_NZLD                 0
 *    10    IGNORE_ED_CS_REQUIRED     0
 *    09    BSS_COLOR_DISABLED        0
 *    08    NO_SIG_EXTN               1
 *    04    DISABLE_BFRP_RESPONSE     0
 *    03    DISABLE_BQRP_RESPONSE     0
 *    02    DISABLE_BSRP_RESPONSE     0
 *    01    DISABLE_MU_BAR_RESPONSE   0
 *    00    DISABLE_BASIC_TRIGGER_RESPONSE 0
 * </pre>
 */
#define MAC_HW_MAC_CNTRL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000050)
#define MAC_HW_MAC_CNTRL_3_OFFSET      0x00000050
#define MAC_HW_MAC_CNTRL_3_INDEX       0x00000014
#define MAC_HW_MAC_CNTRL_3_RESET       0x00000100

static inline u32 mac_hw_mac_cntrl_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);
}

static inline void mac_hw_mac_cntrl_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_CNTRL_3_SENSING_MODE_BIT    ((u32)0x00100000)
#define MAC_HW_MAC_CNTRL_3_SENSING_MODE_POS    20
#define MAC_HW_MAC_CNTRL_3_ADD_TO_UL_LENGTH_BIT    ((u32)0x00080000)
#define MAC_HW_MAC_CNTRL_3_ADD_TO_UL_LENGTH_POS    19
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_QUIET_ELEMENT_BIT    ((u32)0x00040000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_QUIET_ELEMENT_POS    18
#define MAC_HW_MAC_CNTRL_3_ENABLE_RXM_INTERFACE_BIT    ((u32)0x00020000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_RXM_INTERFACE_POS    17
#define MAC_HW_MAC_CNTRL_3_ENABLE_BAU_INTERFACE_BIT    ((u32)0x00010000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_BAU_INTERFACE_POS    16
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_CFP_ELEMENT_BIT    ((u32)0x00008000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_CFP_ELEMENT_POS    15
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_2_BIT    ((u32)0x00004000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_2_POS    14
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_1_BIT    ((u32)0x00002000)
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_1_POS    13
#define MAC_HW_MAC_CNTRL_3_IGNORE_VIR_CS_REQUIRED_BIT    ((u32)0x00001000)
#define MAC_HW_MAC_CNTRL_3_IGNORE_VIR_CS_REQUIRED_POS    12
#define MAC_HW_MAC_CNTRL_3_CALC_NZLD_BIT    ((u32)0x00000800)
#define MAC_HW_MAC_CNTRL_3_CALC_NZLD_POS    11
#define MAC_HW_MAC_CNTRL_3_IGNORE_ED_CS_REQUIRED_BIT    ((u32)0x00000400)
#define MAC_HW_MAC_CNTRL_3_IGNORE_ED_CS_REQUIRED_POS    10
#define MAC_HW_MAC_CNTRL_3_BSS_COLOR_DISABLED_BIT    ((u32)0x00000200)
#define MAC_HW_MAC_CNTRL_3_BSS_COLOR_DISABLED_POS    9
#define MAC_HW_MAC_CNTRL_3_NO_SIG_EXTN_BIT    ((u32)0x00000100)
#define MAC_HW_MAC_CNTRL_3_NO_SIG_EXTN_POS    8
#define MAC_HW_MAC_CNTRL_3_DISABLE_BFRP_RESPONSE_BIT    ((u32)0x00000010)
#define MAC_HW_MAC_CNTRL_3_DISABLE_BFRP_RESPONSE_POS    4
#define MAC_HW_MAC_CNTRL_3_DISABLE_BQRP_RESPONSE_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_CNTRL_3_DISABLE_BQRP_RESPONSE_POS    3
#define MAC_HW_MAC_CNTRL_3_DISABLE_BSRP_RESPONSE_BIT    ((u32)0x00000004)
#define MAC_HW_MAC_CNTRL_3_DISABLE_BSRP_RESPONSE_POS    2
#define MAC_HW_MAC_CNTRL_3_DISABLE_MU_BAR_RESPONSE_BIT    ((u32)0x00000002)
#define MAC_HW_MAC_CNTRL_3_DISABLE_MU_BAR_RESPONSE_POS    1
#define MAC_HW_MAC_CNTRL_3_DISABLE_BASIC_TRIGGER_RESPONSE_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_CNTRL_3_DISABLE_BASIC_TRIGGER_RESPONSE_POS    0

#define MAC_HW_MAC_CNTRL_3_SENSING_MODE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ADD_TO_UL_LENGTH_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_QUIET_ELEMENT_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_RXM_INTERFACE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_BAU_INTERFACE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_CFP_ELEMENT_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_2_RST    0x0
#define MAC_HW_MAC_CNTRL_3_ENABLE_NAV_UPDATE_FROM_RXV_CASE_1_RST    0x0
#define MAC_HW_MAC_CNTRL_3_IGNORE_VIR_CS_REQUIRED_RST    0x0
#define MAC_HW_MAC_CNTRL_3_CALC_NZLD_RST    0x0
#define MAC_HW_MAC_CNTRL_3_IGNORE_ED_CS_REQUIRED_RST    0x0
#define MAC_HW_MAC_CNTRL_3_BSS_COLOR_DISABLED_RST    0x0
#define MAC_HW_MAC_CNTRL_3_NO_SIG_EXTN_RST    0x1
#define MAC_HW_MAC_CNTRL_3_DISABLE_BFRP_RESPONSE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_DISABLE_BQRP_RESPONSE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_DISABLE_BSRP_RESPONSE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_DISABLE_MU_BAR_RESPONSE_RST    0x0
#define MAC_HW_MAC_CNTRL_3_DISABLE_BASIC_TRIGGER_RESPONSE_RST    0x0

static inline void mac_hw_mac_cntrl_3_pack(struct cl_chip *chip, u8 sensing_mode, u8 add_to_ul_length, u8 enable_nav_update_from_quiet_element, u8 enable_rxm_interface, u8 enable_bau_interface, u8 enable_nav_update_from_cfp_element, u8 enable_nav_update_from_rxv_case2, u8 enable_nav_update_from_rxv_case1, u8 ignore_vir_cs_required, u8 calc_nzld, u8 ignore_ed_cs_required, u8 bss_color_disabled, u8 no_sig_extn, u8 disable_bfrp_response, u8 disable_bqrp_response, u8 disable_bsrp_response, u8 disable_mu_bar_response, u8 disable_basic_trigger_response)
{
	ASSERT_ERR_CHIP((((u32)sensing_mode << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)add_to_ul_length << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_nav_update_from_quiet_element << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_rxm_interface << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_bau_interface << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_nav_update_from_cfp_element << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_nav_update_from_rxv_case2 << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_nav_update_from_rxv_case1 << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_vir_cs_required << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)calc_nzld << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_ed_cs_required << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_color_disabled << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)no_sig_extn << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_bfrp_response << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_bqrp_response << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_bsrp_response << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_mu_bar_response << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_basic_trigger_response << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, ((u32)sensing_mode << 20) | ((u32)add_to_ul_length << 19) | ((u32)enable_nav_update_from_quiet_element << 18) | ((u32)enable_rxm_interface << 17) | ((u32)enable_bau_interface << 16) | ((u32)enable_nav_update_from_cfp_element << 15) | ((u32)enable_nav_update_from_rxv_case2 << 14) | ((u32)enable_nav_update_from_rxv_case1 << 13) | ((u32)ignore_vir_cs_required << 12) | ((u32)calc_nzld << 11) | ((u32)ignore_ed_cs_required << 10) | ((u32)bss_color_disabled << 9) | ((u32)no_sig_extn << 8) | ((u32)disable_bfrp_response << 4) | ((u32)disable_bqrp_response << 3) | ((u32)disable_bsrp_response << 2) | ((u32)disable_mu_bar_response << 1) | ((u32)disable_basic_trigger_response << 0));
}

static inline void mac_hw_mac_cntrl_3_unpack(struct cl_chip *chip, u8 *sensing_mode, u8 *add_to_ul_length, u8 *enable_nav_update_from_quiet_element, u8 *enable_rxm_interface, u8 *enable_bau_interface, u8 *enable_nav_update_from_cfp_element, u8 *enable_nav_update_from_rxv_case2, u8 *enable_nav_update_from_rxv_case1, u8 *ignore_vir_cs_required, u8 *calc_nzld, u8 *ignore_ed_cs_required, u8 *bss_color_disabled, u8 *no_sig_extn, u8 *disable_bfrp_response, u8 *disable_bqrp_response, u8 *disable_bsrp_response, u8 *disable_mu_bar_response, u8 *disable_basic_trigger_response)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	*sensing_mode = (local_val & ((u32)0x00100000)) >> 20;
	*add_to_ul_length = (local_val & ((u32)0x00080000)) >> 19;
	*enable_nav_update_from_quiet_element = (local_val & ((u32)0x00040000)) >> 18;
	*enable_rxm_interface = (local_val & ((u32)0x00020000)) >> 17;
	*enable_bau_interface = (local_val & ((u32)0x00010000)) >> 16;
	*enable_nav_update_from_cfp_element = (local_val & ((u32)0x00008000)) >> 15;
	*enable_nav_update_from_rxv_case2 = (local_val & ((u32)0x00004000)) >> 14;
	*enable_nav_update_from_rxv_case1 = (local_val & ((u32)0x00002000)) >> 13;
	*ignore_vir_cs_required = (local_val & ((u32)0x00001000)) >> 12;
	*calc_nzld = (local_val & ((u32)0x00000800)) >> 11;
	*ignore_ed_cs_required = (local_val & ((u32)0x00000400)) >> 10;
	*bss_color_disabled = (local_val & ((u32)0x00000200)) >> 9;
	*no_sig_extn = (local_val & ((u32)0x00000100)) >> 8;
	*disable_bfrp_response = (local_val & ((u32)0x00000010)) >> 4;
	*disable_bqrp_response = (local_val & ((u32)0x00000008)) >> 3;
	*disable_bsrp_response = (local_val & ((u32)0x00000004)) >> 2;
	*disable_mu_bar_response = (local_val & ((u32)0x00000002)) >> 1;
	*disable_basic_trigger_response = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_mac_cntrl_3_sensing_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_mac_cntrl_3_sensing_mode_setf(struct cl_chip *chip, u8 sensingmode)
{
	ASSERT_ERR_CHIP((((u32)sensingmode << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00100000)) | ((u32)sensingmode << 20));
}

static inline u8 mac_hw_mac_cntrl_3_add_to_ul_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_mac_cntrl_3_add_to_ul_length_setf(struct cl_chip *chip, u8 addtoullength)
{
	ASSERT_ERR_CHIP((((u32)addtoullength << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00080000)) | ((u32)addtoullength << 19));
}

static inline u8 mac_hw_mac_cntrl_3_enable_nav_update_from_quiet_element_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_mac_cntrl_3_enable_nav_update_from_quiet_element_setf(struct cl_chip *chip, u8 enablenavupdatefromquietelement)
{
	ASSERT_ERR_CHIP((((u32)enablenavupdatefromquietelement << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00040000)) | ((u32)enablenavupdatefromquietelement << 18));
}

static inline u8 mac_hw_mac_cntrl_3_enable_rxm_interface_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_mac_cntrl_3_enable_rxm_interface_setf(struct cl_chip *chip, u8 enablerxminterface)
{
	ASSERT_ERR_CHIP((((u32)enablerxminterface << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00020000)) | ((u32)enablerxminterface << 17));
}

static inline u8 mac_hw_mac_cntrl_3_enable_bau_interface_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_mac_cntrl_3_enable_bau_interface_setf(struct cl_chip *chip, u8 enablebauinterface)
{
	ASSERT_ERR_CHIP((((u32)enablebauinterface << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00010000)) | ((u32)enablebauinterface << 16));
}

static inline u8 mac_hw_mac_cntrl_3_enable_nav_update_from_cfp_element_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_mac_cntrl_3_enable_nav_update_from_cfp_element_setf(struct cl_chip *chip, u8 enablenavupdatefromcfpelement)
{
	ASSERT_ERR_CHIP((((u32)enablenavupdatefromcfpelement << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00008000)) | ((u32)enablenavupdatefromcfpelement << 15));
}

static inline u8 mac_hw_mac_cntrl_3_enable_nav_update_from_rxv_case_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_mac_cntrl_3_enable_nav_update_from_rxv_case_2_setf(struct cl_chip *chip, u8 enablenavupdatefromrxvcase2)
{
	ASSERT_ERR_CHIP((((u32)enablenavupdatefromrxvcase2 << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00004000)) | ((u32)enablenavupdatefromrxvcase2 << 14));
}

static inline u8 mac_hw_mac_cntrl_3_enable_nav_update_from_rxv_case_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_mac_cntrl_3_enable_nav_update_from_rxv_case_1_setf(struct cl_chip *chip, u8 enablenavupdatefromrxvcase1)
{
	ASSERT_ERR_CHIP((((u32)enablenavupdatefromrxvcase1 << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00002000)) | ((u32)enablenavupdatefromrxvcase1 << 13));
}

static inline u8 mac_hw_mac_cntrl_3_ignore_vir_cs_required_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_mac_cntrl_3_ignore_vir_cs_required_setf(struct cl_chip *chip, u8 ignorevircsrequired)
{
	ASSERT_ERR_CHIP((((u32)ignorevircsrequired << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00001000)) | ((u32)ignorevircsrequired << 12));
}

static inline u8 mac_hw_mac_cntrl_3_calc_nzld_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_mac_cntrl_3_calc_nzld_setf(struct cl_chip *chip, u8 calcnzld)
{
	ASSERT_ERR_CHIP((((u32)calcnzld << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000800)) | ((u32)calcnzld << 11));
}

static inline u8 mac_hw_mac_cntrl_3_ignore_ed_cs_required_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_mac_cntrl_3_ignore_ed_cs_required_setf(struct cl_chip *chip, u8 ignoreedcsrequired)
{
	ASSERT_ERR_CHIP((((u32)ignoreedcsrequired << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000400)) | ((u32)ignoreedcsrequired << 10));
}

static inline u8 mac_hw_mac_cntrl_3_bss_color_disabled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_mac_cntrl_3_bss_color_disabled_setf(struct cl_chip *chip, u8 bsscolordisabled)
{
	ASSERT_ERR_CHIP((((u32)bsscolordisabled << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000200)) | ((u32)bsscolordisabled << 9));
}

static inline u8 mac_hw_mac_cntrl_3_no_sig_extn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_mac_cntrl_3_no_sig_extn_setf(struct cl_chip *chip, u8 nosigextn)
{
	ASSERT_ERR_CHIP((((u32)nosigextn << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000100)) | ((u32)nosigextn << 8));
}

static inline u8 mac_hw_mac_cntrl_3_disable_bfrp_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_mac_cntrl_3_disable_bfrp_response_setf(struct cl_chip *chip, u8 disablebfrpresponse)
{
	ASSERT_ERR_CHIP((((u32)disablebfrpresponse << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000010)) | ((u32)disablebfrpresponse << 4));
}

static inline u8 mac_hw_mac_cntrl_3_disable_bqrp_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_mac_cntrl_3_disable_bqrp_response_setf(struct cl_chip *chip, u8 disablebqrpresponse)
{
	ASSERT_ERR_CHIP((((u32)disablebqrpresponse << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000008)) | ((u32)disablebqrpresponse << 3));
}

static inline u8 mac_hw_mac_cntrl_3_disable_bsrp_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_mac_cntrl_3_disable_bsrp_response_setf(struct cl_chip *chip, u8 disablebsrpresponse)
{
	ASSERT_ERR_CHIP((((u32)disablebsrpresponse << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000004)) | ((u32)disablebsrpresponse << 2));
}

static inline u8 mac_hw_mac_cntrl_3_disable_mu_bar_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_mac_cntrl_3_disable_mu_bar_response_setf(struct cl_chip *chip, u8 disablemubarresponse)
{
	ASSERT_ERR_CHIP((((u32)disablemubarresponse << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000002)) | ((u32)disablemubarresponse << 1));
}

static inline u8 mac_hw_mac_cntrl_3_disable_basic_trigger_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_mac_cntrl_3_disable_basic_trigger_response_setf(struct cl_chip *chip, u8 disablebasictriggerresponse)
{
	ASSERT_ERR_CHIP((((u32)disablebasictriggerresponse << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_MAC_CNTRL_3_ADDR) & ~((u32)0x00000001)) | ((u32)disablebasictriggerresponse << 0));
}

/**
 * @brief MAC_ERR_REC_CNTRL register definition
 *  Contains setting for detection and recovery from HW errors. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    FORCE_AUTO_RESP_20_MHZ    0
 *    30:28 PPS_TIMEOUT               0x0
 *    27    RX_FIFO_OVF_CANCEL        1
 *    26    RX_VEC2_IN_RHD_EN         0
 *    25    RX_PADDING_EN             0
 *    24    TX_UND_FLOW_CNTRL_EN      0
 *    23    HDR_SPLIT_EN              0
 *    18    MASK_CCA_BEFORE_TICK      1
 *    17    RX_FLOW_CNTRL_EN2         0
 *    16    RX_FLOW_CNTRL_EN          0
 *    08    CCA_ZERO_ON_RX_CANCEL     0
 *    07    BA_PS_BITMAP_RESET        0
 *    06    ENCR_RX_FIFO_RESET        0
 *    05    MAC_PHYIFFIFO_RESET       0
 *    04    TX_FIFO_RESET             0
 *    03    RX_FIFO_RESET             0
 *    02    HW_FSM_RESET              0
 *    01    USE_ERR_DET               0
 *    00    USE_ERR_REC               0
 * </pre>
 */
#define MAC_HW_MAC_ERR_REC_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000054)
#define MAC_HW_MAC_ERR_REC_CNTRL_OFFSET      0x00000054
#define MAC_HW_MAC_ERR_REC_CNTRL_INDEX       0x00000015
#define MAC_HW_MAC_ERR_REC_CNTRL_RESET       0x08040000

static inline u32 mac_hw_mac_err_rec_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);
}

static inline void mac_hw_mac_err_rec_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ERR_REC_CNTRL_FORCE_AUTO_RESP_20_MHZ_BIT    ((u32)0x80000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_FORCE_AUTO_RESP_20_MHZ_POS    31
#define MAC_HW_MAC_ERR_REC_CNTRL_PPS_TIMEOUT_MASK    ((u32)0x70000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_PPS_TIMEOUT_LSB    28
#define MAC_HW_MAC_ERR_REC_CNTRL_PPS_TIMEOUT_WIDTH    ((u32)0x00000003)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_OVF_CANCEL_BIT    ((u32)0x08000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_OVF_CANCEL_POS    27
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_VEC_2_IN_RHD_EN_BIT    ((u32)0x04000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_VEC_2_IN_RHD_EN_POS    26
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_PADDING_EN_BIT    ((u32)0x02000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_PADDING_EN_POS    25
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_UND_FLOW_CNTRL_EN_BIT    ((u32)0x01000000)
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_UND_FLOW_CNTRL_EN_POS    24
#define MAC_HW_MAC_ERR_REC_CNTRL_HDR_SPLIT_EN_BIT    ((u32)0x00800000)
#define MAC_HW_MAC_ERR_REC_CNTRL_HDR_SPLIT_EN_POS    23
#define MAC_HW_MAC_ERR_REC_CNTRL_MASK_CCA_BEFORE_TICK_BIT    ((u32)0x00040000)
#define MAC_HW_MAC_ERR_REC_CNTRL_MASK_CCA_BEFORE_TICK_POS    18
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_2_BIT    ((u32)0x00020000)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_2_POS    17
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_BIT    ((u32)0x00010000)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_POS    16
#define MAC_HW_MAC_ERR_REC_CNTRL_CCA_ZERO_ON_RX_CANCEL_BIT    ((u32)0x00000100)
#define MAC_HW_MAC_ERR_REC_CNTRL_CCA_ZERO_ON_RX_CANCEL_POS    8
#define MAC_HW_MAC_ERR_REC_CNTRL_BA_PS_BITMAP_RESET_BIT    ((u32)0x00000080)
#define MAC_HW_MAC_ERR_REC_CNTRL_BA_PS_BITMAP_RESET_POS    7
#define MAC_HW_MAC_ERR_REC_CNTRL_ENCR_RX_FIFO_RESET_BIT    ((u32)0x00000040)
#define MAC_HW_MAC_ERR_REC_CNTRL_ENCR_RX_FIFO_RESET_POS    6
#define MAC_HW_MAC_ERR_REC_CNTRL_MAC_PHYIFFIFO_RESET_BIT    ((u32)0x00000020)
#define MAC_HW_MAC_ERR_REC_CNTRL_MAC_PHYIFFIFO_RESET_POS    5
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_FIFO_RESET_BIT    ((u32)0x00000010)
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_FIFO_RESET_POS    4
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_RESET_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_RESET_POS    3
#define MAC_HW_MAC_ERR_REC_CNTRL_HW_FSM_RESET_BIT    ((u32)0x00000004)
#define MAC_HW_MAC_ERR_REC_CNTRL_HW_FSM_RESET_POS    2
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_DET_BIT    ((u32)0x00000002)
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_DET_POS    1
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_REC_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_REC_POS    0

#define MAC_HW_MAC_ERR_REC_CNTRL_FORCE_AUTO_RESP_20_MHZ_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_PPS_TIMEOUT_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_OVF_CANCEL_RST    0x1
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_VEC_2_IN_RHD_EN_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_PADDING_EN_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_UND_FLOW_CNTRL_EN_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_HDR_SPLIT_EN_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_MASK_CCA_BEFORE_TICK_RST    0x1
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_2_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FLOW_CNTRL_EN_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_CCA_ZERO_ON_RX_CANCEL_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_BA_PS_BITMAP_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_ENCR_RX_FIFO_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_MAC_PHYIFFIFO_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_TX_FIFO_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_RX_FIFO_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_HW_FSM_RESET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_DET_RST    0x0
#define MAC_HW_MAC_ERR_REC_CNTRL_USE_ERR_REC_RST    0x0

static inline void mac_hw_mac_err_rec_cntrl_pack(struct cl_chip *chip, u8 force_auto_resp_20_mhz, u8 pps_timeout, u8 rx_fifo_ovf_cancel, u8 rx_vec2_in_rhd_en, u8 rx_padding_en, u8 tx_und_flow_cntrl_en, u8 hdr_split_en, u8 mask_cca_before_tick, u8 rx_flow_cntrl_en2, u8 rx_flow_cntrl_en, u8 cca_zero_on_rx_cancel, u8 ba_ps_bitmap_reset, u8 encr_rx_fifo_reset, u8 mac_phyiffifo_reset, u8 tx_fifo_reset, u8 rx_fifo_reset, u8 hw_fsm_reset, u8 use_err_det, u8 use_err_rec)
{
	ASSERT_ERR_CHIP((((u32)force_auto_resp_20_mhz << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)pps_timeout << 28) & ~((u32)0x70000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_ovf_cancel << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_vec2_in_rhd_en << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_padding_en << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_und_flow_cntrl_en << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)hdr_split_en << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)mask_cca_before_tick << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_flow_cntrl_en2 << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_flow_cntrl_en << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)cca_zero_on_rx_cancel << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_ps_bitmap_reset << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)encr_rx_fifo_reset << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyiffifo_reset << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_fifo_reset << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_reset << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)hw_fsm_reset << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)use_err_det << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)use_err_rec << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, ((u32)force_auto_resp_20_mhz << 31) | ((u32)pps_timeout << 28) | ((u32)rx_fifo_ovf_cancel << 27) | ((u32)rx_vec2_in_rhd_en << 26) | ((u32)rx_padding_en << 25) | ((u32)tx_und_flow_cntrl_en << 24) | ((u32)hdr_split_en << 23) | ((u32)mask_cca_before_tick << 18) | ((u32)rx_flow_cntrl_en2 << 17) | ((u32)rx_flow_cntrl_en << 16) | ((u32)cca_zero_on_rx_cancel << 8) | ((u32)ba_ps_bitmap_reset << 7) | ((u32)encr_rx_fifo_reset << 6) | ((u32)mac_phyiffifo_reset << 5) | ((u32)tx_fifo_reset << 4) | ((u32)rx_fifo_reset << 3) | ((u32)hw_fsm_reset << 2) | ((u32)use_err_det << 1) | ((u32)use_err_rec << 0));
}

static inline void mac_hw_mac_err_rec_cntrl_unpack(struct cl_chip *chip, u8 *force_auto_resp_20_mhz, u8 *pps_timeout, u8 *rx_fifo_ovf_cancel, u8 *rx_vec2_in_rhd_en, u8 *rx_padding_en, u8 *tx_und_flow_cntrl_en, u8 *hdr_split_en, u8 *mask_cca_before_tick, u8 *rx_flow_cntrl_en2, u8 *rx_flow_cntrl_en, u8 *cca_zero_on_rx_cancel, u8 *ba_ps_bitmap_reset, u8 *encr_rx_fifo_reset, u8 *mac_phyiffifo_reset, u8 *tx_fifo_reset, u8 *rx_fifo_reset, u8 *hw_fsm_reset, u8 *use_err_det, u8 *use_err_rec)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	*force_auto_resp_20_mhz = (local_val & ((u32)0x80000000)) >> 31;
	*pps_timeout = (local_val & ((u32)0x70000000)) >> 28;
	*rx_fifo_ovf_cancel = (local_val & ((u32)0x08000000)) >> 27;
	*rx_vec2_in_rhd_en = (local_val & ((u32)0x04000000)) >> 26;
	*rx_padding_en = (local_val & ((u32)0x02000000)) >> 25;
	*tx_und_flow_cntrl_en = (local_val & ((u32)0x01000000)) >> 24;
	*hdr_split_en = (local_val & ((u32)0x00800000)) >> 23;
	*mask_cca_before_tick = (local_val & ((u32)0x00040000)) >> 18;
	*rx_flow_cntrl_en2 = (local_val & ((u32)0x00020000)) >> 17;
	*rx_flow_cntrl_en = (local_val & ((u32)0x00010000)) >> 16;
	*cca_zero_on_rx_cancel = (local_val & ((u32)0x00000100)) >> 8;
	*ba_ps_bitmap_reset = (local_val & ((u32)0x00000080)) >> 7;
	*encr_rx_fifo_reset = (local_val & ((u32)0x00000040)) >> 6;
	*mac_phyiffifo_reset = (local_val & ((u32)0x00000020)) >> 5;
	*tx_fifo_reset = (local_val & ((u32)0x00000010)) >> 4;
	*rx_fifo_reset = (local_val & ((u32)0x00000008)) >> 3;
	*hw_fsm_reset = (local_val & ((u32)0x00000004)) >> 2;
	*use_err_det = (local_val & ((u32)0x00000002)) >> 1;
	*use_err_rec = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_mac_err_rec_cntrl_force_auto_resp_20_mhz_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_mac_err_rec_cntrl_force_auto_resp_20_mhz_setf(struct cl_chip *chip, u8 forceautoresp20mhz)
{
	ASSERT_ERR_CHIP((((u32)forceautoresp20mhz << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x80000000)) | ((u32)forceautoresp20mhz << 31));
}

static inline u8 mac_hw_mac_err_rec_cntrl_pps_timeout_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x70000000)) >> 28);
}

static inline void mac_hw_mac_err_rec_cntrl_pps_timeout_setf(struct cl_chip *chip, u8 ppstimeout)
{
	ASSERT_ERR_CHIP((((u32)ppstimeout << 28) & ~((u32)0x70000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x70000000)) | ((u32)ppstimeout << 28));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_fifo_ovf_cancel_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_fifo_ovf_cancel_setf(struct cl_chip *chip, u8 rxfifoovfcancel)
{
	ASSERT_ERR_CHIP((((u32)rxfifoovfcancel << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x08000000)) | ((u32)rxfifoovfcancel << 27));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_vec_2_in_rhd_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_vec_2_in_rhd_en_setf(struct cl_chip *chip, u8 rxvec2inrhden)
{
	ASSERT_ERR_CHIP((((u32)rxvec2inrhden << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x04000000)) | ((u32)rxvec2inrhden << 26));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_padding_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_padding_en_setf(struct cl_chip *chip, u8 rxpaddingen)
{
	ASSERT_ERR_CHIP((((u32)rxpaddingen << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x02000000)) | ((u32)rxpaddingen << 25));
}

static inline u8 mac_hw_mac_err_rec_cntrl_tx_und_flow_cntrl_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_mac_err_rec_cntrl_tx_und_flow_cntrl_en_setf(struct cl_chip *chip, u8 txundflowcntrlen)
{
	ASSERT_ERR_CHIP((((u32)txundflowcntrlen << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x01000000)) | ((u32)txundflowcntrlen << 24));
}

static inline u8 mac_hw_mac_err_rec_cntrl_hdr_split_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_mac_err_rec_cntrl_hdr_split_en_setf(struct cl_chip *chip, u8 hdrspliten)
{
	ASSERT_ERR_CHIP((((u32)hdrspliten << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00800000)) | ((u32)hdrspliten << 23));
}

static inline u8 mac_hw_mac_err_rec_cntrl_mask_cca_before_tick_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_mac_err_rec_cntrl_mask_cca_before_tick_setf(struct cl_chip *chip, u8 maskccabeforetick)
{
	ASSERT_ERR_CHIP((((u32)maskccabeforetick << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00040000)) | ((u32)maskccabeforetick << 18));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_flow_cntrl_en_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_flow_cntrl_en_2_setf(struct cl_chip *chip, u8 rxflowcntrlen2)
{
	ASSERT_ERR_CHIP((((u32)rxflowcntrlen2 << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00020000)) | ((u32)rxflowcntrlen2 << 17));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_flow_cntrl_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_flow_cntrl_en_setf(struct cl_chip *chip, u8 rxflowcntrlen)
{
	ASSERT_ERR_CHIP((((u32)rxflowcntrlen << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00010000)) | ((u32)rxflowcntrlen << 16));
}

static inline u8 mac_hw_mac_err_rec_cntrl_cca_zero_on_rx_cancel_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_mac_err_rec_cntrl_cca_zero_on_rx_cancel_setf(struct cl_chip *chip, u8 ccazeroonrxcancel)
{
	ASSERT_ERR_CHIP((((u32)ccazeroonrxcancel << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000100)) | ((u32)ccazeroonrxcancel << 8));
}

static inline u8 mac_hw_mac_err_rec_cntrl_ba_ps_bitmap_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_mac_err_rec_cntrl_ba_ps_bitmap_reset_setf(struct cl_chip *chip, u8 bapsbitmapreset)
{
	ASSERT_ERR_CHIP((((u32)bapsbitmapreset << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000080)) | ((u32)bapsbitmapreset << 7));
}

static inline u8 mac_hw_mac_err_rec_cntrl_encr_rx_fifo_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_mac_err_rec_cntrl_encr_rx_fifo_reset_setf(struct cl_chip *chip, u8 encrrxfiforeset)
{
	ASSERT_ERR_CHIP((((u32)encrrxfiforeset << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000040)) | ((u32)encrrxfiforeset << 6));
}

static inline u8 mac_hw_mac_err_rec_cntrl_mac_phyiffifo_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_mac_err_rec_cntrl_mac_phyiffifo_reset_setf(struct cl_chip *chip, u8 macphyiffiforeset)
{
	ASSERT_ERR_CHIP((((u32)macphyiffiforeset << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000020)) | ((u32)macphyiffiforeset << 5));
}

static inline u8 mac_hw_mac_err_rec_cntrl_tx_fifo_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_mac_err_rec_cntrl_tx_fifo_reset_setf(struct cl_chip *chip, u8 txfiforeset)
{
	ASSERT_ERR_CHIP((((u32)txfiforeset << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000010)) | ((u32)txfiforeset << 4));
}

static inline u8 mac_hw_mac_err_rec_cntrl_rx_fifo_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_mac_err_rec_cntrl_rx_fifo_reset_setf(struct cl_chip *chip, u8 rxfiforeset)
{
	ASSERT_ERR_CHIP((((u32)rxfiforeset << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000008)) | ((u32)rxfiforeset << 3));
}

static inline u8 mac_hw_mac_err_rec_cntrl_hw_fsm_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_mac_err_rec_cntrl_hw_fsm_reset_setf(struct cl_chip *chip, u8 hwfsmreset)
{
	ASSERT_ERR_CHIP((((u32)hwfsmreset << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000004)) | ((u32)hwfsmreset << 2));
}

static inline u8 mac_hw_mac_err_rec_cntrl_use_err_det_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_mac_err_rec_cntrl_use_err_det_setf(struct cl_chip *chip, u8 useerrdet)
{
	ASSERT_ERR_CHIP((((u32)useerrdet << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR) & ~((u32)0x00000002)) | ((u32)useerrdet << 1));
}

static inline u8 mac_hw_mac_err_rec_cntrl_use_err_rec_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_ERR_REC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief MAC_ERR_SET_STATUS register definition
 *  HW error status set register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    03    ERR_IN_HW_LEVEL_3         0
 *    02    ERR_IN_TX_RX_LEVEL_2      0
 *    01    ERR_IN_RX_LEVEL_1         0
 *    00    ERR_IN_TX_LEVEL_1         0
 * </pre>
 */
#define MAC_HW_MAC_ERR_SET_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000058)
#define MAC_HW_MAC_ERR_SET_STATUS_OFFSET      0x00000058
#define MAC_HW_MAC_ERR_SET_STATUS_INDEX       0x00000016
#define MAC_HW_MAC_ERR_SET_STATUS_RESET       0x00000000

static inline void mac_hw_mac_err_set_status_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_HW_LEVEL_3_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_HW_LEVEL_3_POS    3
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_RX_LEVEL_2_BIT    ((u32)0x00000004)
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_RX_LEVEL_2_POS    2
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_RX_LEVEL_1_BIT    ((u32)0x00000002)
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_RX_LEVEL_1_POS    1
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_LEVEL_1_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_LEVEL_1_POS    0

#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_HW_LEVEL_3_RST    0x0
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_RX_LEVEL_2_RST    0x0
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_RX_LEVEL_1_RST    0x0
#define MAC_HW_MAC_ERR_SET_STATUS_ERR_IN_TX_LEVEL_1_RST    0x0

static inline void mac_hw_mac_err_set_status_pack(struct cl_chip *chip, u8 err_in_hw_level_3, u8 err_in_tx_rx_level_2, u8 err_in_rx_level_1, u8 err_in_tx_level_1)
{
	ASSERT_ERR_CHIP((((u32)err_in_hw_level_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)err_in_tx_rx_level_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)err_in_rx_level_1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)err_in_tx_level_1 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, ((u32)err_in_hw_level_3 << 3) | ((u32)err_in_tx_rx_level_2 << 2) | ((u32)err_in_rx_level_1 << 1) | ((u32)err_in_tx_level_1 << 0));
}

static inline void mac_hw_mac_err_set_status_err_in_hw_level_3_setf(struct cl_chip *chip, u8 errinhwlevel3)
{
	ASSERT_ERR_CHIP((((u32)errinhwlevel3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR) & ~((u32)0x00000008)) | ((u32)errinhwlevel3 << 3));
}

static inline void mac_hw_mac_err_set_status_err_in_tx_rx_level_2_setf(struct cl_chip *chip, u8 errintxrxlevel2)
{
	ASSERT_ERR_CHIP((((u32)errintxrxlevel2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR) & ~((u32)0x00000004)) | ((u32)errintxrxlevel2 << 2));
}

static inline void mac_hw_mac_err_set_status_err_in_rx_level_1_setf(struct cl_chip *chip, u8 errinrxlevel1)
{
	ASSERT_ERR_CHIP((((u32)errinrxlevel1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR) & ~((u32)0x00000002)) | ((u32)errinrxlevel1 << 1));
}

static inline void mac_hw_mac_err_set_status_err_in_tx_level_1_setf(struct cl_chip *chip, u8 errintxlevel1)
{
	ASSERT_ERR_CHIP((((u32)errintxlevel1 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_SET_STATUS_ADDR) & ~((u32)0x00000001)) | ((u32)errintxlevel1 << 0));
}

/**
 * @brief MAC_ERR_CLEAR_STATUS register definition
 *  HW error status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    03    CLEAR_ERR_IN_HW_LEVEL_3   0
 *    02    CLEAR_ERR_IN_TX_RX_LEVEL_2 0
 *    01    CLEAR_ERR_IN_RX_LEVEL_1   0
 *    00    CLEAR_ERR_IN_TX_LEVEL_1   0
 * </pre>
 */
#define MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000005C)
#define MAC_HW_MAC_ERR_CLEAR_STATUS_OFFSET      0x0000005C
#define MAC_HW_MAC_ERR_CLEAR_STATUS_INDEX       0x00000017
#define MAC_HW_MAC_ERR_CLEAR_STATUS_RESET       0x00000000

static inline void mac_hw_mac_err_clear_status_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_HW_LEVEL_3_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_HW_LEVEL_3_POS    3
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_RX_LEVEL_2_BIT    ((u32)0x00000004)
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_RX_LEVEL_2_POS    2
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_RX_LEVEL_1_BIT    ((u32)0x00000002)
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_RX_LEVEL_1_POS    1
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_LEVEL_1_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_LEVEL_1_POS    0

#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_HW_LEVEL_3_RST    0x0
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_RX_LEVEL_2_RST    0x0
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_RX_LEVEL_1_RST    0x0
#define MAC_HW_MAC_ERR_CLEAR_STATUS_CLEAR_ERR_IN_TX_LEVEL_1_RST    0x0

static inline void mac_hw_mac_err_clear_status_pack(struct cl_chip *chip, u8 clear_err_in_hw_level_3, u8 clear_err_in_tx_rx_level_2, u8 clear_err_in_rx_level_1, u8 clear_err_in_tx_level_1)
{
	ASSERT_ERR_CHIP((((u32)clear_err_in_hw_level_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_err_in_tx_rx_level_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_err_in_rx_level_1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_err_in_tx_level_1 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, ((u32)clear_err_in_hw_level_3 << 3) | ((u32)clear_err_in_tx_rx_level_2 << 2) | ((u32)clear_err_in_rx_level_1 << 1) | ((u32)clear_err_in_tx_level_1 << 0));
}

static inline void mac_hw_mac_err_clear_status_clear_err_in_hw_level_3_setf(struct cl_chip *chip, u8 clearerrinhwlevel3)
{
	ASSERT_ERR_CHIP((((u32)clearerrinhwlevel3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR) & ~((u32)0x00000008)) | ((u32)clearerrinhwlevel3 << 3));
}

static inline void mac_hw_mac_err_clear_status_clear_err_in_tx_rx_level_2_setf(struct cl_chip *chip, u8 clearerrintxrxlevel2)
{
	ASSERT_ERR_CHIP((((u32)clearerrintxrxlevel2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR) & ~((u32)0x00000004)) | ((u32)clearerrintxrxlevel2 << 2));
}

static inline void mac_hw_mac_err_clear_status_clear_err_in_rx_level_1_setf(struct cl_chip *chip, u8 clearerrinrxlevel1)
{
	ASSERT_ERR_CHIP((((u32)clearerrinrxlevel1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR) & ~((u32)0x00000002)) | ((u32)clearerrinrxlevel1 << 1));
}

static inline void mac_hw_mac_err_clear_status_clear_err_in_tx_level_1_setf(struct cl_chip *chip, u8 clearerrintxlevel1)
{
	ASSERT_ERR_CHIP((((u32)clearerrintxlevel1 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR, (cl_reg_read(chip, MAC_HW_MAC_ERR_CLEAR_STATUS_ADDR) & ~((u32)0x00000001)) | ((u32)clearerrintxlevel1 << 0));
}

/**
 * @brief RX_CNTRL register definition
 *  Controls the HW receive operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EN_DUPLICATE_DETECTION    0
 *    30    ACCEPT_UNKNOWN            0
 *    29    ACCEPT_OTHER_DATA_FRAMES  0
 *    28    ACCEPT_QO_S_NULL          1
 *    27    ACCEPT_QCFWO_DATA         0
 *    26    ACCEPT_Q_DATA             1
 *    25    ACCEPT_CFWO_DATA          0
 *    24    ACCEPT_DATA               1
 *    23    ACCEPT_OTHER_CNTRL_FRAMES 0
 *    22    ACCEPT_CF_END             0
 *    21    ACCEPT_ACK                0
 *    20    ACCEPT_CTS                0
 *    19    ACCEPT_RTS                0
 *    18    ACCEPT_PS_POLL            1
 *    17    ACCEPT_BA                 1
 *    16    ACCEPT_BAR                1
 *    15    ACCEPT_OTHER_MGMT_FRAMES  1
 *    14    DONT_DECRYPT_PMF          0
 *    13    ACCEPT_ALL_BEACON         0
 *    12    ACCEPT_NOT_EXPECTED_BA    0
 *    11    ACCEPT_DECRYPT_ERROR_FRAMES 0
 *    10    ACCEPT_BEACON             1
 *    09    ACCEPT_PROBE_RESP         1
 *    08    ACCEPT_PROBE_REQ          1
 *    07    ACCEPT_MY_UNICAST         1
 *    06    ACCEPT_UNICAST            0
 *    05    ACCEPT_ERROR_FRAMES       0
 *    04    ACCEPT_OTHER_BSSID        0
 *    03    ACCEPT_BROADCAST          1
 *    02    ACCEPT_MULTICAST          0
 *    01    DONT_DECRYPT              0
 *    00    EXC_UNENCRYPTED           0
 * </pre>
 */
#define MAC_HW_RX_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000060)
#define MAC_HW_RX_CNTRL_OFFSET      0x00000060
#define MAC_HW_RX_CNTRL_INDEX       0x00000018
#define MAC_HW_RX_CNTRL_RESET       0x15078788

static inline u32 mac_hw_rx_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);
}

static inline void mac_hw_rx_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CNTRL_EN_DUPLICATE_DETECTION_BIT    ((u32)0x80000000)
#define MAC_HW_RX_CNTRL_EN_DUPLICATE_DETECTION_POS    31
#define MAC_HW_RX_CNTRL_ACCEPT_UNKNOWN_BIT    ((u32)0x40000000)
#define MAC_HW_RX_CNTRL_ACCEPT_UNKNOWN_POS    30
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_DATA_FRAMES_BIT    ((u32)0x20000000)
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_DATA_FRAMES_POS    29
#define MAC_HW_RX_CNTRL_ACCEPT_QO_S_NULL_BIT    ((u32)0x10000000)
#define MAC_HW_RX_CNTRL_ACCEPT_QO_S_NULL_POS    28
#define MAC_HW_RX_CNTRL_ACCEPT_QCFWO_DATA_BIT    ((u32)0x08000000)
#define MAC_HW_RX_CNTRL_ACCEPT_QCFWO_DATA_POS    27
#define MAC_HW_RX_CNTRL_ACCEPT_Q_DATA_BIT    ((u32)0x04000000)
#define MAC_HW_RX_CNTRL_ACCEPT_Q_DATA_POS    26
#define MAC_HW_RX_CNTRL_ACCEPT_CFWO_DATA_BIT    ((u32)0x02000000)
#define MAC_HW_RX_CNTRL_ACCEPT_CFWO_DATA_POS    25
#define MAC_HW_RX_CNTRL_ACCEPT_DATA_BIT     ((u32)0x01000000)
#define MAC_HW_RX_CNTRL_ACCEPT_DATA_POS     24
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_CNTRL_FRAMES_BIT    ((u32)0x00800000)
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_CNTRL_FRAMES_POS    23
#define MAC_HW_RX_CNTRL_ACCEPT_CF_END_BIT    ((u32)0x00400000)
#define MAC_HW_RX_CNTRL_ACCEPT_CF_END_POS    22
#define MAC_HW_RX_CNTRL_ACCEPT_ACK_BIT      ((u32)0x00200000)
#define MAC_HW_RX_CNTRL_ACCEPT_ACK_POS      21
#define MAC_HW_RX_CNTRL_ACCEPT_CTS_BIT      ((u32)0x00100000)
#define MAC_HW_RX_CNTRL_ACCEPT_CTS_POS      20
#define MAC_HW_RX_CNTRL_ACCEPT_RTS_BIT      ((u32)0x00080000)
#define MAC_HW_RX_CNTRL_ACCEPT_RTS_POS      19
#define MAC_HW_RX_CNTRL_ACCEPT_PS_POLL_BIT    ((u32)0x00040000)
#define MAC_HW_RX_CNTRL_ACCEPT_PS_POLL_POS    18
#define MAC_HW_RX_CNTRL_ACCEPT_BA_BIT       ((u32)0x00020000)
#define MAC_HW_RX_CNTRL_ACCEPT_BA_POS       17
#define MAC_HW_RX_CNTRL_ACCEPT_BAR_BIT      ((u32)0x00010000)
#define MAC_HW_RX_CNTRL_ACCEPT_BAR_POS      16
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_MGMT_FRAMES_BIT    ((u32)0x00008000)
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_MGMT_FRAMES_POS    15
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_PMF_BIT    ((u32)0x00004000)
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_PMF_POS    14
#define MAC_HW_RX_CNTRL_ACCEPT_ALL_BEACON_BIT    ((u32)0x00002000)
#define MAC_HW_RX_CNTRL_ACCEPT_ALL_BEACON_POS    13
#define MAC_HW_RX_CNTRL_ACCEPT_NOT_EXPECTED_BA_BIT    ((u32)0x00001000)
#define MAC_HW_RX_CNTRL_ACCEPT_NOT_EXPECTED_BA_POS    12
#define MAC_HW_RX_CNTRL_ACCEPT_DECRYPT_ERROR_FRAMES_BIT    ((u32)0x00000800)
#define MAC_HW_RX_CNTRL_ACCEPT_DECRYPT_ERROR_FRAMES_POS    11
#define MAC_HW_RX_CNTRL_ACCEPT_BEACON_BIT    ((u32)0x00000400)
#define MAC_HW_RX_CNTRL_ACCEPT_BEACON_POS    10
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_RESP_BIT    ((u32)0x00000200)
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_RESP_POS    9
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_REQ_BIT    ((u32)0x00000100)
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_REQ_POS    8
#define MAC_HW_RX_CNTRL_ACCEPT_MY_UNICAST_BIT    ((u32)0x00000080)
#define MAC_HW_RX_CNTRL_ACCEPT_MY_UNICAST_POS    7
#define MAC_HW_RX_CNTRL_ACCEPT_UNICAST_BIT    ((u32)0x00000040)
#define MAC_HW_RX_CNTRL_ACCEPT_UNICAST_POS    6
#define MAC_HW_RX_CNTRL_ACCEPT_ERROR_FRAMES_BIT    ((u32)0x00000020)
#define MAC_HW_RX_CNTRL_ACCEPT_ERROR_FRAMES_POS    5
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_BSSID_BIT    ((u32)0x00000010)
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_BSSID_POS    4
#define MAC_HW_RX_CNTRL_ACCEPT_BROADCAST_BIT    ((u32)0x00000008)
#define MAC_HW_RX_CNTRL_ACCEPT_BROADCAST_POS    3
#define MAC_HW_RX_CNTRL_ACCEPT_MULTICAST_BIT    ((u32)0x00000004)
#define MAC_HW_RX_CNTRL_ACCEPT_MULTICAST_POS    2
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_BIT    ((u32)0x00000002)
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_POS    1
#define MAC_HW_RX_CNTRL_EXC_UNENCRYPTED_BIT    ((u32)0x00000001)
#define MAC_HW_RX_CNTRL_EXC_UNENCRYPTED_POS    0

#define MAC_HW_RX_CNTRL_EN_DUPLICATE_DETECTION_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_UNKNOWN_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_DATA_FRAMES_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_QO_S_NULL_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_QCFWO_DATA_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_Q_DATA_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_CFWO_DATA_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_DATA_RST     0x1
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_CNTRL_FRAMES_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_CF_END_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_ACK_RST      0x0
#define MAC_HW_RX_CNTRL_ACCEPT_CTS_RST      0x0
#define MAC_HW_RX_CNTRL_ACCEPT_RTS_RST      0x0
#define MAC_HW_RX_CNTRL_ACCEPT_PS_POLL_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_BA_RST       0x1
#define MAC_HW_RX_CNTRL_ACCEPT_BAR_RST      0x1
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_MGMT_FRAMES_RST    0x1
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_PMF_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_ALL_BEACON_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_NOT_EXPECTED_BA_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_DECRYPT_ERROR_FRAMES_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_BEACON_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_RESP_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_PROBE_REQ_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_MY_UNICAST_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_UNICAST_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_ERROR_FRAMES_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_OTHER_BSSID_RST    0x0
#define MAC_HW_RX_CNTRL_ACCEPT_BROADCAST_RST    0x1
#define MAC_HW_RX_CNTRL_ACCEPT_MULTICAST_RST    0x0
#define MAC_HW_RX_CNTRL_DONT_DECRYPT_RST    0x0
#define MAC_HW_RX_CNTRL_EXC_UNENCRYPTED_RST    0x0

static inline void mac_hw_rx_cntrl_pack(struct cl_chip *chip, u8 en_duplicate_detection, u8 accept_unknown, u8 accept_other_data_frames, u8 accept_qo_s_null, u8 accept_qcfwo_data, u8 accept_q_data, u8 accept_cfwo_data, u8 accept_data, u8 accept_other_cntrl_frames, u8 accept_cf_end, u8 accept_ack, u8 accept_cts, u8 accept_rts, u8 accept_ps_poll, u8 accept_ba, u8 accept_bar, u8 accept_other_mgmt_frames, u8 dont_decrypt_pmf, u8 accept_all_beacon, u8 accept_not_expected_ba, u8 accept_decrypt_error_frames, u8 accept_beacon, u8 accept_probe_resp, u8 accept_probe_req, u8 accept_my_unicast, u8 accept_unicast, u8 accept_error_frames, u8 accept_other_bssid, u8 accept_broadcast, u8 accept_multicast, u8 dont_decrypt, u8 exc_unencrypted)
{
	ASSERT_ERR_CHIP((((u32)en_duplicate_detection << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_unknown << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_other_data_frames << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_qo_s_null << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_qcfwo_data << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_q_data << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_cfwo_data << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_data << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_other_cntrl_frames << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_cf_end << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_ack << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_cts << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_rts << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_ps_poll << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_ba << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_bar << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_other_mgmt_frames << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)dont_decrypt_pmf << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_all_beacon << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_not_expected_ba << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_decrypt_error_frames << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_beacon << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_probe_resp << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_probe_req << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_my_unicast << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_unicast << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_error_frames << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_other_bssid << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_broadcast << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_multicast << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)dont_decrypt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)exc_unencrypted << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, ((u32)en_duplicate_detection << 31) | ((u32)accept_unknown << 30) | ((u32)accept_other_data_frames << 29) | ((u32)accept_qo_s_null << 28) | ((u32)accept_qcfwo_data << 27) | ((u32)accept_q_data << 26) | ((u32)accept_cfwo_data << 25) | ((u32)accept_data << 24) | ((u32)accept_other_cntrl_frames << 23) | ((u32)accept_cf_end << 22) | ((u32)accept_ack << 21) | ((u32)accept_cts << 20) | ((u32)accept_rts << 19) | ((u32)accept_ps_poll << 18) | ((u32)accept_ba << 17) | ((u32)accept_bar << 16) | ((u32)accept_other_mgmt_frames << 15) | ((u32)dont_decrypt_pmf << 14) | ((u32)accept_all_beacon << 13) | ((u32)accept_not_expected_ba << 12) | ((u32)accept_decrypt_error_frames << 11) | ((u32)accept_beacon << 10) | ((u32)accept_probe_resp << 9) | ((u32)accept_probe_req << 8) | ((u32)accept_my_unicast << 7) | ((u32)accept_unicast << 6) | ((u32)accept_error_frames << 5) | ((u32)accept_other_bssid << 4) | ((u32)accept_broadcast << 3) | ((u32)accept_multicast << 2) | ((u32)dont_decrypt << 1) | ((u32)exc_unencrypted << 0));
}

static inline void mac_hw_rx_cntrl_unpack(struct cl_chip *chip, u8 *en_duplicate_detection, u8 *accept_unknown, u8 *accept_other_data_frames, u8 *accept_qo_s_null, u8 *accept_qcfwo_data, u8 *accept_q_data, u8 *accept_cfwo_data, u8 *accept_data, u8 *accept_other_cntrl_frames, u8 *accept_cf_end, u8 *accept_ack, u8 *accept_cts, u8 *accept_rts, u8 *accept_ps_poll, u8 *accept_ba, u8 *accept_bar, u8 *accept_other_mgmt_frames, u8 *dont_decrypt_pmf, u8 *accept_all_beacon, u8 *accept_not_expected_ba, u8 *accept_decrypt_error_frames, u8 *accept_beacon, u8 *accept_probe_resp, u8 *accept_probe_req, u8 *accept_my_unicast, u8 *accept_unicast, u8 *accept_error_frames, u8 *accept_other_bssid, u8 *accept_broadcast, u8 *accept_multicast, u8 *dont_decrypt, u8 *exc_unencrypted)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	*en_duplicate_detection = (local_val & ((u32)0x80000000)) >> 31;
	*accept_unknown = (local_val & ((u32)0x40000000)) >> 30;
	*accept_other_data_frames = (local_val & ((u32)0x20000000)) >> 29;
	*accept_qo_s_null = (local_val & ((u32)0x10000000)) >> 28;
	*accept_qcfwo_data = (local_val & ((u32)0x08000000)) >> 27;
	*accept_q_data = (local_val & ((u32)0x04000000)) >> 26;
	*accept_cfwo_data = (local_val & ((u32)0x02000000)) >> 25;
	*accept_data = (local_val & ((u32)0x01000000)) >> 24;
	*accept_other_cntrl_frames = (local_val & ((u32)0x00800000)) >> 23;
	*accept_cf_end = (local_val & ((u32)0x00400000)) >> 22;
	*accept_ack = (local_val & ((u32)0x00200000)) >> 21;
	*accept_cts = (local_val & ((u32)0x00100000)) >> 20;
	*accept_rts = (local_val & ((u32)0x00080000)) >> 19;
	*accept_ps_poll = (local_val & ((u32)0x00040000)) >> 18;
	*accept_ba = (local_val & ((u32)0x00020000)) >> 17;
	*accept_bar = (local_val & ((u32)0x00010000)) >> 16;
	*accept_other_mgmt_frames = (local_val & ((u32)0x00008000)) >> 15;
	*dont_decrypt_pmf = (local_val & ((u32)0x00004000)) >> 14;
	*accept_all_beacon = (local_val & ((u32)0x00002000)) >> 13;
	*accept_not_expected_ba = (local_val & ((u32)0x00001000)) >> 12;
	*accept_decrypt_error_frames = (local_val & ((u32)0x00000800)) >> 11;
	*accept_beacon = (local_val & ((u32)0x00000400)) >> 10;
	*accept_probe_resp = (local_val & ((u32)0x00000200)) >> 9;
	*accept_probe_req = (local_val & ((u32)0x00000100)) >> 8;
	*accept_my_unicast = (local_val & ((u32)0x00000080)) >> 7;
	*accept_unicast = (local_val & ((u32)0x00000040)) >> 6;
	*accept_error_frames = (local_val & ((u32)0x00000020)) >> 5;
	*accept_other_bssid = (local_val & ((u32)0x00000010)) >> 4;
	*accept_broadcast = (local_val & ((u32)0x00000008)) >> 3;
	*accept_multicast = (local_val & ((u32)0x00000004)) >> 2;
	*dont_decrypt = (local_val & ((u32)0x00000002)) >> 1;
	*exc_unencrypted = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_cntrl_en_duplicate_detection_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_rx_cntrl_accept_unknown_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_rx_cntrl_accept_unknown_setf(struct cl_chip *chip, u8 acceptunknown)
{
	ASSERT_ERR_CHIP((((u32)acceptunknown << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x40000000)) | ((u32)acceptunknown << 30));
}

static inline u8 mac_hw_rx_cntrl_accept_other_data_frames_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_rx_cntrl_accept_other_data_frames_setf(struct cl_chip *chip, u8 acceptotherdataframes)
{
	ASSERT_ERR_CHIP((((u32)acceptotherdataframes << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x20000000)) | ((u32)acceptotherdataframes << 29));
}

static inline u8 mac_hw_rx_cntrl_accept_qo_s_null_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_rx_cntrl_accept_qo_s_null_setf(struct cl_chip *chip, u8 acceptqosnull)
{
	ASSERT_ERR_CHIP((((u32)acceptqosnull << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x10000000)) | ((u32)acceptqosnull << 28));
}

static inline u8 mac_hw_rx_cntrl_accept_qcfwo_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_rx_cntrl_accept_qcfwo_data_setf(struct cl_chip *chip, u8 acceptqcfwodata)
{
	ASSERT_ERR_CHIP((((u32)acceptqcfwodata << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x08000000)) | ((u32)acceptqcfwodata << 27));
}

static inline u8 mac_hw_rx_cntrl_accept_q_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_rx_cntrl_accept_q_data_setf(struct cl_chip *chip, u8 acceptqdata)
{
	ASSERT_ERR_CHIP((((u32)acceptqdata << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x04000000)) | ((u32)acceptqdata << 26));
}

static inline u8 mac_hw_rx_cntrl_accept_cfwo_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_rx_cntrl_accept_cfwo_data_setf(struct cl_chip *chip, u8 acceptcfwodata)
{
	ASSERT_ERR_CHIP((((u32)acceptcfwodata << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x02000000)) | ((u32)acceptcfwodata << 25));
}

static inline u8 mac_hw_rx_cntrl_accept_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_rx_cntrl_accept_data_setf(struct cl_chip *chip, u8 acceptdata)
{
	ASSERT_ERR_CHIP((((u32)acceptdata << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x01000000)) | ((u32)acceptdata << 24));
}

static inline u8 mac_hw_rx_cntrl_accept_other_cntrl_frames_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_cntrl_accept_other_cntrl_frames_setf(struct cl_chip *chip, u8 acceptothercntrlframes)
{
	ASSERT_ERR_CHIP((((u32)acceptothercntrlframes << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00800000)) | ((u32)acceptothercntrlframes << 23));
}

static inline u8 mac_hw_rx_cntrl_accept_cf_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_cntrl_accept_cf_end_setf(struct cl_chip *chip, u8 acceptcfend)
{
	ASSERT_ERR_CHIP((((u32)acceptcfend << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00400000)) | ((u32)acceptcfend << 22));
}

static inline u8 mac_hw_rx_cntrl_accept_ack_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_rx_cntrl_accept_ack_setf(struct cl_chip *chip, u8 acceptack)
{
	ASSERT_ERR_CHIP((((u32)acceptack << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00200000)) | ((u32)acceptack << 21));
}

static inline u8 mac_hw_rx_cntrl_accept_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_cntrl_accept_cts_setf(struct cl_chip *chip, u8 acceptcts)
{
	ASSERT_ERR_CHIP((((u32)acceptcts << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00100000)) | ((u32)acceptcts << 20));
}

static inline u8 mac_hw_rx_cntrl_accept_rts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_cntrl_accept_rts_setf(struct cl_chip *chip, u8 acceptrts)
{
	ASSERT_ERR_CHIP((((u32)acceptrts << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00080000)) | ((u32)acceptrts << 19));
}

static inline u8 mac_hw_rx_cntrl_accept_ps_poll_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_cntrl_accept_ps_poll_setf(struct cl_chip *chip, u8 acceptpspoll)
{
	ASSERT_ERR_CHIP((((u32)acceptpspoll << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00040000)) | ((u32)acceptpspoll << 18));
}

static inline u8 mac_hw_rx_cntrl_accept_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_rx_cntrl_accept_ba_setf(struct cl_chip *chip, u8 acceptba)
{
	ASSERT_ERR_CHIP((((u32)acceptba << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00020000)) | ((u32)acceptba << 17));
}

static inline u8 mac_hw_rx_cntrl_accept_bar_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_cntrl_accept_bar_setf(struct cl_chip *chip, u8 acceptbar)
{
	ASSERT_ERR_CHIP((((u32)acceptbar << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00010000)) | ((u32)acceptbar << 16));
}

static inline u8 mac_hw_rx_cntrl_accept_other_mgmt_frames_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_rx_cntrl_accept_other_mgmt_frames_setf(struct cl_chip *chip, u8 acceptothermgmtframes)
{
	ASSERT_ERR_CHIP((((u32)acceptothermgmtframes << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00008000)) | ((u32)acceptothermgmtframes << 15));
}

static inline u8 mac_hw_rx_cntrl_dont_decrypt_pmf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_rx_cntrl_dont_decrypt_pmf_setf(struct cl_chip *chip, u8 dontdecryptpmf)
{
	ASSERT_ERR_CHIP((((u32)dontdecryptpmf << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00004000)) | ((u32)dontdecryptpmf << 14));
}

static inline u8 mac_hw_rx_cntrl_accept_all_beacon_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_rx_cntrl_accept_all_beacon_setf(struct cl_chip *chip, u8 acceptallbeacon)
{
	ASSERT_ERR_CHIP((((u32)acceptallbeacon << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00002000)) | ((u32)acceptallbeacon << 13));
}

static inline u8 mac_hw_rx_cntrl_accept_not_expected_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_rx_cntrl_accept_not_expected_ba_setf(struct cl_chip *chip, u8 acceptnotexpectedba)
{
	ASSERT_ERR_CHIP((((u32)acceptnotexpectedba << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00001000)) | ((u32)acceptnotexpectedba << 12));
}

static inline u8 mac_hw_rx_cntrl_accept_decrypt_error_frames_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_rx_cntrl_accept_decrypt_error_frames_setf(struct cl_chip *chip, u8 acceptdecrypterrorframes)
{
	ASSERT_ERR_CHIP((((u32)acceptdecrypterrorframes << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000800)) | ((u32)acceptdecrypterrorframes << 11));
}

static inline u8 mac_hw_rx_cntrl_accept_beacon_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_rx_cntrl_accept_beacon_setf(struct cl_chip *chip, u8 acceptbeacon)
{
	ASSERT_ERR_CHIP((((u32)acceptbeacon << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000400)) | ((u32)acceptbeacon << 10));
}

static inline u8 mac_hw_rx_cntrl_accept_probe_resp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_rx_cntrl_accept_probe_resp_setf(struct cl_chip *chip, u8 acceptproberesp)
{
	ASSERT_ERR_CHIP((((u32)acceptproberesp << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000200)) | ((u32)acceptproberesp << 9));
}

static inline u8 mac_hw_rx_cntrl_accept_probe_req_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_cntrl_accept_probe_req_setf(struct cl_chip *chip, u8 acceptprobereq)
{
	ASSERT_ERR_CHIP((((u32)acceptprobereq << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000100)) | ((u32)acceptprobereq << 8));
}

static inline u8 mac_hw_rx_cntrl_accept_my_unicast_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_rx_cntrl_accept_my_unicast_setf(struct cl_chip *chip, u8 acceptmyunicast)
{
	ASSERT_ERR_CHIP((((u32)acceptmyunicast << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000080)) | ((u32)acceptmyunicast << 7));
}

static inline u8 mac_hw_rx_cntrl_accept_unicast_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_rx_cntrl_accept_unicast_setf(struct cl_chip *chip, u8 acceptunicast)
{
	ASSERT_ERR_CHIP((((u32)acceptunicast << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000040)) | ((u32)acceptunicast << 6));
}

static inline u8 mac_hw_rx_cntrl_accept_error_frames_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_cntrl_accept_error_frames_setf(struct cl_chip *chip, u8 accepterrorframes)
{
	ASSERT_ERR_CHIP((((u32)accepterrorframes << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000020)) | ((u32)accepterrorframes << 5));
}

static inline u8 mac_hw_rx_cntrl_accept_other_bssid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_cntrl_accept_other_bssid_setf(struct cl_chip *chip, u8 acceptotherbssid)
{
	ASSERT_ERR_CHIP((((u32)acceptotherbssid << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000010)) | ((u32)acceptotherbssid << 4));
}

static inline u8 mac_hw_rx_cntrl_accept_broadcast_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_cntrl_accept_broadcast_setf(struct cl_chip *chip, u8 acceptbroadcast)
{
	ASSERT_ERR_CHIP((((u32)acceptbroadcast << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000008)) | ((u32)acceptbroadcast << 3));
}

static inline u8 mac_hw_rx_cntrl_accept_multicast_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_cntrl_accept_multicast_setf(struct cl_chip *chip, u8 acceptmulticast)
{
	ASSERT_ERR_CHIP((((u32)acceptmulticast << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000004)) | ((u32)acceptmulticast << 2));
}

static inline u8 mac_hw_rx_cntrl_dont_decrypt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_cntrl_dont_decrypt_setf(struct cl_chip *chip, u8 dontdecrypt)
{
	ASSERT_ERR_CHIP((((u32)dontdecrypt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000002)) | ((u32)dontdecrypt << 1));
}

static inline u8 mac_hw_rx_cntrl_exc_unencrypted_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_cntrl_exc_unencrypted_setf(struct cl_chip *chip, u8 excunencrypted)
{
	ASSERT_ERR_CHIP((((u32)excunencrypted << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_ADDR) & ~((u32)0x00000001)) | ((u32)excunencrypted << 0));
}

/**
 * @brief BCN_CNTRL_1 register definition
 *  Information related to beacon transmission is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 NO_BCN_TX_TIME            0x1B
 *    23    IMP_TBTT_IN_128_US        0
 *    22:16 IMP_TBTT_PERIOD           0x1A
 *    15:00 BEACON_INT                0x0
 * </pre>
 */
#define MAC_HW_BCN_CNTRL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000064)
#define MAC_HW_BCN_CNTRL_1_OFFSET      0x00000064
#define MAC_HW_BCN_CNTRL_1_INDEX       0x00000019
#define MAC_HW_BCN_CNTRL_1_RESET       0x1B1A0000

static inline u32 mac_hw_bcn_cntrl_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);
}

static inline void mac_hw_bcn_cntrl_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BCN_CNTRL_1_NO_BCN_TX_TIME_MASK    ((u32)0xFF000000)
#define MAC_HW_BCN_CNTRL_1_NO_BCN_TX_TIME_LSB    24
#define MAC_HW_BCN_CNTRL_1_NO_BCN_TX_TIME_WIDTH    ((u32)0x00000008)
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_IN_128_US_BIT    ((u32)0x00800000)
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_IN_128_US_POS    23
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_PERIOD_MASK    ((u32)0x007F0000)
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_PERIOD_LSB    16
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_PERIOD_WIDTH    ((u32)0x00000007)
#define MAC_HW_BCN_CNTRL_1_BEACON_INT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BCN_CNTRL_1_BEACON_INT_LSB    0
#define MAC_HW_BCN_CNTRL_1_BEACON_INT_WIDTH    ((u32)0x00000010)

#define MAC_HW_BCN_CNTRL_1_NO_BCN_TX_TIME_RST    0x1B
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_IN_128_US_RST    0x0
#define MAC_HW_BCN_CNTRL_1_IMP_TBTT_PERIOD_RST    0x1A
#define MAC_HW_BCN_CNTRL_1_BEACON_INT_RST    0x0

static inline void mac_hw_bcn_cntrl_1_pack(struct cl_chip *chip, u8 no_bcn_tx_time, u8 imp_tbtt_in_128_us, u8 imp_tbtt_period, u16 beacon_int)
{
	ASSERT_ERR_CHIP((((u32)no_bcn_tx_time << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_tbtt_in_128_us << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_tbtt_period << 16) & ~((u32)0x007F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)beacon_int << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, ((u32)no_bcn_tx_time << 24) | ((u32)imp_tbtt_in_128_us << 23) | ((u32)imp_tbtt_period << 16) | ((u32)beacon_int << 0));
}

static inline void mac_hw_bcn_cntrl_1_unpack(struct cl_chip *chip, u8 *no_bcn_tx_time, u8 *imp_tbtt_in_128_us, u8 *imp_tbtt_period, u16 *beacon_int)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);

	*no_bcn_tx_time = (local_val & ((u32)0xFF000000)) >> 24;
	*imp_tbtt_in_128_us = (local_val & ((u32)0x00800000)) >> 23;
	*imp_tbtt_period = (local_val & ((u32)0x007F0000)) >> 16;
	*beacon_int = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bcn_cntrl_1_no_bcn_tx_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_bcn_cntrl_1_no_bcn_tx_time_setf(struct cl_chip *chip, u8 nobcntxtime)
{
	ASSERT_ERR_CHIP((((u32)nobcntxtime << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR) & ~((u32)0xFF000000)) | ((u32)nobcntxtime << 24));
}

static inline u8 mac_hw_bcn_cntrl_1_imp_tbtt_in_128_us_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_bcn_cntrl_1_imp_tbtt_in_128_us_setf(struct cl_chip *chip, u8 imptbttin128us)
{
	ASSERT_ERR_CHIP((((u32)imptbttin128us << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR) & ~((u32)0x00800000)) | ((u32)imptbttin128us << 23));
}

static inline u8 mac_hw_bcn_cntrl_1_imp_tbtt_period_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x007F0000)) >> 16);
}

static inline void mac_hw_bcn_cntrl_1_imp_tbtt_period_setf(struct cl_chip *chip, u8 imptbttperiod)
{
	ASSERT_ERR_CHIP((((u32)imptbttperiod << 16) & ~((u32)0x007F0000)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR) & ~((u32)0x007F0000)) | ((u32)imptbttperiod << 16));
}

static inline u16 mac_hw_bcn_cntrl_1_beacon_int_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bcn_cntrl_1_beacon_int_setf(struct cl_chip *chip, u16 beaconint)
{
	ASSERT_ERR_CHIP((((u32)beaconint << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_1_ADDR) & ~((u32)0x0000FFFF)) | ((u32)beaconint << 0));
}

/**
 * @brief BCN_CNTRL_2 register definition
 *  Information related to beacon transmission is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:16 AID                       0x0
 *    15:08 TIM_OFFSET                0x0
 *    07:00 BCN_UPDATE_OFFSET         0x0
 * </pre>
 */
#define MAC_HW_BCN_CNTRL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000068)
#define MAC_HW_BCN_CNTRL_2_OFFSET      0x00000068
#define MAC_HW_BCN_CNTRL_2_INDEX       0x0000001A
#define MAC_HW_BCN_CNTRL_2_RESET       0x00000000

static inline u32 mac_hw_bcn_cntrl_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR);
}

static inline void mac_hw_bcn_cntrl_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BCN_CNTRL_2_AID_MASK         ((u32)0x0FFF0000)
#define MAC_HW_BCN_CNTRL_2_AID_LSB          16
#define MAC_HW_BCN_CNTRL_2_AID_WIDTH        ((u32)0x0000000C)
#define MAC_HW_BCN_CNTRL_2_TIM_OFFSET_MASK    ((u32)0x0000FF00)
#define MAC_HW_BCN_CNTRL_2_TIM_OFFSET_LSB    8
#define MAC_HW_BCN_CNTRL_2_TIM_OFFSET_WIDTH    ((u32)0x00000008)
#define MAC_HW_BCN_CNTRL_2_BCN_UPDATE_OFFSET_MASK    ((u32)0x000000FF)
#define MAC_HW_BCN_CNTRL_2_BCN_UPDATE_OFFSET_LSB    0
#define MAC_HW_BCN_CNTRL_2_BCN_UPDATE_OFFSET_WIDTH    ((u32)0x00000008)

#define MAC_HW_BCN_CNTRL_2_AID_RST          0x0
#define MAC_HW_BCN_CNTRL_2_TIM_OFFSET_RST    0x0
#define MAC_HW_BCN_CNTRL_2_BCN_UPDATE_OFFSET_RST    0x0

static inline void mac_hw_bcn_cntrl_2_pack(struct cl_chip *chip, u16 aid, u8 tim_offset, u8 bcn_update_offset)
{
	ASSERT_ERR_CHIP((((u32)aid << 16) & ~((u32)0x0FFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_offset << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_update_offset << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_2_ADDR, ((u32)aid << 16) | ((u32)tim_offset << 8) | ((u32)bcn_update_offset << 0));
}

static inline void mac_hw_bcn_cntrl_2_unpack(struct cl_chip *chip, u16 *aid, u8 *tim_offset, u8 *bcn_update_offset)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR);

	*aid = (local_val & ((u32)0x0FFF0000)) >> 16;
	*tim_offset = (local_val & ((u32)0x0000FF00)) >> 8;
	*bcn_update_offset = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_bcn_cntrl_2_aid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR);

	return (u16)((local_val & ((u32)0x0FFF0000)) >> 16);
}

static inline void mac_hw_bcn_cntrl_2_aid_setf(struct cl_chip *chip, u16 aid)
{
	ASSERT_ERR_CHIP((((u32)aid << 16) & ~((u32)0x0FFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR) & ~((u32)0x0FFF0000)) | ((u32)aid << 16));
}

static inline u8 mac_hw_bcn_cntrl_2_tim_offset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_bcn_cntrl_2_tim_offset_setf(struct cl_chip *chip, u8 timoffset)
{
	ASSERT_ERR_CHIP((((u32)timoffset << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR) & ~((u32)0x0000FF00)) | ((u32)timoffset << 8));
}

static inline u8 mac_hw_bcn_cntrl_2_bcn_update_offset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_bcn_cntrl_2_bcn_update_offset_setf(struct cl_chip *chip, u8 bcnupdateoffset)
{
	ASSERT_ERR_CHIP((((u32)bcnupdateoffset << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_2_ADDR) & ~((u32)0x000000FF)) | ((u32)bcnupdateoffset << 0));
}

/**
 * @brief RX_CNTRL_2 register definition
 *  RX receive control 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 primary20_Location        0x0
 *    29    primary80_Location        0
 *    19    disable_response_6ghz     0
 *    18    clear_SBSNLegs_Bar        0
 *    17    clear_SBSNLegs_Data       0
 *    16    enable_Quiet_Interval     0
 *    09    accept_Non_TB             0
 *    08    accept_BQRPtrigger        0
 *    07    accept_BSRPtrigger        0
 *    06    accept_BFRPtrigger        0
 *    05    accept_Mu_RTS             0
 *    04    accept_Mu_BAR             0
 *    03    accept_Basic_Trigger      0
 *    02    accept_NDP                0
 *    01    accept_BRP                0
 *    00    accept_NDPAvht            1
 * </pre>
 */
#define MAC_HW_RX_CNTRL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000006C)
#define MAC_HW_RX_CNTRL_2_OFFSET      0x0000006C
#define MAC_HW_RX_CNTRL_2_INDEX       0x0000001B
#define MAC_HW_RX_CNTRL_2_RESET       0x00000001

static inline u32 mac_hw_rx_cntrl_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);
}

static inline void mac_hw_rx_cntrl_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CNTRL_2_PRIMARY_20_LOCATION_MASK    ((u32)0xC0000000)
#define MAC_HW_RX_CNTRL_2_PRIMARY_20_LOCATION_LSB    30
#define MAC_HW_RX_CNTRL_2_PRIMARY_20_LOCATION_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_CNTRL_2_PRIMARY_80_LOCATION_BIT    ((u32)0x20000000)
#define MAC_HW_RX_CNTRL_2_PRIMARY_80_LOCATION_POS    29
#define MAC_HW_RX_CNTRL_2_DISABLE_RESPONSE_6_GHZ_BIT    ((u32)0x00080000)
#define MAC_HW_RX_CNTRL_2_DISABLE_RESPONSE_6_GHZ_POS    19
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_BAR_BIT    ((u32)0x00040000)
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_BAR_POS    18
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_DATA_BIT    ((u32)0x00020000)
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_DATA_POS    17
#define MAC_HW_RX_CNTRL_2_ENABLE_QUIET_INTERVAL_BIT    ((u32)0x00010000)
#define MAC_HW_RX_CNTRL_2_ENABLE_QUIET_INTERVAL_POS    16
#define MAC_HW_RX_CNTRL_2_ACCEPT_NON_TB_BIT    ((u32)0x00000200)
#define MAC_HW_RX_CNTRL_2_ACCEPT_NON_TB_POS    9
#define MAC_HW_RX_CNTRL_2_ACCEPT_BQRPTRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_RX_CNTRL_2_ACCEPT_BQRPTRIGGER_POS    8
#define MAC_HW_RX_CNTRL_2_ACCEPT_BSRPTRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_RX_CNTRL_2_ACCEPT_BSRPTRIGGER_POS    7
#define MAC_HW_RX_CNTRL_2_ACCEPT_BFRPTRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_RX_CNTRL_2_ACCEPT_BFRPTRIGGER_POS    6
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_RTS_BIT    ((u32)0x00000020)
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_RTS_POS    5
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_BAR_BIT    ((u32)0x00000010)
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_BAR_POS    4
#define MAC_HW_RX_CNTRL_2_ACCEPT_BASIC_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_RX_CNTRL_2_ACCEPT_BASIC_TRIGGER_POS    3
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDP_BIT    ((u32)0x00000004)
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDP_POS    2
#define MAC_HW_RX_CNTRL_2_ACCEPT_BRP_BIT    ((u32)0x00000002)
#define MAC_HW_RX_CNTRL_2_ACCEPT_BRP_POS    1
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDPAVHT_BIT    ((u32)0x00000001)
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDPAVHT_POS    0

#define MAC_HW_RX_CNTRL_2_PRIMARY_20_LOCATION_RST    0x0
#define MAC_HW_RX_CNTRL_2_PRIMARY_80_LOCATION_RST    0x0
#define MAC_HW_RX_CNTRL_2_DISABLE_RESPONSE_6_GHZ_RST    0x0
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_BAR_RST    0x0
#define MAC_HW_RX_CNTRL_2_CLEAR_SBSNLEGS_DATA_RST    0x0
#define MAC_HW_RX_CNTRL_2_ENABLE_QUIET_INTERVAL_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_NON_TB_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_BQRPTRIGGER_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_BSRPTRIGGER_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_BFRPTRIGGER_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_RTS_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_MU_BAR_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_BASIC_TRIGGER_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDP_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_BRP_RST    0x0
#define MAC_HW_RX_CNTRL_2_ACCEPT_NDPAVHT_RST    0x1

static inline void mac_hw_rx_cntrl_2_pack(struct cl_chip *chip, u8 primary20_location, u8 primary80_location, u8 disable_response_6ghz, u8 clear_sbsnlegs_bar, u8 clear_sbsnlegs_data, u8 enable_quiet_interval, u8 accept_non_tb, u8 accept_bqrptrigger, u8 accept_bsrptrigger, u8 accept_bfrptrigger, u8 accept_mu_rts, u8 accept_mu_bar, u8 accept_basic_trigger, u8 accept_ndp, u8 accept_brp, u8 accept_ndpavht)
{
	ASSERT_ERR_CHIP((((u32)primary20_location << 30) & ~((u32)0xC0000000)) == 0);
	ASSERT_ERR_CHIP((((u32)primary80_location << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)disable_response_6ghz << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_sbsnlegs_bar << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_sbsnlegs_data << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)enable_quiet_interval << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_non_tb << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_bqrptrigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_bsrptrigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_bfrptrigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_mu_rts << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_mu_bar << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_basic_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_ndp << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_brp << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)accept_ndpavht << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, ((u32)primary20_location << 30) | ((u32)primary80_location << 29) | ((u32)disable_response_6ghz << 19) | ((u32)clear_sbsnlegs_bar << 18) | ((u32)clear_sbsnlegs_data << 17) | ((u32)enable_quiet_interval << 16) | ((u32)accept_non_tb << 9) | ((u32)accept_bqrptrigger << 8) | ((u32)accept_bsrptrigger << 7) | ((u32)accept_bfrptrigger << 6) | ((u32)accept_mu_rts << 5) | ((u32)accept_mu_bar << 4) | ((u32)accept_basic_trigger << 3) | ((u32)accept_ndp << 2) | ((u32)accept_brp << 1) | ((u32)accept_ndpavht << 0));
}

static inline void mac_hw_rx_cntrl_2_unpack(struct cl_chip *chip, u8 *primary20_location, u8 *primary80_location, u8 *disable_response_6ghz, u8 *clear_sbsnlegs_bar, u8 *clear_sbsnlegs_data, u8 *enable_quiet_interval, u8 *accept_non_tb, u8 *accept_bqrptrigger, u8 *accept_bsrptrigger, u8 *accept_bfrptrigger, u8 *accept_mu_rts, u8 *accept_mu_bar, u8 *accept_basic_trigger, u8 *accept_ndp, u8 *accept_brp, u8 *accept_ndpavht)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	*primary20_location = (local_val & ((u32)0xC0000000)) >> 30;
	*primary80_location = (local_val & ((u32)0x20000000)) >> 29;
	*disable_response_6ghz = (local_val & ((u32)0x00080000)) >> 19;
	*clear_sbsnlegs_bar = (local_val & ((u32)0x00040000)) >> 18;
	*clear_sbsnlegs_data = (local_val & ((u32)0x00020000)) >> 17;
	*enable_quiet_interval = (local_val & ((u32)0x00010000)) >> 16;
	*accept_non_tb = (local_val & ((u32)0x00000200)) >> 9;
	*accept_bqrptrigger = (local_val & ((u32)0x00000100)) >> 8;
	*accept_bsrptrigger = (local_val & ((u32)0x00000080)) >> 7;
	*accept_bfrptrigger = (local_val & ((u32)0x00000040)) >> 6;
	*accept_mu_rts = (local_val & ((u32)0x00000020)) >> 5;
	*accept_mu_bar = (local_val & ((u32)0x00000010)) >> 4;
	*accept_basic_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*accept_ndp = (local_val & ((u32)0x00000004)) >> 2;
	*accept_brp = (local_val & ((u32)0x00000002)) >> 1;
	*accept_ndpavht = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_cntrl_2_primary_20_location_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0xC0000000)) >> 30);
}

static inline void mac_hw_rx_cntrl_2_primary_20_location_setf(struct cl_chip *chip, u8 primary20location)
{
	ASSERT_ERR_CHIP((((u32)primary20location << 30) & ~((u32)0xC0000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0xC0000000)) | ((u32)primary20location << 30));
}

static inline u8 mac_hw_rx_cntrl_2_primary_80_location_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_rx_cntrl_2_primary_80_location_setf(struct cl_chip *chip, u8 primary80location)
{
	ASSERT_ERR_CHIP((((u32)primary80location << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x20000000)) | ((u32)primary80location << 29));
}

static inline u8 mac_hw_rx_cntrl_2_disable_response_6_ghz_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_cntrl_2_disable_response_6_ghz_setf(struct cl_chip *chip, u8 disableresponse6ghz)
{
	ASSERT_ERR_CHIP((((u32)disableresponse6ghz << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00080000)) | ((u32)disableresponse6ghz << 19));
}

static inline u8 mac_hw_rx_cntrl_2_clear_sbsnlegs_bar_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_cntrl_2_clear_sbsnlegs_bar_setf(struct cl_chip *chip, u8 clearsbsnlegsbar)
{
	ASSERT_ERR_CHIP((((u32)clearsbsnlegsbar << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00040000)) | ((u32)clearsbsnlegsbar << 18));
}

static inline u8 mac_hw_rx_cntrl_2_clear_sbsnlegs_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_rx_cntrl_2_clear_sbsnlegs_data_setf(struct cl_chip *chip, u8 clearsbsnlegsdata)
{
	ASSERT_ERR_CHIP((((u32)clearsbsnlegsdata << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00020000)) | ((u32)clearsbsnlegsdata << 17));
}

static inline u8 mac_hw_rx_cntrl_2_enable_quiet_interval_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_cntrl_2_enable_quiet_interval_setf(struct cl_chip *chip, u8 enablequietinterval)
{
	ASSERT_ERR_CHIP((((u32)enablequietinterval << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00010000)) | ((u32)enablequietinterval << 16));
}

static inline u8 mac_hw_rx_cntrl_2_accept_non_tb_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_rx_cntrl_2_accept_non_tb_setf(struct cl_chip *chip, u8 acceptnontb)
{
	ASSERT_ERR_CHIP((((u32)acceptnontb << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000200)) | ((u32)acceptnontb << 9));
}

static inline u8 mac_hw_rx_cntrl_2_accept_bqrptrigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_cntrl_2_accept_bqrptrigger_setf(struct cl_chip *chip, u8 acceptbqrptrigger)
{
	ASSERT_ERR_CHIP((((u32)acceptbqrptrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000100)) | ((u32)acceptbqrptrigger << 8));
}

static inline u8 mac_hw_rx_cntrl_2_accept_bsrptrigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_rx_cntrl_2_accept_bsrptrigger_setf(struct cl_chip *chip, u8 acceptbsrptrigger)
{
	ASSERT_ERR_CHIP((((u32)acceptbsrptrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000080)) | ((u32)acceptbsrptrigger << 7));
}

static inline u8 mac_hw_rx_cntrl_2_accept_bfrptrigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_rx_cntrl_2_accept_bfrptrigger_setf(struct cl_chip *chip, u8 acceptbfrptrigger)
{
	ASSERT_ERR_CHIP((((u32)acceptbfrptrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000040)) | ((u32)acceptbfrptrigger << 6));
}

static inline u8 mac_hw_rx_cntrl_2_accept_mu_rts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_cntrl_2_accept_mu_rts_setf(struct cl_chip *chip, u8 acceptmurts)
{
	ASSERT_ERR_CHIP((((u32)acceptmurts << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000020)) | ((u32)acceptmurts << 5));
}

static inline u8 mac_hw_rx_cntrl_2_accept_mu_bar_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_cntrl_2_accept_mu_bar_setf(struct cl_chip *chip, u8 acceptmubar)
{
	ASSERT_ERR_CHIP((((u32)acceptmubar << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000010)) | ((u32)acceptmubar << 4));
}

static inline u8 mac_hw_rx_cntrl_2_accept_basic_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_cntrl_2_accept_basic_trigger_setf(struct cl_chip *chip, u8 acceptbasictrigger)
{
	ASSERT_ERR_CHIP((((u32)acceptbasictrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000008)) | ((u32)acceptbasictrigger << 3));
}

static inline u8 mac_hw_rx_cntrl_2_accept_ndp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_cntrl_2_accept_ndp_setf(struct cl_chip *chip, u8 acceptndp)
{
	ASSERT_ERR_CHIP((((u32)acceptndp << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000004)) | ((u32)acceptndp << 2));
}

static inline u8 mac_hw_rx_cntrl_2_accept_brp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_cntrl_2_accept_brp_setf(struct cl_chip *chip, u8 acceptbrp)
{
	ASSERT_ERR_CHIP((((u32)acceptbrp << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000002)) | ((u32)acceptbrp << 1));
}

static inline u8 mac_hw_rx_cntrl_2_accept_ndpavht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_cntrl_2_accept_ndpavht_setf(struct cl_chip *chip, u8 acceptndpavht)
{
	ASSERT_ERR_CHIP((((u32)acceptndpavht << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_2_ADDR) & ~((u32)0x00000001)) | ((u32)acceptndpavht << 0));
}

/**
 * @brief RX_CNTRL_3 register definition
 *  Controls the HW receive operation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23    RX_DISABLE_WAIT_PIPE_CLEAN 0
 *    22    RX_INTERRUPT_ENABLE       1
 *    21    ALWAYS_GEN_EOP_INT        0
 *    20    GEN_EOP_INT_FOR_PPDU_W_BFRP 0
 *    19    GEN_EOP_INT_FOR_PPDU_W_BQRP 0
 *    18    GEN_EOP_INT_FOR_PPDU_W_BSRP 0
 *    17    GEN_EOP_INT_FOR_PPDU_W_MU_BAR 0
 *    16    GEN_EOP_INT_FOR_PPDU_W_BASIC_TRIGGER 0
 *    11    GEN_INT_FOR_NDPA          0
 *    10    GEN_INT_FOR_NEED_BFR_VHT  0
 *    09    GEN_INT_FOR_RTS_NEED_CTS  0
 *    08    GEN_INT_FOR_NEED_CF_END   0
 *    07    GEN_INT_FOR_NEED_BA       0
 *    06    GEN_INT_FOR_NEED_ACK      0
 *    05    GEN_INT_FOR_MU_RTS        0
 *    04    GEN_INT_FOR_BFRP_DETECT   0
 *    03    GEN_INT_FOR_BQRP_DETECT   0
 *    02    GEN_INT_FOR_BSRP_DETECT   0
 *    01    GEN_INT_FOR_MU_BAR_DETECT 0
 *    00    GEN_INT_FOR_BASIC_TRIGGER_DETECT 0
 * </pre>
 */
#define MAC_HW_RX_CNTRL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000070)
#define MAC_HW_RX_CNTRL_3_OFFSET      0x00000070
#define MAC_HW_RX_CNTRL_3_INDEX       0x0000001C
#define MAC_HW_RX_CNTRL_3_RESET       0x00400000

static inline u32 mac_hw_rx_cntrl_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);
}

static inline void mac_hw_rx_cntrl_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CNTRL_3_RX_DISABLE_WAIT_PIPE_CLEAN_BIT    ((u32)0x00800000)
#define MAC_HW_RX_CNTRL_3_RX_DISABLE_WAIT_PIPE_CLEAN_POS    23
#define MAC_HW_RX_CNTRL_3_RX_INTERRUPT_ENABLE_BIT    ((u32)0x00400000)
#define MAC_HW_RX_CNTRL_3_RX_INTERRUPT_ENABLE_POS    22
#define MAC_HW_RX_CNTRL_3_ALWAYS_GEN_EOP_INT_BIT    ((u32)0x00200000)
#define MAC_HW_RX_CNTRL_3_ALWAYS_GEN_EOP_INT_POS    21
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BFRP_BIT    ((u32)0x00100000)
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BFRP_POS    20
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BQRP_BIT    ((u32)0x00080000)
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BQRP_POS    19
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BSRP_BIT    ((u32)0x00040000)
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BSRP_POS    18
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_MU_BAR_BIT    ((u32)0x00020000)
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_MU_BAR_POS    17
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BASIC_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BASIC_TRIGGER_POS    16
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NDPA_BIT    ((u32)0x00000800)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NDPA_POS    11
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BFR_VHT_BIT    ((u32)0x00000400)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BFR_VHT_POS    10
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_RTS_NEED_CTS_BIT    ((u32)0x00000200)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_RTS_NEED_CTS_POS    9
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_CF_END_BIT    ((u32)0x00000100)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_CF_END_POS    8
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BA_BIT    ((u32)0x00000080)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BA_POS    7
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_ACK_BIT    ((u32)0x00000040)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_ACK_POS    6
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_RTS_BIT    ((u32)0x00000020)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_RTS_POS    5
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BFRP_DETECT_BIT    ((u32)0x00000010)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BFRP_DETECT_POS    4
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BQRP_DETECT_BIT    ((u32)0x00000008)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BQRP_DETECT_POS    3
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BSRP_DETECT_BIT    ((u32)0x00000004)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BSRP_DETECT_POS    2
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_BAR_DETECT_BIT    ((u32)0x00000002)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_BAR_DETECT_POS    1
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BASIC_TRIGGER_DETECT_BIT    ((u32)0x00000001)
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BASIC_TRIGGER_DETECT_POS    0

#define MAC_HW_RX_CNTRL_3_RX_DISABLE_WAIT_PIPE_CLEAN_RST    0x0
#define MAC_HW_RX_CNTRL_3_RX_INTERRUPT_ENABLE_RST    0x1
#define MAC_HW_RX_CNTRL_3_ALWAYS_GEN_EOP_INT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BFRP_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BQRP_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BSRP_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_MU_BAR_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_EOP_INT_FOR_PPDU_W_BASIC_TRIGGER_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NDPA_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BFR_VHT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_RTS_NEED_CTS_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_CF_END_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_BA_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_NEED_ACK_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_RTS_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BFRP_DETECT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BQRP_DETECT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BSRP_DETECT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_MU_BAR_DETECT_RST    0x0
#define MAC_HW_RX_CNTRL_3_GEN_INT_FOR_BASIC_TRIGGER_DETECT_RST    0x0

static inline void mac_hw_rx_cntrl_3_pack(struct cl_chip *chip, u8 rx_disable_wait_pipe_clean, u8 rx_interrupt_enable, u8 always_gen_eop_int, u8 gen_eop_int_for_ppdu_w_bfrp, u8 gen_eop_int_for_ppdu_w_bqrp, u8 gen_eop_int_for_ppdu_w_bsrp, u8 gen_eop_int_for_ppdu_w_mu_bar, u8 gen_eop_int_for_ppdu_w_basic_trigger, u8 gen_int_for_ndpa, u8 gen_int_for_need_bfr_vht, u8 gen_int_for_rts_need_cts, u8 gen_int_for_need_cf_end, u8 gen_int_for_need_ba, u8 gen_int_for_need_ack, u8 gen_int_for_mu_rts, u8 gen_int_for_bfrp_detect, u8 gen_int_for_bqrp_detect, u8 gen_int_for_bsrp_detect, u8 gen_int_for_mu_bar_detect, u8 gen_int_for_basic_trigger_detect)
{
	ASSERT_ERR_CHIP((((u32)rx_disable_wait_pipe_clean << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_interrupt_enable << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)always_gen_eop_int << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_eop_int_for_ppdu_w_bfrp << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_eop_int_for_ppdu_w_bqrp << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_eop_int_for_ppdu_w_bsrp << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_eop_int_for_ppdu_w_mu_bar << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_eop_int_for_ppdu_w_basic_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_ndpa << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_need_bfr_vht << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_rts_need_cts << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_need_cf_end << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_need_ba << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_need_ack << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_mu_rts << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_bfrp_detect << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_bqrp_detect << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_bsrp_detect << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_mu_bar_detect << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)gen_int_for_basic_trigger_detect << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, ((u32)rx_disable_wait_pipe_clean << 23) | ((u32)rx_interrupt_enable << 22) | ((u32)always_gen_eop_int << 21) | ((u32)gen_eop_int_for_ppdu_w_bfrp << 20) | ((u32)gen_eop_int_for_ppdu_w_bqrp << 19) | ((u32)gen_eop_int_for_ppdu_w_bsrp << 18) | ((u32)gen_eop_int_for_ppdu_w_mu_bar << 17) | ((u32)gen_eop_int_for_ppdu_w_basic_trigger << 16) | ((u32)gen_int_for_ndpa << 11) | ((u32)gen_int_for_need_bfr_vht << 10) | ((u32)gen_int_for_rts_need_cts << 9) | ((u32)gen_int_for_need_cf_end << 8) | ((u32)gen_int_for_need_ba << 7) | ((u32)gen_int_for_need_ack << 6) | ((u32)gen_int_for_mu_rts << 5) | ((u32)gen_int_for_bfrp_detect << 4) | ((u32)gen_int_for_bqrp_detect << 3) | ((u32)gen_int_for_bsrp_detect << 2) | ((u32)gen_int_for_mu_bar_detect << 1) | ((u32)gen_int_for_basic_trigger_detect << 0));
}

static inline void mac_hw_rx_cntrl_3_unpack(struct cl_chip *chip, u8 *rx_disable_wait_pipe_clean, u8 *rx_interrupt_enable, u8 *always_gen_eop_int, u8 *gen_eop_int_for_ppdu_w_bfrp, u8 *gen_eop_int_for_ppdu_w_bqrp, u8 *gen_eop_int_for_ppdu_w_bsrp, u8 *gen_eop_int_for_ppdu_w_mu_bar, u8 *gen_eop_int_for_ppdu_w_basic_trigger, u8 *gen_int_for_ndpa, u8 *gen_int_for_need_bfr_vht, u8 *gen_int_for_rts_need_cts, u8 *gen_int_for_need_cf_end, u8 *gen_int_for_need_ba, u8 *gen_int_for_need_ack, u8 *gen_int_for_mu_rts, u8 *gen_int_for_bfrp_detect, u8 *gen_int_for_bqrp_detect, u8 *gen_int_for_bsrp_detect, u8 *gen_int_for_mu_bar_detect, u8 *gen_int_for_basic_trigger_detect)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	*rx_disable_wait_pipe_clean = (local_val & ((u32)0x00800000)) >> 23;
	*rx_interrupt_enable = (local_val & ((u32)0x00400000)) >> 22;
	*always_gen_eop_int = (local_val & ((u32)0x00200000)) >> 21;
	*gen_eop_int_for_ppdu_w_bfrp = (local_val & ((u32)0x00100000)) >> 20;
	*gen_eop_int_for_ppdu_w_bqrp = (local_val & ((u32)0x00080000)) >> 19;
	*gen_eop_int_for_ppdu_w_bsrp = (local_val & ((u32)0x00040000)) >> 18;
	*gen_eop_int_for_ppdu_w_mu_bar = (local_val & ((u32)0x00020000)) >> 17;
	*gen_eop_int_for_ppdu_w_basic_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*gen_int_for_ndpa = (local_val & ((u32)0x00000800)) >> 11;
	*gen_int_for_need_bfr_vht = (local_val & ((u32)0x00000400)) >> 10;
	*gen_int_for_rts_need_cts = (local_val & ((u32)0x00000200)) >> 9;
	*gen_int_for_need_cf_end = (local_val & ((u32)0x00000100)) >> 8;
	*gen_int_for_need_ba = (local_val & ((u32)0x00000080)) >> 7;
	*gen_int_for_need_ack = (local_val & ((u32)0x00000040)) >> 6;
	*gen_int_for_mu_rts = (local_val & ((u32)0x00000020)) >> 5;
	*gen_int_for_bfrp_detect = (local_val & ((u32)0x00000010)) >> 4;
	*gen_int_for_bqrp_detect = (local_val & ((u32)0x00000008)) >> 3;
	*gen_int_for_bsrp_detect = (local_val & ((u32)0x00000004)) >> 2;
	*gen_int_for_mu_bar_detect = (local_val & ((u32)0x00000002)) >> 1;
	*gen_int_for_basic_trigger_detect = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_cntrl_3_rx_disable_wait_pipe_clean_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_cntrl_3_rx_disable_wait_pipe_clean_setf(struct cl_chip *chip, u8 rxdisablewaitpipeclean)
{
	ASSERT_ERR_CHIP((((u32)rxdisablewaitpipeclean << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00800000)) | ((u32)rxdisablewaitpipeclean << 23));
}

static inline u8 mac_hw_rx_cntrl_3_rx_interrupt_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_cntrl_3_rx_interrupt_enable_setf(struct cl_chip *chip, u8 rxinterruptenable)
{
	ASSERT_ERR_CHIP((((u32)rxinterruptenable << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00400000)) | ((u32)rxinterruptenable << 22));
}

static inline u8 mac_hw_rx_cntrl_3_always_gen_eop_int_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_rx_cntrl_3_always_gen_eop_int_setf(struct cl_chip *chip, u8 alwaysgeneopint)
{
	ASSERT_ERR_CHIP((((u32)alwaysgeneopint << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00200000)) | ((u32)alwaysgeneopint << 21));
}

static inline u8 mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bfrp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bfrp_setf(struct cl_chip *chip, u8 geneopintforppduwbfrp)
{
	ASSERT_ERR_CHIP((((u32)geneopintforppduwbfrp << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00100000)) | ((u32)geneopintforppduwbfrp << 20));
}

static inline u8 mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bqrp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bqrp_setf(struct cl_chip *chip, u8 geneopintforppduwbqrp)
{
	ASSERT_ERR_CHIP((((u32)geneopintforppduwbqrp << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00080000)) | ((u32)geneopintforppduwbqrp << 19));
}

static inline u8 mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bsrp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_bsrp_setf(struct cl_chip *chip, u8 geneopintforppduwbsrp)
{
	ASSERT_ERR_CHIP((((u32)geneopintforppduwbsrp << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00040000)) | ((u32)geneopintforppduwbsrp << 18));
}

static inline u8 mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_mu_bar_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_mu_bar_setf(struct cl_chip *chip, u8 geneopintforppduwmubar)
{
	ASSERT_ERR_CHIP((((u32)geneopintforppduwmubar << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00020000)) | ((u32)geneopintforppduwmubar << 17));
}

static inline u8 mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_basic_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_cntrl_3_gen_eop_int_for_ppdu_w_basic_trigger_setf(struct cl_chip *chip, u8 geneopintforppduwbasictrigger)
{
	ASSERT_ERR_CHIP((((u32)geneopintforppduwbasictrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00010000)) | ((u32)geneopintforppduwbasictrigger << 16));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_ndpa_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_ndpa_setf(struct cl_chip *chip, u8 genintforndpa)
{
	ASSERT_ERR_CHIP((((u32)genintforndpa << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000800)) | ((u32)genintforndpa << 11));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_need_bfr_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_need_bfr_vht_setf(struct cl_chip *chip, u8 genintforneedbfrvht)
{
	ASSERT_ERR_CHIP((((u32)genintforneedbfrvht << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000400)) | ((u32)genintforneedbfrvht << 10));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_rts_need_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_rts_need_cts_setf(struct cl_chip *chip, u8 genintforrtsneedcts)
{
	ASSERT_ERR_CHIP((((u32)genintforrtsneedcts << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000200)) | ((u32)genintforrtsneedcts << 9));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_need_cf_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_need_cf_end_setf(struct cl_chip *chip, u8 genintforneedcfend)
{
	ASSERT_ERR_CHIP((((u32)genintforneedcfend << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000100)) | ((u32)genintforneedcfend << 8));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_need_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_need_ba_setf(struct cl_chip *chip, u8 genintforneedba)
{
	ASSERT_ERR_CHIP((((u32)genintforneedba << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000080)) | ((u32)genintforneedba << 7));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_need_ack_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_need_ack_setf(struct cl_chip *chip, u8 genintforneedack)
{
	ASSERT_ERR_CHIP((((u32)genintforneedack << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000040)) | ((u32)genintforneedack << 6));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_mu_rts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_mu_rts_setf(struct cl_chip *chip, u8 genintformurts)
{
	ASSERT_ERR_CHIP((((u32)genintformurts << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000020)) | ((u32)genintformurts << 5));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_bfrp_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_bfrp_detect_setf(struct cl_chip *chip, u8 genintforbfrpdetect)
{
	ASSERT_ERR_CHIP((((u32)genintforbfrpdetect << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000010)) | ((u32)genintforbfrpdetect << 4));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_bqrp_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_bqrp_detect_setf(struct cl_chip *chip, u8 genintforbqrpdetect)
{
	ASSERT_ERR_CHIP((((u32)genintforbqrpdetect << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000008)) | ((u32)genintforbqrpdetect << 3));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_bsrp_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_bsrp_detect_setf(struct cl_chip *chip, u8 genintforbsrpdetect)
{
	ASSERT_ERR_CHIP((((u32)genintforbsrpdetect << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000004)) | ((u32)genintforbsrpdetect << 2));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_mu_bar_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_mu_bar_detect_setf(struct cl_chip *chip, u8 genintformubardetect)
{
	ASSERT_ERR_CHIP((((u32)genintformubardetect << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000002)) | ((u32)genintformubardetect << 1));
}

static inline u8 mac_hw_rx_cntrl_3_gen_int_for_basic_trigger_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_cntrl_3_gen_int_for_basic_trigger_detect_setf(struct cl_chip *chip, u8 genintforbasictriggerdetect)
{
	ASSERT_ERR_CHIP((((u32)genintforbasictriggerdetect << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_CNTRL_3_ADDR) & ~((u32)0x00000001)) | ((u32)genintforbasictriggerdetect << 0));
}

/**
 * @brief BCN_CNTRL_3 register definition
 *  Beacon control 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    IGNORE_DTIM_CNT           0
 *    09:00 BCN_INTRVAL_LSB           0x0
 * </pre>
 */
#define MAC_HW_BCN_CNTRL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000074)
#define MAC_HW_BCN_CNTRL_3_OFFSET      0x00000074
#define MAC_HW_BCN_CNTRL_3_INDEX       0x0000001D
#define MAC_HW_BCN_CNTRL_3_RESET       0x00000000

static inline u32 mac_hw_bcn_cntrl_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR);
}

static inline void mac_hw_bcn_cntrl_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BCN_CNTRL_3_IGNORE_DTIM_CNT_BIT    ((u32)0x80000000)
#define MAC_HW_BCN_CNTRL_3_IGNORE_DTIM_CNT_POS    31
#define MAC_HW_BCN_CNTRL_3_BCN_INTRVAL_LSB_MASK    ((u32)0x000003FF)
#define MAC_HW_BCN_CNTRL_3_BCN_INTRVAL_LSB_LSB    0
#define MAC_HW_BCN_CNTRL_3_BCN_INTRVAL_LSB_WIDTH    ((u32)0x0000000A)

#define MAC_HW_BCN_CNTRL_3_IGNORE_DTIM_CNT_RST    0x0
#define MAC_HW_BCN_CNTRL_3_BCN_INTRVAL_LSB_RST    0x0

static inline void mac_hw_bcn_cntrl_3_pack(struct cl_chip *chip, u8 ignore_dtim_cnt, u16 bcn_intrval_lsb)
{
	ASSERT_ERR_CHIP((((u32)ignore_dtim_cnt << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_intrval_lsb << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_3_ADDR, ((u32)ignore_dtim_cnt << 31) | ((u32)bcn_intrval_lsb << 0));
}

static inline void mac_hw_bcn_cntrl_3_unpack(struct cl_chip *chip, u8 *ignore_dtim_cnt, u16 *bcn_intrval_lsb)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR);

	*ignore_dtim_cnt = (local_val & ((u32)0x80000000)) >> 31;
	*bcn_intrval_lsb = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u8 mac_hw_bcn_cntrl_3_ignore_dtim_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_bcn_cntrl_3_ignore_dtim_cnt_setf(struct cl_chip *chip, u8 ignoredtimcnt)
{
	ASSERT_ERR_CHIP((((u32)ignoredtimcnt << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR) & ~((u32)0x80000000)) | ((u32)ignoredtimcnt << 31));
}

static inline u16 mac_hw_bcn_cntrl_3_bcn_intrval_lsb_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_bcn_cntrl_3_bcn_intrval_lsb_setf(struct cl_chip *chip, u16 bcnintrvallsb)
{
	ASSERT_ERR_CHIP((((u32)bcnintrvallsb << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_BCN_CNTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_BCN_CNTRL_3_ADDR) & ~((u32)0x000003FF)) | ((u32)bcnintrvallsb << 0));
}

/**
 * @brief TX_POWER_LEVEL_DELTA_1 register definition
 *  Indicates adjustments in power per chain register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 TX_POWER_DELTA_3          0x0
 *    23:16 TX_POWER_DELTA_2          0x0
 *    15:08 TX_POWER_DELTA_1          0x0
 *    07:00 TX_POWER_DELTA_0          0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000080)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_OFFSET      0x00000080
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_INDEX       0x00000020
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_RESET       0x00000000

static inline u32 mac_hw_tx_power_level_delta_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);
}

static inline void mac_hw_tx_power_level_delta_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_3_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_3_LSB    24
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_2_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_2_LSB    16
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_1_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_1_LSB    8
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_1_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_0_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_0_LSB    0
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_0_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_3_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_2_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_1_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_1_TX_POWER_DELTA_0_RST    0x0

static inline void mac_hw_tx_power_level_delta_1_pack(struct cl_chip *chip, u8 tx_power_delta_3, u8 tx_power_delta_2, u8 tx_power_delta_1, u8 tx_power_delta_0)
{
	ASSERT_ERR_CHIP((((u32)tx_power_delta_3 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_2 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_1 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, ((u32)tx_power_delta_3 << 24) | ((u32)tx_power_delta_2 << 16) | ((u32)tx_power_delta_1 << 8) | ((u32)tx_power_delta_0 << 0));
}

static inline void mac_hw_tx_power_level_delta_1_unpack(struct cl_chip *chip, u8 *tx_power_delta_3, u8 *tx_power_delta_2, u8 *tx_power_delta_1, u8 *tx_power_delta_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);

	*tx_power_delta_3 = (local_val & ((u32)0xFF000000)) >> 24;
	*tx_power_delta_2 = (local_val & ((u32)0x00FF0000)) >> 16;
	*tx_power_delta_1 = (local_val & ((u32)0x0000FF00)) >> 8;
	*tx_power_delta_0 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_power_level_delta_1_tx_power_delta_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_power_level_delta_1_tx_power_delta_3_setf(struct cl_chip *chip, u8 txpowerdelta3)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta3 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR) & ~((u32)0xFF000000)) | ((u32)txpowerdelta3 << 24));
}

static inline u8 mac_hw_tx_power_level_delta_1_tx_power_delta_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_power_level_delta_1_tx_power_delta_2_setf(struct cl_chip *chip, u8 txpowerdelta2)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta2 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR) & ~((u32)0x00FF0000)) | ((u32)txpowerdelta2 << 16));
}

static inline u8 mac_hw_tx_power_level_delta_1_tx_power_delta_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_power_level_delta_1_tx_power_delta_1_setf(struct cl_chip *chip, u8 txpowerdelta1)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta1 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR) & ~((u32)0x0000FF00)) | ((u32)txpowerdelta1 << 8));
}

static inline u8 mac_hw_tx_power_level_delta_1_tx_power_delta_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_power_level_delta_1_tx_power_delta_0_setf(struct cl_chip *chip, u8 txpowerdelta0)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_1_ADDR) & ~((u32)0x000000FF)) | ((u32)txpowerdelta0 << 0));
}

/**
 * @brief TX_POWER_LEVEL_DELTA_2 register definition
 *  Indicates adjustments in power per antenna  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 TX_POWER_DELTA_7          0x0
 *    23:16 TX_POWER_DELTA_6          0x0
 *    15:08 TX_POWER_DELTA_5          0x0
 *    07:00 TX_POWER_DELTA_4          0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000084)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_OFFSET      0x00000084
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_INDEX       0x00000021
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_RESET       0x00000000

static inline u32 mac_hw_tx_power_level_delta_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);
}

static inline void mac_hw_tx_power_level_delta_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_7_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_7_LSB    24
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_7_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_6_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_6_LSB    16
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_6_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_5_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_5_LSB    8
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_5_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_4_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_4_LSB    0
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_4_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_7_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_6_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_5_RST    0x0
#define MAC_HW_TX_POWER_LEVEL_DELTA_2_TX_POWER_DELTA_4_RST    0x0

static inline void mac_hw_tx_power_level_delta_2_pack(struct cl_chip *chip, u8 tx_power_delta_7, u8 tx_power_delta_6, u8 tx_power_delta_5, u8 tx_power_delta_4)
{
	ASSERT_ERR_CHIP((((u32)tx_power_delta_7 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_6 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_5 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_power_delta_4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, ((u32)tx_power_delta_7 << 24) | ((u32)tx_power_delta_6 << 16) | ((u32)tx_power_delta_5 << 8) | ((u32)tx_power_delta_4 << 0));
}

static inline void mac_hw_tx_power_level_delta_2_unpack(struct cl_chip *chip, u8 *tx_power_delta_7, u8 *tx_power_delta_6, u8 *tx_power_delta_5, u8 *tx_power_delta_4)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);

	*tx_power_delta_7 = (local_val & ((u32)0xFF000000)) >> 24;
	*tx_power_delta_6 = (local_val & ((u32)0x00FF0000)) >> 16;
	*tx_power_delta_5 = (local_val & ((u32)0x0000FF00)) >> 8;
	*tx_power_delta_4 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_power_level_delta_2_tx_power_delta_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_power_level_delta_2_tx_power_delta_7_setf(struct cl_chip *chip, u8 txpowerdelta7)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta7 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR) & ~((u32)0xFF000000)) | ((u32)txpowerdelta7 << 24));
}

static inline u8 mac_hw_tx_power_level_delta_2_tx_power_delta_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_power_level_delta_2_tx_power_delta_6_setf(struct cl_chip *chip, u8 txpowerdelta6)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta6 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR) & ~((u32)0x00FF0000)) | ((u32)txpowerdelta6 << 16));
}

static inline u8 mac_hw_tx_power_level_delta_2_tx_power_delta_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_power_level_delta_2_tx_power_delta_5_setf(struct cl_chip *chip, u8 txpowerdelta5)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta5 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR) & ~((u32)0x0000FF00)) | ((u32)txpowerdelta5 << 8));
}

static inline u8 mac_hw_tx_power_level_delta_2_tx_power_delta_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_power_level_delta_2_tx_power_delta_4_setf(struct cl_chip *chip, u8 txpowerdelta4)
{
	ASSERT_ERR_CHIP((((u32)txpowerdelta4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_LEVEL_DELTA_2_ADDR) & ~((u32)0x000000FF)) | ((u32)txpowerdelta4 << 0));
}

/**
 * @brief ENCR_KEY_ECBA register definition
 *  This register contains the KSR index and KSR data register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 KSR_INDEX                 0x0
 *    15:08 KSR_GEN                   0x0
 *    07:00 ECBA                      0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_ECBA_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000088)
#define MAC_HW_ENCR_KEY_ECBA_OFFSET      0x00000088
#define MAC_HW_ENCR_KEY_ECBA_INDEX       0x00000022
#define MAC_HW_ENCR_KEY_ECBA_RESET       0x00000000

static inline u32 mac_hw_encr_key_ecba_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR);
}

static inline void mac_hw_encr_key_ecba_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_ECBA_KSR_INDEX_MASK    ((u32)0xFF000000)
#define MAC_HW_ENCR_KEY_ECBA_KSR_INDEX_LSB    24
#define MAC_HW_ENCR_KEY_ECBA_KSR_INDEX_WIDTH    ((u32)0x00000008)
#define MAC_HW_ENCR_KEY_ECBA_KSR_GEN_MASK    ((u32)0x0000FF00)
#define MAC_HW_ENCR_KEY_ECBA_KSR_GEN_LSB    8
#define MAC_HW_ENCR_KEY_ECBA_KSR_GEN_WIDTH    ((u32)0x00000008)
#define MAC_HW_ENCR_KEY_ECBA_ECBA_MASK      ((u32)0x000000FF)
#define MAC_HW_ENCR_KEY_ECBA_ECBA_LSB       0
#define MAC_HW_ENCR_KEY_ECBA_ECBA_WIDTH     ((u32)0x00000008)

#define MAC_HW_ENCR_KEY_ECBA_KSR_INDEX_RST    0x0
#define MAC_HW_ENCR_KEY_ECBA_KSR_GEN_RST    0x0
#define MAC_HW_ENCR_KEY_ECBA_ECBA_RST       0x0

static inline void mac_hw_encr_key_ecba_pack(struct cl_chip *chip, u8 ksr_index, u8 ksr_gen, u8 ecba)
{
	ASSERT_ERR_CHIP((((u32)ksr_index << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ksr_gen << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)ecba << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_ADDR, ((u32)ksr_index << 24) | ((u32)ksr_gen << 8) | ((u32)ecba << 0));
}

static inline void mac_hw_encr_key_ecba_unpack(struct cl_chip *chip, u8 *ksr_index, u8 *ksr_gen, u8 *ecba)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR);

	*ksr_index = (local_val & ((u32)0xFF000000)) >> 24;
	*ksr_gen = (local_val & ((u32)0x0000FF00)) >> 8;
	*ecba = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_encr_key_ecba_ksr_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_encr_key_ecba_ksr_index_setf(struct cl_chip *chip, u8 ksrindex)
{
	ASSERT_ERR_CHIP((((u32)ksrindex << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR) & ~((u32)0xFF000000)) | ((u32)ksrindex << 24));
}

static inline u8 mac_hw_encr_key_ecba_ksr_gen_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_encr_key_ecba_ksr_gen_setf(struct cl_chip *chip, u8 ksrgen)
{
	ASSERT_ERR_CHIP((((u32)ksrgen << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR) & ~((u32)0x0000FF00)) | ((u32)ksrgen << 8));
}

static inline u8 mac_hw_encr_key_ecba_ecba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_encr_key_ecba_ecba_setf(struct cl_chip *chip, u8 ecba)
{
	ASSERT_ERR_CHIP((((u32)ecba << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_ADDR) & ~((u32)0x000000FF)) | ((u32)ecba << 0));
}

/**
 * @brief ENCR_KEY_ECBA_MASK register definition
 *  This register is used as a specific bit write en register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    KSR_AID_OR_GEN_ECBA_WR    0
 *    30    KSR_AID_SEL               0
 *    23:00 KSR_GEN_ECBA_BIT_EN       0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_ECBA_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000008C)
#define MAC_HW_ENCR_KEY_ECBA_MASK_OFFSET      0x0000008C
#define MAC_HW_ENCR_KEY_ECBA_MASK_INDEX       0x00000023
#define MAC_HW_ENCR_KEY_ECBA_MASK_RESET       0x00000000

static inline u32 mac_hw_encr_key_ecba_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR);
}

static inline void mac_hw_encr_key_ecba_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_OR_GEN_ECBA_WR_BIT    ((u32)0x80000000)
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_OR_GEN_ECBA_WR_POS    31
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_SEL_BIT    ((u32)0x40000000)
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_SEL_POS    30
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_GEN_ECBA_BIT_EN_MASK    ((u32)0x00FFFFFF)
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_GEN_ECBA_BIT_EN_LSB    0
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_GEN_ECBA_BIT_EN_WIDTH    ((u32)0x00000018)

#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_OR_GEN_ECBA_WR_RST    0x0
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_AID_SEL_RST    0x0
#define MAC_HW_ENCR_KEY_ECBA_MASK_KSR_GEN_ECBA_BIT_EN_RST    0x0

static inline void mac_hw_encr_key_ecba_mask_pack(struct cl_chip *chip, u8 ksr_aid_or_gen_ecba_wr, u8 ksr_aid_sel, u32 ksr_gen_ecba_bit_en)
{
	ASSERT_ERR_CHIP((((u32)ksr_aid_or_gen_ecba_wr << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ksr_aid_sel << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ksr_gen_ecba_bit_en << 0) & ~((u32)0x00FFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR, ((u32)ksr_aid_or_gen_ecba_wr << 31) | ((u32)ksr_aid_sel << 30) | ((u32)ksr_gen_ecba_bit_en << 0));
}

static inline void mac_hw_encr_key_ecba_mask_unpack(struct cl_chip *chip, u8 *ksr_aid_or_gen_ecba_wr, u8 *ksr_aid_sel, u32 *ksr_gen_ecba_bit_en)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR);

	*ksr_aid_or_gen_ecba_wr = (local_val & ((u32)0x80000000)) >> 31;
	*ksr_aid_sel = (local_val & ((u32)0x40000000)) >> 30;
	*ksr_gen_ecba_bit_en = (local_val & ((u32)0x00FFFFFF)) >> 0;
}

static inline u8 mac_hw_encr_key_ecba_mask_ksr_aid_or_gen_ecba_wr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_encr_key_ecba_mask_ksr_aid_or_gen_ecba_wr_setf(struct cl_chip *chip, u8 ksraidorgenecbawr)
{
	ASSERT_ERR_CHIP((((u32)ksraidorgenecbawr << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR) & ~((u32)0x80000000)) | ((u32)ksraidorgenecbawr << 31));
}

static inline u8 mac_hw_encr_key_ecba_mask_ksr_aid_sel_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_encr_key_ecba_mask_ksr_aid_sel_setf(struct cl_chip *chip, u8 ksraidsel)
{
	ASSERT_ERR_CHIP((((u32)ksraidsel << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR) & ~((u32)0x40000000)) | ((u32)ksraidsel << 30));
}

static inline u32 mac_hw_encr_key_ecba_mask_ksr_gen_ecba_bit_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR);

	return (u32)((local_val & ((u32)0x00FFFFFF)) >> 0);
}

static inline void mac_hw_encr_key_ecba_mask_ksr_gen_ecba_bit_en_setf(struct cl_chip *chip, u32 ksrgenecbabiten)
{
	ASSERT_ERR_CHIP((((u32)ksrgenecbabiten << 0) & ~((u32)0x00FFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_KEY_ECBA_MASK_ADDR) & ~((u32)0x00FFFFFF)) | ((u32)ksrgenecbabiten << 0));
}

/**
 * @brief DTIM_CFP_1 register definition
 *  Contains the DTIM and the CFP Count. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    DTIM_UPDATED_BY_SW        0
 *    15:08 CFP_PERIOD                0x0
 *    07:00 DTIM_PERIOD               0x0
 * </pre>
 */
#define MAC_HW_DTIM_CFP_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000090)
#define MAC_HW_DTIM_CFP_1_OFFSET      0x00000090
#define MAC_HW_DTIM_CFP_1_INDEX       0x00000024
#define MAC_HW_DTIM_CFP_1_RESET       0x00000000

static inline u32 mac_hw_dtim_cfp_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR);
}

static inline void mac_hw_dtim_cfp_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DTIM_CFP_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DTIM_CFP_1_DTIM_UPDATED_BY_SW_BIT    ((u32)0x80000000)
#define MAC_HW_DTIM_CFP_1_DTIM_UPDATED_BY_SW_POS    31
#define MAC_HW_DTIM_CFP_1_CFP_PERIOD_MASK    ((u32)0x0000FF00)
#define MAC_HW_DTIM_CFP_1_CFP_PERIOD_LSB    8
#define MAC_HW_DTIM_CFP_1_CFP_PERIOD_WIDTH    ((u32)0x00000008)
#define MAC_HW_DTIM_CFP_1_DTIM_PERIOD_MASK    ((u32)0x000000FF)
#define MAC_HW_DTIM_CFP_1_DTIM_PERIOD_LSB    0
#define MAC_HW_DTIM_CFP_1_DTIM_PERIOD_WIDTH    ((u32)0x00000008)

#define MAC_HW_DTIM_CFP_1_DTIM_UPDATED_BY_SW_RST    0x0
#define MAC_HW_DTIM_CFP_1_CFP_PERIOD_RST    0x0
#define MAC_HW_DTIM_CFP_1_DTIM_PERIOD_RST    0x0

static inline void mac_hw_dtim_cfp_1_pack(struct cl_chip *chip, u8 dtim_updated_by_sw, u8 cfp_period, u8 dtim_period)
{
	ASSERT_ERR_CHIP((((u32)dtim_updated_by_sw << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)cfp_period << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)dtim_period << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DTIM_CFP_1_ADDR, ((u32)dtim_updated_by_sw << 31) | ((u32)cfp_period << 8) | ((u32)dtim_period << 0));
}

static inline void mac_hw_dtim_cfp_1_unpack(struct cl_chip *chip, u8 *dtim_updated_by_sw, u8 *cfp_period, u8 *dtim_period)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR);

	*dtim_updated_by_sw = (local_val & ((u32)0x80000000)) >> 31;
	*cfp_period = (local_val & ((u32)0x0000FF00)) >> 8;
	*dtim_period = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_dtim_cfp_1_dtim_updated_by_sw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_dtim_cfp_1_dtim_updated_by_sw_setf(struct cl_chip *chip, u8 dtimupdatedbysw)
{
	ASSERT_ERR_CHIP((((u32)dtimupdatedbysw << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_DTIM_CFP_1_ADDR, (cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR) & ~((u32)0x80000000)) | ((u32)dtimupdatedbysw << 31));
}

static inline u8 mac_hw_dtim_cfp_1_cfp_period_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_dtim_cfp_1_cfp_period_setf(struct cl_chip *chip, u8 cfpperiod)
{
	ASSERT_ERR_CHIP((((u32)cfpperiod << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_DTIM_CFP_1_ADDR, (cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR) & ~((u32)0x0000FF00)) | ((u32)cfpperiod << 8));
}

static inline u8 mac_hw_dtim_cfp_1_dtim_period_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_dtim_cfp_1_dtim_period_setf(struct cl_chip *chip, u8 dtimperiod)
{
	ASSERT_ERR_CHIP((((u32)dtimperiod << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DTIM_CFP_1_ADDR, (cl_reg_read(chip, MAC_HW_DTIM_CFP_1_ADDR) & ~((u32)0x000000FF)) | ((u32)dtimperiod << 0));
}

/**
 * @brief DTIM_CFP_2 register definition
 *  Contains the DTIM and the CFP Count. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 CFP_MAX_DURATION          0x0
 * </pre>
 */
#define MAC_HW_DTIM_CFP_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000094)
#define MAC_HW_DTIM_CFP_2_OFFSET      0x00000094
#define MAC_HW_DTIM_CFP_2_INDEX       0x00000025
#define MAC_HW_DTIM_CFP_2_RESET       0x00000000

static inline u32 mac_hw_dtim_cfp_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DTIM_CFP_2_ADDR);
}

static inline void mac_hw_dtim_cfp_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DTIM_CFP_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DTIM_CFP_2_CFP_MAX_DURATION_MASK    ((u32)0x0000FFFF)
#define MAC_HW_DTIM_CFP_2_CFP_MAX_DURATION_LSB    0
#define MAC_HW_DTIM_CFP_2_CFP_MAX_DURATION_WIDTH    ((u32)0x00000010)

#define MAC_HW_DTIM_CFP_2_CFP_MAX_DURATION_RST    0x0

static inline u16 mac_hw_dtim_cfp_2_cfp_max_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DTIM_CFP_2_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_dtim_cfp_2_cfp_max_duration_setf(struct cl_chip *chip, u16 cfpmaxduration)
{
	ASSERT_ERR_CHIP((((u32)cfpmaxduration << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_DTIM_CFP_2_ADDR, (u32)cfpmaxduration << 0);
}

/**
 * @brief RETRY_LIMITS register definition
 *  Contains the value of the short and long retry limit. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 DOT_11_LONG_RETRY_LIMIT   0x4
 *    07:00 DOT_11_SHORT_RETRY_LIMIT  0x7
 * </pre>
 */
#define MAC_HW_RETRY_LIMITS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000098)
#define MAC_HW_RETRY_LIMITS_OFFSET      0x00000098
#define MAC_HW_RETRY_LIMITS_INDEX       0x00000026
#define MAC_HW_RETRY_LIMITS_RESET       0x00000407

static inline u32 mac_hw_retry_limits_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR);
}

static inline void mac_hw_retry_limits_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RETRY_LIMITS_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RETRY_LIMITS_DOT_11_LONG_RETRY_LIMIT_MASK    ((u32)0x0000FF00)
#define MAC_HW_RETRY_LIMITS_DOT_11_LONG_RETRY_LIMIT_LSB    8
#define MAC_HW_RETRY_LIMITS_DOT_11_LONG_RETRY_LIMIT_WIDTH    ((u32)0x00000008)
#define MAC_HW_RETRY_LIMITS_DOT_11_SHORT_RETRY_LIMIT_MASK    ((u32)0x000000FF)
#define MAC_HW_RETRY_LIMITS_DOT_11_SHORT_RETRY_LIMIT_LSB    0
#define MAC_HW_RETRY_LIMITS_DOT_11_SHORT_RETRY_LIMIT_WIDTH    ((u32)0x00000008)

#define MAC_HW_RETRY_LIMITS_DOT_11_LONG_RETRY_LIMIT_RST    0x4
#define MAC_HW_RETRY_LIMITS_DOT_11_SHORT_RETRY_LIMIT_RST    0x7

static inline void mac_hw_retry_limits_pack(struct cl_chip *chip, u8 dot_11_long_retry_limit, u8 dot_11_short_retry_limit)
{
	ASSERT_ERR_CHIP((((u32)dot_11_long_retry_limit << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)dot_11_short_retry_limit << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RETRY_LIMITS_ADDR, ((u32)dot_11_long_retry_limit << 8) | ((u32)dot_11_short_retry_limit << 0));
}

static inline void mac_hw_retry_limits_unpack(struct cl_chip *chip, u8 *dot_11_long_retry_limit, u8 *dot_11_short_retry_limit)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR);

	*dot_11_long_retry_limit = (local_val & ((u32)0x0000FF00)) >> 8;
	*dot_11_short_retry_limit = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_retry_limits_dot_11_long_retry_limit_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_retry_limits_dot_11_long_retry_limit_setf(struct cl_chip *chip, u8 dot11longretrylimit)
{
	ASSERT_ERR_CHIP((((u32)dot11longretrylimit << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_RETRY_LIMITS_ADDR, (cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR) & ~((u32)0x0000FF00)) | ((u32)dot11longretrylimit << 8));
}

static inline u8 mac_hw_retry_limits_dot_11_short_retry_limit_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_retry_limits_dot_11_short_retry_limit_setf(struct cl_chip *chip, u8 dot11shortretrylimit)
{
	ASSERT_ERR_CHIP((((u32)dot11shortretrylimit << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RETRY_LIMITS_ADDR, (cl_reg_read(chip, MAC_HW_RETRY_LIMITS_ADDR) & ~((u32)0x000000FF)) | ((u32)dot11shortretrylimit << 0));
}

/**
 * @brief BB_SERVICE register definition
 *  Register used for programming the Service parameter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    28:26 MAX_PHY_NTX               0x2
 *    23:16 BB_SERVICE_B              0x0
 *    15:00 BB_SERVICE_A              0x0
 * </pre>
 */
#define MAC_HW_BB_SERVICE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000009C)
#define MAC_HW_BB_SERVICE_OFFSET      0x0000009C
#define MAC_HW_BB_SERVICE_INDEX       0x00000027
#define MAC_HW_BB_SERVICE_RESET       0x08000000

static inline u32 mac_hw_bb_service_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR);
}

static inline void mac_hw_bb_service_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BB_SERVICE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BB_SERVICE_MAX_PHY_NTX_MASK    ((u32)0x1C000000)
#define MAC_HW_BB_SERVICE_MAX_PHY_NTX_LSB    26
#define MAC_HW_BB_SERVICE_MAX_PHY_NTX_WIDTH    ((u32)0x00000003)
#define MAC_HW_BB_SERVICE_BB_SERVICE_B_MASK    ((u32)0x00FF0000)
#define MAC_HW_BB_SERVICE_BB_SERVICE_B_LSB    16
#define MAC_HW_BB_SERVICE_BB_SERVICE_B_WIDTH    ((u32)0x00000008)
#define MAC_HW_BB_SERVICE_BB_SERVICE_A_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BB_SERVICE_BB_SERVICE_A_LSB    0
#define MAC_HW_BB_SERVICE_BB_SERVICE_A_WIDTH    ((u32)0x00000010)

#define MAC_HW_BB_SERVICE_MAX_PHY_NTX_RST    0x2
#define MAC_HW_BB_SERVICE_BB_SERVICE_B_RST    0x0
#define MAC_HW_BB_SERVICE_BB_SERVICE_A_RST    0x0

static inline void mac_hw_bb_service_pack(struct cl_chip *chip, u8 max_phy_ntx, u8 bb_service_b, u16 bb_service_a)
{
	ASSERT_ERR_CHIP((((u32)max_phy_ntx << 26) & ~((u32)0x1C000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bb_service_b << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bb_service_a << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BB_SERVICE_ADDR, ((u32)max_phy_ntx << 26) | ((u32)bb_service_b << 16) | ((u32)bb_service_a << 0));
}

static inline void mac_hw_bb_service_unpack(struct cl_chip *chip, u8 *max_phy_ntx, u8 *bb_service_b, u16 *bb_service_a)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR);

	*max_phy_ntx = (local_val & ((u32)0x1C000000)) >> 26;
	*bb_service_b = (local_val & ((u32)0x00FF0000)) >> 16;
	*bb_service_a = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bb_service_max_phy_ntx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR);

	return (u8)((local_val & ((u32)0x1C000000)) >> 26);
}

static inline void mac_hw_bb_service_max_phy_ntx_setf(struct cl_chip *chip, u8 maxphyntx)
{
	ASSERT_ERR_CHIP((((u32)maxphyntx << 26) & ~((u32)0x1C000000)) == 0);
	cl_reg_write(chip, MAC_HW_BB_SERVICE_ADDR, (cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR) & ~((u32)0x1C000000)) | ((u32)maxphyntx << 26));
}

static inline u8 mac_hw_bb_service_bb_service_b_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_bb_service_bb_service_b_setf(struct cl_chip *chip, u8 bbserviceb)
{
	ASSERT_ERR_CHIP((((u32)bbserviceb << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_BB_SERVICE_ADDR, (cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR) & ~((u32)0x00FF0000)) | ((u32)bbserviceb << 16));
}

static inline u16 mac_hw_bb_service_bb_service_a_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bb_service_bb_service_a_setf(struct cl_chip *chip, u16 bbservicea)
{
	ASSERT_ERR_CHIP((((u32)bbservicea << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BB_SERVICE_ADDR, (cl_reg_read(chip, MAC_HW_BB_SERVICE_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bbservicea << 0));
}

/**
 * @brief MAX_POWER_LEVEL register definition
 *  Contains the power level for response frame register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 NEAR_STA_DSSS_MAX_PWR_LEVEL 0x4
 *    23:16 NEAR_STA_OFDM_MAX_PWR_LEVEL 0x4
 *    15:08 DSSS_MAX_PWR_LEVEL        0x4
 *    07:00 OFDM_MAX_PWR_LEVEL        0x4
 * </pre>
 */
#define MAC_HW_MAX_POWER_LEVEL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000A0)
#define MAC_HW_MAX_POWER_LEVEL_OFFSET      0x000000A0
#define MAC_HW_MAX_POWER_LEVEL_INDEX       0x00000028
#define MAC_HW_MAX_POWER_LEVEL_RESET       0x04040404

static inline u32 mac_hw_max_power_level_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);
}

static inline void mac_hw_max_power_level_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_DSSS_MAX_PWR_LEVEL_MASK    ((u32)0xFF000000)
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_DSSS_MAX_PWR_LEVEL_LSB    24
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_DSSS_MAX_PWR_LEVEL_WIDTH    ((u32)0x00000008)
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_OFDM_MAX_PWR_LEVEL_MASK    ((u32)0x00FF0000)
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_OFDM_MAX_PWR_LEVEL_LSB    16
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_OFDM_MAX_PWR_LEVEL_WIDTH    ((u32)0x00000008)
#define MAC_HW_MAX_POWER_LEVEL_DSSS_MAX_PWR_LEVEL_MASK    ((u32)0x0000FF00)
#define MAC_HW_MAX_POWER_LEVEL_DSSS_MAX_PWR_LEVEL_LSB    8
#define MAC_HW_MAX_POWER_LEVEL_DSSS_MAX_PWR_LEVEL_WIDTH    ((u32)0x00000008)
#define MAC_HW_MAX_POWER_LEVEL_OFDM_MAX_PWR_LEVEL_MASK    ((u32)0x000000FF)
#define MAC_HW_MAX_POWER_LEVEL_OFDM_MAX_PWR_LEVEL_LSB    0
#define MAC_HW_MAX_POWER_LEVEL_OFDM_MAX_PWR_LEVEL_WIDTH    ((u32)0x00000008)

#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_DSSS_MAX_PWR_LEVEL_RST    0x4
#define MAC_HW_MAX_POWER_LEVEL_NEAR_STA_OFDM_MAX_PWR_LEVEL_RST    0x4
#define MAC_HW_MAX_POWER_LEVEL_DSSS_MAX_PWR_LEVEL_RST    0x4
#define MAC_HW_MAX_POWER_LEVEL_OFDM_MAX_PWR_LEVEL_RST    0x4

static inline void mac_hw_max_power_level_pack(struct cl_chip *chip, u8 near_sta_dsss_max_pwr_level, u8 near_sta_ofdm_max_pwr_level, u8 dsss_max_pwr_level, u8 ofdm_max_pwr_level)
{
	ASSERT_ERR_CHIP((((u32)near_sta_dsss_max_pwr_level << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)near_sta_ofdm_max_pwr_level << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)dsss_max_pwr_level << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)ofdm_max_pwr_level << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, ((u32)near_sta_dsss_max_pwr_level << 24) | ((u32)near_sta_ofdm_max_pwr_level << 16) | ((u32)dsss_max_pwr_level << 8) | ((u32)ofdm_max_pwr_level << 0));
}

static inline void mac_hw_max_power_level_unpack(struct cl_chip *chip, u8 *near_sta_dsss_max_pwr_level, u8 *near_sta_ofdm_max_pwr_level, u8 *dsss_max_pwr_level, u8 *ofdm_max_pwr_level)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);

	*near_sta_dsss_max_pwr_level = (local_val & ((u32)0xFF000000)) >> 24;
	*near_sta_ofdm_max_pwr_level = (local_val & ((u32)0x00FF0000)) >> 16;
	*dsss_max_pwr_level = (local_val & ((u32)0x0000FF00)) >> 8;
	*ofdm_max_pwr_level = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_max_power_level_near_sta_dsss_max_pwr_level_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_max_power_level_near_sta_dsss_max_pwr_level_setf(struct cl_chip *chip, u8 nearstadsssmaxpwrlevel)
{
	ASSERT_ERR_CHIP((((u32)nearstadsssmaxpwrlevel << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR) & ~((u32)0xFF000000)) | ((u32)nearstadsssmaxpwrlevel << 24));
}

static inline u8 mac_hw_max_power_level_near_sta_ofdm_max_pwr_level_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_max_power_level_near_sta_ofdm_max_pwr_level_setf(struct cl_chip *chip, u8 nearstaofdmmaxpwrlevel)
{
	ASSERT_ERR_CHIP((((u32)nearstaofdmmaxpwrlevel << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR) & ~((u32)0x00FF0000)) | ((u32)nearstaofdmmaxpwrlevel << 16));
}

static inline u8 mac_hw_max_power_level_dsss_max_pwr_level_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_max_power_level_dsss_max_pwr_level_setf(struct cl_chip *chip, u8 dsssmaxpwrlevel)
{
	ASSERT_ERR_CHIP((((u32)dsssmaxpwrlevel << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR) & ~((u32)0x0000FF00)) | ((u32)dsssmaxpwrlevel << 8));
}

static inline u8 mac_hw_max_power_level_ofdm_max_pwr_level_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_max_power_level_ofdm_max_pwr_level_setf(struct cl_chip *chip, u8 ofdmmaxpwrlevel)
{
	ASSERT_ERR_CHIP((((u32)ofdmmaxpwrlevel << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_MAX_POWER_LEVEL_ADDR) & ~((u32)0x000000FF)) | ((u32)ofdmmaxpwrlevel << 0));
}

/**
 * @brief KSR_WRAP_AROUND register definition
 *  key search engine wrap around value register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:00 ksr_wrap_around           0xBF
 * </pre>
 */
#define MAC_HW_KSR_WRAP_AROUND_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000A8)
#define MAC_HW_KSR_WRAP_AROUND_OFFSET      0x000000A8
#define MAC_HW_KSR_WRAP_AROUND_INDEX       0x0000002A
#define MAC_HW_KSR_WRAP_AROUND_RESET       0x000000BF

static inline u32 mac_hw_ksr_wrap_around_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_KSR_WRAP_AROUND_ADDR);
}

static inline void mac_hw_ksr_wrap_around_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_KSR_WRAP_AROUND_ADDR, value);
}

/* Field definitions */
#define MAC_HW_KSR_WRAP_AROUND_KSR_WRAP_AROUND_MASK    ((u32)0x000000FF)
#define MAC_HW_KSR_WRAP_AROUND_KSR_WRAP_AROUND_LSB    0
#define MAC_HW_KSR_WRAP_AROUND_KSR_WRAP_AROUND_WIDTH    ((u32)0x00000008)

#define MAC_HW_KSR_WRAP_AROUND_KSR_WRAP_AROUND_RST    0xBF

static inline u8 mac_hw_ksr_wrap_around_ksr_wrap_around_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_KSR_WRAP_AROUND_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_ksr_wrap_around_ksr_wrap_around_setf(struct cl_chip *chip, u8 ksrwraparound)
{
	ASSERT_ERR_CHIP((((u32)ksrwraparound << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_KSR_WRAP_AROUND_ADDR, (u32)ksrwraparound << 0);
}

/**
 * @brief ENCR_KEY_0 register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCR_KEY_RAM_WORD_0       0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000AC)
#define MAC_HW_ENCR_KEY_0_OFFSET      0x000000AC
#define MAC_HW_ENCR_KEY_0_INDEX       0x0000002B
#define MAC_HW_ENCR_KEY_0_RESET       0x00000000

static inline u32 mac_hw_encr_key_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_0_ADDR);
}

static inline void mac_hw_encr_key_0_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_0_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_0_ENCR_KEY_RAM_WORD_0_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCR_KEY_0_ENCR_KEY_RAM_WORD_0_LSB    0
#define MAC_HW_ENCR_KEY_0_ENCR_KEY_RAM_WORD_0_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCR_KEY_0_ENCR_KEY_RAM_WORD_0_RST    0x0

static inline u32 mac_hw_encr_key_0_encr_key_ram_word_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_0_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encr_key_0_encr_key_ram_word_0_setf(struct cl_chip *chip, u32 encrkeyramword0)
{
	ASSERT_ERR_CHIP((((u32)encrkeyramword0 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_0_ADDR, (u32)encrkeyramword0 << 0);
}

/**
 * @brief ENCR_KEY_1 register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCR_KEY_RAM_WORD_1       0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000B0)
#define MAC_HW_ENCR_KEY_1_OFFSET      0x000000B0
#define MAC_HW_ENCR_KEY_1_INDEX       0x0000002C
#define MAC_HW_ENCR_KEY_1_RESET       0x00000000

static inline u32 mac_hw_encr_key_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_1_ADDR);
}

static inline void mac_hw_encr_key_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_1_ENCR_KEY_RAM_WORD_1_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCR_KEY_1_ENCR_KEY_RAM_WORD_1_LSB    0
#define MAC_HW_ENCR_KEY_1_ENCR_KEY_RAM_WORD_1_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCR_KEY_1_ENCR_KEY_RAM_WORD_1_RST    0x0

static inline u32 mac_hw_encr_key_1_encr_key_ram_word_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_1_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encr_key_1_encr_key_ram_word_1_setf(struct cl_chip *chip, u32 encrkeyramword1)
{
	ASSERT_ERR_CHIP((((u32)encrkeyramword1 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_1_ADDR, (u32)encrkeyramword1 << 0);
}

/**
 * @brief ENCR_KEY_2 register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCR_KEY_RAM_WORD_2       0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000B4)
#define MAC_HW_ENCR_KEY_2_OFFSET      0x000000B4
#define MAC_HW_ENCR_KEY_2_INDEX       0x0000002D
#define MAC_HW_ENCR_KEY_2_RESET       0x00000000

static inline u32 mac_hw_encr_key_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_2_ADDR);
}

static inline void mac_hw_encr_key_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_2_ENCR_KEY_RAM_WORD_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCR_KEY_2_ENCR_KEY_RAM_WORD_2_LSB    0
#define MAC_HW_ENCR_KEY_2_ENCR_KEY_RAM_WORD_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCR_KEY_2_ENCR_KEY_RAM_WORD_2_RST    0x0

static inline u32 mac_hw_encr_key_2_encr_key_ram_word_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_2_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encr_key_2_encr_key_ram_word_2_setf(struct cl_chip *chip, u32 encrkeyramword2)
{
	ASSERT_ERR_CHIP((((u32)encrkeyramword2 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_2_ADDR, (u32)encrkeyramword2 << 0);
}

/**
 * @brief ENCR_KEY_3 register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCR_KEY_RAM_WORD_3       0x0
 * </pre>
 */
#define MAC_HW_ENCR_KEY_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000B8)
#define MAC_HW_ENCR_KEY_3_OFFSET      0x000000B8
#define MAC_HW_ENCR_KEY_3_INDEX       0x0000002E
#define MAC_HW_ENCR_KEY_3_RESET       0x00000000

static inline u32 mac_hw_encr_key_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_KEY_3_ADDR);
}

static inline void mac_hw_encr_key_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_KEY_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_KEY_3_ENCR_KEY_RAM_WORD_3_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCR_KEY_3_ENCR_KEY_RAM_WORD_3_LSB    0
#define MAC_HW_ENCR_KEY_3_ENCR_KEY_RAM_WORD_3_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCR_KEY_3_ENCR_KEY_RAM_WORD_3_RST    0x0

static inline u32 mac_hw_encr_key_3_encr_key_ram_word_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_KEY_3_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encr_key_3_encr_key_ram_word_3_setf(struct cl_chip *chip, u32 encrkeyramword3)
{
	ASSERT_ERR_CHIP((((u32)encrkeyramword3 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_KEY_3_ADDR, (u32)encrkeyramword3 << 0);
}

/**
 * @brief ENCR_MAC_ADDR_LOW register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MAC_ADDR_RAM_LOW          0xFFFFFFFF
 * </pre>
 */
#define MAC_HW_ENCR_MAC_ADDR_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000BC)
#define MAC_HW_ENCR_MAC_ADDR_LOW_OFFSET      0x000000BC
#define MAC_HW_ENCR_MAC_ADDR_LOW_INDEX       0x0000002F
#define MAC_HW_ENCR_MAC_ADDR_LOW_RESET       0xFFFFFFFF

static inline u32 mac_hw_encr_mac_addr_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_MAC_ADDR_LOW_ADDR);
}

static inline void mac_hw_encr_mac_addr_low_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_MAC_ADDR_LOW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_MAC_ADDR_LOW_MAC_ADDR_RAM_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCR_MAC_ADDR_LOW_MAC_ADDR_RAM_LOW_LSB    0
#define MAC_HW_ENCR_MAC_ADDR_LOW_MAC_ADDR_RAM_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCR_MAC_ADDR_LOW_MAC_ADDR_RAM_LOW_RST    0xFFFFFFFF

static inline u32 mac_hw_encr_mac_addr_low_mac_addr_ram_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_MAC_ADDR_LOW_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encr_mac_addr_low_mac_addr_ram_low_setf(struct cl_chip *chip, u32 macaddrramlow)
{
	ASSERT_ERR_CHIP((((u32)macaddrramlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_MAC_ADDR_LOW_ADDR, (u32)macaddrramlow << 0);
}

/**
 * @brief ENCR_MAC_ADDR_HIGH register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 MAC_ADDR_RAM_HIGH         0xFFFF
 * </pre>
 */
#define MAC_HW_ENCR_MAC_ADDR_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000C0)
#define MAC_HW_ENCR_MAC_ADDR_HIGH_OFFSET      0x000000C0
#define MAC_HW_ENCR_MAC_ADDR_HIGH_INDEX       0x00000030
#define MAC_HW_ENCR_MAC_ADDR_HIGH_RESET       0x0000FFFF

static inline u32 mac_hw_encr_mac_addr_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_MAC_ADDR_HIGH_ADDR);
}

static inline void mac_hw_encr_mac_addr_high_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_MAC_ADDR_HIGH_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_MAC_ADDR_HIGH_MAC_ADDR_RAM_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_ENCR_MAC_ADDR_HIGH_MAC_ADDR_RAM_HIGH_LSB    0
#define MAC_HW_ENCR_MAC_ADDR_HIGH_MAC_ADDR_RAM_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_ENCR_MAC_ADDR_HIGH_MAC_ADDR_RAM_HIGH_RST    0xFFFF

static inline u16 mac_hw_encr_mac_addr_high_mac_addr_ram_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_MAC_ADDR_HIGH_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_encr_mac_addr_high_mac_addr_ram_high_setf(struct cl_chip *chip, u16 macaddrramhigh)
{
	ASSERT_ERR_CHIP((((u32)macaddrramhigh << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_MAC_ADDR_HIGH_ADDR, (u32)macaddrramhigh << 0);
}

/**
 * @brief ENCR_CNTRL register definition
 *  Window registers used to program the encryption parameters into the KeyStorage RAM from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    NEW_READ                  0
 *    30    NEW_WRITE                 0
 *    29    NEW_WRITE_EXTRAM_ONLY     0
 *    25:16 KEY_INDEX_RAM             0x0
 *    15:11 EXT_RAM                   0x0
 *    10:08 C_TYPE_RAM                0x0
 *    07:04 VLAN_IDRAM                0x0
 *    03:02 SPP_RAM                   0x0
 *    01    USE_DEF_KEY_RAM           0
 *    00    C_LEN_RAM                 0
 * </pre>
 */
#define MAC_HW_ENCR_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000C4)
#define MAC_HW_ENCR_CNTRL_OFFSET      0x000000C4
#define MAC_HW_ENCR_CNTRL_INDEX       0x00000031
#define MAC_HW_ENCR_CNTRL_RESET       0x00000000

static inline u32 mac_hw_encr_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);
}

static inline void mac_hw_encr_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCR_CNTRL_NEW_READ_BIT      ((u32)0x80000000)
#define MAC_HW_ENCR_CNTRL_NEW_READ_POS      31
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_BIT     ((u32)0x40000000)
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_POS     30
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_EXTRAM_ONLY_BIT    ((u32)0x20000000)
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_EXTRAM_ONLY_POS    29
#define MAC_HW_ENCR_CNTRL_KEY_INDEX_RAM_MASK    ((u32)0x03FF0000)
#define MAC_HW_ENCR_CNTRL_KEY_INDEX_RAM_LSB    16
#define MAC_HW_ENCR_CNTRL_KEY_INDEX_RAM_WIDTH    ((u32)0x0000000A)
#define MAC_HW_ENCR_CNTRL_EXT_RAM_MASK      ((u32)0x0000F800)
#define MAC_HW_ENCR_CNTRL_EXT_RAM_LSB       11
#define MAC_HW_ENCR_CNTRL_EXT_RAM_WIDTH     ((u32)0x00000005)
#define MAC_HW_ENCR_CNTRL_C_TYPE_RAM_MASK    ((u32)0x00000700)
#define MAC_HW_ENCR_CNTRL_C_TYPE_RAM_LSB    8
#define MAC_HW_ENCR_CNTRL_C_TYPE_RAM_WIDTH    ((u32)0x00000003)
#define MAC_HW_ENCR_CNTRL_VLAN_IDRAM_MASK    ((u32)0x000000F0)
#define MAC_HW_ENCR_CNTRL_VLAN_IDRAM_LSB    4
#define MAC_HW_ENCR_CNTRL_VLAN_IDRAM_WIDTH    ((u32)0x00000004)
#define MAC_HW_ENCR_CNTRL_SPP_RAM_MASK      ((u32)0x0000000C)
#define MAC_HW_ENCR_CNTRL_SPP_RAM_LSB       2
#define MAC_HW_ENCR_CNTRL_SPP_RAM_WIDTH     ((u32)0x00000002)
#define MAC_HW_ENCR_CNTRL_USE_DEF_KEY_RAM_BIT    ((u32)0x00000002)
#define MAC_HW_ENCR_CNTRL_USE_DEF_KEY_RAM_POS    1
#define MAC_HW_ENCR_CNTRL_C_LEN_RAM_BIT     ((u32)0x00000001)
#define MAC_HW_ENCR_CNTRL_C_LEN_RAM_POS     0

#define MAC_HW_ENCR_CNTRL_NEW_READ_RST      0x0
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_RST     0x0
#define MAC_HW_ENCR_CNTRL_NEW_WRITE_EXTRAM_ONLY_RST    0x0
#define MAC_HW_ENCR_CNTRL_KEY_INDEX_RAM_RST    0x0
#define MAC_HW_ENCR_CNTRL_EXT_RAM_RST       0x0
#define MAC_HW_ENCR_CNTRL_C_TYPE_RAM_RST    0x0
#define MAC_HW_ENCR_CNTRL_VLAN_IDRAM_RST    0x0
#define MAC_HW_ENCR_CNTRL_SPP_RAM_RST       0x0
#define MAC_HW_ENCR_CNTRL_USE_DEF_KEY_RAM_RST    0x0
#define MAC_HW_ENCR_CNTRL_C_LEN_RAM_RST     0x0

static inline void mac_hw_encr_cntrl_pack(struct cl_chip *chip, u8 new_read, u8 new_write, u8 new_write_extram_only, u16 key_index_ram, u8 ext_ram, u8 c_type_ram, u8 vlan_idram, u8 spp_ram, u8 use_def_key_ram, u8 c_len_ram)
{
	ASSERT_ERR_CHIP((((u32)new_read << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)new_write << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)new_write_extram_only << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)key_index_ram << 16) & ~((u32)0x03FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)ext_ram << 11) & ~((u32)0x0000F800)) == 0);
	ASSERT_ERR_CHIP((((u32)c_type_ram << 8) & ~((u32)0x00000700)) == 0);
	ASSERT_ERR_CHIP((((u32)vlan_idram << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)spp_ram << 2) & ~((u32)0x0000000C)) == 0);
	ASSERT_ERR_CHIP((((u32)use_def_key_ram << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)c_len_ram << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, ((u32)new_read << 31) | ((u32)new_write << 30) | ((u32)new_write_extram_only << 29) | ((u32)key_index_ram << 16) | ((u32)ext_ram << 11) | ((u32)c_type_ram << 8) | ((u32)vlan_idram << 4) | ((u32)spp_ram << 2) | ((u32)use_def_key_ram << 1) | ((u32)c_len_ram << 0));
}

static inline void mac_hw_encr_cntrl_unpack(struct cl_chip *chip, u8 *new_read, u8 *new_write, u8 *new_write_extram_only, u16 *key_index_ram, u8 *ext_ram, u8 *c_type_ram, u8 *vlan_idram, u8 *spp_ram, u8 *use_def_key_ram, u8 *c_len_ram)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	*new_read = (local_val & ((u32)0x80000000)) >> 31;
	*new_write = (local_val & ((u32)0x40000000)) >> 30;
	*new_write_extram_only = (local_val & ((u32)0x20000000)) >> 29;
	*key_index_ram = (local_val & ((u32)0x03FF0000)) >> 16;
	*ext_ram = (local_val & ((u32)0x0000F800)) >> 11;
	*c_type_ram = (local_val & ((u32)0x00000700)) >> 8;
	*vlan_idram = (local_val & ((u32)0x000000F0)) >> 4;
	*spp_ram = (local_val & ((u32)0x0000000C)) >> 2;
	*use_def_key_ram = (local_val & ((u32)0x00000002)) >> 1;
	*c_len_ram = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_encr_cntrl_new_read_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_encr_cntrl_new_read_setf(struct cl_chip *chip, u8 newread)
{
	ASSERT_ERR_CHIP((((u32)newread << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x80000000)) | ((u32)newread << 31));
}

static inline u8 mac_hw_encr_cntrl_new_write_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_encr_cntrl_new_write_setf(struct cl_chip *chip, u8 newwrite)
{
	ASSERT_ERR_CHIP((((u32)newwrite << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x40000000)) | ((u32)newwrite << 30));
}

static inline u8 mac_hw_encr_cntrl_new_write_extram_only_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_encr_cntrl_new_write_extram_only_setf(struct cl_chip *chip, u8 newwriteextramonly)
{
	ASSERT_ERR_CHIP((((u32)newwriteextramonly << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x20000000)) | ((u32)newwriteextramonly << 29));
}

static inline u16 mac_hw_encr_cntrl_key_index_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u16)((local_val & ((u32)0x03FF0000)) >> 16);
}

static inline void mac_hw_encr_cntrl_key_index_ram_setf(struct cl_chip *chip, u16 keyindexram)
{
	ASSERT_ERR_CHIP((((u32)keyindexram << 16) & ~((u32)0x03FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x03FF0000)) | ((u32)keyindexram << 16));
}

static inline u8 mac_hw_encr_cntrl_ext_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000F800)) >> 11);
}

static inline void mac_hw_encr_cntrl_ext_ram_setf(struct cl_chip *chip, u8 extram)
{
	ASSERT_ERR_CHIP((((u32)extram << 11) & ~((u32)0x0000F800)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x0000F800)) | ((u32)extram << 11));
}

static inline u8 mac_hw_encr_cntrl_c_type_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000700)) >> 8);
}

static inline void mac_hw_encr_cntrl_c_type_ram_setf(struct cl_chip *chip, u8 ctyperam)
{
	ASSERT_ERR_CHIP((((u32)ctyperam << 8) & ~((u32)0x00000700)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x00000700)) | ((u32)ctyperam << 8));
}

static inline u8 mac_hw_encr_cntrl_vlan_idram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_encr_cntrl_vlan_idram_setf(struct cl_chip *chip, u8 vlanidram)
{
	ASSERT_ERR_CHIP((((u32)vlanidram << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x000000F0)) | ((u32)vlanidram << 4));
}

static inline u8 mac_hw_encr_cntrl_spp_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline void mac_hw_encr_cntrl_spp_ram_setf(struct cl_chip *chip, u8 sppram)
{
	ASSERT_ERR_CHIP((((u32)sppram << 2) & ~((u32)0x0000000C)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x0000000C)) | ((u32)sppram << 2));
}

static inline u8 mac_hw_encr_cntrl_use_def_key_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_encr_cntrl_use_def_key_ram_setf(struct cl_chip *chip, u8 usedefkeyram)
{
	ASSERT_ERR_CHIP((((u32)usedefkeyram << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x00000002)) | ((u32)usedefkeyram << 1));
}

static inline u8 mac_hw_encr_cntrl_c_len_ram_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_encr_cntrl_c_len_ram_setf(struct cl_chip *chip, u8 clenram)
{
	ASSERT_ERR_CHIP((((u32)clenram << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_ENCR_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_ENCR_CNTRL_ADDR) & ~((u32)0x00000001)) | ((u32)clenram << 0));
}

/**
 * @brief ENCRWPIINTKEY_0 register definition
 *  Encryption WPI Integrity Key 0 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCRWPIINTKEY0            0x0
 * </pre>
 */
#define MAC_HW_ENCRWPIINTKEY_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000C8)
#define MAC_HW_ENCRWPIINTKEY_0_OFFSET      0x000000C8
#define MAC_HW_ENCRWPIINTKEY_0_INDEX       0x00000032
#define MAC_HW_ENCRWPIINTKEY_0_RESET       0x00000000

static inline u32 mac_hw_encrwpiintkey_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_0_ADDR);
}

static inline void mac_hw_encrwpiintkey_0_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_0_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCRWPIINTKEY_0_ENCRWPIINTKEY_0_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCRWPIINTKEY_0_ENCRWPIINTKEY_0_LSB    0
#define MAC_HW_ENCRWPIINTKEY_0_ENCRWPIINTKEY_0_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCRWPIINTKEY_0_ENCRWPIINTKEY_0_RST    0x0

static inline u32 mac_hw_encrwpiintkey_0_encrwpiintkey_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_0_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encrwpiintkey_0_encrwpiintkey_0_setf(struct cl_chip *chip, u32 encrwpiintkey0)
{
	ASSERT_ERR_CHIP((((u32)encrwpiintkey0 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_0_ADDR, (u32)encrwpiintkey0 << 0);
}

/**
 * @brief ENCRWPIINTKEY_1 register definition
 *  Encryption WPI Integrity Key 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCRWPIINTKEY1            0x0
 * </pre>
 */
#define MAC_HW_ENCRWPIINTKEY_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000CC)
#define MAC_HW_ENCRWPIINTKEY_1_OFFSET      0x000000CC
#define MAC_HW_ENCRWPIINTKEY_1_INDEX       0x00000033
#define MAC_HW_ENCRWPIINTKEY_1_RESET       0x00000000

static inline u32 mac_hw_encrwpiintkey_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_1_ADDR);
}

static inline void mac_hw_encrwpiintkey_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCRWPIINTKEY_1_ENCRWPIINTKEY_1_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCRWPIINTKEY_1_ENCRWPIINTKEY_1_LSB    0
#define MAC_HW_ENCRWPIINTKEY_1_ENCRWPIINTKEY_1_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCRWPIINTKEY_1_ENCRWPIINTKEY_1_RST    0x0

static inline u32 mac_hw_encrwpiintkey_1_encrwpiintkey_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_1_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encrwpiintkey_1_encrwpiintkey_1_setf(struct cl_chip *chip, u32 encrwpiintkey1)
{
	ASSERT_ERR_CHIP((((u32)encrwpiintkey1 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_1_ADDR, (u32)encrwpiintkey1 << 0);
}

/**
 * @brief ENCRWPIINTKEY_2 register definition
 *  Encryption WPI Integrity Key 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCRWPIINTKEY2            0x0
 * </pre>
 */
#define MAC_HW_ENCRWPIINTKEY_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000D0)
#define MAC_HW_ENCRWPIINTKEY_2_OFFSET      0x000000D0
#define MAC_HW_ENCRWPIINTKEY_2_INDEX       0x00000034
#define MAC_HW_ENCRWPIINTKEY_2_RESET       0x00000000

static inline u32 mac_hw_encrwpiintkey_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_2_ADDR);
}

static inline void mac_hw_encrwpiintkey_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCRWPIINTKEY_2_ENCRWPIINTKEY_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCRWPIINTKEY_2_ENCRWPIINTKEY_2_LSB    0
#define MAC_HW_ENCRWPIINTKEY_2_ENCRWPIINTKEY_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCRWPIINTKEY_2_ENCRWPIINTKEY_2_RST    0x0

static inline u32 mac_hw_encrwpiintkey_2_encrwpiintkey_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_2_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encrwpiintkey_2_encrwpiintkey_2_setf(struct cl_chip *chip, u32 encrwpiintkey2)
{
	ASSERT_ERR_CHIP((((u32)encrwpiintkey2 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_2_ADDR, (u32)encrwpiintkey2 << 0);
}

/**
 * @brief ENCRWPIINTKEY_3 register definition
 *  Encryption WPI Integrity Key 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ENCRWPIINTKEY3            0x0
 * </pre>
 */
#define MAC_HW_ENCRWPIINTKEY_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000D4)
#define MAC_HW_ENCRWPIINTKEY_3_OFFSET      0x000000D4
#define MAC_HW_ENCRWPIINTKEY_3_INDEX       0x00000035
#define MAC_HW_ENCRWPIINTKEY_3_RESET       0x00000000

static inline u32 mac_hw_encrwpiintkey_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_3_ADDR);
}

static inline void mac_hw_encrwpiintkey_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ENCRWPIINTKEY_3_ENCRWPIINTKEY_3_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ENCRWPIINTKEY_3_ENCRWPIINTKEY_3_LSB    0
#define MAC_HW_ENCRWPIINTKEY_3_ENCRWPIINTKEY_3_WIDTH    ((u32)0x00000020)

#define MAC_HW_ENCRWPIINTKEY_3_ENCRWPIINTKEY_3_RST    0x0

static inline u32 mac_hw_encrwpiintkey_3_encrwpiintkey_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ENCRWPIINTKEY_3_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_encrwpiintkey_3_encrwpiintkey_3_setf(struct cl_chip *chip, u32 encrwpiintkey3)
{
	ASSERT_ERR_CHIP((((u32)encrwpiintkey3 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ENCRWPIINTKEY_3_ADDR, (u32)encrwpiintkey3 << 0);
}

/**
 * @brief RX_INV_LINE register definition
 *  Invalidate a line in the ps bitmap register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    INV                       0
 *    19:16 TID                       0x0
 *    07:00 KSR_ID                    0x0
 * </pre>
 */
#define MAC_HW_RX_INV_LINE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000D8)
#define MAC_HW_RX_INV_LINE_OFFSET      0x000000D8
#define MAC_HW_RX_INV_LINE_INDEX       0x00000036
#define MAC_HW_RX_INV_LINE_RESET       0x00000000

static inline u32 mac_hw_rx_inv_line_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR);
}

static inline void mac_hw_rx_inv_line_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INV_LINE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INV_LINE_INV_BIT          ((u32)0x80000000)
#define MAC_HW_RX_INV_LINE_INV_POS          31
#define MAC_HW_RX_INV_LINE_TID_MASK         ((u32)0x000F0000)
#define MAC_HW_RX_INV_LINE_TID_LSB          16
#define MAC_HW_RX_INV_LINE_TID_WIDTH        ((u32)0x00000004)
#define MAC_HW_RX_INV_LINE_KSR_ID_MASK      ((u32)0x000000FF)
#define MAC_HW_RX_INV_LINE_KSR_ID_LSB       0
#define MAC_HW_RX_INV_LINE_KSR_ID_WIDTH     ((u32)0x00000008)

#define MAC_HW_RX_INV_LINE_INV_RST          0x0
#define MAC_HW_RX_INV_LINE_TID_RST          0x0
#define MAC_HW_RX_INV_LINE_KSR_ID_RST       0x0

static inline void mac_hw_rx_inv_line_pack(struct cl_chip *chip, u8 inv, u8 tid, u8 ksr_id)
{
	ASSERT_ERR_CHIP((((u32)inv << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tid << 16) & ~((u32)0x000F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)ksr_id << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INV_LINE_ADDR, ((u32)inv << 31) | ((u32)tid << 16) | ((u32)ksr_id << 0));
}

static inline void mac_hw_rx_inv_line_unpack(struct cl_chip *chip, u8 *inv, u8 *tid, u8 *ksr_id)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR);

	*inv = (local_val & ((u32)0x80000000)) >> 31;
	*tid = (local_val & ((u32)0x000F0000)) >> 16;
	*ksr_id = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_rx_inv_line_inv_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_rx_inv_line_inv_setf(struct cl_chip *chip, u8 inv)
{
	ASSERT_ERR_CHIP((((u32)inv << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INV_LINE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR) & ~((u32)0x80000000)) | ((u32)inv << 31));
}

static inline u8 mac_hw_rx_inv_line_tid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR);

	return (u8)((local_val & ((u32)0x000F0000)) >> 16);
}

static inline void mac_hw_rx_inv_line_tid_setf(struct cl_chip *chip, u8 tid)
{
	ASSERT_ERR_CHIP((((u32)tid << 16) & ~((u32)0x000F0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INV_LINE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR) & ~((u32)0x000F0000)) | ((u32)tid << 16));
}

static inline u8 mac_hw_rx_inv_line_ksr_id_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_rx_inv_line_ksr_id_setf(struct cl_chip *chip, u8 ksrid)
{
	ASSERT_ERR_CHIP((((u32)ksrid << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INV_LINE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INV_LINE_ADDR) & ~((u32)0x000000FF)) | ((u32)ksrid << 0));
}

/**
 * @brief RATES register definition
 *  Indicates the BSS Basic Rate Set. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    11:00 BSS_BASIC_RATE_SET        0x150
 * </pre>
 */
#define MAC_HW_RATES_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000DC)
#define MAC_HW_RATES_OFFSET      0x000000DC
#define MAC_HW_RATES_INDEX       0x00000037
#define MAC_HW_RATES_RESET       0x00000150

static inline u32 mac_hw_rates_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RATES_ADDR);
}

static inline void mac_hw_rates_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RATES_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RATES_BSS_BASIC_RATE_SET_MASK    ((u32)0x00000FFF)
#define MAC_HW_RATES_BSS_BASIC_RATE_SET_LSB    0
#define MAC_HW_RATES_BSS_BASIC_RATE_SET_WIDTH    ((u32)0x0000000C)

#define MAC_HW_RATES_BSS_BASIC_RATE_SET_RST    0x150

static inline u16 mac_hw_rates_bss_basic_rate_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RATES_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_rates_bss_basic_rate_set_setf(struct cl_chip *chip, u16 bssbasicrateset)
{
	ASSERT_ERR_CHIP((((u32)bssbasicrateset << 0) & ~((u32)0x00000FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RATES_ADDR, (u32)bssbasicrateset << 0);
}

/**
 * @brief OLBC register definition
 *  Contains settings to determine if there is an OLBC. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 DSSS_COUNT                0x0
 *    23:16 OFDM_COUNT                0x0
 *    15:00 OLBC_TIMER                0x0
 * </pre>
 */
#define MAC_HW_OLBC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000E0)
#define MAC_HW_OLBC_OFFSET      0x000000E0
#define MAC_HW_OLBC_INDEX       0x00000038
#define MAC_HW_OLBC_RESET       0x00000000

static inline u32 mac_hw_olbc_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_OLBC_ADDR);
}

static inline void mac_hw_olbc_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_OLBC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_OLBC_DSSS_COUNT_MASK         ((u32)0xFF000000)
#define MAC_HW_OLBC_DSSS_COUNT_LSB          24
#define MAC_HW_OLBC_DSSS_COUNT_WIDTH        ((u32)0x00000008)
#define MAC_HW_OLBC_OFDM_COUNT_MASK         ((u32)0x00FF0000)
#define MAC_HW_OLBC_OFDM_COUNT_LSB          16
#define MAC_HW_OLBC_OFDM_COUNT_WIDTH        ((u32)0x00000008)
#define MAC_HW_OLBC_OLBC_TIMER_MASK         ((u32)0x0000FFFF)
#define MAC_HW_OLBC_OLBC_TIMER_LSB          0
#define MAC_HW_OLBC_OLBC_TIMER_WIDTH        ((u32)0x00000010)

#define MAC_HW_OLBC_DSSS_COUNT_RST          0x0
#define MAC_HW_OLBC_OFDM_COUNT_RST          0x0
#define MAC_HW_OLBC_OLBC_TIMER_RST          0x0

static inline void mac_hw_olbc_pack(struct cl_chip *chip, u8 dsss_count, u8 ofdm_count, u16 olbc_timer)
{
	ASSERT_ERR_CHIP((((u32)dsss_count << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ofdm_count << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_timer << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_OLBC_ADDR, ((u32)dsss_count << 24) | ((u32)ofdm_count << 16) | ((u32)olbc_timer << 0));
}

static inline void mac_hw_olbc_unpack(struct cl_chip *chip, u8 *dsss_count, u8 *ofdm_count, u16 *olbc_timer)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_OLBC_ADDR);

	*dsss_count = (local_val & ((u32)0xFF000000)) >> 24;
	*ofdm_count = (local_val & ((u32)0x00FF0000)) >> 16;
	*olbc_timer = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_olbc_dsss_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_OLBC_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_olbc_dsss_count_setf(struct cl_chip *chip, u8 dssscount)
{
	ASSERT_ERR_CHIP((((u32)dssscount << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_OLBC_ADDR, (cl_reg_read(chip, MAC_HW_OLBC_ADDR) & ~((u32)0xFF000000)) | ((u32)dssscount << 24));
}

static inline u8 mac_hw_olbc_ofdm_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_OLBC_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_olbc_ofdm_count_setf(struct cl_chip *chip, u8 ofdmcount)
{
	ASSERT_ERR_CHIP((((u32)ofdmcount << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_OLBC_ADDR, (cl_reg_read(chip, MAC_HW_OLBC_ADDR) & ~((u32)0x00FF0000)) | ((u32)ofdmcount << 16));
}

static inline u16 mac_hw_olbc_olbc_timer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_OLBC_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_olbc_olbc_timer_setf(struct cl_chip *chip, u16 olbctimer)
{
	ASSERT_ERR_CHIP((((u32)olbctimer << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_OLBC_ADDR, (cl_reg_read(chip, MAC_HW_OLBC_ADDR) & ~((u32)0x0000FFFF)) | ((u32)olbctimer << 0));
}

/**
 * @brief TIMINGS_1 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:18 TX_CHAIN_DELAY_IN_MAC_CLK 0x230
 *    17:08 TX_RF_DELAY_IN_MAC_CLK    0xA0
 *    07:00 MAC_CORE_CLK_FREQ         0xA0
 * </pre>
 */
#define MAC_HW_TIMINGS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000E4)
#define MAC_HW_TIMINGS_1_OFFSET      0x000000E4
#define MAC_HW_TIMINGS_1_INDEX       0x00000039
#define MAC_HW_TIMINGS_1_RESET       0x08C0A0A0

static inline u32 mac_hw_timings_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR);
}

static inline void mac_hw_timings_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_1_TX_CHAIN_DELAY_IN_MAC_CLK_MASK    ((u32)0x0FFC0000)
#define MAC_HW_TIMINGS_1_TX_CHAIN_DELAY_IN_MAC_CLK_LSB    18
#define MAC_HW_TIMINGS_1_TX_CHAIN_DELAY_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_1_TX_RF_DELAY_IN_MAC_CLK_MASK    ((u32)0x0003FF00)
#define MAC_HW_TIMINGS_1_TX_RF_DELAY_IN_MAC_CLK_LSB    8
#define MAC_HW_TIMINGS_1_TX_RF_DELAY_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_1_MAC_CORE_CLK_FREQ_MASK    ((u32)0x000000FF)
#define MAC_HW_TIMINGS_1_MAC_CORE_CLK_FREQ_LSB    0
#define MAC_HW_TIMINGS_1_MAC_CORE_CLK_FREQ_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_1_TX_CHAIN_DELAY_IN_MAC_CLK_RST    0x230
#define MAC_HW_TIMINGS_1_TX_RF_DELAY_IN_MAC_CLK_RST    0xA0
#define MAC_HW_TIMINGS_1_MAC_CORE_CLK_FREQ_RST    0xA0

static inline void mac_hw_timings_1_pack(struct cl_chip *chip, u16 tx_chain_delay_in_mac_clk, u16 tx_rf_delay_in_mac_clk, u8 mac_core_clk_freq)
{
	ASSERT_ERR_CHIP((((u32)tx_chain_delay_in_mac_clk << 18) & ~((u32)0x0FFC0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_rf_delay_in_mac_clk << 8) & ~((u32)0x0003FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_core_clk_freq << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_1_ADDR, ((u32)tx_chain_delay_in_mac_clk << 18) | ((u32)tx_rf_delay_in_mac_clk << 8) | ((u32)mac_core_clk_freq << 0));
}

static inline void mac_hw_timings_1_unpack(struct cl_chip *chip, u16 *tx_chain_delay_in_mac_clk, u16 *tx_rf_delay_in_mac_clk, u8 *mac_core_clk_freq)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR);

	*tx_chain_delay_in_mac_clk = (local_val & ((u32)0x0FFC0000)) >> 18;
	*tx_rf_delay_in_mac_clk = (local_val & ((u32)0x0003FF00)) >> 8;
	*mac_core_clk_freq = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_timings_1_tx_chain_delay_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR);

	return (u16)((local_val & ((u32)0x0FFC0000)) >> 18);
}

static inline void mac_hw_timings_1_tx_chain_delay_in_mac_clk_setf(struct cl_chip *chip, u16 txchaindelayinmacclk)
{
	ASSERT_ERR_CHIP((((u32)txchaindelayinmacclk << 18) & ~((u32)0x0FFC0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_1_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR) & ~((u32)0x0FFC0000)) | ((u32)txchaindelayinmacclk << 18));
}

static inline u16 mac_hw_timings_1_tx_rf_delay_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR);

	return (u16)((local_val & ((u32)0x0003FF00)) >> 8);
}

static inline void mac_hw_timings_1_tx_rf_delay_in_mac_clk_setf(struct cl_chip *chip, u16 txrfdelayinmacclk)
{
	ASSERT_ERR_CHIP((((u32)txrfdelayinmacclk << 8) & ~((u32)0x0003FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_1_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR) & ~((u32)0x0003FF00)) | ((u32)txrfdelayinmacclk << 8));
}

static inline u8 mac_hw_timings_1_mac_core_clk_freq_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_1_mac_core_clk_freq_setf(struct cl_chip *chip, u8 maccoreclkfreq)
{
	ASSERT_ERR_CHIP((((u32)maccoreclkfreq << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_1_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_1_ADDR) & ~((u32)0x000000FF)) | ((u32)maccoreclkfreq << 0));
}

/**
 * @brief TIMINGS_2 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:08 SLOT_TIME_IN_MAC_CLK      0x5A0
 *    07:00 SLOT_TIME                 0x9
 * </pre>
 */
#define MAC_HW_TIMINGS_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000E8)
#define MAC_HW_TIMINGS_2_OFFSET      0x000000E8
#define MAC_HW_TIMINGS_2_INDEX       0x0000003A
#define MAC_HW_TIMINGS_2_RESET       0x0005A009

static inline u32 mac_hw_timings_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR);
}

static inline void mac_hw_timings_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_2_SLOT_TIME_IN_MAC_CLK_MASK    ((u32)0x00FFFF00)
#define MAC_HW_TIMINGS_2_SLOT_TIME_IN_MAC_CLK_LSB    8
#define MAC_HW_TIMINGS_2_SLOT_TIME_IN_MAC_CLK_WIDTH    ((u32)0x00000010)
#define MAC_HW_TIMINGS_2_SLOT_TIME_MASK     ((u32)0x000000FF)
#define MAC_HW_TIMINGS_2_SLOT_TIME_LSB      0
#define MAC_HW_TIMINGS_2_SLOT_TIME_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_2_SLOT_TIME_IN_MAC_CLK_RST    0x5A0
#define MAC_HW_TIMINGS_2_SLOT_TIME_RST      0x9

static inline void mac_hw_timings_2_pack(struct cl_chip *chip, u16 slot_time_in_mac_clk, u8 slot_time)
{
	ASSERT_ERR_CHIP((((u32)slot_time_in_mac_clk << 8) & ~((u32)0x00FFFF00)) == 0);
	ASSERT_ERR_CHIP((((u32)slot_time << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_2_ADDR, ((u32)slot_time_in_mac_clk << 8) | ((u32)slot_time << 0));
}

static inline void mac_hw_timings_2_unpack(struct cl_chip *chip, u16 *slot_time_in_mac_clk, u8 *slot_time)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR);

	*slot_time_in_mac_clk = (local_val & ((u32)0x00FFFF00)) >> 8;
	*slot_time = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_timings_2_slot_time_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR);

	return (u16)((local_val & ((u32)0x00FFFF00)) >> 8);
}

static inline void mac_hw_timings_2_slot_time_in_mac_clk_setf(struct cl_chip *chip, u16 slottimeinmacclk)
{
	ASSERT_ERR_CHIP((((u32)slottimeinmacclk << 8) & ~((u32)0x00FFFF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_2_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR) & ~((u32)0x00FFFF00)) | ((u32)slottimeinmacclk << 8));
}

static inline u8 mac_hw_timings_2_slot_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_2_slot_time_setf(struct cl_chip *chip, u8 slottime)
{
	ASSERT_ERR_CHIP((((u32)slottime << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_2_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_2_ADDR) & ~((u32)0x000000FF)) | ((u32)slottime << 0));
}

/**
 * @brief TIMINGS_3 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 RX_RF_DELAY_IN_MAC_CLK    0x0
 *    19:10 TX_DELAY_RF_ON_IN_MAC_CLK 0xA0
 *    09:00 MAC_PROC_DELAY_IN_MAC_CLK 0x48
 * </pre>
 */
#define MAC_HW_TIMINGS_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000EC)
#define MAC_HW_TIMINGS_3_OFFSET      0x000000EC
#define MAC_HW_TIMINGS_3_INDEX       0x0000003B
#define MAC_HW_TIMINGS_3_RESET       0x00028048

static inline u32 mac_hw_timings_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR);
}

static inline void mac_hw_timings_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_3_RX_RF_DELAY_IN_MAC_CLK_MASK    ((u32)0x3FF00000)
#define MAC_HW_TIMINGS_3_RX_RF_DELAY_IN_MAC_CLK_LSB    20
#define MAC_HW_TIMINGS_3_RX_RF_DELAY_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_3_TX_DELAY_RF_ON_IN_MAC_CLK_MASK    ((u32)0x000FFC00)
#define MAC_HW_TIMINGS_3_TX_DELAY_RF_ON_IN_MAC_CLK_LSB    10
#define MAC_HW_TIMINGS_3_TX_DELAY_RF_ON_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_3_MAC_PROC_DELAY_IN_MAC_CLK_MASK    ((u32)0x000003FF)
#define MAC_HW_TIMINGS_3_MAC_PROC_DELAY_IN_MAC_CLK_LSB    0
#define MAC_HW_TIMINGS_3_MAC_PROC_DELAY_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)

#define MAC_HW_TIMINGS_3_RX_RF_DELAY_IN_MAC_CLK_RST    0x0
#define MAC_HW_TIMINGS_3_TX_DELAY_RF_ON_IN_MAC_CLK_RST    0xA0
#define MAC_HW_TIMINGS_3_MAC_PROC_DELAY_IN_MAC_CLK_RST    0x48

static inline void mac_hw_timings_3_pack(struct cl_chip *chip, u16 rx_rf_delay_in_mac_clk, u16 tx_delay_rf_on_in_mac_clk, u16 mac_proc_delay_in_mac_clk)
{
	ASSERT_ERR_CHIP((((u32)rx_rf_delay_in_mac_clk << 20) & ~((u32)0x3FF00000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_delay_rf_on_in_mac_clk << 10) & ~((u32)0x000FFC00)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_proc_delay_in_mac_clk << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_3_ADDR, ((u32)rx_rf_delay_in_mac_clk << 20) | ((u32)tx_delay_rf_on_in_mac_clk << 10) | ((u32)mac_proc_delay_in_mac_clk << 0));
}

static inline void mac_hw_timings_3_unpack(struct cl_chip *chip, u16 *rx_rf_delay_in_mac_clk, u16 *tx_delay_rf_on_in_mac_clk, u16 *mac_proc_delay_in_mac_clk)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR);

	*rx_rf_delay_in_mac_clk = (local_val & ((u32)0x3FF00000)) >> 20;
	*tx_delay_rf_on_in_mac_clk = (local_val & ((u32)0x000FFC00)) >> 10;
	*mac_proc_delay_in_mac_clk = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_timings_3_rx_rf_delay_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline void mac_hw_timings_3_rx_rf_delay_in_mac_clk_setf(struct cl_chip *chip, u16 rxrfdelayinmacclk)
{
	ASSERT_ERR_CHIP((((u32)rxrfdelayinmacclk << 20) & ~((u32)0x3FF00000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_3_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR) & ~((u32)0x3FF00000)) | ((u32)rxrfdelayinmacclk << 20));
}

static inline u16 mac_hw_timings_3_tx_delay_rf_on_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline void mac_hw_timings_3_tx_delay_rf_on_in_mac_clk_setf(struct cl_chip *chip, u16 txdelayrfoninmacclk)
{
	ASSERT_ERR_CHIP((((u32)txdelayrfoninmacclk << 10) & ~((u32)0x000FFC00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_3_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR) & ~((u32)0x000FFC00)) | ((u32)txdelayrfoninmacclk << 10));
}

static inline u16 mac_hw_timings_3_mac_proc_delay_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_timings_3_mac_proc_delay_in_mac_clk_setf(struct cl_chip *chip, u16 macprocdelayinmacclk)
{
	ASSERT_ERR_CHIP((((u32)macprocdelayinmacclk << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_3_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_3_ADDR) & ~((u32)0x000003FF)) | ((u32)macprocdelayinmacclk << 0));
}

/**
 * @brief TIMINGS_4 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:22 RADIO_WAKE_UP_TIME        0x15
 *    21:12 RADIO_CHIRP_TIME          0x14
 * </pre>
 */
#define MAC_HW_TIMINGS_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000F0)
#define MAC_HW_TIMINGS_4_OFFSET      0x000000F0
#define MAC_HW_TIMINGS_4_INDEX       0x0000003C
#define MAC_HW_TIMINGS_4_RESET       0x05414000

static inline u32 mac_hw_timings_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR);
}

static inline void mac_hw_timings_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_4_RADIO_WAKE_UP_TIME_MASK    ((u32)0xFFC00000)
#define MAC_HW_TIMINGS_4_RADIO_WAKE_UP_TIME_LSB    22
#define MAC_HW_TIMINGS_4_RADIO_WAKE_UP_TIME_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_4_RADIO_CHIRP_TIME_MASK    ((u32)0x003FF000)
#define MAC_HW_TIMINGS_4_RADIO_CHIRP_TIME_LSB    12
#define MAC_HW_TIMINGS_4_RADIO_CHIRP_TIME_WIDTH    ((u32)0x0000000A)

#define MAC_HW_TIMINGS_4_RADIO_WAKE_UP_TIME_RST    0x15
#define MAC_HW_TIMINGS_4_RADIO_CHIRP_TIME_RST    0x14

static inline void mac_hw_timings_4_pack(struct cl_chip *chip, u16 radio_wake_up_time, u16 radio_chirp_time)
{
	ASSERT_ERR_CHIP((((u32)radio_wake_up_time << 22) & ~((u32)0xFFC00000)) == 0);
	ASSERT_ERR_CHIP((((u32)radio_chirp_time << 12) & ~((u32)0x003FF000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_4_ADDR, ((u32)radio_wake_up_time << 22) | ((u32)radio_chirp_time << 12));
}

static inline void mac_hw_timings_4_unpack(struct cl_chip *chip, u16 *radio_wake_up_time, u16 *radio_chirp_time)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR);

	*radio_wake_up_time = (local_val & ((u32)0xFFC00000)) >> 22;
	*radio_chirp_time = (local_val & ((u32)0x003FF000)) >> 12;
}

static inline u16 mac_hw_timings_4_radio_wake_up_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR);

	return (u16)((local_val & ((u32)0xFFC00000)) >> 22);
}

static inline void mac_hw_timings_4_radio_wake_up_time_setf(struct cl_chip *chip, u16 radiowakeuptime)
{
	ASSERT_ERR_CHIP((((u32)radiowakeuptime << 22) & ~((u32)0xFFC00000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_4_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR) & ~((u32)0xFFC00000)) | ((u32)radiowakeuptime << 22));
}

static inline u16 mac_hw_timings_4_radio_chirp_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR);

	return (u16)((local_val & ((u32)0x003FF000)) >> 12);
}

static inline void mac_hw_timings_4_radio_chirp_time_setf(struct cl_chip *chip, u16 radiochirptime)
{
	ASSERT_ERR_CHIP((((u32)radiochirptime << 12) & ~((u32)0x003FF000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_4_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_4_ADDR) & ~((u32)0x003FF000)) | ((u32)radiochirptime << 12));
}

/**
 * @brief TIMINGS_5 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:08 SIFS_B_IN_MAC_CLK         0x640
 *    07:00 SIFS_B                    0xA
 * </pre>
 */
#define MAC_HW_TIMINGS_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000F4)
#define MAC_HW_TIMINGS_5_OFFSET      0x000000F4
#define MAC_HW_TIMINGS_5_INDEX       0x0000003D
#define MAC_HW_TIMINGS_5_RESET       0x0006400A

static inline u32 mac_hw_timings_5_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR);
}

static inline void mac_hw_timings_5_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_5_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_5_SIFS_B_IN_MAC_CLK_MASK    ((u32)0x00FFFF00)
#define MAC_HW_TIMINGS_5_SIFS_B_IN_MAC_CLK_LSB    8
#define MAC_HW_TIMINGS_5_SIFS_B_IN_MAC_CLK_WIDTH    ((u32)0x00000010)
#define MAC_HW_TIMINGS_5_SIFS_B_MASK        ((u32)0x000000FF)
#define MAC_HW_TIMINGS_5_SIFS_B_LSB         0
#define MAC_HW_TIMINGS_5_SIFS_B_WIDTH       ((u32)0x00000008)

#define MAC_HW_TIMINGS_5_SIFS_B_IN_MAC_CLK_RST    0x640
#define MAC_HW_TIMINGS_5_SIFS_B_RST         0xA

static inline void mac_hw_timings_5_pack(struct cl_chip *chip, u16 sifs_b_in_mac_clk, u8 sifs_b)
{
	ASSERT_ERR_CHIP((((u32)sifs_b_in_mac_clk << 8) & ~((u32)0x00FFFF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sifs_b << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_5_ADDR, ((u32)sifs_b_in_mac_clk << 8) | ((u32)sifs_b << 0));
}

static inline void mac_hw_timings_5_unpack(struct cl_chip *chip, u16 *sifs_b_in_mac_clk, u8 *sifs_b)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR);

	*sifs_b_in_mac_clk = (local_val & ((u32)0x00FFFF00)) >> 8;
	*sifs_b = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_timings_5_sifs_b_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR);

	return (u16)((local_val & ((u32)0x00FFFF00)) >> 8);
}

static inline void mac_hw_timings_5_sifs_b_in_mac_clk_setf(struct cl_chip *chip, u16 sifsbinmacclk)
{
	ASSERT_ERR_CHIP((((u32)sifsbinmacclk << 8) & ~((u32)0x00FFFF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_5_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR) & ~((u32)0x00FFFF00)) | ((u32)sifsbinmacclk << 8));
}

static inline u8 mac_hw_timings_5_sifs_b_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_5_sifs_b_setf(struct cl_chip *chip, u8 sifsb)
{
	ASSERT_ERR_CHIP((((u32)sifsb << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_5_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_5_ADDR) & ~((u32)0x000000FF)) | ((u32)sifsb << 0));
}

/**
 * @brief TIMINGS_6 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:24 SEC_CCA_DELAY_IN_MAC_CLK  0x40
 *    23:08 SIFS_A_IN_MAC_CLK         0xA00
 *    07:00 SIFS_A                    0x10
 * </pre>
 */
#define MAC_HW_TIMINGS_6_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000F8)
#define MAC_HW_TIMINGS_6_OFFSET      0x000000F8
#define MAC_HW_TIMINGS_6_INDEX       0x0000003E
#define MAC_HW_TIMINGS_6_RESET       0x400A0010

static inline u32 mac_hw_timings_6_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR);
}

static inline void mac_hw_timings_6_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_6_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_6_SEC_CCA_DELAY_IN_MAC_CLK_MASK    ((u32)0x7F000000)
#define MAC_HW_TIMINGS_6_SEC_CCA_DELAY_IN_MAC_CLK_LSB    24
#define MAC_HW_TIMINGS_6_SEC_CCA_DELAY_IN_MAC_CLK_WIDTH    ((u32)0x00000007)
#define MAC_HW_TIMINGS_6_SIFS_A_IN_MAC_CLK_MASK    ((u32)0x00FFFF00)
#define MAC_HW_TIMINGS_6_SIFS_A_IN_MAC_CLK_LSB    8
#define MAC_HW_TIMINGS_6_SIFS_A_IN_MAC_CLK_WIDTH    ((u32)0x00000010)
#define MAC_HW_TIMINGS_6_SIFS_A_MASK        ((u32)0x000000FF)
#define MAC_HW_TIMINGS_6_SIFS_A_LSB         0
#define MAC_HW_TIMINGS_6_SIFS_A_WIDTH       ((u32)0x00000008)

#define MAC_HW_TIMINGS_6_SEC_CCA_DELAY_IN_MAC_CLK_RST    0x40
#define MAC_HW_TIMINGS_6_SIFS_A_IN_MAC_CLK_RST    0xA00
#define MAC_HW_TIMINGS_6_SIFS_A_RST         0x10

static inline void mac_hw_timings_6_pack(struct cl_chip *chip, u8 sec_cca_delay_in_mac_clk, u16 sifs_a_in_mac_clk, u8 sifs_a)
{
	ASSERT_ERR_CHIP((((u32)sec_cca_delay_in_mac_clk << 24) & ~((u32)0x7F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sifs_a_in_mac_clk << 8) & ~((u32)0x00FFFF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sifs_a << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_6_ADDR, ((u32)sec_cca_delay_in_mac_clk << 24) | ((u32)sifs_a_in_mac_clk << 8) | ((u32)sifs_a << 0));
}

static inline void mac_hw_timings_6_unpack(struct cl_chip *chip, u8 *sec_cca_delay_in_mac_clk, u16 *sifs_a_in_mac_clk, u8 *sifs_a)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR);

	*sec_cca_delay_in_mac_clk = (local_val & ((u32)0x7F000000)) >> 24;
	*sifs_a_in_mac_clk = (local_val & ((u32)0x00FFFF00)) >> 8;
	*sifs_a = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_6_sec_cca_delay_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR);

	return (u8)((local_val & ((u32)0x7F000000)) >> 24);
}

static inline void mac_hw_timings_6_sec_cca_delay_in_mac_clk_setf(struct cl_chip *chip, u8 secccadelayinmacclk)
{
	ASSERT_ERR_CHIP((((u32)secccadelayinmacclk << 24) & ~((u32)0x7F000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_6_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR) & ~((u32)0x7F000000)) | ((u32)secccadelayinmacclk << 24));
}

static inline u16 mac_hw_timings_6_sifs_a_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR);

	return (u16)((local_val & ((u32)0x00FFFF00)) >> 8);
}

static inline void mac_hw_timings_6_sifs_a_in_mac_clk_setf(struct cl_chip *chip, u16 sifsainmacclk)
{
	ASSERT_ERR_CHIP((((u32)sifsainmacclk << 8) & ~((u32)0x00FFFF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_6_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR) & ~((u32)0x00FFFF00)) | ((u32)sifsainmacclk << 8));
}

static inline u8 mac_hw_timings_6_sifs_a_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_6_sifs_a_setf(struct cl_chip *chip, u8 sifsa)
{
	ASSERT_ERR_CHIP((((u32)sifsa << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_6_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_6_ADDR) & ~((u32)0x000000FF)) | ((u32)sifsa << 0));
}

/**
 * @brief TIMINGS_7 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    28:24 HTP_FLAG_DELAY            0x1
 *    23:16 NDPA_TO_NDP_RX_START_DELAY 0x39
 *    14:12 RX_CCA_20_DELAY           0x1
 *    11:08 RX_CCA_DELAY              0x4
 *    07:00 RIFS                      0x2
 * </pre>
 */
#define MAC_HW_TIMINGS_7_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000000FC)
#define MAC_HW_TIMINGS_7_OFFSET      0x000000FC
#define MAC_HW_TIMINGS_7_INDEX       0x0000003F
#define MAC_HW_TIMINGS_7_RESET       0x01391402

static inline u32 mac_hw_timings_7_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);
}

static inline void mac_hw_timings_7_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_7_HTP_FLAG_DELAY_MASK    ((u32)0x1F000000)
#define MAC_HW_TIMINGS_7_HTP_FLAG_DELAY_LSB    24
#define MAC_HW_TIMINGS_7_HTP_FLAG_DELAY_WIDTH    ((u32)0x00000005)
#define MAC_HW_TIMINGS_7_NDPA_TO_NDP_RX_START_DELAY_MASK    ((u32)0x00FF0000)
#define MAC_HW_TIMINGS_7_NDPA_TO_NDP_RX_START_DELAY_LSB    16
#define MAC_HW_TIMINGS_7_NDPA_TO_NDP_RX_START_DELAY_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_7_RX_CCA_20_DELAY_MASK    ((u32)0x00007000)
#define MAC_HW_TIMINGS_7_RX_CCA_20_DELAY_LSB    12
#define MAC_HW_TIMINGS_7_RX_CCA_20_DELAY_WIDTH    ((u32)0x00000003)
#define MAC_HW_TIMINGS_7_RX_CCA_DELAY_MASK    ((u32)0x00000F00)
#define MAC_HW_TIMINGS_7_RX_CCA_DELAY_LSB    8
#define MAC_HW_TIMINGS_7_RX_CCA_DELAY_WIDTH    ((u32)0x00000004)
#define MAC_HW_TIMINGS_7_RIFS_MASK          ((u32)0x000000FF)
#define MAC_HW_TIMINGS_7_RIFS_LSB           0
#define MAC_HW_TIMINGS_7_RIFS_WIDTH         ((u32)0x00000008)

#define MAC_HW_TIMINGS_7_HTP_FLAG_DELAY_RST    0x1
#define MAC_HW_TIMINGS_7_NDPA_TO_NDP_RX_START_DELAY_RST    0x39
#define MAC_HW_TIMINGS_7_RX_CCA_20_DELAY_RST    0x1
#define MAC_HW_TIMINGS_7_RX_CCA_DELAY_RST    0x4
#define MAC_HW_TIMINGS_7_RIFS_RST           0x2

static inline void mac_hw_timings_7_pack(struct cl_chip *chip, u8 htp_flag_delay, u8 ndpa_to_ndp_rx_start_delay, u8 rx_cca_20_delay, u8 rx_cca_delay, u8 rifs)
{
	ASSERT_ERR_CHIP((((u32)htp_flag_delay << 24) & ~((u32)0x1F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ndpa_to_ndp_rx_start_delay << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_cca_20_delay << 12) & ~((u32)0x00007000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_cca_delay << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)rifs << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, ((u32)htp_flag_delay << 24) | ((u32)ndpa_to_ndp_rx_start_delay << 16) | ((u32)rx_cca_20_delay << 12) | ((u32)rx_cca_delay << 8) | ((u32)rifs << 0));
}

static inline void mac_hw_timings_7_unpack(struct cl_chip *chip, u8 *htp_flag_delay, u8 *ndpa_to_ndp_rx_start_delay, u8 *rx_cca_20_delay, u8 *rx_cca_delay, u8 *rifs)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	*htp_flag_delay = (local_val & ((u32)0x1F000000)) >> 24;
	*ndpa_to_ndp_rx_start_delay = (local_val & ((u32)0x00FF0000)) >> 16;
	*rx_cca_20_delay = (local_val & ((u32)0x00007000)) >> 12;
	*rx_cca_delay = (local_val & ((u32)0x00000F00)) >> 8;
	*rifs = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_7_htp_flag_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	return (u8)((local_val & ((u32)0x1F000000)) >> 24);
}

static inline void mac_hw_timings_7_htp_flag_delay_setf(struct cl_chip *chip, u8 htpflagdelay)
{
	ASSERT_ERR_CHIP((((u32)htpflagdelay << 24) & ~((u32)0x1F000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR) & ~((u32)0x1F000000)) | ((u32)htpflagdelay << 24));
}

static inline u8 mac_hw_timings_7_ndpa_to_ndp_rx_start_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_timings_7_ndpa_to_ndp_rx_start_delay_setf(struct cl_chip *chip, u8 ndpatondprxstartdelay)
{
	ASSERT_ERR_CHIP((((u32)ndpatondprxstartdelay << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR) & ~((u32)0x00FF0000)) | ((u32)ndpatondprxstartdelay << 16));
}

static inline u8 mac_hw_timings_7_rx_cca_20_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	return (u8)((local_val & ((u32)0x00007000)) >> 12);
}

static inline void mac_hw_timings_7_rx_cca_20_delay_setf(struct cl_chip *chip, u8 rxcca20delay)
{
	ASSERT_ERR_CHIP((((u32)rxcca20delay << 12) & ~((u32)0x00007000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR) & ~((u32)0x00007000)) | ((u32)rxcca20delay << 12));
}

static inline u8 mac_hw_timings_7_rx_cca_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_timings_7_rx_cca_delay_setf(struct cl_chip *chip, u8 rxccadelay)
{
	ASSERT_ERR_CHIP((((u32)rxccadelay << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR) & ~((u32)0x00000F00)) | ((u32)rxccadelay << 8));
}

static inline u8 mac_hw_timings_7_rifs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_7_rifs_setf(struct cl_chip *chip, u8 rifs)
{
	ASSERT_ERR_CHIP((((u32)rifs << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_7_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_7_ADDR) & ~((u32)0x000000FF)) | ((u32)rifs << 0));
}

/**
 * @brief TIMINGS_8 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RX_START_DELAY_MIMO       0x21
 *    23:16 RX_START_DELAY_SHORT      0x60
 *    15:08 RX_START_DELAY_LONG       0xD2
 *    07:00 RX_START_DELAY_OFDM       0x21
 * </pre>
 */
#define MAC_HW_TIMINGS_8_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000100)
#define MAC_HW_TIMINGS_8_OFFSET      0x00000100
#define MAC_HW_TIMINGS_8_INDEX       0x00000040
#define MAC_HW_TIMINGS_8_RESET       0x2160D221

static inline u32 mac_hw_timings_8_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);
}

static inline void mac_hw_timings_8_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_8_RX_START_DELAY_MIMO_MASK    ((u32)0xFF000000)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_MIMO_LSB    24
#define MAC_HW_TIMINGS_8_RX_START_DELAY_MIMO_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_SHORT_MASK    ((u32)0x00FF0000)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_SHORT_LSB    16
#define MAC_HW_TIMINGS_8_RX_START_DELAY_SHORT_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_LONG_MASK    ((u32)0x0000FF00)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_LONG_LSB    8
#define MAC_HW_TIMINGS_8_RX_START_DELAY_LONG_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_OFDM_MASK    ((u32)0x000000FF)
#define MAC_HW_TIMINGS_8_RX_START_DELAY_OFDM_LSB    0
#define MAC_HW_TIMINGS_8_RX_START_DELAY_OFDM_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_8_RX_START_DELAY_MIMO_RST    0x21
#define MAC_HW_TIMINGS_8_RX_START_DELAY_SHORT_RST    0x60
#define MAC_HW_TIMINGS_8_RX_START_DELAY_LONG_RST    0xD2
#define MAC_HW_TIMINGS_8_RX_START_DELAY_OFDM_RST    0x21

static inline void mac_hw_timings_8_pack(struct cl_chip *chip, u8 rx_start_delay_mimo, u8 rx_start_delay_short, u8 rx_start_delay_long, u8 rx_start_delay_ofdm)
{
	ASSERT_ERR_CHIP((((u32)rx_start_delay_mimo << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_start_delay_short << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_start_delay_long << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_start_delay_ofdm << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, ((u32)rx_start_delay_mimo << 24) | ((u32)rx_start_delay_short << 16) | ((u32)rx_start_delay_long << 8) | ((u32)rx_start_delay_ofdm << 0));
}

static inline void mac_hw_timings_8_unpack(struct cl_chip *chip, u8 *rx_start_delay_mimo, u8 *rx_start_delay_short, u8 *rx_start_delay_long, u8 *rx_start_delay_ofdm)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);

	*rx_start_delay_mimo = (local_val & ((u32)0xFF000000)) >> 24;
	*rx_start_delay_short = (local_val & ((u32)0x00FF0000)) >> 16;
	*rx_start_delay_long = (local_val & ((u32)0x0000FF00)) >> 8;
	*rx_start_delay_ofdm = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_8_rx_start_delay_mimo_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_timings_8_rx_start_delay_mimo_setf(struct cl_chip *chip, u8 rxstartdelaymimo)
{
	ASSERT_ERR_CHIP((((u32)rxstartdelaymimo << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR) & ~((u32)0xFF000000)) | ((u32)rxstartdelaymimo << 24));
}

static inline u8 mac_hw_timings_8_rx_start_delay_short_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_timings_8_rx_start_delay_short_setf(struct cl_chip *chip, u8 rxstartdelayshort)
{
	ASSERT_ERR_CHIP((((u32)rxstartdelayshort << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR) & ~((u32)0x00FF0000)) | ((u32)rxstartdelayshort << 16));
}

static inline u8 mac_hw_timings_8_rx_start_delay_long_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_timings_8_rx_start_delay_long_setf(struct cl_chip *chip, u8 rxstartdelaylong)
{
	ASSERT_ERR_CHIP((((u32)rxstartdelaylong << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR) & ~((u32)0x0000FF00)) | ((u32)rxstartdelaylong << 8));
}

static inline u8 mac_hw_timings_8_rx_start_delay_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_8_rx_start_delay_ofdm_setf(struct cl_chip *chip, u8 rxstartdelayofdm)
{
	ASSERT_ERR_CHIP((((u32)rxstartdelayofdm << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_8_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_8_ADDR) & ~((u32)0x000000FF)) | ((u32)rxstartdelayofdm << 0));
}

/**
 * @brief TIMINGS_9 register definition
 *  Contains protocol timing information. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:20 RIFS_TO_IN_MAC_CLK        0x320
 *    19:10 RIFS_IN_MAC_CLK           0x140
 *    09:00 TX_DMA_PROC_DLY_IN_MAC_CLK 0xF0
 * </pre>
 */
#define MAC_HW_TIMINGS_9_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000104)
#define MAC_HW_TIMINGS_9_OFFSET      0x00000104
#define MAC_HW_TIMINGS_9_INDEX       0x00000041
#define MAC_HW_TIMINGS_9_RESET       0x320500F0

static inline u32 mac_hw_timings_9_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR);
}

static inline void mac_hw_timings_9_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_9_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_9_RIFS_TO_IN_MAC_CLK_MASK    ((u32)0xFFF00000)
#define MAC_HW_TIMINGS_9_RIFS_TO_IN_MAC_CLK_LSB    20
#define MAC_HW_TIMINGS_9_RIFS_TO_IN_MAC_CLK_WIDTH    ((u32)0x0000000C)
#define MAC_HW_TIMINGS_9_RIFS_IN_MAC_CLK_MASK    ((u32)0x000FFC00)
#define MAC_HW_TIMINGS_9_RIFS_IN_MAC_CLK_LSB    10
#define MAC_HW_TIMINGS_9_RIFS_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_9_TX_DMA_PROC_DLY_IN_MAC_CLK_MASK    ((u32)0x000003FF)
#define MAC_HW_TIMINGS_9_TX_DMA_PROC_DLY_IN_MAC_CLK_LSB    0
#define MAC_HW_TIMINGS_9_TX_DMA_PROC_DLY_IN_MAC_CLK_WIDTH    ((u32)0x0000000A)

#define MAC_HW_TIMINGS_9_RIFS_TO_IN_MAC_CLK_RST    0x320
#define MAC_HW_TIMINGS_9_RIFS_IN_MAC_CLK_RST    0x140
#define MAC_HW_TIMINGS_9_TX_DMA_PROC_DLY_IN_MAC_CLK_RST    0xF0

static inline void mac_hw_timings_9_pack(struct cl_chip *chip, u16 rifs_to_in_mac_clk, u16 rifs_in_mac_clk, u16 tx_dma_proc_dly_in_mac_clk)
{
	ASSERT_ERR_CHIP((((u32)rifs_to_in_mac_clk << 20) & ~((u32)0xFFF00000)) == 0);
	ASSERT_ERR_CHIP((((u32)rifs_in_mac_clk << 10) & ~((u32)0x000FFC00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_dma_proc_dly_in_mac_clk << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_9_ADDR, ((u32)rifs_to_in_mac_clk << 20) | ((u32)rifs_in_mac_clk << 10) | ((u32)tx_dma_proc_dly_in_mac_clk << 0));
}

static inline void mac_hw_timings_9_unpack(struct cl_chip *chip, u16 *rifs_to_in_mac_clk, u16 *rifs_in_mac_clk, u16 *tx_dma_proc_dly_in_mac_clk)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR);

	*rifs_to_in_mac_clk = (local_val & ((u32)0xFFF00000)) >> 20;
	*rifs_in_mac_clk = (local_val & ((u32)0x000FFC00)) >> 10;
	*tx_dma_proc_dly_in_mac_clk = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_timings_9_rifs_to_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR);

	return (u16)((local_val & ((u32)0xFFF00000)) >> 20);
}

static inline void mac_hw_timings_9_rifs_to_in_mac_clk_setf(struct cl_chip *chip, u16 rifstoinmacclk)
{
	ASSERT_ERR_CHIP((((u32)rifstoinmacclk << 20) & ~((u32)0xFFF00000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_9_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR) & ~((u32)0xFFF00000)) | ((u32)rifstoinmacclk << 20));
}

static inline u16 mac_hw_timings_9_rifs_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline void mac_hw_timings_9_rifs_in_mac_clk_setf(struct cl_chip *chip, u16 rifsinmacclk)
{
	ASSERT_ERR_CHIP((((u32)rifsinmacclk << 10) & ~((u32)0x000FFC00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_9_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR) & ~((u32)0x000FFC00)) | ((u32)rifsinmacclk << 10));
}

static inline u16 mac_hw_timings_9_tx_dma_proc_dly_in_mac_clk_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_timings_9_tx_dma_proc_dly_in_mac_clk_setf(struct cl_chip *chip, u16 txdmaprocdlyinmacclk)
{
	ASSERT_ERR_CHIP((((u32)txdmaprocdlyinmacclk << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_9_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_9_ADDR) & ~((u32)0x000003FF)) | ((u32)txdmaprocdlyinmacclk << 0));
}

/**
 * @brief TIMINGS_10 register definition
 *  Controls timing and delay parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 CCA_MASK_TIME_IN_MAC_CLOCKS 0x0
 *    03:00 SECOND_ATHD_READ_DELAY    0x4
 * </pre>
 */
#define MAC_HW_TIMINGS_10_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000108)
#define MAC_HW_TIMINGS_10_OFFSET      0x00000108
#define MAC_HW_TIMINGS_10_INDEX       0x00000042
#define MAC_HW_TIMINGS_10_RESET       0x00000004

static inline u32 mac_hw_timings_10_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR);
}

static inline void mac_hw_timings_10_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_10_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_10_CCA_MASK_TIME_IN_MAC_CLOCKS_MASK    ((u32)0xFFFF0000)
#define MAC_HW_TIMINGS_10_CCA_MASK_TIME_IN_MAC_CLOCKS_LSB    16
#define MAC_HW_TIMINGS_10_CCA_MASK_TIME_IN_MAC_CLOCKS_WIDTH    ((u32)0x00000010)
#define MAC_HW_TIMINGS_10_SECOND_ATHD_READ_DELAY_MASK    ((u32)0x0000000F)
#define MAC_HW_TIMINGS_10_SECOND_ATHD_READ_DELAY_LSB    0
#define MAC_HW_TIMINGS_10_SECOND_ATHD_READ_DELAY_WIDTH    ((u32)0x00000004)

#define MAC_HW_TIMINGS_10_CCA_MASK_TIME_IN_MAC_CLOCKS_RST    0x0
#define MAC_HW_TIMINGS_10_SECOND_ATHD_READ_DELAY_RST    0x4

static inline void mac_hw_timings_10_pack(struct cl_chip *chip, u16 cca_mask_time_in_mac_clocks, u8 second_athd_read_delay)
{
	ASSERT_ERR_CHIP((((u32)cca_mask_time_in_mac_clocks << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)second_athd_read_delay << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_10_ADDR, ((u32)cca_mask_time_in_mac_clocks << 16) | ((u32)second_athd_read_delay << 0));
}

static inline void mac_hw_timings_10_unpack(struct cl_chip *chip, u16 *cca_mask_time_in_mac_clocks, u8 *second_athd_read_delay)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR);

	*cca_mask_time_in_mac_clocks = (local_val & ((u32)0xFFFF0000)) >> 16;
	*second_athd_read_delay = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u16 mac_hw_timings_10_cca_mask_time_in_mac_clocks_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_timings_10_cca_mask_time_in_mac_clocks_setf(struct cl_chip *chip, u16 ccamasktimeinmacclocks)
{
	ASSERT_ERR_CHIP((((u32)ccamasktimeinmacclocks << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_10_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR) & ~((u32)0xFFFF0000)) | ((u32)ccamasktimeinmacclocks << 16));
}

static inline u8 mac_hw_timings_10_second_athd_read_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_timings_10_second_athd_read_delay_setf(struct cl_chip *chip, u8 secondathdreaddelay)
{
	ASSERT_ERR_CHIP((((u32)secondathdreaddelay << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_10_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_10_ADDR) & ~((u32)0x0000000F)) | ((u32)secondathdreaddelay << 0));
}

/**
 * @brief PROT_TRIG_TIMER register definition
 *  Contains timers for early protocol triggers. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 HCCA_TRIGGER_TIMER        0x0
 *    07:00 EDCA_TRIGGER_TIMER        0x9
 * </pre>
 */
#define MAC_HW_PROT_TRIG_TIMER_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000010C)
#define MAC_HW_PROT_TRIG_TIMER_OFFSET      0x0000010C
#define MAC_HW_PROT_TRIG_TIMER_INDEX       0x00000043
#define MAC_HW_PROT_TRIG_TIMER_RESET       0x00000009

static inline u32 mac_hw_prot_trig_timer_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_PROT_TRIG_TIMER_ADDR);
}

static inline void mac_hw_prot_trig_timer_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PROT_TRIG_TIMER_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PROT_TRIG_TIMER_HCCA_TRIGGER_TIMER_MASK    ((u32)0x0000FF00)
#define MAC_HW_PROT_TRIG_TIMER_HCCA_TRIGGER_TIMER_LSB    8
#define MAC_HW_PROT_TRIG_TIMER_HCCA_TRIGGER_TIMER_WIDTH    ((u32)0x00000008)
#define MAC_HW_PROT_TRIG_TIMER_EDCA_TRIGGER_TIMER_MASK    ((u32)0x000000FF)
#define MAC_HW_PROT_TRIG_TIMER_EDCA_TRIGGER_TIMER_LSB    0
#define MAC_HW_PROT_TRIG_TIMER_EDCA_TRIGGER_TIMER_WIDTH    ((u32)0x00000008)

#define MAC_HW_PROT_TRIG_TIMER_HCCA_TRIGGER_TIMER_RST    0x0
#define MAC_HW_PROT_TRIG_TIMER_EDCA_TRIGGER_TIMER_RST    0x9

static inline void mac_hw_prot_trig_timer_pack(struct cl_chip *chip, u8 hcca_trigger_timer, u8 edca_trigger_timer)
{
	ASSERT_ERR_CHIP((((u32)hcca_trigger_timer << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)edca_trigger_timer << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_PROT_TRIG_TIMER_ADDR, ((u32)hcca_trigger_timer << 8) | ((u32)edca_trigger_timer << 0));
}

static inline void mac_hw_prot_trig_timer_unpack(struct cl_chip *chip, u8 *hcca_trigger_timer, u8 *edca_trigger_timer)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PROT_TRIG_TIMER_ADDR);

	*hcca_trigger_timer = (local_val & ((u32)0x0000FF00)) >> 8;
	*edca_trigger_timer = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_prot_trig_timer_hcca_trigger_timer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PROT_TRIG_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_prot_trig_timer_edca_trigger_timer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PROT_TRIG_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_prot_trig_timer_edca_trigger_timer_setf(struct cl_chip *chip, u8 edcatriggertimer)
{
	ASSERT_ERR_CHIP((((u32)edcatriggertimer << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_PROT_TRIG_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_PROT_TRIG_TIMER_ADDR) & ~((u32)0x000000FF)) | ((u32)edcatriggertimer << 0));
}

/**
 * @brief TX_TRIGGER_TIMER register definition
 *  Contains timers for transmit interrupt moderation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 TX_PACKET_TIMEOUT         0xF
 *    07:00 TX_ABSOLUTE_TIMEOUT       0x9C
 * </pre>
 */
#define MAC_HW_TX_TRIGGER_TIMER_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000110)
#define MAC_HW_TX_TRIGGER_TIMER_OFFSET      0x00000110
#define MAC_HW_TX_TRIGGER_TIMER_INDEX       0x00000044
#define MAC_HW_TX_TRIGGER_TIMER_RESET       0x00000F9C

static inline u32 mac_hw_tx_trigger_timer_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR);
}

static inline void mac_hw_tx_trigger_timer_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_TRIGGER_TIMER_TX_PACKET_TIMEOUT_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_TRIGGER_TIMER_TX_PACKET_TIMEOUT_LSB    8
#define MAC_HW_TX_TRIGGER_TIMER_TX_PACKET_TIMEOUT_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_TRIGGER_TIMER_TX_ABSOLUTE_TIMEOUT_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_TRIGGER_TIMER_TX_ABSOLUTE_TIMEOUT_LSB    0
#define MAC_HW_TX_TRIGGER_TIMER_TX_ABSOLUTE_TIMEOUT_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_TRIGGER_TIMER_TX_PACKET_TIMEOUT_RST    0xF
#define MAC_HW_TX_TRIGGER_TIMER_TX_ABSOLUTE_TIMEOUT_RST    0x9C

static inline void mac_hw_tx_trigger_timer_pack(struct cl_chip *chip, u8 tx_packet_timeout, u8 tx_absolute_timeout)
{
	ASSERT_ERR_CHIP((((u32)tx_packet_timeout << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_absolute_timeout << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR, ((u32)tx_packet_timeout << 8) | ((u32)tx_absolute_timeout << 0));
}

static inline void mac_hw_tx_trigger_timer_unpack(struct cl_chip *chip, u8 *tx_packet_timeout, u8 *tx_absolute_timeout)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR);

	*tx_packet_timeout = (local_val & ((u32)0x0000FF00)) >> 8;
	*tx_absolute_timeout = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_trigger_timer_tx_packet_timeout_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_trigger_timer_tx_packet_timeout_setf(struct cl_chip *chip, u8 txpackettimeout)
{
	ASSERT_ERR_CHIP((((u32)txpackettimeout << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR) & ~((u32)0x0000FF00)) | ((u32)txpackettimeout << 8));
}

static inline u8 mac_hw_tx_trigger_timer_tx_absolute_timeout_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_trigger_timer_tx_absolute_timeout_setf(struct cl_chip *chip, u8 txabsolutetimeout)
{
	ASSERT_ERR_CHIP((((u32)txabsolutetimeout << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_TX_TRIGGER_TIMER_ADDR) & ~((u32)0x000000FF)) | ((u32)txabsolutetimeout << 0));
}

/**
 * @brief RX_TRIGGER_TIMER register definition
 *  Contains timers for receive interrupt moderation. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:16 RX_PAYLOAD_USED_COUNT     0xF
 *    15:08 RX_PACKET_TIMEOUT         0xF
 *    07:00 RX_ABSOLUTE_TIMEOUT       0x9C
 * </pre>
 */
#define MAC_HW_RX_TRIGGER_TIMER_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000114)
#define MAC_HW_RX_TRIGGER_TIMER_OFFSET      0x00000114
#define MAC_HW_RX_TRIGGER_TIMER_INDEX       0x00000045
#define MAC_HW_RX_TRIGGER_TIMER_RESET       0x000F0F9C

static inline u32 mac_hw_rx_trigger_timer_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR);
}

static inline void mac_hw_rx_trigger_timer_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_TRIGGER_TIMER_RX_PAYLOAD_USED_COUNT_MASK    ((u32)0x00FF0000)
#define MAC_HW_RX_TRIGGER_TIMER_RX_PAYLOAD_USED_COUNT_LSB    16
#define MAC_HW_RX_TRIGGER_TIMER_RX_PAYLOAD_USED_COUNT_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_TRIGGER_TIMER_RX_PACKET_TIMEOUT_MASK    ((u32)0x0000FF00)
#define MAC_HW_RX_TRIGGER_TIMER_RX_PACKET_TIMEOUT_LSB    8
#define MAC_HW_RX_TRIGGER_TIMER_RX_PACKET_TIMEOUT_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_TRIGGER_TIMER_RX_ABSOLUTE_TIMEOUT_MASK    ((u32)0x000000FF)
#define MAC_HW_RX_TRIGGER_TIMER_RX_ABSOLUTE_TIMEOUT_LSB    0
#define MAC_HW_RX_TRIGGER_TIMER_RX_ABSOLUTE_TIMEOUT_WIDTH    ((u32)0x00000008)

#define MAC_HW_RX_TRIGGER_TIMER_RX_PAYLOAD_USED_COUNT_RST    0xF
#define MAC_HW_RX_TRIGGER_TIMER_RX_PACKET_TIMEOUT_RST    0xF
#define MAC_HW_RX_TRIGGER_TIMER_RX_ABSOLUTE_TIMEOUT_RST    0x9C

static inline void mac_hw_rx_trigger_timer_pack(struct cl_chip *chip, u8 rx_payload_used_count, u8 rx_packet_timeout, u8 rx_absolute_timeout)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_used_count << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_packet_timeout << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_absolute_timeout << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR, ((u32)rx_payload_used_count << 16) | ((u32)rx_packet_timeout << 8) | ((u32)rx_absolute_timeout << 0));
}

static inline void mac_hw_rx_trigger_timer_unpack(struct cl_chip *chip, u8 *rx_payload_used_count, u8 *rx_packet_timeout, u8 *rx_absolute_timeout)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR);

	*rx_payload_used_count = (local_val & ((u32)0x00FF0000)) >> 16;
	*rx_packet_timeout = (local_val & ((u32)0x0000FF00)) >> 8;
	*rx_absolute_timeout = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_rx_trigger_timer_rx_payload_used_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_rx_trigger_timer_rx_payload_used_count_setf(struct cl_chip *chip, u8 rxpayloadusedcount)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadusedcount << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR) & ~((u32)0x00FF0000)) | ((u32)rxpayloadusedcount << 16));
}

static inline u8 mac_hw_rx_trigger_timer_rx_packet_timeout_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_rx_trigger_timer_rx_packet_timeout_setf(struct cl_chip *chip, u8 rxpackettimeout)
{
	ASSERT_ERR_CHIP((((u32)rxpackettimeout << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR) & ~((u32)0x0000FF00)) | ((u32)rxpackettimeout << 8));
}

static inline u8 mac_hw_rx_trigger_timer_rx_absolute_timeout_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_rx_trigger_timer_rx_absolute_timeout_setf(struct cl_chip *chip, u8 rxabsolutetimeout)
{
	ASSERT_ERR_CHIP((((u32)rxabsolutetimeout << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_TIMER_ADDR) & ~((u32)0x000000FF)) | ((u32)rxabsolutetimeout << 0));
}

/**
 * @brief MIB_TABLE_WRITE register definition
 *  Window register used to write to the MIB Table from software. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 MIB_VALUE                 0x0
 *    15    MIB_WRITE                 0
 *    14    MIB_INCREMENT_MODE        1
 *    09:00 MIB_TABLE_INDEX           0x0
 * </pre>
 */
#define MAC_HW_MIB_TABLE_WRITE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000118)
#define MAC_HW_MIB_TABLE_WRITE_OFFSET      0x00000118
#define MAC_HW_MIB_TABLE_WRITE_INDEX       0x00000046
#define MAC_HW_MIB_TABLE_WRITE_RESET       0x00004000

static inline u32 mac_hw_mib_table_write_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);
}

static inline void mac_hw_mib_table_write_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MIB_TABLE_WRITE_MIB_VALUE_MASK    ((u32)0xFFFF0000)
#define MAC_HW_MIB_TABLE_WRITE_MIB_VALUE_LSB    16
#define MAC_HW_MIB_TABLE_WRITE_MIB_VALUE_WIDTH    ((u32)0x00000010)
#define MAC_HW_MIB_TABLE_WRITE_MIB_WRITE_BIT    ((u32)0x00008000)
#define MAC_HW_MIB_TABLE_WRITE_MIB_WRITE_POS    15
#define MAC_HW_MIB_TABLE_WRITE_MIB_INCREMENT_MODE_BIT    ((u32)0x00004000)
#define MAC_HW_MIB_TABLE_WRITE_MIB_INCREMENT_MODE_POS    14
#define MAC_HW_MIB_TABLE_WRITE_MIB_TABLE_INDEX_MASK    ((u32)0x000003FF)
#define MAC_HW_MIB_TABLE_WRITE_MIB_TABLE_INDEX_LSB    0
#define MAC_HW_MIB_TABLE_WRITE_MIB_TABLE_INDEX_WIDTH    ((u32)0x0000000A)

#define MAC_HW_MIB_TABLE_WRITE_MIB_VALUE_RST    0x0
#define MAC_HW_MIB_TABLE_WRITE_MIB_WRITE_RST    0x0
#define MAC_HW_MIB_TABLE_WRITE_MIB_INCREMENT_MODE_RST    0x1
#define MAC_HW_MIB_TABLE_WRITE_MIB_TABLE_INDEX_RST    0x0

static inline void mac_hw_mib_table_write_pack(struct cl_chip *chip, u16 mib_value, u8 mib_write, u8 mib_increment_mode, u16 mib_table_index)
{
	ASSERT_ERR_CHIP((((u32)mib_value << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)mib_write << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)mib_increment_mode << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)mib_table_index << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, ((u32)mib_value << 16) | ((u32)mib_write << 15) | ((u32)mib_increment_mode << 14) | ((u32)mib_table_index << 0));
}

static inline void mac_hw_mib_table_write_unpack(struct cl_chip *chip, u16 *mib_value, u8 *mib_write, u8 *mib_increment_mode, u16 *mib_table_index)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);

	*mib_value = (local_val & ((u32)0xFFFF0000)) >> 16;
	*mib_write = (local_val & ((u32)0x00008000)) >> 15;
	*mib_increment_mode = (local_val & ((u32)0x00004000)) >> 14;
	*mib_table_index = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_mib_table_write_mib_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_mib_table_write_mib_value_setf(struct cl_chip *chip, u16 mibvalue)
{
	ASSERT_ERR_CHIP((((u32)mibvalue << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, (cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR) & ~((u32)0xFFFF0000)) | ((u32)mibvalue << 16));
}

static inline u8 mac_hw_mib_table_write_mib_write_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_mib_table_write_mib_write_setf(struct cl_chip *chip, u8 mibwrite)
{
	ASSERT_ERR_CHIP((((u32)mibwrite << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, (cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR) & ~((u32)0x00008000)) | ((u32)mibwrite << 15));
}

static inline u8 mac_hw_mib_table_write_mib_increment_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_mib_table_write_mib_increment_mode_setf(struct cl_chip *chip, u8 mibincrementmode)
{
	ASSERT_ERR_CHIP((((u32)mibincrementmode << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, (cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR) & ~((u32)0x00004000)) | ((u32)mibincrementmode << 14));
}

static inline u16 mac_hw_mib_table_write_mib_table_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_mib_table_write_mib_table_index_setf(struct cl_chip *chip, u16 mibtableindex)
{
	ASSERT_ERR_CHIP((((u32)mibtableindex << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_MIB_TABLE_WRITE_ADDR, (cl_reg_read(chip, MAC_HW_MIB_TABLE_WRITE_ADDR) & ~((u32)0x000003FF)) | ((u32)mibtableindex << 0));
}

/**
 * @brief MONOTONIC_COUNTER_1 register definition
 *  General purpose timer provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MONOTONIC_COUNTER_1       0x0
 * </pre>
 */
#define MAC_HW_MONOTONIC_COUNTER_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000011C)
#define MAC_HW_MONOTONIC_COUNTER_1_OFFSET      0x0000011C
#define MAC_HW_MONOTONIC_COUNTER_1_INDEX       0x00000047
#define MAC_HW_MONOTONIC_COUNTER_1_RESET       0x00000000

static inline u32 mac_hw_monotonic_counter_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_1_ADDR);
}

/* Field definitions */
#define MAC_HW_MONOTONIC_COUNTER_1_MONOTONIC_COUNTER_1_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_MONOTONIC_COUNTER_1_MONOTONIC_COUNTER_1_LSB    0
#define MAC_HW_MONOTONIC_COUNTER_1_MONOTONIC_COUNTER_1_WIDTH    ((u32)0x00000020)

#define MAC_HW_MONOTONIC_COUNTER_1_MONOTONIC_COUNTER_1_RST    0x0

static inline u32 mac_hw_monotonic_counter_1_monotonic_counter_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_1_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief MONOTONIC_COUNTER_2_LO register definition
 *  General purpose timer provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MONOTONIC_COUNTER_LOW_2   0x0
 * </pre>
 */
#define MAC_HW_MONOTONIC_COUNTER_2_LO_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000120)
#define MAC_HW_MONOTONIC_COUNTER_2_LO_OFFSET      0x00000120
#define MAC_HW_MONOTONIC_COUNTER_2_LO_INDEX       0x00000048
#define MAC_HW_MONOTONIC_COUNTER_2_LO_RESET       0x00000000

static inline u32 mac_hw_monotonic_counter_2_lo_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_2_LO_ADDR);
}

/* Field definitions */
#define MAC_HW_MONOTONIC_COUNTER_2_LO_MONOTONIC_COUNTER_LOW_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_MONOTONIC_COUNTER_2_LO_MONOTONIC_COUNTER_LOW_2_LSB    0
#define MAC_HW_MONOTONIC_COUNTER_2_LO_MONOTONIC_COUNTER_LOW_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_MONOTONIC_COUNTER_2_LO_MONOTONIC_COUNTER_LOW_2_RST    0x0

static inline u32 mac_hw_monotonic_counter_2_lo_monotonic_counter_low_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_2_LO_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief MONOTONIC_COUNTER_2_HI register definition
 *  General purpose timer provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 MONOTONIC_COUNTER_HIGH_2  0x0
 * </pre>
 */
#define MAC_HW_MONOTONIC_COUNTER_2_HI_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000124)
#define MAC_HW_MONOTONIC_COUNTER_2_HI_OFFSET      0x00000124
#define MAC_HW_MONOTONIC_COUNTER_2_HI_INDEX       0x00000049
#define MAC_HW_MONOTONIC_COUNTER_2_HI_RESET       0x00000000

static inline u32 mac_hw_monotonic_counter_2_hi_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_2_HI_ADDR);
}

/* Field definitions */
#define MAC_HW_MONOTONIC_COUNTER_2_HI_MONOTONIC_COUNTER_HIGH_2_MASK    ((u32)0x0000FFFF)
#define MAC_HW_MONOTONIC_COUNTER_2_HI_MONOTONIC_COUNTER_HIGH_2_LSB    0
#define MAC_HW_MONOTONIC_COUNTER_2_HI_MONOTONIC_COUNTER_HIGH_2_WIDTH    ((u32)0x00000010)

#define MAC_HW_MONOTONIC_COUNTER_2_HI_MONOTONIC_COUNTER_HIGH_2_RST    0x0

static inline u16 mac_hw_monotonic_counter_2_hi_monotonic_counter_high_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MONOTONIC_COUNTER_2_HI_ADDR);

	return (u16)(local_val >> 0);
}

/**
 * @brief ABS_TIMER_0 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER0_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000128)
#define MAC_HW_ABS_TIMER_0_OFFSET      0x00000128
#define MAC_HW_ABS_TIMER_0_INDEX       0x0000004A
#define MAC_HW_ABS_TIMER_0_RESET       0x00000000

static inline u32 mac_hw_abs_timer_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_0_ADDR);
}

static inline void mac_hw_abs_timer_0_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_0_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_0_ABS_TIMER_0_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_0_ABS_TIMER_0_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_0_ABS_TIMER_0_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_0_ABS_TIMER_0_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_0_abs_timer_0_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_0_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_0_abs_timer_0_value_setf(struct cl_chip *chip, u32 abstimer0value)
{
	ASSERT_ERR_CHIP((((u32)abstimer0value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_0_ADDR, (u32)abstimer0value << 0);
}

/**
 * @brief ABS_TIMER_1 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER1_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000012C)
#define MAC_HW_ABS_TIMER_1_OFFSET      0x0000012C
#define MAC_HW_ABS_TIMER_1_INDEX       0x0000004B
#define MAC_HW_ABS_TIMER_1_RESET       0x00000000

static inline u32 mac_hw_abs_timer_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_1_ADDR);
}

static inline void mac_hw_abs_timer_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_1_ABS_TIMER_1_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_1_ABS_TIMER_1_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_1_ABS_TIMER_1_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_1_ABS_TIMER_1_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_1_abs_timer_1_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_1_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_1_abs_timer_1_value_setf(struct cl_chip *chip, u32 abstimer1value)
{
	ASSERT_ERR_CHIP((((u32)abstimer1value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_1_ADDR, (u32)abstimer1value << 0);
}

/**
 * @brief ABS_TIMER_2 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER2_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000130)
#define MAC_HW_ABS_TIMER_2_OFFSET      0x00000130
#define MAC_HW_ABS_TIMER_2_INDEX       0x0000004C
#define MAC_HW_ABS_TIMER_2_RESET       0x00000000

static inline u32 mac_hw_abs_timer_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_2_ADDR);
}

static inline void mac_hw_abs_timer_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_2_ABS_TIMER_2_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_2_ABS_TIMER_2_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_2_ABS_TIMER_2_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_2_ABS_TIMER_2_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_2_abs_timer_2_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_2_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_2_abs_timer_2_value_setf(struct cl_chip *chip, u32 abstimer2value)
{
	ASSERT_ERR_CHIP((((u32)abstimer2value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_2_ADDR, (u32)abstimer2value << 0);
}

/**
 * @brief ABS_TIMER_3 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER3_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000134)
#define MAC_HW_ABS_TIMER_3_OFFSET      0x00000134
#define MAC_HW_ABS_TIMER_3_INDEX       0x0000004D
#define MAC_HW_ABS_TIMER_3_RESET       0x00000000

static inline u32 mac_hw_abs_timer_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_3_ADDR);
}

static inline void mac_hw_abs_timer_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_3_ABS_TIMER_3_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_3_ABS_TIMER_3_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_3_ABS_TIMER_3_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_3_ABS_TIMER_3_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_3_abs_timer_3_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_3_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_3_abs_timer_3_value_setf(struct cl_chip *chip, u32 abstimer3value)
{
	ASSERT_ERR_CHIP((((u32)abstimer3value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_3_ADDR, (u32)abstimer3value << 0);
}

/**
 * @brief ABS_TIMER_4 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER4_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000138)
#define MAC_HW_ABS_TIMER_4_OFFSET      0x00000138
#define MAC_HW_ABS_TIMER_4_INDEX       0x0000004E
#define MAC_HW_ABS_TIMER_4_RESET       0x00000000

static inline u32 mac_hw_abs_timer_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_4_ADDR);
}

static inline void mac_hw_abs_timer_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_4_ABS_TIMER_4_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_4_ABS_TIMER_4_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_4_ABS_TIMER_4_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_4_ABS_TIMER_4_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_4_abs_timer_4_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_4_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_4_abs_timer_4_value_setf(struct cl_chip *chip, u32 abstimer4value)
{
	ASSERT_ERR_CHIP((((u32)abstimer4value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_4_ADDR, (u32)abstimer4value << 0);
}

/**
 * @brief ABS_TIMER_5 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER5_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000013C)
#define MAC_HW_ABS_TIMER_5_OFFSET      0x0000013C
#define MAC_HW_ABS_TIMER_5_INDEX       0x0000004F
#define MAC_HW_ABS_TIMER_5_RESET       0x00000000

static inline u32 mac_hw_abs_timer_5_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_5_ADDR);
}

static inline void mac_hw_abs_timer_5_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_5_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_5_ABS_TIMER_5_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_5_ABS_TIMER_5_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_5_ABS_TIMER_5_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_5_ABS_TIMER_5_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_5_abs_timer_5_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_5_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_5_abs_timer_5_value_setf(struct cl_chip *chip, u32 abstimer5value)
{
	ASSERT_ERR_CHIP((((u32)abstimer5value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_5_ADDR, (u32)abstimer5value << 0);
}

/**
 * @brief ABS_TIMER_6 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER6_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_6_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000140)
#define MAC_HW_ABS_TIMER_6_OFFSET      0x00000140
#define MAC_HW_ABS_TIMER_6_INDEX       0x00000050
#define MAC_HW_ABS_TIMER_6_RESET       0x00000000

static inline u32 mac_hw_abs_timer_6_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_6_ADDR);
}

static inline void mac_hw_abs_timer_6_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_6_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_6_ABS_TIMER_6_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_6_ABS_TIMER_6_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_6_ABS_TIMER_6_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_6_ABS_TIMER_6_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_6_abs_timer_6_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_6_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_6_abs_timer_6_value_setf(struct cl_chip *chip, u32 abstimer6value)
{
	ASSERT_ERR_CHIP((((u32)abstimer6value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_6_ADDR, (u32)abstimer6value << 0);
}

/**
 * @brief ABS_TIMER_7 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER7_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_7_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000144)
#define MAC_HW_ABS_TIMER_7_OFFSET      0x00000144
#define MAC_HW_ABS_TIMER_7_INDEX       0x00000051
#define MAC_HW_ABS_TIMER_7_RESET       0x00000000

static inline u32 mac_hw_abs_timer_7_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_7_ADDR);
}

static inline void mac_hw_abs_timer_7_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_7_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_7_ABS_TIMER_7_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_7_ABS_TIMER_7_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_7_ABS_TIMER_7_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_7_ABS_TIMER_7_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_7_abs_timer_7_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_7_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_7_abs_timer_7_value_setf(struct cl_chip *chip, u32 abstimer7value)
{
	ASSERT_ERR_CHIP((((u32)abstimer7value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_7_ADDR, (u32)abstimer7value << 0);
}

/**
 * @brief ABS_TIMER_8 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER8_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_8_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000148)
#define MAC_HW_ABS_TIMER_8_OFFSET      0x00000148
#define MAC_HW_ABS_TIMER_8_INDEX       0x00000052
#define MAC_HW_ABS_TIMER_8_RESET       0x00000000

static inline u32 mac_hw_abs_timer_8_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_8_ADDR);
}

static inline void mac_hw_abs_timer_8_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_8_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_8_ABS_TIMER_8_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_8_ABS_TIMER_8_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_8_ABS_TIMER_8_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_8_ABS_TIMER_8_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_8_abs_timer_8_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_8_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_8_abs_timer_8_value_setf(struct cl_chip *chip, u32 abstimer8value)
{
	ASSERT_ERR_CHIP((((u32)abstimer8value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_8_ADDR, (u32)abstimer8value << 0);
}

/**
 * @brief ABS_TIMER_9 register definition
 *  General purpose counter provided to SW. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 ABS_TIMER9_VALUE          0x0
 * </pre>
 */
#define MAC_HW_ABS_TIMER_9_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000014C)
#define MAC_HW_ABS_TIMER_9_OFFSET      0x0000014C
#define MAC_HW_ABS_TIMER_9_INDEX       0x00000053
#define MAC_HW_ABS_TIMER_9_RESET       0x00000000

static inline u32 mac_hw_abs_timer_9_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ABS_TIMER_9_ADDR);
}

static inline void mac_hw_abs_timer_9_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ABS_TIMER_9_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ABS_TIMER_9_ABS_TIMER_9_VALUE_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ABS_TIMER_9_ABS_TIMER_9_VALUE_LSB    0
#define MAC_HW_ABS_TIMER_9_ABS_TIMER_9_VALUE_WIDTH    ((u32)0x00000020)

#define MAC_HW_ABS_TIMER_9_ABS_TIMER_9_VALUE_RST    0x0

static inline u32 mac_hw_abs_timer_9_abs_timer_9_value_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ABS_TIMER_9_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_abs_timer_9_abs_timer_9_value_setf(struct cl_chip *chip, u32 abstimer9value)
{
	ASSERT_ERR_CHIP((((u32)abstimer9value << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ABS_TIMER_9_ADDR, (u32)abstimer9value << 0);
}

/**
 * @brief MAX_RX_LENGTH register definition
 *  Configure the maximum PSDU length received. Should be 4095 in abg and 65535 in HT register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:00 MAX_ALLOWED_LENGTH        0xFFFFFF
 * </pre>
 */
#define MAC_HW_MAX_RX_LENGTH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000150)
#define MAC_HW_MAX_RX_LENGTH_OFFSET      0x00000150
#define MAC_HW_MAX_RX_LENGTH_INDEX       0x00000054
#define MAC_HW_MAX_RX_LENGTH_RESET       0x00FFFFFF

static inline u32 mac_hw_max_rx_length_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAX_RX_LENGTH_ADDR);
}

static inline void mac_hw_max_rx_length_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAX_RX_LENGTH_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAX_RX_LENGTH_MAX_ALLOWED_LENGTH_MASK    ((u32)0x00FFFFFF)
#define MAC_HW_MAX_RX_LENGTH_MAX_ALLOWED_LENGTH_LSB    0
#define MAC_HW_MAX_RX_LENGTH_MAX_ALLOWED_LENGTH_WIDTH    ((u32)0x00000018)

#define MAC_HW_MAX_RX_LENGTH_MAX_ALLOWED_LENGTH_RST    0xFFFFFF

static inline u32 mac_hw_max_rx_length_max_allowed_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAX_RX_LENGTH_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_max_rx_length_max_allowed_length_setf(struct cl_chip *chip, u32 maxallowedlength)
{
	ASSERT_ERR_CHIP((((u32)maxallowedlength << 0) & ~((u32)0x00FFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_MAX_RX_LENGTH_ADDR, (u32)maxallowedlength << 0);
}

/**
 * @brief RX_TRIGGER_2_TIMER register definition
 *  Contains timers for receive interrupt moderation register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:16 rx_Payload_Used_Count2    0x0F
 *    15:08 rx_Packet_Timeout2        0x0F
 *    07:00 rx_Absolute_Timeout2      0x9C
 * </pre>
 */
#define MAC_HW_RX_TRIGGER_2_TIMER_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000154)
#define MAC_HW_RX_TRIGGER_2_TIMER_OFFSET      0x00000154
#define MAC_HW_RX_TRIGGER_2_TIMER_INDEX       0x00000055
#define MAC_HW_RX_TRIGGER_2_TIMER_RESET       0x000F0F9C

static inline u32 mac_hw_rx_trigger_2_timer_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR);
}

static inline void mac_hw_rx_trigger_2_timer_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PAYLOAD_USED_COUNT_2_MASK    ((u32)0x00FF0000)
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PAYLOAD_USED_COUNT_2_LSB    16
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PAYLOAD_USED_COUNT_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PACKET_TIMEOUT_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PACKET_TIMEOUT_2_LSB    8
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PACKET_TIMEOUT_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_ABSOLUTE_TIMEOUT_2_MASK    ((u32)0x000000FF)
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_ABSOLUTE_TIMEOUT_2_LSB    0
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_ABSOLUTE_TIMEOUT_2_WIDTH    ((u32)0x00000008)

#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PAYLOAD_USED_COUNT_2_RST    0x0F
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_PACKET_TIMEOUT_2_RST    0x0F
#define MAC_HW_RX_TRIGGER_2_TIMER_RX_ABSOLUTE_TIMEOUT_2_RST    0x9C

static inline void mac_hw_rx_trigger_2_timer_pack(struct cl_chip *chip, u8 rx_payload_used_count2, u8 rx_packet_timeout2, u8 rx_absolute_timeout2)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_used_count2 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_packet_timeout2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_absolute_timeout2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR, ((u32)rx_payload_used_count2 << 16) | ((u32)rx_packet_timeout2 << 8) | ((u32)rx_absolute_timeout2 << 0));
}

static inline void mac_hw_rx_trigger_2_timer_unpack(struct cl_chip *chip, u8 *rx_payload_used_count2, u8 *rx_packet_timeout2, u8 *rx_absolute_timeout2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR);

	*rx_payload_used_count2 = (local_val & ((u32)0x00FF0000)) >> 16;
	*rx_packet_timeout2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*rx_absolute_timeout2 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_rx_trigger_2_timer_rx_payload_used_count_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_rx_trigger_2_timer_rx_payload_used_count_2_setf(struct cl_chip *chip, u8 rxpayloadusedcount2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadusedcount2 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR) & ~((u32)0x00FF0000)) | ((u32)rxpayloadusedcount2 << 16));
}

static inline u8 mac_hw_rx_trigger_2_timer_rx_packet_timeout_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_rx_trigger_2_timer_rx_packet_timeout_2_setf(struct cl_chip *chip, u8 rxpackettimeout2)
{
	ASSERT_ERR_CHIP((((u32)rxpackettimeout2 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR) & ~((u32)0x0000FF00)) | ((u32)rxpackettimeout2 << 8));
}

static inline u8 mac_hw_rx_trigger_2_timer_rx_absolute_timeout_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_rx_trigger_2_timer_rx_absolute_timeout_2_setf(struct cl_chip *chip, u8 rxabsolutetimeout2)
{
	ASSERT_ERR_CHIP((((u32)rxabsolutetimeout2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR, (cl_reg_read(chip, MAC_HW_RX_TRIGGER_2_TIMER_ADDR) & ~((u32)0x000000FF)) | ((u32)rxabsolutetimeout2 << 0));
}

/**
 * @brief TX_CHAINS_CTRL_1 register definition
 *  Indicates max possible TX chains per formatMod register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    19:16 max_tx_chains_HE          0x6
 *    15:12 max_tx_chains_VHT         0x4
 *    11:08 max_tx_chains_HT          0x4
 *    07:04 max_tx_chains_non_HT      0x4
 *    03:00 max_tx_chains_11b         0x1
 * </pre>
 */
#define MAC_HW_TX_CHAINS_CTRL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000160)
#define MAC_HW_TX_CHAINS_CTRL_1_OFFSET      0x00000160
#define MAC_HW_TX_CHAINS_CTRL_1_INDEX       0x00000058
#define MAC_HW_TX_CHAINS_CTRL_1_RESET       0x00064441

static inline u32 mac_hw_tx_chains_ctrl_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);
}

static inline void mac_hw_tx_chains_ctrl_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HE_MASK    ((u32)0x000F0000)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HE_LSB    16
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HE_WIDTH    ((u32)0x00000004)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_VHT_MASK    ((u32)0x0000F000)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_VHT_LSB    12
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_VHT_WIDTH    ((u32)0x00000004)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HT_MASK    ((u32)0x00000F00)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HT_LSB    8
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HT_WIDTH    ((u32)0x00000004)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_NON_HT_MASK    ((u32)0x000000F0)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_NON_HT_LSB    4
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_NON_HT_WIDTH    ((u32)0x00000004)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_11_B_MASK    ((u32)0x0000000F)
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_11_B_LSB    0
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_11_B_WIDTH    ((u32)0x00000004)

#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HE_RST    0x6
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_VHT_RST    0x4
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_HT_RST    0x4
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_NON_HT_RST    0x4
#define MAC_HW_TX_CHAINS_CTRL_1_MAX_TX_CHAINS_11_B_RST    0x1

static inline void mac_hw_tx_chains_ctrl_1_pack(struct cl_chip *chip, u8 max_tx_chains_he, u8 max_tx_chains_vht, u8 max_tx_chains_ht, u8 max_tx_chains_non_ht, u8 max_tx_chains_11b)
{
	ASSERT_ERR_CHIP((((u32)max_tx_chains_he << 16) & ~((u32)0x000F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)max_tx_chains_vht << 12) & ~((u32)0x0000F000)) == 0);
	ASSERT_ERR_CHIP((((u32)max_tx_chains_ht << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)max_tx_chains_non_ht << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)max_tx_chains_11b << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, ((u32)max_tx_chains_he << 16) | ((u32)max_tx_chains_vht << 12) | ((u32)max_tx_chains_ht << 8) | ((u32)max_tx_chains_non_ht << 4) | ((u32)max_tx_chains_11b << 0));
}

static inline void mac_hw_tx_chains_ctrl_1_unpack(struct cl_chip *chip, u8 *max_tx_chains_he, u8 *max_tx_chains_vht, u8 *max_tx_chains_ht, u8 *max_tx_chains_non_ht, u8 *max_tx_chains_11b)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	*max_tx_chains_he = (local_val & ((u32)0x000F0000)) >> 16;
	*max_tx_chains_vht = (local_val & ((u32)0x0000F000)) >> 12;
	*max_tx_chains_ht = (local_val & ((u32)0x00000F00)) >> 8;
	*max_tx_chains_non_ht = (local_val & ((u32)0x000000F0)) >> 4;
	*max_tx_chains_11b = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_tx_chains_ctrl_1_max_tx_chains_he_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x000F0000)) >> 16);
}

static inline void mac_hw_tx_chains_ctrl_1_max_tx_chains_he_setf(struct cl_chip *chip, u8 maxtxchainshe)
{
	ASSERT_ERR_CHIP((((u32)maxtxchainshe << 16) & ~((u32)0x000F0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR) & ~((u32)0x000F0000)) | ((u32)maxtxchainshe << 16));
}

static inline u8 mac_hw_tx_chains_ctrl_1_max_tx_chains_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x0000F000)) >> 12);
}

static inline void mac_hw_tx_chains_ctrl_1_max_tx_chains_vht_setf(struct cl_chip *chip, u8 maxtxchainsvht)
{
	ASSERT_ERR_CHIP((((u32)maxtxchainsvht << 12) & ~((u32)0x0000F000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR) & ~((u32)0x0000F000)) | ((u32)maxtxchainsvht << 12));
}

static inline u8 mac_hw_tx_chains_ctrl_1_max_tx_chains_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_tx_chains_ctrl_1_max_tx_chains_ht_setf(struct cl_chip *chip, u8 maxtxchainsht)
{
	ASSERT_ERR_CHIP((((u32)maxtxchainsht << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR) & ~((u32)0x00000F00)) | ((u32)maxtxchainsht << 8));
}

static inline u8 mac_hw_tx_chains_ctrl_1_max_tx_chains_non_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_tx_chains_ctrl_1_max_tx_chains_non_ht_setf(struct cl_chip *chip, u8 maxtxchainsnonht)
{
	ASSERT_ERR_CHIP((((u32)maxtxchainsnonht << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR) & ~((u32)0x000000F0)) | ((u32)maxtxchainsnonht << 4));
}

static inline u8 mac_hw_tx_chains_ctrl_1_max_tx_chains_11_b_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_tx_chains_ctrl_1_max_tx_chains_11_b_setf(struct cl_chip *chip, u8 maxtxchains11b)
{
	ASSERT_ERR_CHIP((((u32)maxtxchains11b << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_1_ADDR) & ~((u32)0x0000000F)) | ((u32)maxtxchains11b << 0));
}

/**
 * @brief TX_CHAINS_CTRL_2 register definition
 *  Indicates TX chains bit map for AR register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:24 tx_chains_VHT             0xF
 *    21:16 tx_chains_HT              0xF
 *    13:08 tx_chains_non_HT          0xF
 *    05:00 tx_chains_11b             0x1
 * </pre>
 */
#define MAC_HW_TX_CHAINS_CTRL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000164)
#define MAC_HW_TX_CHAINS_CTRL_2_OFFSET      0x00000164
#define MAC_HW_TX_CHAINS_CTRL_2_INDEX       0x00000059
#define MAC_HW_TX_CHAINS_CTRL_2_RESET       0x0F0F0F01

static inline u32 mac_hw_tx_chains_ctrl_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);
}

static inline void mac_hw_tx_chains_ctrl_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_VHT_MASK    ((u32)0x3F000000)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_VHT_LSB    24
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_VHT_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_HT_MASK    ((u32)0x003F0000)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_HT_LSB    16
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_HT_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_NON_HT_MASK    ((u32)0x00003F00)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_NON_HT_LSB    8
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_NON_HT_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_11_B_MASK    ((u32)0x0000003F)
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_11_B_LSB    0
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_11_B_WIDTH    ((u32)0x00000006)

#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_VHT_RST    0xF
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_HT_RST    0xF
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_NON_HT_RST    0xF
#define MAC_HW_TX_CHAINS_CTRL_2_TX_CHAINS_11_B_RST    0x1

static inline void mac_hw_tx_chains_ctrl_2_pack(struct cl_chip *chip, u8 tx_chains_vht, u8 tx_chains_ht, u8 tx_chains_non_ht, u8 tx_chains_11b)
{
	ASSERT_ERR_CHIP((((u32)tx_chains_vht << 24) & ~((u32)0x3F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_chains_ht << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_chains_non_ht << 8) & ~((u32)0x00003F00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_chains_11b << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, ((u32)tx_chains_vht << 24) | ((u32)tx_chains_ht << 16) | ((u32)tx_chains_non_ht << 8) | ((u32)tx_chains_11b << 0));
}

static inline void mac_hw_tx_chains_ctrl_2_unpack(struct cl_chip *chip, u8 *tx_chains_vht, u8 *tx_chains_ht, u8 *tx_chains_non_ht, u8 *tx_chains_11b)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);

	*tx_chains_vht = (local_val & ((u32)0x3F000000)) >> 24;
	*tx_chains_ht = (local_val & ((u32)0x003F0000)) >> 16;
	*tx_chains_non_ht = (local_val & ((u32)0x00003F00)) >> 8;
	*tx_chains_11b = (local_val & ((u32)0x0000003F)) >> 0;
}

static inline u8 mac_hw_tx_chains_ctrl_2_tx_chains_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x3F000000)) >> 24);
}

static inline void mac_hw_tx_chains_ctrl_2_tx_chains_vht_setf(struct cl_chip *chip, u8 txchainsvht)
{
	ASSERT_ERR_CHIP((((u32)txchainsvht << 24) & ~((u32)0x3F000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR) & ~((u32)0x3F000000)) | ((u32)txchainsvht << 24));
}

static inline u8 mac_hw_tx_chains_ctrl_2_tx_chains_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_tx_chains_ctrl_2_tx_chains_ht_setf(struct cl_chip *chip, u8 txchainsht)
{
	ASSERT_ERR_CHIP((((u32)txchainsht << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR) & ~((u32)0x003F0000)) | ((u32)txchainsht << 16));
}

static inline u8 mac_hw_tx_chains_ctrl_2_tx_chains_non_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00003F00)) >> 8);
}

static inline void mac_hw_tx_chains_ctrl_2_tx_chains_non_ht_setf(struct cl_chip *chip, u8 txchainsnonht)
{
	ASSERT_ERR_CHIP((((u32)txchainsnonht << 8) & ~((u32)0x00003F00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR) & ~((u32)0x00003F00)) | ((u32)txchainsnonht << 8));
}

static inline u8 mac_hw_tx_chains_ctrl_2_tx_chains_11_b_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x0000003F)) >> 0);
}

static inline void mac_hw_tx_chains_ctrl_2_tx_chains_11_b_setf(struct cl_chip *chip, u8 txchains11b)
{
	ASSERT_ERR_CHIP((((u32)txchains11b << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_2_ADDR) & ~((u32)0x0000003F)) | ((u32)txchains11b << 0));
}

/**
 * @brief TX_CHAINS_CTRL_3 register definition
 *  Indicates TX chains bit map for AR register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    13:08 tx_chains_FTM             0x1
 *    05:00 tx_chains_HE              0x3F
 * </pre>
 */
#define MAC_HW_TX_CHAINS_CTRL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000168)
#define MAC_HW_TX_CHAINS_CTRL_3_OFFSET      0x00000168
#define MAC_HW_TX_CHAINS_CTRL_3_INDEX       0x0000005A
#define MAC_HW_TX_CHAINS_CTRL_3_RESET       0x0000013F

static inline u32 mac_hw_tx_chains_ctrl_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR);
}

static inline void mac_hw_tx_chains_ctrl_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_FTM_MASK    ((u32)0x00003F00)
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_FTM_LSB    8
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_FTM_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_HE_MASK    ((u32)0x0000003F)
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_HE_LSB    0
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_HE_WIDTH    ((u32)0x00000006)

#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_FTM_RST    0x1
#define MAC_HW_TX_CHAINS_CTRL_3_TX_CHAINS_HE_RST    0x3F

static inline void mac_hw_tx_chains_ctrl_3_pack(struct cl_chip *chip, u8 tx_chains_ftm, u8 tx_chains_he)
{
	ASSERT_ERR_CHIP((((u32)tx_chains_ftm << 8) & ~((u32)0x00003F00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_chains_he << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR, ((u32)tx_chains_ftm << 8) | ((u32)tx_chains_he << 0));
}

static inline void mac_hw_tx_chains_ctrl_3_unpack(struct cl_chip *chip, u8 *tx_chains_ftm, u8 *tx_chains_he)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR);

	*tx_chains_ftm = (local_val & ((u32)0x00003F00)) >> 8;
	*tx_chains_he = (local_val & ((u32)0x0000003F)) >> 0;
}

static inline u8 mac_hw_tx_chains_ctrl_3_tx_chains_ftm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x00003F00)) >> 8);
}

static inline void mac_hw_tx_chains_ctrl_3_tx_chains_ftm_setf(struct cl_chip *chip, u8 txchainsftm)
{
	ASSERT_ERR_CHIP((((u32)txchainsftm << 8) & ~((u32)0x00003F00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR) & ~((u32)0x00003F00)) | ((u32)txchainsftm << 8));
}

static inline u8 mac_hw_tx_chains_ctrl_3_tx_chains_he_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR);

	return (u8)((local_val & ((u32)0x0000003F)) >> 0);
}

static inline void mac_hw_tx_chains_ctrl_3_tx_chains_he_setf(struct cl_chip *chip, u8 txchainshe)
{
	ASSERT_ERR_CHIP((((u32)txchainshe << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR, (cl_reg_read(chip, MAC_HW_TX_CHAINS_CTRL_3_ADDR) & ~((u32)0x0000003F)) | ((u32)txchainshe << 0));
}

/**
 * @brief TX_ACK_POLICY register definition
 *  Controls ACK POLICY override register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    enable_ack_policy_override 0
 *    11:10 ACK_POLICY_HE_TB          0x0
 *    09:08 ACK_POLICY_HE_MU          0x2
 *    07:06 ACK_POLICY_HE_SU_TRIGGER_INCL 0x2
 *    05:04 ACK_POLICY_HE_SU_TRIGGER_NOT_INCL 0x0
 *    03:02 ACK_POLICY_VHT            0x3
 *    01:00 ACK_POLICY_HT             0x0
 * </pre>
 */
#define MAC_HW_TX_ACK_POLICY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000178)
#define MAC_HW_TX_ACK_POLICY_OFFSET      0x00000178
#define MAC_HW_TX_ACK_POLICY_INDEX       0x0000005E
#define MAC_HW_TX_ACK_POLICY_RESET       0x0000028C

static inline u32 mac_hw_tx_ack_policy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);
}

static inline void mac_hw_tx_ack_policy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_ACK_POLICY_ENABLE_ACK_POLICY_OVERRIDE_BIT    ((u32)0x80000000)
#define MAC_HW_TX_ACK_POLICY_ENABLE_ACK_POLICY_OVERRIDE_POS    31
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_TB_MASK    ((u32)0x00000C00)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_TB_LSB    10
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_TB_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_MU_MASK    ((u32)0x00000300)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_MU_LSB    8
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_MU_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_INCL_MASK    ((u32)0x000000C0)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_INCL_LSB    6
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_INCL_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_NOT_INCL_MASK    ((u32)0x00000030)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_NOT_INCL_LSB    4
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_NOT_INCL_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_VHT_MASK    ((u32)0x0000000C)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_VHT_LSB    2
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_VHT_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HT_MASK    ((u32)0x00000003)
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HT_LSB    0
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HT_WIDTH    ((u32)0x00000002)

#define MAC_HW_TX_ACK_POLICY_ENABLE_ACK_POLICY_OVERRIDE_RST    0x0
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_TB_RST    0x0
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_MU_RST    0x2
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_INCL_RST    0x2
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HE_SU_TRIGGER_NOT_INCL_RST    0x0
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_VHT_RST    0x3
#define MAC_HW_TX_ACK_POLICY_ACK_POLICY_HT_RST    0x0

static inline void mac_hw_tx_ack_policy_pack(struct cl_chip *chip, u8 enable_ack_policy_override, u8 ack_policy_he_tb, u8 ack_policy_he_mu, u8 ack_policy_he_su_trigger_incl, u8 ack_policy_he_su_trigger_not_incl, u8 ack_policy_vht, u8 ack_policy_ht)
{
	ASSERT_ERR_CHIP((((u32)enable_ack_policy_override << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_he_tb << 10) & ~((u32)0x00000C00)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_he_mu << 8) & ~((u32)0x00000300)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_he_su_trigger_incl << 6) & ~((u32)0x000000C0)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_he_su_trigger_not_incl << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_vht << 2) & ~((u32)0x0000000C)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_policy_ht << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, ((u32)enable_ack_policy_override << 31) | ((u32)ack_policy_he_tb << 10) | ((u32)ack_policy_he_mu << 8) | ((u32)ack_policy_he_su_trigger_incl << 6) | ((u32)ack_policy_he_su_trigger_not_incl << 4) | ((u32)ack_policy_vht << 2) | ((u32)ack_policy_ht << 0));
}

static inline void mac_hw_tx_ack_policy_unpack(struct cl_chip *chip, u8 *enable_ack_policy_override, u8 *ack_policy_he_tb, u8 *ack_policy_he_mu, u8 *ack_policy_he_su_trigger_incl, u8 *ack_policy_he_su_trigger_not_incl, u8 *ack_policy_vht, u8 *ack_policy_ht)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	*enable_ack_policy_override = (local_val & ((u32)0x80000000)) >> 31;
	*ack_policy_he_tb = (local_val & ((u32)0x00000C00)) >> 10;
	*ack_policy_he_mu = (local_val & ((u32)0x00000300)) >> 8;
	*ack_policy_he_su_trigger_incl = (local_val & ((u32)0x000000C0)) >> 6;
	*ack_policy_he_su_trigger_not_incl = (local_val & ((u32)0x00000030)) >> 4;
	*ack_policy_vht = (local_val & ((u32)0x0000000C)) >> 2;
	*ack_policy_ht = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_tx_ack_policy_enable_ack_policy_override_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_tx_ack_policy_enable_ack_policy_override_setf(struct cl_chip *chip, u8 enableackpolicyoverride)
{
	ASSERT_ERR_CHIP((((u32)enableackpolicyoverride << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x80000000)) | ((u32)enableackpolicyoverride << 31));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_he_tb_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x00000C00)) >> 10);
}

static inline void mac_hw_tx_ack_policy_ack_policy_he_tb_setf(struct cl_chip *chip, u8 ackpolicyhetb)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyhetb << 10) & ~((u32)0x00000C00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x00000C00)) | ((u32)ackpolicyhetb << 10));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_he_mu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x00000300)) >> 8);
}

static inline void mac_hw_tx_ack_policy_ack_policy_he_mu_setf(struct cl_chip *chip, u8 ackpolicyhemu)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyhemu << 8) & ~((u32)0x00000300)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x00000300)) | ((u32)ackpolicyhemu << 8));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_he_su_trigger_incl_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x000000C0)) >> 6);
}

static inline void mac_hw_tx_ack_policy_ack_policy_he_su_trigger_incl_setf(struct cl_chip *chip, u8 ackpolicyhesutriggerincl)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyhesutriggerincl << 6) & ~((u32)0x000000C0)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x000000C0)) | ((u32)ackpolicyhesutriggerincl << 6));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_he_su_trigger_not_incl_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_tx_ack_policy_ack_policy_he_su_trigger_not_incl_setf(struct cl_chip *chip, u8 ackpolicyhesutriggernotincl)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyhesutriggernotincl << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x00000030)) | ((u32)ackpolicyhesutriggernotincl << 4));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline void mac_hw_tx_ack_policy_ack_policy_vht_setf(struct cl_chip *chip, u8 ackpolicyvht)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyvht << 2) & ~((u32)0x0000000C)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x0000000C)) | ((u32)ackpolicyvht << 2));
}

static inline u8 mac_hw_tx_ack_policy_ack_policy_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

static inline void mac_hw_tx_ack_policy_ack_policy_ht_setf(struct cl_chip *chip, u8 ackpolicyht)
{
	ASSERT_ERR_CHIP((((u32)ackpolicyht << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_TX_ACK_POLICY_ADDR, (cl_reg_read(chip, MAC_HW_TX_ACK_POLICY_ADDR) & ~((u32)0x00000003)) | ((u32)ackpolicyht << 0));
}

/**
 * @brief HTP_RESPONSE_CTRL register definition
 *  Configures HTP response conditions register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:04 CS_EVALUATION_WINDOW      0x8
 *    03:00 CCA_20_BUSY_FILTER        0x0
 * </pre>
 */
#define MAC_HW_HTP_RESPONSE_CTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000017C)
#define MAC_HW_HTP_RESPONSE_CTRL_OFFSET      0x0000017C
#define MAC_HW_HTP_RESPONSE_CTRL_INDEX       0x0000005F
#define MAC_HW_HTP_RESPONSE_CTRL_RESET       0x00000080

static inline u32 mac_hw_htp_response_ctrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR);
}

static inline void mac_hw_htp_response_ctrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HTP_RESPONSE_CTRL_CS_EVALUATION_WINDOW_MASK    ((u32)0x000000F0)
#define MAC_HW_HTP_RESPONSE_CTRL_CS_EVALUATION_WINDOW_LSB    4
#define MAC_HW_HTP_RESPONSE_CTRL_CS_EVALUATION_WINDOW_WIDTH    ((u32)0x00000004)
#define MAC_HW_HTP_RESPONSE_CTRL_CCA_20_BUSY_FILTER_MASK    ((u32)0x0000000F)
#define MAC_HW_HTP_RESPONSE_CTRL_CCA_20_BUSY_FILTER_LSB    0
#define MAC_HW_HTP_RESPONSE_CTRL_CCA_20_BUSY_FILTER_WIDTH    ((u32)0x00000004)

#define MAC_HW_HTP_RESPONSE_CTRL_CS_EVALUATION_WINDOW_RST    0x8
#define MAC_HW_HTP_RESPONSE_CTRL_CCA_20_BUSY_FILTER_RST    0x0

static inline void mac_hw_htp_response_ctrl_pack(struct cl_chip *chip, u8 cs_evaluation_window, u8 cca_20_busy_filter)
{
	ASSERT_ERR_CHIP((((u32)cs_evaluation_window << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)cca_20_busy_filter << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR, ((u32)cs_evaluation_window << 4) | ((u32)cca_20_busy_filter << 0));
}

static inline void mac_hw_htp_response_ctrl_unpack(struct cl_chip *chip, u8 *cs_evaluation_window, u8 *cca_20_busy_filter)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR);

	*cs_evaluation_window = (local_val & ((u32)0x000000F0)) >> 4;
	*cca_20_busy_filter = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_htp_response_ctrl_cs_evaluation_window_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_htp_response_ctrl_cs_evaluation_window_setf(struct cl_chip *chip, u8 csevaluationwindow)
{
	ASSERT_ERR_CHIP((((u32)csevaluationwindow << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR) & ~((u32)0x000000F0)) | ((u32)csevaluationwindow << 4));
}

static inline u8 mac_hw_htp_response_ctrl_cca_20_busy_filter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_htp_response_ctrl_cca_20_busy_filter_setf(struct cl_chip *chip, u8 cca20busyfilter)
{
	ASSERT_ERR_CHIP((((u32)cca20busyfilter << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_HTP_RESPONSE_CTRL_ADDR) & ~((u32)0x0000000F)) | ((u32)cca20busyfilter << 0));
}

/**
 * @brief RX_TRIG_INFO_1 register definition
 *  Holds the trigger frames common_info[31_0] register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_1            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000180)
#define MAC_HW_RX_TRIG_INFO_1_OFFSET      0x00000180
#define MAC_HW_RX_TRIG_INFO_1_INDEX       0x00000060
#define MAC_HW_RX_TRIG_INFO_1_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_1_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_1_RX_TRIG_INFO_1_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_1_RX_TRIG_INFO_1_LSB    0
#define MAC_HW_RX_TRIG_INFO_1_RX_TRIG_INFO_1_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_1_RX_TRIG_INFO_1_RST    0x0

static inline u32 mac_hw_rx_trig_info_1_rx_trig_info_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_1_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_2 register definition
 *  Holds the trigger frames common_info[63_32 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_2            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000184)
#define MAC_HW_RX_TRIG_INFO_2_OFFSET      0x00000184
#define MAC_HW_RX_TRIG_INFO_2_INDEX       0x00000061
#define MAC_HW_RX_TRIG_INFO_2_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_2_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_2_RX_TRIG_INFO_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_2_RX_TRIG_INFO_2_LSB    0
#define MAC_HW_RX_TRIG_INFO_2_RX_TRIG_INFO_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_2_RX_TRIG_INFO_2_RST    0x0

static inline u32 mac_hw_rx_trig_info_2_rx_trig_info_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_2_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_3 register definition
 *  Holds the trigger frames user_info[31_0] register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_3            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000188)
#define MAC_HW_RX_TRIG_INFO_3_OFFSET      0x00000188
#define MAC_HW_RX_TRIG_INFO_3_INDEX       0x00000062
#define MAC_HW_RX_TRIG_INFO_3_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_3_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_3_RX_TRIG_INFO_3_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_3_RX_TRIG_INFO_3_LSB    0
#define MAC_HW_RX_TRIG_INFO_3_RX_TRIG_INFO_3_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_3_RX_TRIG_INFO_3_RST    0x0

static inline u32 mac_hw_rx_trig_info_3_rx_trig_info_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_3_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_4 register definition
 *  Holds the trigger frames user_info[63_32] register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_4            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000018C)
#define MAC_HW_RX_TRIG_INFO_4_OFFSET      0x0000018C
#define MAC_HW_RX_TRIG_INFO_4_INDEX       0x00000063
#define MAC_HW_RX_TRIG_INFO_4_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_4_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_4_RX_TRIG_INFO_4_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_4_RX_TRIG_INFO_4_LSB    0
#define MAC_HW_RX_TRIG_INFO_4_RX_TRIG_INFO_4_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_4_RX_TRIG_INFO_4_RST    0x0

static inline u32 mac_hw_rx_trig_info_4_rx_trig_info_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_4_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_5 register definition
 *  Holds the latest PPDU RX VECTOR_1 31_0 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_5            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000190)
#define MAC_HW_RX_TRIG_INFO_5_OFFSET      0x00000190
#define MAC_HW_RX_TRIG_INFO_5_INDEX       0x00000064
#define MAC_HW_RX_TRIG_INFO_5_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_5_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_5_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_5_RX_TRIG_INFO_5_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_5_RX_TRIG_INFO_5_LSB    0
#define MAC_HW_RX_TRIG_INFO_5_RX_TRIG_INFO_5_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_5_RX_TRIG_INFO_5_RST    0x0

static inline u32 mac_hw_rx_trig_info_5_rx_trig_info_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_5_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_6 register definition
 *  Holds the latest PPDU RX VECTOR_1 63_32 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_6            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_6_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000194)
#define MAC_HW_RX_TRIG_INFO_6_OFFSET      0x00000194
#define MAC_HW_RX_TRIG_INFO_6_INDEX       0x00000065
#define MAC_HW_RX_TRIG_INFO_6_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_6_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_6_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_6_RX_TRIG_INFO_6_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_6_RX_TRIG_INFO_6_LSB    0
#define MAC_HW_RX_TRIG_INFO_6_RX_TRIG_INFO_6_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_6_RX_TRIG_INFO_6_RST    0x0

static inline u32 mac_hw_rx_trig_info_6_rx_trig_info_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_6_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_7 register definition
 *  Holds the latest PPDU RX VECTOR_1 95_64 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_7            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_7_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000198)
#define MAC_HW_RX_TRIG_INFO_7_OFFSET      0x00000198
#define MAC_HW_RX_TRIG_INFO_7_INDEX       0x00000066
#define MAC_HW_RX_TRIG_INFO_7_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_7_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_7_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_7_RX_TRIG_INFO_7_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_7_RX_TRIG_INFO_7_LSB    0
#define MAC_HW_RX_TRIG_INFO_7_RX_TRIG_INFO_7_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_7_RX_TRIG_INFO_7_RST    0x0

static inline u32 mac_hw_rx_trig_info_7_rx_trig_info_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_7_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_8 register definition
 *  Holds the latest PPDU RX VECTOR_1 127_96 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_8            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_8_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000019C)
#define MAC_HW_RX_TRIG_INFO_8_OFFSET      0x0000019C
#define MAC_HW_RX_TRIG_INFO_8_INDEX       0x00000067
#define MAC_HW_RX_TRIG_INFO_8_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_8_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_8_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_8_RX_TRIG_INFO_8_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_8_RX_TRIG_INFO_8_LSB    0
#define MAC_HW_RX_TRIG_INFO_8_RX_TRIG_INFO_8_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_8_RX_TRIG_INFO_8_RST    0x0

static inline u32 mac_hw_rx_trig_info_8_rx_trig_info_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_8_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_9 register definition
 *  Holds the latest PPDU RX VECTOR_1 159_128 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_9            0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_9_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001A0)
#define MAC_HW_RX_TRIG_INFO_9_OFFSET      0x000001A0
#define MAC_HW_RX_TRIG_INFO_9_INDEX       0x00000068
#define MAC_HW_RX_TRIG_INFO_9_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_9_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_9_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_9_RX_TRIG_INFO_9_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_9_RX_TRIG_INFO_9_LSB    0
#define MAC_HW_RX_TRIG_INFO_9_RX_TRIG_INFO_9_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_9_RX_TRIG_INFO_9_RST    0x0

static inline u32 mac_hw_rx_trig_info_9_rx_trig_info_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_9_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_10 register definition
 *  Holds the latest PPDU RX VECTOR_1 191_160 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_10           0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_10_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001A4)
#define MAC_HW_RX_TRIG_INFO_10_OFFSET      0x000001A4
#define MAC_HW_RX_TRIG_INFO_10_INDEX       0x00000069
#define MAC_HW_RX_TRIG_INFO_10_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_10_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_10_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_10_RX_TRIG_INFO_10_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_10_RX_TRIG_INFO_10_LSB    0
#define MAC_HW_RX_TRIG_INFO_10_RX_TRIG_INFO_10_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_10_RX_TRIG_INFO_10_RST    0x0

static inline u32 mac_hw_rx_trig_info_10_rx_trig_info_10_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_10_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_11 register definition
 *  Holds the latest PPDU RX VECTOR_1 223_192 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_11           0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_11_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001A8)
#define MAC_HW_RX_TRIG_INFO_11_OFFSET      0x000001A8
#define MAC_HW_RX_TRIG_INFO_11_INDEX       0x0000006A
#define MAC_HW_RX_TRIG_INFO_11_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_11_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_11_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_11_RX_TRIG_INFO_11_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_11_RX_TRIG_INFO_11_LSB    0
#define MAC_HW_RX_TRIG_INFO_11_RX_TRIG_INFO_11_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_11_RX_TRIG_INFO_11_RST    0x0

static inline u32 mac_hw_rx_trig_info_11_rx_trig_info_11_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_11_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_TRIG_INFO_12 register definition
 *  Holds the latest PPDU RX VECTOR_1 255_224 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_TRIG_INFO_12           0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_12_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001AC)
#define MAC_HW_RX_TRIG_INFO_12_OFFSET      0x000001AC
#define MAC_HW_RX_TRIG_INFO_12_INDEX       0x0000006B
#define MAC_HW_RX_TRIG_INFO_12_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_12_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_12_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_12_RX_TRIG_INFO_12_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_TRIG_INFO_12_RX_TRIG_INFO_12_LSB    0
#define MAC_HW_RX_TRIG_INFO_12_RX_TRIG_INFO_12_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_TRIG_INFO_12_RX_TRIG_INFO_12_RST    0x0

static inline u32 mac_hw_rx_trig_info_12_rx_trig_info_12_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_12_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_RESP_STATUS_1 register definition
 *  Holds status of the PPDU that is soliciting the register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    26    INTRA_BSS_TXOP_HOLDER_MATCH 0
 *    25    TXOP_HOLDER_MATCH         0
 *    24    KSR_ID_VALID              0
 *    23:16 KSR_ID                    0x0
 *    11:08 TRIGGER_TYPE              0x0
 *    05:02 FRAME_SUB_TYPE            0x0
 *    01:00 FRAME_TYPE                0x0
 * </pre>
 */
#define MAC_HW_RX_RESP_STATUS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001B0)
#define MAC_HW_RX_RESP_STATUS_1_OFFSET      0x000001B0
#define MAC_HW_RX_RESP_STATUS_1_INDEX       0x0000006C
#define MAC_HW_RX_RESP_STATUS_1_RESET       0x00000000

static inline u32 mac_hw_rx_resp_status_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_RESP_STATUS_1_INTRA_BSS_TXOP_HOLDER_MATCH_BIT    ((u32)0x04000000)
#define MAC_HW_RX_RESP_STATUS_1_INTRA_BSS_TXOP_HOLDER_MATCH_POS    26
#define MAC_HW_RX_RESP_STATUS_1_TXOP_HOLDER_MATCH_BIT    ((u32)0x02000000)
#define MAC_HW_RX_RESP_STATUS_1_TXOP_HOLDER_MATCH_POS    25
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_VALID_BIT    ((u32)0x01000000)
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_VALID_POS    24
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_MASK    ((u32)0x00FF0000)
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_LSB    16
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESP_STATUS_1_TRIGGER_TYPE_MASK    ((u32)0x00000F00)
#define MAC_HW_RX_RESP_STATUS_1_TRIGGER_TYPE_LSB    8
#define MAC_HW_RX_RESP_STATUS_1_TRIGGER_TYPE_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESP_STATUS_1_FRAME_SUB_TYPE_MASK    ((u32)0x0000003C)
#define MAC_HW_RX_RESP_STATUS_1_FRAME_SUB_TYPE_LSB    2
#define MAC_HW_RX_RESP_STATUS_1_FRAME_SUB_TYPE_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESP_STATUS_1_FRAME_TYPE_MASK    ((u32)0x00000003)
#define MAC_HW_RX_RESP_STATUS_1_FRAME_TYPE_LSB    0
#define MAC_HW_RX_RESP_STATUS_1_FRAME_TYPE_WIDTH    ((u32)0x00000002)

#define MAC_HW_RX_RESP_STATUS_1_INTRA_BSS_TXOP_HOLDER_MATCH_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_TXOP_HOLDER_MATCH_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_VALID_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_KSR_ID_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_TRIGGER_TYPE_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_FRAME_SUB_TYPE_RST    0x0
#define MAC_HW_RX_RESP_STATUS_1_FRAME_TYPE_RST    0x0

static inline void mac_hw_rx_resp_status_1_unpack(struct cl_chip *chip, u8 *intra_bss_txop_holder_match, u8 *txop_holder_match, u8 *ksr_id_valid, u8 *ksr_id, u8 *trigger_type, u8 *frame_sub_type, u8 *frame_type)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	*intra_bss_txop_holder_match = (local_val & ((u32)0x04000000)) >> 26;
	*txop_holder_match = (local_val & ((u32)0x02000000)) >> 25;
	*ksr_id_valid = (local_val & ((u32)0x01000000)) >> 24;
	*ksr_id = (local_val & ((u32)0x00FF0000)) >> 16;
	*trigger_type = (local_val & ((u32)0x00000F00)) >> 8;
	*frame_sub_type = (local_val & ((u32)0x0000003C)) >> 2;
	*frame_type = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_rx_resp_status_1_intra_bss_txop_holder_match_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_rx_resp_status_1_txop_holder_match_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_rx_resp_status_1_ksr_id_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_rx_resp_status_1_ksr_id_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline u8 mac_hw_rx_resp_status_1_trigger_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline u8 mac_hw_rx_resp_status_1_frame_sub_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x0000003C)) >> 2);
}

static inline u8 mac_hw_rx_resp_status_1_frame_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

/**
 * @brief RX_RESP_STATUS_2 register definition
 *  Holds information about the required response register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 BA_LENGTH                 0x14
 *    11:08 ARSN                      0x0
 *    07:04 RESP_TYPE                 0x0
 *    03:02 AVAILABLE_BW              0x0
 *    01    TRIGGER_FCS_OK            0
 *    00    RESPONSE_REQUIRED         0
 * </pre>
 */
#define MAC_HW_RX_RESP_STATUS_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001B4)
#define MAC_HW_RX_RESP_STATUS_2_OFFSET      0x000001B4
#define MAC_HW_RX_RESP_STATUS_2_INDEX       0x0000006D
#define MAC_HW_RX_RESP_STATUS_2_RESET       0x00140000

static inline u32 mac_hw_rx_resp_status_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_RESP_STATUS_2_BA_LENGTH_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_RESP_STATUS_2_BA_LENGTH_LSB    16
#define MAC_HW_RX_RESP_STATUS_2_BA_LENGTH_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_RESP_STATUS_2_ARSN_MASK    ((u32)0x00000F00)
#define MAC_HW_RX_RESP_STATUS_2_ARSN_LSB    8
#define MAC_HW_RX_RESP_STATUS_2_ARSN_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESP_STATUS_2_RESP_TYPE_MASK    ((u32)0x000000F0)
#define MAC_HW_RX_RESP_STATUS_2_RESP_TYPE_LSB    4
#define MAC_HW_RX_RESP_STATUS_2_RESP_TYPE_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESP_STATUS_2_AVAILABLE_BW_MASK    ((u32)0x0000000C)
#define MAC_HW_RX_RESP_STATUS_2_AVAILABLE_BW_LSB    2
#define MAC_HW_RX_RESP_STATUS_2_AVAILABLE_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESP_STATUS_2_TRIGGER_FCS_OK_BIT    ((u32)0x00000002)
#define MAC_HW_RX_RESP_STATUS_2_TRIGGER_FCS_OK_POS    1
#define MAC_HW_RX_RESP_STATUS_2_RESPONSE_REQUIRED_BIT    ((u32)0x00000001)
#define MAC_HW_RX_RESP_STATUS_2_RESPONSE_REQUIRED_POS    0

#define MAC_HW_RX_RESP_STATUS_2_BA_LENGTH_RST    0x14
#define MAC_HW_RX_RESP_STATUS_2_ARSN_RST    0x0
#define MAC_HW_RX_RESP_STATUS_2_RESP_TYPE_RST    0x0
#define MAC_HW_RX_RESP_STATUS_2_AVAILABLE_BW_RST    0x0
#define MAC_HW_RX_RESP_STATUS_2_TRIGGER_FCS_OK_RST    0x0
#define MAC_HW_RX_RESP_STATUS_2_RESPONSE_REQUIRED_RST    0x0

static inline void mac_hw_rx_resp_status_2_unpack(struct cl_chip *chip, u16 *ba_length, u8 *arsn, u8 *resp_type, u8 *available_bw, u8 *trigger_fcs_ok, u8 *response_required)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	*ba_length = (local_val & ((u32)0xFFFF0000)) >> 16;
	*arsn = (local_val & ((u32)0x00000F00)) >> 8;
	*resp_type = (local_val & ((u32)0x000000F0)) >> 4;
	*available_bw = (local_val & ((u32)0x0000000C)) >> 2;
	*trigger_fcs_ok = (local_val & ((u32)0x00000002)) >> 1;
	*response_required = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u16 mac_hw_rx_resp_status_2_ba_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u8 mac_hw_rx_resp_status_2_arsn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline u8 mac_hw_rx_resp_status_2_resp_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline u8 mac_hw_rx_resp_status_2_available_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline u8 mac_hw_rx_resp_status_2_trigger_fcs_ok_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_rx_resp_status_2_response_required_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESP_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief RX_TRIG_INFO_13 register definition
 *  Holds the fields extracted from the trigger frame register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07    PE_DISAMBIGUITY           0
 *    06    FEC_CODING_TYPE           0
 *    05:04 PRE_FEC_PADDING_FACTOR    0x0
 *    03    LDPC_EXTRA_SYMBOL         0
 *    02:00 NUM_LTF_SYMBOLS           0x0
 * </pre>
 */
#define MAC_HW_RX_TRIG_INFO_13_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001B8)
#define MAC_HW_RX_TRIG_INFO_13_OFFSET      0x000001B8
#define MAC_HW_RX_TRIG_INFO_13_INDEX       0x0000006E
#define MAC_HW_RX_TRIG_INFO_13_RESET       0x00000000

static inline u32 mac_hw_rx_trig_info_13_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_TRIG_INFO_13_PE_DISAMBIGUITY_BIT    ((u32)0x00000080)
#define MAC_HW_RX_TRIG_INFO_13_PE_DISAMBIGUITY_POS    7
#define MAC_HW_RX_TRIG_INFO_13_FEC_CODING_TYPE_BIT    ((u32)0x00000040)
#define MAC_HW_RX_TRIG_INFO_13_FEC_CODING_TYPE_POS    6
#define MAC_HW_RX_TRIG_INFO_13_PRE_FEC_PADDING_FACTOR_MASK    ((u32)0x00000030)
#define MAC_HW_RX_TRIG_INFO_13_PRE_FEC_PADDING_FACTOR_LSB    4
#define MAC_HW_RX_TRIG_INFO_13_PRE_FEC_PADDING_FACTOR_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_TRIG_INFO_13_LDPC_EXTRA_SYMBOL_BIT    ((u32)0x00000008)
#define MAC_HW_RX_TRIG_INFO_13_LDPC_EXTRA_SYMBOL_POS    3
#define MAC_HW_RX_TRIG_INFO_13_NUM_LTF_SYMBOLS_MASK    ((u32)0x00000007)
#define MAC_HW_RX_TRIG_INFO_13_NUM_LTF_SYMBOLS_LSB    0
#define MAC_HW_RX_TRIG_INFO_13_NUM_LTF_SYMBOLS_WIDTH    ((u32)0x00000003)

#define MAC_HW_RX_TRIG_INFO_13_PE_DISAMBIGUITY_RST    0x0
#define MAC_HW_RX_TRIG_INFO_13_FEC_CODING_TYPE_RST    0x0
#define MAC_HW_RX_TRIG_INFO_13_PRE_FEC_PADDING_FACTOR_RST    0x0
#define MAC_HW_RX_TRIG_INFO_13_LDPC_EXTRA_SYMBOL_RST    0x0
#define MAC_HW_RX_TRIG_INFO_13_NUM_LTF_SYMBOLS_RST    0x0

static inline void mac_hw_rx_trig_info_13_unpack(struct cl_chip *chip, u8 *pe_disambiguity, u8 *fec_coding_type, u8 *pre_fec_padding_factor, u8 *ldpc_extra_symbol, u8 *num_ltf_symbols)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	*pe_disambiguity = (local_val & ((u32)0x00000080)) >> 7;
	*fec_coding_type = (local_val & ((u32)0x00000040)) >> 6;
	*pre_fec_padding_factor = (local_val & ((u32)0x00000030)) >> 4;
	*ldpc_extra_symbol = (local_val & ((u32)0x00000008)) >> 3;
	*num_ltf_symbols = (local_val & ((u32)0x00000007)) >> 0;
}

static inline u8 mac_hw_rx_trig_info_13_pe_disambiguity_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_rx_trig_info_13_fec_coding_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_rx_trig_info_13_pre_fec_padding_factor_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline u8 mac_hw_rx_trig_info_13_ldpc_extra_symbol_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_rx_trig_info_13_num_ltf_symbols_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_TRIG_INFO_13_ADDR);

	return (u8)((local_val & ((u32)0x00000007)) >> 0);
}

/**
 * @brief RX_RESPONSE_PARAMS_1 register definition
 *  RX  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:24 ARSN                      0xE
 *    23:16 UPH                       0x0
 *    15:10 GROUP_VALID_FUTURE        0x0
 *    09:00 GROUP_VALID               0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001C0)
#define MAC_HW_RX_RESPONSE_PARAMS_1_OFFSET      0x000001C0
#define MAC_HW_RX_RESPONSE_PARAMS_1_INDEX       0x00000070
#define MAC_HW_RX_RESPONSE_PARAMS_1_RESET       0x0E000000

static inline u32 mac_hw_rx_response_params_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);
}

static inline void mac_hw_rx_response_params_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_1_ARSN_MASK    ((u32)0x0F000000)
#define MAC_HW_RX_RESPONSE_PARAMS_1_ARSN_LSB    24
#define MAC_HW_RX_RESPONSE_PARAMS_1_ARSN_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESPONSE_PARAMS_1_UPH_MASK    ((u32)0x00FF0000)
#define MAC_HW_RX_RESPONSE_PARAMS_1_UPH_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_1_UPH_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_FUTURE_MASK    ((u32)0x0000FC00)
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_FUTURE_LSB    10
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_FUTURE_WIDTH    ((u32)0x00000006)
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_MASK    ((u32)0x000003FF)
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_WIDTH    ((u32)0x0000000A)

#define MAC_HW_RX_RESPONSE_PARAMS_1_ARSN_RST    0xE
#define MAC_HW_RX_RESPONSE_PARAMS_1_UPH_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_FUTURE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_1_GROUP_VALID_RST    0x0

static inline void mac_hw_rx_response_params_1_pack(struct cl_chip *chip, u8 arsn, u8 uph, u8 group_valid_future, u16 group_valid)
{
	ASSERT_ERR_CHIP((((u32)arsn << 24) & ~((u32)0x0F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)uph << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)group_valid_future << 10) & ~((u32)0x0000FC00)) == 0);
	ASSERT_ERR_CHIP((((u32)group_valid << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, ((u32)arsn << 24) | ((u32)uph << 16) | ((u32)group_valid_future << 10) | ((u32)group_valid << 0));
}

static inline void mac_hw_rx_response_params_1_unpack(struct cl_chip *chip, u8 *arsn, u8 *uph, u8 *group_valid_future, u16 *group_valid)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);

	*arsn = (local_val & ((u32)0x0F000000)) >> 24;
	*uph = (local_val & ((u32)0x00FF0000)) >> 16;
	*group_valid_future = (local_val & ((u32)0x0000FC00)) >> 10;
	*group_valid = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_1_arsn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);

	return (u8)((local_val & ((u32)0x0F000000)) >> 24);
}

static inline void mac_hw_rx_response_params_1_arsn_setf(struct cl_chip *chip, u8 arsn)
{
	ASSERT_ERR_CHIP((((u32)arsn << 24) & ~((u32)0x0F000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR) & ~((u32)0x0F000000)) | ((u32)arsn << 24));
}

static inline u8 mac_hw_rx_response_params_1_uph_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_rx_response_params_1_uph_setf(struct cl_chip *chip, u8 uph)
{
	ASSERT_ERR_CHIP((((u32)uph << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR) & ~((u32)0x00FF0000)) | ((u32)uph << 16));
}

static inline u8 mac_hw_rx_response_params_1_group_valid_future_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);

	return (u8)((local_val & ((u32)0x0000FC00)) >> 10);
}

static inline void mac_hw_rx_response_params_1_group_valid_future_setf(struct cl_chip *chip, u8 groupvalidfuture)
{
	ASSERT_ERR_CHIP((((u32)groupvalidfuture << 10) & ~((u32)0x0000FC00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR) & ~((u32)0x0000FC00)) | ((u32)groupvalidfuture << 10));
}

static inline u16 mac_hw_rx_response_params_1_group_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_rx_response_params_1_group_valid_setf(struct cl_chip *chip, u16 groupvalid)
{
	ASSERT_ERR_CHIP((((u32)groupvalid << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_1_ADDR) & ~((u32)0x000003FF)) | ((u32)groupvalid << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_2 register definition
 *  RX  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 TX_POWER_LEVEL            0x0
 *    20    TRIGGER_RESPONDING        0
 *    19:18 GI_TYPE                   0x0
 *    17    STBC                      0
 *    16    PREAMBLE_TYPE             0
 *    15    FEC_CODING                0
 *    14:08 MCS                       0x0
 *    07:04 LEG_RATE                  0x0
 *    03:00 FORMAT_MOD                0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001C4)
#define MAC_HW_RX_RESPONSE_PARAMS_2_OFFSET      0x000001C4
#define MAC_HW_RX_RESPONSE_PARAMS_2_INDEX       0x00000071
#define MAC_HW_RX_RESPONSE_PARAMS_2_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);
}

static inline void mac_hw_rx_response_params_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_2_TX_POWER_LEVEL_MASK    ((u32)0xFF000000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_TX_POWER_LEVEL_LSB    24
#define MAC_HW_RX_RESPONSE_PARAMS_2_TX_POWER_LEVEL_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESPONSE_PARAMS_2_TRIGGER_RESPONDING_BIT    ((u32)0x00100000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_TRIGGER_RESPONDING_POS    20
#define MAC_HW_RX_RESPONSE_PARAMS_2_GI_TYPE_MASK    ((u32)0x000C0000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_GI_TYPE_LSB    18
#define MAC_HW_RX_RESPONSE_PARAMS_2_GI_TYPE_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_2_STBC_BIT    ((u32)0x00020000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_STBC_POS    17
#define MAC_HW_RX_RESPONSE_PARAMS_2_PREAMBLE_TYPE_BIT    ((u32)0x00010000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_PREAMBLE_TYPE_POS    16
#define MAC_HW_RX_RESPONSE_PARAMS_2_FEC_CODING_BIT    ((u32)0x00008000)
#define MAC_HW_RX_RESPONSE_PARAMS_2_FEC_CODING_POS    15
#define MAC_HW_RX_RESPONSE_PARAMS_2_MCS_MASK    ((u32)0x00007F00)
#define MAC_HW_RX_RESPONSE_PARAMS_2_MCS_LSB    8
#define MAC_HW_RX_RESPONSE_PARAMS_2_MCS_WIDTH    ((u32)0x00000007)
#define MAC_HW_RX_RESPONSE_PARAMS_2_LEG_RATE_MASK    ((u32)0x000000F0)
#define MAC_HW_RX_RESPONSE_PARAMS_2_LEG_RATE_LSB    4
#define MAC_HW_RX_RESPONSE_PARAMS_2_LEG_RATE_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESPONSE_PARAMS_2_FORMAT_MOD_MASK    ((u32)0x0000000F)
#define MAC_HW_RX_RESPONSE_PARAMS_2_FORMAT_MOD_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_2_FORMAT_MOD_WIDTH    ((u32)0x00000004)

#define MAC_HW_RX_RESPONSE_PARAMS_2_TX_POWER_LEVEL_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_TRIGGER_RESPONDING_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_GI_TYPE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_STBC_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_PREAMBLE_TYPE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_FEC_CODING_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_MCS_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_LEG_RATE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_2_FORMAT_MOD_RST    0x0

static inline void mac_hw_rx_response_params_2_pack(struct cl_chip *chip, u8 tx_power_level, u8 trigger_responding, u8 gi_type, u8 stbc, u8 preamble_type, u8 fec_coding, u8 mcs, u8 leg_rate, u8 format_mod)
{
	ASSERT_ERR_CHIP((((u32)tx_power_level << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)trigger_responding << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)gi_type << 18) & ~((u32)0x000C0000)) == 0);
	ASSERT_ERR_CHIP((((u32)stbc << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)preamble_type << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)fec_coding << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)mcs << 8) & ~((u32)0x00007F00)) == 0);
	ASSERT_ERR_CHIP((((u32)leg_rate << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)format_mod << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, ((u32)tx_power_level << 24) | ((u32)trigger_responding << 20) | ((u32)gi_type << 18) | ((u32)stbc << 17) | ((u32)preamble_type << 16) | ((u32)fec_coding << 15) | ((u32)mcs << 8) | ((u32)leg_rate << 4) | ((u32)format_mod << 0));
}

static inline void mac_hw_rx_response_params_2_unpack(struct cl_chip *chip, u8 *tx_power_level, u8 *trigger_responding, u8 *gi_type, u8 *stbc, u8 *preamble_type, u8 *fec_coding, u8 *mcs, u8 *leg_rate, u8 *format_mod)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	*tx_power_level = (local_val & ((u32)0xFF000000)) >> 24;
	*trigger_responding = (local_val & ((u32)0x00100000)) >> 20;
	*gi_type = (local_val & ((u32)0x000C0000)) >> 18;
	*stbc = (local_val & ((u32)0x00020000)) >> 17;
	*preamble_type = (local_val & ((u32)0x00010000)) >> 16;
	*fec_coding = (local_val & ((u32)0x00008000)) >> 15;
	*mcs = (local_val & ((u32)0x00007F00)) >> 8;
	*leg_rate = (local_val & ((u32)0x000000F0)) >> 4;
	*format_mod = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_rx_response_params_2_tx_power_level_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_rx_response_params_2_tx_power_level_setf(struct cl_chip *chip, u8 txpowerlevel)
{
	ASSERT_ERR_CHIP((((u32)txpowerlevel << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0xFF000000)) | ((u32)txpowerlevel << 24));
}

static inline u8 mac_hw_rx_response_params_2_trigger_responding_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_response_params_2_trigger_responding_setf(struct cl_chip *chip, u8 triggerresponding)
{
	ASSERT_ERR_CHIP((((u32)triggerresponding << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x00100000)) | ((u32)triggerresponding << 20));
}

static inline u8 mac_hw_rx_response_params_2_gi_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x000C0000)) >> 18);
}

static inline void mac_hw_rx_response_params_2_gi_type_setf(struct cl_chip *chip, u8 gitype)
{
	ASSERT_ERR_CHIP((((u32)gitype << 18) & ~((u32)0x000C0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x000C0000)) | ((u32)gitype << 18));
}

static inline u8 mac_hw_rx_response_params_2_stbc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_rx_response_params_2_stbc_setf(struct cl_chip *chip, u8 stbc)
{
	ASSERT_ERR_CHIP((((u32)stbc << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x00020000)) | ((u32)stbc << 17));
}

static inline u8 mac_hw_rx_response_params_2_preamble_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_response_params_2_preamble_type_setf(struct cl_chip *chip, u8 preambletype)
{
	ASSERT_ERR_CHIP((((u32)preambletype << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x00010000)) | ((u32)preambletype << 16));
}

static inline u8 mac_hw_rx_response_params_2_fec_coding_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_rx_response_params_2_fec_coding_setf(struct cl_chip *chip, u8 feccoding)
{
	ASSERT_ERR_CHIP((((u32)feccoding << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x00008000)) | ((u32)feccoding << 15));
}

static inline u8 mac_hw_rx_response_params_2_mcs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x00007F00)) >> 8);
}

static inline void mac_hw_rx_response_params_2_mcs_setf(struct cl_chip *chip, u8 mcs)
{
	ASSERT_ERR_CHIP((((u32)mcs << 8) & ~((u32)0x00007F00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x00007F00)) | ((u32)mcs << 8));
}

static inline u8 mac_hw_rx_response_params_2_leg_rate_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_rx_response_params_2_leg_rate_setf(struct cl_chip *chip, u8 legrate)
{
	ASSERT_ERR_CHIP((((u32)legrate << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x000000F0)) | ((u32)legrate << 4));
}

static inline u8 mac_hw_rx_response_params_2_format_mod_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_rx_response_params_2_format_mod_setf(struct cl_chip *chip, u8 formatmod)
{
	ASSERT_ERR_CHIP((((u32)formatmod << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_2_ADDR) & ~((u32)0x0000000F)) | ((u32)formatmod << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_3 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    17:16 CH_BW                     0x0
 *    15:00 SERVICE                   0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001C8)
#define MAC_HW_RX_RESPONSE_PARAMS_3_OFFSET      0x000001C8
#define MAC_HW_RX_RESPONSE_PARAMS_3_INDEX       0x00000072
#define MAC_HW_RX_RESPONSE_PARAMS_3_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR);
}

static inline void mac_hw_rx_response_params_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_3_CH_BW_MASK    ((u32)0x00030000)
#define MAC_HW_RX_RESPONSE_PARAMS_3_CH_BW_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_3_CH_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_3_SERVICE_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_RESPONSE_PARAMS_3_SERVICE_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_3_SERVICE_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_RESPONSE_PARAMS_3_CH_BW_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_3_SERVICE_RST    0x0

static inline void mac_hw_rx_response_params_3_pack(struct cl_chip *chip, u8 ch_bw, u16 service)
{
	ASSERT_ERR_CHIP((((u32)ch_bw << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)service << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR, ((u32)ch_bw << 16) | ((u32)service << 0));
}

static inline void mac_hw_rx_response_params_3_unpack(struct cl_chip *chip, u8 *ch_bw, u16 *service)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR);

	*ch_bw = (local_val & ((u32)0x00030000)) >> 16;
	*service = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_3_ch_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_rx_response_params_3_ch_bw_setf(struct cl_chip *chip, u8 chbw)
{
	ASSERT_ERR_CHIP((((u32)chbw << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR) & ~((u32)0x00030000)) | ((u32)chbw << 16));
}

static inline u16 mac_hw_rx_response_params_3_service_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_response_params_3_service_setf(struct cl_chip *chip, u16 service)
{
	ASSERT_ERR_CHIP((((u32)service << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_3_ADDR) & ~((u32)0x0000FFFF)) | ((u32)service << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_4 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    TXOP_DURATION_VALID       0
 *    30:24 TXOP_DURATION             0x0
 *    17:16 MAX_PE_DURATION           0x0
 *    15    UPLINK                    0
 *    14    DOPPLER                   0
 *    13    BEAM_CHANGE               0
 *    12    DCM                       0
 *    11:08 SPATIAL_REUSE_HE_SU       0x0
 *    07:06 LTF_TYPE                  0x0
 *    05:00 BSS_COLOR                 0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001CC)
#define MAC_HW_RX_RESPONSE_PARAMS_4_OFFSET      0x000001CC
#define MAC_HW_RX_RESPONSE_PARAMS_4_INDEX       0x00000073
#define MAC_HW_RX_RESPONSE_PARAMS_4_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);
}

static inline void mac_hw_rx_response_params_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_VALID_BIT    ((u32)0x80000000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_VALID_POS    31
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_MASK    ((u32)0x7F000000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_LSB    24
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_WIDTH    ((u32)0x00000007)
#define MAC_HW_RX_RESPONSE_PARAMS_4_MAX_PE_DURATION_MASK    ((u32)0x00030000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_MAX_PE_DURATION_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_4_MAX_PE_DURATION_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_4_UPLINK_BIT    ((u32)0x00008000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_UPLINK_POS    15
#define MAC_HW_RX_RESPONSE_PARAMS_4_DOPPLER_BIT    ((u32)0x00004000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_DOPPLER_POS    14
#define MAC_HW_RX_RESPONSE_PARAMS_4_BEAM_CHANGE_BIT    ((u32)0x00002000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_BEAM_CHANGE_POS    13
#define MAC_HW_RX_RESPONSE_PARAMS_4_DCM_BIT    ((u32)0x00001000)
#define MAC_HW_RX_RESPONSE_PARAMS_4_DCM_POS    12
#define MAC_HW_RX_RESPONSE_PARAMS_4_SPATIAL_REUSE_HE_SU_MASK    ((u32)0x00000F00)
#define MAC_HW_RX_RESPONSE_PARAMS_4_SPATIAL_REUSE_HE_SU_LSB    8
#define MAC_HW_RX_RESPONSE_PARAMS_4_SPATIAL_REUSE_HE_SU_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_RESPONSE_PARAMS_4_LTF_TYPE_MASK    ((u32)0x000000C0)
#define MAC_HW_RX_RESPONSE_PARAMS_4_LTF_TYPE_LSB    6
#define MAC_HW_RX_RESPONSE_PARAMS_4_LTF_TYPE_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_4_BSS_COLOR_MASK    ((u32)0x0000003F)
#define MAC_HW_RX_RESPONSE_PARAMS_4_BSS_COLOR_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_4_BSS_COLOR_WIDTH    ((u32)0x00000006)

#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_VALID_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_TXOP_DURATION_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_MAX_PE_DURATION_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_UPLINK_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_DOPPLER_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_BEAM_CHANGE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_DCM_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_SPATIAL_REUSE_HE_SU_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_LTF_TYPE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_4_BSS_COLOR_RST    0x0

static inline void mac_hw_rx_response_params_4_pack(struct cl_chip *chip, u8 txop_duration_valid, u8 txop_duration, u8 max_pe_duration, u8 uplink, u8 doppler, u8 beam_change, u8 dcm, u8 spatial_reuse_he_su, u8 ltf_type, u8 bss_color)
{
	ASSERT_ERR_CHIP((((u32)txop_duration_valid << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_duration << 24) & ~((u32)0x7F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)max_pe_duration << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)uplink << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)doppler << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)beam_change << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)dcm << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)spatial_reuse_he_su << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)ltf_type << 6) & ~((u32)0x000000C0)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_color << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, ((u32)txop_duration_valid << 31) | ((u32)txop_duration << 24) | ((u32)max_pe_duration << 16) | ((u32)uplink << 15) | ((u32)doppler << 14) | ((u32)beam_change << 13) | ((u32)dcm << 12) | ((u32)spatial_reuse_he_su << 8) | ((u32)ltf_type << 6) | ((u32)bss_color << 0));
}

static inline void mac_hw_rx_response_params_4_unpack(struct cl_chip *chip, u8 *txop_duration_valid, u8 *txop_duration, u8 *max_pe_duration, u8 *uplink, u8 *doppler, u8 *beam_change, u8 *dcm, u8 *spatial_reuse_he_su, u8 *ltf_type, u8 *bss_color)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	*txop_duration_valid = (local_val & ((u32)0x80000000)) >> 31;
	*txop_duration = (local_val & ((u32)0x7F000000)) >> 24;
	*max_pe_duration = (local_val & ((u32)0x00030000)) >> 16;
	*uplink = (local_val & ((u32)0x00008000)) >> 15;
	*doppler = (local_val & ((u32)0x00004000)) >> 14;
	*beam_change = (local_val & ((u32)0x00002000)) >> 13;
	*dcm = (local_val & ((u32)0x00001000)) >> 12;
	*spatial_reuse_he_su = (local_val & ((u32)0x00000F00)) >> 8;
	*ltf_type = (local_val & ((u32)0x000000C0)) >> 6;
	*bss_color = (local_val & ((u32)0x0000003F)) >> 0;
}

static inline u8 mac_hw_rx_response_params_4_txop_duration_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_rx_response_params_4_txop_duration_valid_setf(struct cl_chip *chip, u8 txopdurationvalid)
{
	ASSERT_ERR_CHIP((((u32)txopdurationvalid << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x80000000)) | ((u32)txopdurationvalid << 31));
}

static inline u8 mac_hw_rx_response_params_4_txop_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x7F000000)) >> 24);
}

static inline void mac_hw_rx_response_params_4_txop_duration_setf(struct cl_chip *chip, u8 txopduration)
{
	ASSERT_ERR_CHIP((((u32)txopduration << 24) & ~((u32)0x7F000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x7F000000)) | ((u32)txopduration << 24));
}

static inline u8 mac_hw_rx_response_params_4_max_pe_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_rx_response_params_4_max_pe_duration_setf(struct cl_chip *chip, u8 maxpeduration)
{
	ASSERT_ERR_CHIP((((u32)maxpeduration << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00030000)) | ((u32)maxpeduration << 16));
}

static inline u8 mac_hw_rx_response_params_4_uplink_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_rx_response_params_4_uplink_setf(struct cl_chip *chip, u8 uplink)
{
	ASSERT_ERR_CHIP((((u32)uplink << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00008000)) | ((u32)uplink << 15));
}

static inline u8 mac_hw_rx_response_params_4_doppler_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_rx_response_params_4_doppler_setf(struct cl_chip *chip, u8 doppler)
{
	ASSERT_ERR_CHIP((((u32)doppler << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00004000)) | ((u32)doppler << 14));
}

static inline u8 mac_hw_rx_response_params_4_beam_change_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_rx_response_params_4_beam_change_setf(struct cl_chip *chip, u8 beamchange)
{
	ASSERT_ERR_CHIP((((u32)beamchange << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00002000)) | ((u32)beamchange << 13));
}

static inline u8 mac_hw_rx_response_params_4_dcm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_rx_response_params_4_dcm_setf(struct cl_chip *chip, u8 dcm)
{
	ASSERT_ERR_CHIP((((u32)dcm << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00001000)) | ((u32)dcm << 12));
}

static inline u8 mac_hw_rx_response_params_4_spatial_reuse_he_su_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_rx_response_params_4_spatial_reuse_he_su_setf(struct cl_chip *chip, u8 spatialreusehesu)
{
	ASSERT_ERR_CHIP((((u32)spatialreusehesu << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x00000F00)) | ((u32)spatialreusehesu << 8));
}

static inline u8 mac_hw_rx_response_params_4_ltf_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x000000C0)) >> 6);
}

static inline void mac_hw_rx_response_params_4_ltf_type_setf(struct cl_chip *chip, u8 ltftype)
{
	ASSERT_ERR_CHIP((((u32)ltftype << 6) & ~((u32)0x000000C0)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x000000C0)) | ((u32)ltftype << 6));
}

static inline u8 mac_hw_rx_response_params_4_bss_color_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR);

	return (u8)((local_val & ((u32)0x0000003F)) >> 0);
}

static inline void mac_hw_rx_response_params_4_bss_color_setf(struct cl_chip *chip, u8 bsscolor)
{
	ASSERT_ERR_CHIP((((u32)bsscolor << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_4_ADDR) & ~((u32)0x0000003F)) | ((u32)bsscolor << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_5 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SMM_INDEX                 0x0
 *    23:22 FTM                       0x0
 *    21    DO_IMPLICIT_LEARNING      0
 *    20    SOUNDING                  0
 *    19    SMOOTHING                 0
 *    18    DOZE_NOT_ALLOWED          0
 *    17    AGGREGATION               0
 *    16    NO_SIG_EXTN               0
 *    15    BEAMFORMED                0
 *    14:12 PA_DETECT                 0x0
 *    11:00 LEG_LENGTH                0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001D0)
#define MAC_HW_RX_RESPONSE_PARAMS_5_OFFSET      0x000001D0
#define MAC_HW_RX_RESPONSE_PARAMS_5_INDEX       0x00000074
#define MAC_HW_RX_RESPONSE_PARAMS_5_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_5_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);
}

static inline void mac_hw_rx_response_params_5_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMM_INDEX_MASK    ((u32)0xFF000000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMM_INDEX_LSB    24
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMM_INDEX_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESPONSE_PARAMS_5_FTM_MASK    ((u32)0x00C00000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_FTM_LSB    22
#define MAC_HW_RX_RESPONSE_PARAMS_5_FTM_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_5_DO_IMPLICIT_LEARNING_BIT    ((u32)0x00200000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_DO_IMPLICIT_LEARNING_POS    21
#define MAC_HW_RX_RESPONSE_PARAMS_5_SOUNDING_BIT    ((u32)0x00100000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_SOUNDING_POS    20
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMOOTHING_BIT    ((u32)0x00080000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMOOTHING_POS    19
#define MAC_HW_RX_RESPONSE_PARAMS_5_DOZE_NOT_ALLOWED_BIT    ((u32)0x00040000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_DOZE_NOT_ALLOWED_POS    18
#define MAC_HW_RX_RESPONSE_PARAMS_5_AGGREGATION_BIT    ((u32)0x00020000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_AGGREGATION_POS    17
#define MAC_HW_RX_RESPONSE_PARAMS_5_NO_SIG_EXTN_BIT    ((u32)0x00010000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_NO_SIG_EXTN_POS    16
#define MAC_HW_RX_RESPONSE_PARAMS_5_BEAMFORMED_BIT    ((u32)0x00008000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_BEAMFORMED_POS    15
#define MAC_HW_RX_RESPONSE_PARAMS_5_PA_DETECT_MASK    ((u32)0x00007000)
#define MAC_HW_RX_RESPONSE_PARAMS_5_PA_DETECT_LSB    12
#define MAC_HW_RX_RESPONSE_PARAMS_5_PA_DETECT_WIDTH    ((u32)0x00000003)
#define MAC_HW_RX_RESPONSE_PARAMS_5_LEG_LENGTH_MASK    ((u32)0x00000FFF)
#define MAC_HW_RX_RESPONSE_PARAMS_5_LEG_LENGTH_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_5_LEG_LENGTH_WIDTH    ((u32)0x0000000C)

#define MAC_HW_RX_RESPONSE_PARAMS_5_SMM_INDEX_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_FTM_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_DO_IMPLICIT_LEARNING_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_SOUNDING_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_SMOOTHING_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_DOZE_NOT_ALLOWED_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_AGGREGATION_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_NO_SIG_EXTN_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_BEAMFORMED_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_PA_DETECT_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_5_LEG_LENGTH_RST    0x0

static inline void mac_hw_rx_response_params_5_pack(struct cl_chip *chip, u8 smm_index, u8 ftm, u8 do_implicit_learning, u8 sounding, u8 smoothing, u8 doze_not_allowed, u8 aggregation, u8 no_sig_extn, u8 beamformed, u8 pa_detect, u16 leg_length)
{
	ASSERT_ERR_CHIP((((u32)smm_index << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ftm << 22) & ~((u32)0x00C00000)) == 0);
	ASSERT_ERR_CHIP((((u32)do_implicit_learning << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)sounding << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)smoothing << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)doze_not_allowed << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)aggregation << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)no_sig_extn << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)beamformed << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)pa_detect << 12) & ~((u32)0x00007000)) == 0);
	ASSERT_ERR_CHIP((((u32)leg_length << 0) & ~((u32)0x00000FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, ((u32)smm_index << 24) | ((u32)ftm << 22) | ((u32)do_implicit_learning << 21) | ((u32)sounding << 20) | ((u32)smoothing << 19) | ((u32)doze_not_allowed << 18) | ((u32)aggregation << 17) | ((u32)no_sig_extn << 16) | ((u32)beamformed << 15) | ((u32)pa_detect << 12) | ((u32)leg_length << 0));
}

static inline void mac_hw_rx_response_params_5_unpack(struct cl_chip *chip, u8 *smm_index, u8 *ftm, u8 *do_implicit_learning, u8 *sounding, u8 *smoothing, u8 *doze_not_allowed, u8 *aggregation, u8 *no_sig_extn, u8 *beamformed, u8 *pa_detect, u16 *leg_length)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	*smm_index = (local_val & ((u32)0xFF000000)) >> 24;
	*ftm = (local_val & ((u32)0x00C00000)) >> 22;
	*do_implicit_learning = (local_val & ((u32)0x00200000)) >> 21;
	*sounding = (local_val & ((u32)0x00100000)) >> 20;
	*smoothing = (local_val & ((u32)0x00080000)) >> 19;
	*doze_not_allowed = (local_val & ((u32)0x00040000)) >> 18;
	*aggregation = (local_val & ((u32)0x00020000)) >> 17;
	*no_sig_extn = (local_val & ((u32)0x00010000)) >> 16;
	*beamformed = (local_val & ((u32)0x00008000)) >> 15;
	*pa_detect = (local_val & ((u32)0x00007000)) >> 12;
	*leg_length = (local_val & ((u32)0x00000FFF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_5_smm_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_rx_response_params_5_smm_index_setf(struct cl_chip *chip, u8 smmindex)
{
	ASSERT_ERR_CHIP((((u32)smmindex << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0xFF000000)) | ((u32)smmindex << 24));
}

static inline u8 mac_hw_rx_response_params_5_ftm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00C00000)) >> 22);
}

static inline void mac_hw_rx_response_params_5_ftm_setf(struct cl_chip *chip, u8 ftm)
{
	ASSERT_ERR_CHIP((((u32)ftm << 22) & ~((u32)0x00C00000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00C00000)) | ((u32)ftm << 22));
}

static inline u8 mac_hw_rx_response_params_5_do_implicit_learning_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_rx_response_params_5_do_implicit_learning_setf(struct cl_chip *chip, u8 doimplicitlearning)
{
	ASSERT_ERR_CHIP((((u32)doimplicitlearning << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00200000)) | ((u32)doimplicitlearning << 21));
}

static inline u8 mac_hw_rx_response_params_5_sounding_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_response_params_5_sounding_setf(struct cl_chip *chip, u8 sounding)
{
	ASSERT_ERR_CHIP((((u32)sounding << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00100000)) | ((u32)sounding << 20));
}

static inline u8 mac_hw_rx_response_params_5_smoothing_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_response_params_5_smoothing_setf(struct cl_chip *chip, u8 smoothing)
{
	ASSERT_ERR_CHIP((((u32)smoothing << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00080000)) | ((u32)smoothing << 19));
}

static inline u8 mac_hw_rx_response_params_5_doze_not_allowed_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_response_params_5_doze_not_allowed_setf(struct cl_chip *chip, u8 dozenotallowed)
{
	ASSERT_ERR_CHIP((((u32)dozenotallowed << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00040000)) | ((u32)dozenotallowed << 18));
}

static inline u8 mac_hw_rx_response_params_5_aggregation_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_rx_response_params_5_aggregation_setf(struct cl_chip *chip, u8 aggregation)
{
	ASSERT_ERR_CHIP((((u32)aggregation << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00020000)) | ((u32)aggregation << 17));
}

static inline u8 mac_hw_rx_response_params_5_no_sig_extn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_response_params_5_no_sig_extn_setf(struct cl_chip *chip, u8 nosigextn)
{
	ASSERT_ERR_CHIP((((u32)nosigextn << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00010000)) | ((u32)nosigextn << 16));
}

static inline u8 mac_hw_rx_response_params_5_beamformed_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_rx_response_params_5_beamformed_setf(struct cl_chip *chip, u8 beamformed)
{
	ASSERT_ERR_CHIP((((u32)beamformed << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00008000)) | ((u32)beamformed << 15));
}

static inline u8 mac_hw_rx_response_params_5_pa_detect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u8)((local_val & ((u32)0x00007000)) >> 12);
}

static inline void mac_hw_rx_response_params_5_pa_detect_setf(struct cl_chip *chip, u8 padetect)
{
	ASSERT_ERR_CHIP((((u32)padetect << 12) & ~((u32)0x00007000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00007000)) | ((u32)padetect << 12));
}

static inline u16 mac_hw_rx_response_params_5_leg_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR);

	return (u16)((local_val & ((u32)0x00000FFF)) >> 0);
}

static inline void mac_hw_rx_response_params_5_leg_length_setf(struct cl_chip *chip, u16 leglength)
{
	ASSERT_ERR_CHIP((((u32)leglength << 0) & ~((u32)0x00000FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_5_ADDR) & ~((u32)0x00000FFF)) | ((u32)leglength << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_6 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 GENERAL_RC0               0x0
 *    23:00 HT_LENGTH                 0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_6_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001D4)
#define MAC_HW_RX_RESPONSE_PARAMS_6_OFFSET      0x000001D4
#define MAC_HW_RX_RESPONSE_PARAMS_6_INDEX       0x00000075
#define MAC_HW_RX_RESPONSE_PARAMS_6_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_6_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR);
}

static inline void mac_hw_rx_response_params_6_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_6_GENERAL_RC_0_MASK    ((u32)0xFF000000)
#define MAC_HW_RX_RESPONSE_PARAMS_6_GENERAL_RC_0_LSB    24
#define MAC_HW_RX_RESPONSE_PARAMS_6_GENERAL_RC_0_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESPONSE_PARAMS_6_HT_LENGTH_MASK    ((u32)0x00FFFFFF)
#define MAC_HW_RX_RESPONSE_PARAMS_6_HT_LENGTH_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_6_HT_LENGTH_WIDTH    ((u32)0x00000018)

#define MAC_HW_RX_RESPONSE_PARAMS_6_GENERAL_RC_0_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_6_HT_LENGTH_RST    0x0

static inline void mac_hw_rx_response_params_6_pack(struct cl_chip *chip, u8 general_rc0, u32 ht_length)
{
	ASSERT_ERR_CHIP((((u32)general_rc0 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ht_length << 0) & ~((u32)0x00FFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR, ((u32)general_rc0 << 24) | ((u32)ht_length << 0));
}

static inline void mac_hw_rx_response_params_6_unpack(struct cl_chip *chip, u8 *general_rc0, u32 *ht_length)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR);

	*general_rc0 = (local_val & ((u32)0xFF000000)) >> 24;
	*ht_length = (local_val & ((u32)0x00FFFFFF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_6_general_rc_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_rx_response_params_6_general_rc_0_setf(struct cl_chip *chip, u8 generalrc0)
{
	ASSERT_ERR_CHIP((((u32)generalrc0 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR) & ~((u32)0xFF000000)) | ((u32)generalrc0 << 24));
}

static inline u32 mac_hw_rx_response_params_6_ht_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR);

	return (u32)((local_val & ((u32)0x00FFFFFF)) >> 0);
}

static inline void mac_hw_rx_response_params_6_ht_length_setf(struct cl_chip *chip, u32 htlength)
{
	ASSERT_ERR_CHIP((((u32)htlength << 0) & ~((u32)0x00FFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_6_ADDR) & ~((u32)0x00FFFFFF)) | ((u32)htlength << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_7 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:16 ACTIVE_TX_CHAINS          0x0
 *    15:00 ANTENNA_SET               0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_7_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001D8)
#define MAC_HW_RX_RESPONSE_PARAMS_7_OFFSET      0x000001D8
#define MAC_HW_RX_RESPONSE_PARAMS_7_INDEX       0x00000076
#define MAC_HW_RX_RESPONSE_PARAMS_7_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_7_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR);
}

static inline void mac_hw_rx_response_params_7_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_7_ACTIVE_TX_CHAINS_MASK    ((u32)0x00FF0000)
#define MAC_HW_RX_RESPONSE_PARAMS_7_ACTIVE_TX_CHAINS_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_7_ACTIVE_TX_CHAINS_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_RESPONSE_PARAMS_7_ANTENNA_SET_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_RESPONSE_PARAMS_7_ANTENNA_SET_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_7_ANTENNA_SET_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_RESPONSE_PARAMS_7_ACTIVE_TX_CHAINS_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_7_ANTENNA_SET_RST    0x0

static inline void mac_hw_rx_response_params_7_pack(struct cl_chip *chip, u8 active_tx_chains, u16 antenna_set)
{
	ASSERT_ERR_CHIP((((u32)active_tx_chains << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_set << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR, ((u32)active_tx_chains << 16) | ((u32)antenna_set << 0));
}

static inline void mac_hw_rx_response_params_7_unpack(struct cl_chip *chip, u8 *active_tx_chains, u16 *antenna_set)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR);

	*active_tx_chains = (local_val & ((u32)0x00FF0000)) >> 16;
	*antenna_set = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_7_active_tx_chains_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_rx_response_params_7_active_tx_chains_setf(struct cl_chip *chip, u8 activetxchains)
{
	ASSERT_ERR_CHIP((((u32)activetxchains << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR) & ~((u32)0x00FF0000)) | ((u32)activetxchains << 16));
}

static inline u16 mac_hw_rx_response_params_7_antenna_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_response_params_7_antenna_set_setf(struct cl_chip *chip, u16 antennaset)
{
	ASSERT_ERR_CHIP((((u32)antennaset << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_7_ADDR) & ~((u32)0x0000FFFF)) | ((u32)antennaset << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_8 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 GENERAL_MAC_CTRL0         0x0
 *    12:00 GENERAL_PHY_CONTROL       0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_8_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001DC)
#define MAC_HW_RX_RESPONSE_PARAMS_8_OFFSET      0x000001DC
#define MAC_HW_RX_RESPONSE_PARAMS_8_INDEX       0x00000077
#define MAC_HW_RX_RESPONSE_PARAMS_8_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_8_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR);
}

static inline void mac_hw_rx_response_params_8_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_MAC_CTRL_0_MASK    ((u32)0x003F0000)
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_MAC_CTRL_0_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_MAC_CTRL_0_WIDTH    ((u32)0x00000006)
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_PHY_CONTROL_MASK    ((u32)0x00001FFF)
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_PHY_CONTROL_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_PHY_CONTROL_WIDTH    ((u32)0x0000000D)

#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_MAC_CTRL_0_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_8_GENERAL_PHY_CONTROL_RST    0x0

static inline void mac_hw_rx_response_params_8_pack(struct cl_chip *chip, u8 general_mac_ctrl0, u16 general_phy_control)
{
	ASSERT_ERR_CHIP((((u32)general_mac_ctrl0 << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)general_phy_control << 0) & ~((u32)0x00001FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR, ((u32)general_mac_ctrl0 << 16) | ((u32)general_phy_control << 0));
}

static inline void mac_hw_rx_response_params_8_unpack(struct cl_chip *chip, u8 *general_mac_ctrl0, u16 *general_phy_control)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR);

	*general_mac_ctrl0 = (local_val & ((u32)0x003F0000)) >> 16;
	*general_phy_control = (local_val & ((u32)0x00001FFF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_8_general_mac_ctrl_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_rx_response_params_8_general_mac_ctrl_0_setf(struct cl_chip *chip, u8 generalmacctrl0)
{
	ASSERT_ERR_CHIP((((u32)generalmacctrl0 << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR) & ~((u32)0x003F0000)) | ((u32)generalmacctrl0 << 16));
}

static inline u16 mac_hw_rx_response_params_8_general_phy_control_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR);

	return (u16)((local_val & ((u32)0x00001FFF)) >> 0);
}

static inline void mac_hw_rx_response_params_8_general_phy_control_setf(struct cl_chip *chip, u16 generalphycontrol)
{
	ASSERT_ERR_CHIP((((u32)generalphycontrol << 0) & ~((u32)0x00001FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_8_ADDR) & ~((u32)0x00001FFF)) | ((u32)generalphycontrol << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_9 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    24:16 HE_SIG_A2_RESERVED        0x0
 *    15:00 SPATIAL_REUSE_HE_TRIG     0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_9_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001E0)
#define MAC_HW_RX_RESPONSE_PARAMS_9_OFFSET      0x000001E0
#define MAC_HW_RX_RESPONSE_PARAMS_9_INDEX       0x00000078
#define MAC_HW_RX_RESPONSE_PARAMS_9_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_9_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR);
}

static inline void mac_hw_rx_response_params_9_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_9_HE_SIG_A_2_RESERVED_MASK    ((u32)0x01FF0000)
#define MAC_HW_RX_RESPONSE_PARAMS_9_HE_SIG_A_2_RESERVED_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_9_HE_SIG_A_2_RESERVED_WIDTH    ((u32)0x00000009)
#define MAC_HW_RX_RESPONSE_PARAMS_9_SPATIAL_REUSE_HE_TRIG_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_RESPONSE_PARAMS_9_SPATIAL_REUSE_HE_TRIG_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_9_SPATIAL_REUSE_HE_TRIG_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_RESPONSE_PARAMS_9_HE_SIG_A_2_RESERVED_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_9_SPATIAL_REUSE_HE_TRIG_RST    0x0

static inline void mac_hw_rx_response_params_9_pack(struct cl_chip *chip, u16 he_sig_a2_reserved, u16 spatial_reuse_he_trig)
{
	ASSERT_ERR_CHIP((((u32)he_sig_a2_reserved << 16) & ~((u32)0x01FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)spatial_reuse_he_trig << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR, ((u32)he_sig_a2_reserved << 16) | ((u32)spatial_reuse_he_trig << 0));
}

static inline void mac_hw_rx_response_params_9_unpack(struct cl_chip *chip, u16 *he_sig_a2_reserved, u16 *spatial_reuse_he_trig)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR);

	*he_sig_a2_reserved = (local_val & ((u32)0x01FF0000)) >> 16;
	*spatial_reuse_he_trig = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_response_params_9_he_sig_a_2_reserved_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR);

	return (u16)((local_val & ((u32)0x01FF0000)) >> 16);
}

static inline void mac_hw_rx_response_params_9_he_sig_a_2_reserved_setf(struct cl_chip *chip, u16 hesiga2reserved)
{
	ASSERT_ERR_CHIP((((u32)hesiga2reserved << 16) & ~((u32)0x01FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR) & ~((u32)0x01FF0000)) | ((u32)hesiga2reserved << 16));
}

static inline u16 mac_hw_rx_response_params_9_spatial_reuse_he_trig_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_response_params_9_spatial_reuse_he_trig_setf(struct cl_chip *chip, u16 spatialreusehetrig)
{
	ASSERT_ERR_CHIP((((u32)spatialreusehetrig << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_9_ADDR) & ~((u32)0x0000FFFF)) | ((u32)spatialreusehetrig << 0));
}

/**
 * @brief RX_RESPONSE_PARAMS_10 register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    PE_DISAMBIGUITY           0
 *    20    LDPC_EXTRA_SYMBOL         0
 *    19    LTF_MODE                  0
 *    18:16 NUM_OF_HE_LTF_SYMBOLS     0x0
 *    15:14 PRE_FEC_PAD_FACTOR        0x0
 *    13:11 STARTING_STS              0x0
 *    10:08 N_STS                     0x0
 *    07:00 RU_ALLOCATION             0x0
 * </pre>
 */
#define MAC_HW_RX_RESPONSE_PARAMS_10_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001E4)
#define MAC_HW_RX_RESPONSE_PARAMS_10_OFFSET      0x000001E4
#define MAC_HW_RX_RESPONSE_PARAMS_10_INDEX       0x00000079
#define MAC_HW_RX_RESPONSE_PARAMS_10_RESET       0x00000000

static inline u32 mac_hw_rx_response_params_10_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);
}

static inline void mac_hw_rx_response_params_10_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_RESPONSE_PARAMS_10_PE_DISAMBIGUITY_BIT    ((u32)0x00200000)
#define MAC_HW_RX_RESPONSE_PARAMS_10_PE_DISAMBIGUITY_POS    21
#define MAC_HW_RX_RESPONSE_PARAMS_10_LDPC_EXTRA_SYMBOL_BIT    ((u32)0x00100000)
#define MAC_HW_RX_RESPONSE_PARAMS_10_LDPC_EXTRA_SYMBOL_POS    20
#define MAC_HW_RX_RESPONSE_PARAMS_10_LTF_MODE_BIT    ((u32)0x00080000)
#define MAC_HW_RX_RESPONSE_PARAMS_10_LTF_MODE_POS    19
#define MAC_HW_RX_RESPONSE_PARAMS_10_NUM_OF_HE_LTF_SYMBOLS_MASK    ((u32)0x00070000)
#define MAC_HW_RX_RESPONSE_PARAMS_10_NUM_OF_HE_LTF_SYMBOLS_LSB    16
#define MAC_HW_RX_RESPONSE_PARAMS_10_NUM_OF_HE_LTF_SYMBOLS_WIDTH    ((u32)0x00000003)
#define MAC_HW_RX_RESPONSE_PARAMS_10_PRE_FEC_PAD_FACTOR_MASK    ((u32)0x0000C000)
#define MAC_HW_RX_RESPONSE_PARAMS_10_PRE_FEC_PAD_FACTOR_LSB    14
#define MAC_HW_RX_RESPONSE_PARAMS_10_PRE_FEC_PAD_FACTOR_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_RESPONSE_PARAMS_10_STARTING_STS_MASK    ((u32)0x00003800)
#define MAC_HW_RX_RESPONSE_PARAMS_10_STARTING_STS_LSB    11
#define MAC_HW_RX_RESPONSE_PARAMS_10_STARTING_STS_WIDTH    ((u32)0x00000003)
#define MAC_HW_RX_RESPONSE_PARAMS_10_N_STS_MASK    ((u32)0x00000700)
#define MAC_HW_RX_RESPONSE_PARAMS_10_N_STS_LSB    8
#define MAC_HW_RX_RESPONSE_PARAMS_10_N_STS_WIDTH    ((u32)0x00000003)
#define MAC_HW_RX_RESPONSE_PARAMS_10_RU_ALLOCATION_MASK    ((u32)0x000000FF)
#define MAC_HW_RX_RESPONSE_PARAMS_10_RU_ALLOCATION_LSB    0
#define MAC_HW_RX_RESPONSE_PARAMS_10_RU_ALLOCATION_WIDTH    ((u32)0x00000008)

#define MAC_HW_RX_RESPONSE_PARAMS_10_PE_DISAMBIGUITY_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_LDPC_EXTRA_SYMBOL_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_LTF_MODE_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_NUM_OF_HE_LTF_SYMBOLS_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_PRE_FEC_PAD_FACTOR_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_STARTING_STS_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_N_STS_RST    0x0
#define MAC_HW_RX_RESPONSE_PARAMS_10_RU_ALLOCATION_RST    0x0

static inline void mac_hw_rx_response_params_10_pack(struct cl_chip *chip, u8 pe_disambiguity, u8 ldpc_extra_symbol, u8 ltf_mode, u8 num_of_he_ltf_symbols, u8 pre_fec_pad_factor, u8 starting_sts, u8 n_sts, u8 ru_allocation)
{
	ASSERT_ERR_CHIP((((u32)pe_disambiguity << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)ldpc_extra_symbol << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)ltf_mode << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)num_of_he_ltf_symbols << 16) & ~((u32)0x00070000)) == 0);
	ASSERT_ERR_CHIP((((u32)pre_fec_pad_factor << 14) & ~((u32)0x0000C000)) == 0);
	ASSERT_ERR_CHIP((((u32)starting_sts << 11) & ~((u32)0x00003800)) == 0);
	ASSERT_ERR_CHIP((((u32)n_sts << 8) & ~((u32)0x00000700)) == 0);
	ASSERT_ERR_CHIP((((u32)ru_allocation << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, ((u32)pe_disambiguity << 21) | ((u32)ldpc_extra_symbol << 20) | ((u32)ltf_mode << 19) | ((u32)num_of_he_ltf_symbols << 16) | ((u32)pre_fec_pad_factor << 14) | ((u32)starting_sts << 11) | ((u32)n_sts << 8) | ((u32)ru_allocation << 0));
}

static inline void mac_hw_rx_response_params_10_unpack(struct cl_chip *chip, u8 *pe_disambiguity, u8 *ldpc_extra_symbol, u8 *ltf_mode, u8 *num_of_he_ltf_symbols, u8 *pre_fec_pad_factor, u8 *starting_sts, u8 *n_sts, u8 *ru_allocation)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	*pe_disambiguity = (local_val & ((u32)0x00200000)) >> 21;
	*ldpc_extra_symbol = (local_val & ((u32)0x00100000)) >> 20;
	*ltf_mode = (local_val & ((u32)0x00080000)) >> 19;
	*num_of_he_ltf_symbols = (local_val & ((u32)0x00070000)) >> 16;
	*pre_fec_pad_factor = (local_val & ((u32)0x0000C000)) >> 14;
	*starting_sts = (local_val & ((u32)0x00003800)) >> 11;
	*n_sts = (local_val & ((u32)0x00000700)) >> 8;
	*ru_allocation = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_rx_response_params_10_pe_disambiguity_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_rx_response_params_10_pe_disambiguity_setf(struct cl_chip *chip, u8 pedisambiguity)
{
	ASSERT_ERR_CHIP((((u32)pedisambiguity << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00200000)) | ((u32)pedisambiguity << 21));
}

static inline u8 mac_hw_rx_response_params_10_ldpc_extra_symbol_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_response_params_10_ldpc_extra_symbol_setf(struct cl_chip *chip, u8 ldpcextrasymbol)
{
	ASSERT_ERR_CHIP((((u32)ldpcextrasymbol << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00100000)) | ((u32)ldpcextrasymbol << 20));
}

static inline u8 mac_hw_rx_response_params_10_ltf_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_response_params_10_ltf_mode_setf(struct cl_chip *chip, u8 ltfmode)
{
	ASSERT_ERR_CHIP((((u32)ltfmode << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00080000)) | ((u32)ltfmode << 19));
}

static inline u8 mac_hw_rx_response_params_10_num_of_he_ltf_symbols_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00070000)) >> 16);
}

static inline void mac_hw_rx_response_params_10_num_of_he_ltf_symbols_setf(struct cl_chip *chip, u8 numofheltfsymbols)
{
	ASSERT_ERR_CHIP((((u32)numofheltfsymbols << 16) & ~((u32)0x00070000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00070000)) | ((u32)numofheltfsymbols << 16));
}

static inline u8 mac_hw_rx_response_params_10_pre_fec_pad_factor_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x0000C000)) >> 14);
}

static inline void mac_hw_rx_response_params_10_pre_fec_pad_factor_setf(struct cl_chip *chip, u8 prefecpadfactor)
{
	ASSERT_ERR_CHIP((((u32)prefecpadfactor << 14) & ~((u32)0x0000C000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x0000C000)) | ((u32)prefecpadfactor << 14));
}

static inline u8 mac_hw_rx_response_params_10_starting_sts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00003800)) >> 11);
}

static inline void mac_hw_rx_response_params_10_starting_sts_setf(struct cl_chip *chip, u8 startingsts)
{
	ASSERT_ERR_CHIP((((u32)startingsts << 11) & ~((u32)0x00003800)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00003800)) | ((u32)startingsts << 11));
}

static inline u8 mac_hw_rx_response_params_10_n_sts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x00000700)) >> 8);
}

static inline void mac_hw_rx_response_params_10_n_sts_setf(struct cl_chip *chip, u8 nsts)
{
	ASSERT_ERR_CHIP((((u32)nsts << 8) & ~((u32)0x00000700)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x00000700)) | ((u32)nsts << 8));
}

static inline u8 mac_hw_rx_response_params_10_ru_allocation_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_rx_response_params_10_ru_allocation_setf(struct cl_chip *chip, u8 ruallocation)
{
	ASSERT_ERR_CHIP((((u32)ruallocation << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR, (cl_reg_read(chip, MAC_HW_RX_RESPONSE_PARAMS_10_ADDR) & ~((u32)0x000000FF)) | ((u32)ruallocation << 0));
}

/**
 * @brief RX_OVERFLOW_AVOID register definition
 *  Controls RX fifo overflow avoidance register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15    CHECK_ROOM_IN_MPIF_FIFO   0
 *    11:00 ENCR_INIT_STALL           0x80
 * </pre>
 */
#define MAC_HW_RX_OVERFLOW_AVOID_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001F0)
#define MAC_HW_RX_OVERFLOW_AVOID_OFFSET      0x000001F0
#define MAC_HW_RX_OVERFLOW_AVOID_INDEX       0x0000007C
#define MAC_HW_RX_OVERFLOW_AVOID_RESET       0x00000080

static inline u32 mac_hw_rx_overflow_avoid_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR);
}

static inline void mac_hw_rx_overflow_avoid_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_OVERFLOW_AVOID_CHECK_ROOM_IN_MPIF_FIFO_BIT    ((u32)0x00008000)
#define MAC_HW_RX_OVERFLOW_AVOID_CHECK_ROOM_IN_MPIF_FIFO_POS    15
#define MAC_HW_RX_OVERFLOW_AVOID_ENCR_INIT_STALL_MASK    ((u32)0x00000FFF)
#define MAC_HW_RX_OVERFLOW_AVOID_ENCR_INIT_STALL_LSB    0
#define MAC_HW_RX_OVERFLOW_AVOID_ENCR_INIT_STALL_WIDTH    ((u32)0x0000000C)

#define MAC_HW_RX_OVERFLOW_AVOID_CHECK_ROOM_IN_MPIF_FIFO_RST    0x0
#define MAC_HW_RX_OVERFLOW_AVOID_ENCR_INIT_STALL_RST    0x80

static inline void mac_hw_rx_overflow_avoid_pack(struct cl_chip *chip, u8 check_room_in_mpif_fifo, u16 encr_init_stall)
{
	ASSERT_ERR_CHIP((((u32)check_room_in_mpif_fifo << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)encr_init_stall << 0) & ~((u32)0x00000FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR, ((u32)check_room_in_mpif_fifo << 15) | ((u32)encr_init_stall << 0));
}

static inline void mac_hw_rx_overflow_avoid_unpack(struct cl_chip *chip, u8 *check_room_in_mpif_fifo, u16 *encr_init_stall)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR);

	*check_room_in_mpif_fifo = (local_val & ((u32)0x00008000)) >> 15;
	*encr_init_stall = (local_val & ((u32)0x00000FFF)) >> 0;
}

static inline u8 mac_hw_rx_overflow_avoid_check_room_in_mpif_fifo_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_rx_overflow_avoid_check_room_in_mpif_fifo_setf(struct cl_chip *chip, u8 checkroominmpiffifo)
{
	ASSERT_ERR_CHIP((((u32)checkroominmpiffifo << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR, (cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR) & ~((u32)0x00008000)) | ((u32)checkroominmpiffifo << 15));
}

static inline u16 mac_hw_rx_overflow_avoid_encr_init_stall_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR);

	return (u16)((local_val & ((u32)0x00000FFF)) >> 0);
}

static inline void mac_hw_rx_overflow_avoid_encr_init_stall_setf(struct cl_chip *chip, u16 encrinitstall)
{
	ASSERT_ERR_CHIP((((u32)encrinitstall << 0) & ~((u32)0x00000FFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR, (cl_reg_read(chip, MAC_HW_RX_OVERFLOW_AVOID_ADDR) & ~((u32)0x00000FFF)) | ((u32)encrinitstall << 0));
}

/**
 * @brief RX_DISCARD_MPDU_CNT register definition
 *  Contains the number of MPDUs that were discarded  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_DISCARD_MPDU_CNT       0x0
 * </pre>
 */
#define MAC_HW_RX_DISCARD_MPDU_CNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000001F4)
#define MAC_HW_RX_DISCARD_MPDU_CNT_OFFSET      0x000001F4
#define MAC_HW_RX_DISCARD_MPDU_CNT_INDEX       0x0000007D
#define MAC_HW_RX_DISCARD_MPDU_CNT_RESET       0x00000000

static inline u32 mac_hw_rx_discard_mpdu_cnt_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_DISCARD_MPDU_CNT_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_DISCARD_MPDU_CNT_RX_DISCARD_MPDU_CNT_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_DISCARD_MPDU_CNT_RX_DISCARD_MPDU_CNT_LSB    0
#define MAC_HW_RX_DISCARD_MPDU_CNT_RX_DISCARD_MPDU_CNT_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_DISCARD_MPDU_CNT_RX_DISCARD_MPDU_CNT_RST    0x0

static inline u32 mac_hw_rx_discard_mpdu_cnt_rx_discard_mpdu_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_DISCARD_MPDU_CNT_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief EDCA_AC_0 register definition
 *  Contains the AC0 parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EDCA_DISABLE_0            0
 *    27:12 TX_OP_LIMIT_0             0x0
 *    11:08 CW_MAX_0                  0xA
 *    07:04 CW_MIN_0                  0x4
 *    03:00 AIFSN_0                   0x7
 * </pre>
 */
#define MAC_HW_EDCA_AC_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000200)
#define MAC_HW_EDCA_AC_0_OFFSET      0x00000200
#define MAC_HW_EDCA_AC_0_INDEX       0x00000080
#define MAC_HW_EDCA_AC_0_RESET       0x00000A47

static inline u32 mac_hw_edca_ac_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);
}

static inline void mac_hw_edca_ac_0_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_0_EDCA_DISABLE_0_BIT    ((u32)0x80000000)
#define MAC_HW_EDCA_AC_0_EDCA_DISABLE_0_POS    31
#define MAC_HW_EDCA_AC_0_TX_OP_LIMIT_0_MASK    ((u32)0x0FFFF000)
#define MAC_HW_EDCA_AC_0_TX_OP_LIMIT_0_LSB    12
#define MAC_HW_EDCA_AC_0_TX_OP_LIMIT_0_WIDTH    ((u32)0x00000010)
#define MAC_HW_EDCA_AC_0_CW_MAX_0_MASK      ((u32)0x00000F00)
#define MAC_HW_EDCA_AC_0_CW_MAX_0_LSB       8
#define MAC_HW_EDCA_AC_0_CW_MAX_0_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_0_CW_MIN_0_MASK      ((u32)0x000000F0)
#define MAC_HW_EDCA_AC_0_CW_MIN_0_LSB       4
#define MAC_HW_EDCA_AC_0_CW_MIN_0_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_0_AIFSN_0_MASK       ((u32)0x0000000F)
#define MAC_HW_EDCA_AC_0_AIFSN_0_LSB        0
#define MAC_HW_EDCA_AC_0_AIFSN_0_WIDTH      ((u32)0x00000004)

#define MAC_HW_EDCA_AC_0_EDCA_DISABLE_0_RST    0x0
#define MAC_HW_EDCA_AC_0_TX_OP_LIMIT_0_RST    0x0
#define MAC_HW_EDCA_AC_0_CW_MAX_0_RST       0xA
#define MAC_HW_EDCA_AC_0_CW_MIN_0_RST       0x4
#define MAC_HW_EDCA_AC_0_AIFSN_0_RST        0x7

static inline void mac_hw_edca_ac_0_pack(struct cl_chip *chip, u8 edca_disable_0, u16 tx_op_limit_0, u8 cw_max_0, u8 cw_min_0, u8 aifsn_0)
{
	ASSERT_ERR_CHIP((((u32)edca_disable_0 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_op_limit_0 << 12) & ~((u32)0x0FFFF000)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_max_0 << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_min_0 << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)aifsn_0 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, ((u32)edca_disable_0 << 31) | ((u32)tx_op_limit_0 << 12) | ((u32)cw_max_0 << 8) | ((u32)cw_min_0 << 4) | ((u32)aifsn_0 << 0));
}

static inline void mac_hw_edca_ac_0_unpack(struct cl_chip *chip, u8 *edca_disable_0, u16 *tx_op_limit_0, u8 *cw_max_0, u8 *cw_min_0, u8 *aifsn_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	*edca_disable_0 = (local_val & ((u32)0x80000000)) >> 31;
	*tx_op_limit_0 = (local_val & ((u32)0x0FFFF000)) >> 12;
	*cw_max_0 = (local_val & ((u32)0x00000F00)) >> 8;
	*cw_min_0 = (local_val & ((u32)0x000000F0)) >> 4;
	*aifsn_0 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_edca_ac_0_edca_disable_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_edca_ac_0_edca_disable_0_setf(struct cl_chip *chip, u8 edcadisable0)
{
	ASSERT_ERR_CHIP((((u32)edcadisable0 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR) & ~((u32)0x80000000)) | ((u32)edcadisable0 << 31));
}

static inline u16 mac_hw_edca_ac_0_tx_op_limit_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	return (u16)((local_val & ((u32)0x0FFFF000)) >> 12);
}

static inline void mac_hw_edca_ac_0_tx_op_limit_0_setf(struct cl_chip *chip, u16 txoplimit0)
{
	ASSERT_ERR_CHIP((((u32)txoplimit0 << 12) & ~((u32)0x0FFFF000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR) & ~((u32)0x0FFFF000)) | ((u32)txoplimit0 << 12));
}

static inline u8 mac_hw_edca_ac_0_cw_max_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_edca_ac_0_cw_max_0_setf(struct cl_chip *chip, u8 cwmax0)
{
	ASSERT_ERR_CHIP((((u32)cwmax0 << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR) & ~((u32)0x00000F00)) | ((u32)cwmax0 << 8));
}

static inline u8 mac_hw_edca_ac_0_cw_min_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_edca_ac_0_cw_min_0_setf(struct cl_chip *chip, u8 cwmin0)
{
	ASSERT_ERR_CHIP((((u32)cwmin0 << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR) & ~((u32)0x000000F0)) | ((u32)cwmin0 << 4));
}

static inline u8 mac_hw_edca_ac_0_aifsn_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_edca_ac_0_aifsn_0_setf(struct cl_chip *chip, u8 aifsn0)
{
	ASSERT_ERR_CHIP((((u32)aifsn0 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_0_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_0_ADDR) & ~((u32)0x0000000F)) | ((u32)aifsn0 << 0));
}

/**
 * @brief EDCA_AC_1 register definition
 *  Contains the AC1 parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EDCA_DISABLE_1            0
 *    27:12 TX_OP_LIMIT_1             0x0
 *    11:08 CW_MAX_1                  0xA
 *    07:04 CW_MIN_1                  0x4
 *    03:00 AIFSN_1                   0x3
 * </pre>
 */
#define MAC_HW_EDCA_AC_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000204)
#define MAC_HW_EDCA_AC_1_OFFSET      0x00000204
#define MAC_HW_EDCA_AC_1_INDEX       0x00000081
#define MAC_HW_EDCA_AC_1_RESET       0x00000A43

static inline u32 mac_hw_edca_ac_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);
}

static inline void mac_hw_edca_ac_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_1_EDCA_DISABLE_1_BIT    ((u32)0x80000000)
#define MAC_HW_EDCA_AC_1_EDCA_DISABLE_1_POS    31
#define MAC_HW_EDCA_AC_1_TX_OP_LIMIT_1_MASK    ((u32)0x0FFFF000)
#define MAC_HW_EDCA_AC_1_TX_OP_LIMIT_1_LSB    12
#define MAC_HW_EDCA_AC_1_TX_OP_LIMIT_1_WIDTH    ((u32)0x00000010)
#define MAC_HW_EDCA_AC_1_CW_MAX_1_MASK      ((u32)0x00000F00)
#define MAC_HW_EDCA_AC_1_CW_MAX_1_LSB       8
#define MAC_HW_EDCA_AC_1_CW_MAX_1_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_1_CW_MIN_1_MASK      ((u32)0x000000F0)
#define MAC_HW_EDCA_AC_1_CW_MIN_1_LSB       4
#define MAC_HW_EDCA_AC_1_CW_MIN_1_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_1_AIFSN_1_MASK       ((u32)0x0000000F)
#define MAC_HW_EDCA_AC_1_AIFSN_1_LSB        0
#define MAC_HW_EDCA_AC_1_AIFSN_1_WIDTH      ((u32)0x00000004)

#define MAC_HW_EDCA_AC_1_EDCA_DISABLE_1_RST    0x0
#define MAC_HW_EDCA_AC_1_TX_OP_LIMIT_1_RST    0x0
#define MAC_HW_EDCA_AC_1_CW_MAX_1_RST       0xA
#define MAC_HW_EDCA_AC_1_CW_MIN_1_RST       0x4
#define MAC_HW_EDCA_AC_1_AIFSN_1_RST        0x3

static inline void mac_hw_edca_ac_1_pack(struct cl_chip *chip, u8 edca_disable_1, u16 tx_op_limit_1, u8 cw_max_1, u8 cw_min_1, u8 aifsn_1)
{
	ASSERT_ERR_CHIP((((u32)edca_disable_1 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_op_limit_1 << 12) & ~((u32)0x0FFFF000)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_max_1 << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_min_1 << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)aifsn_1 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, ((u32)edca_disable_1 << 31) | ((u32)tx_op_limit_1 << 12) | ((u32)cw_max_1 << 8) | ((u32)cw_min_1 << 4) | ((u32)aifsn_1 << 0));
}

static inline void mac_hw_edca_ac_1_unpack(struct cl_chip *chip, u8 *edca_disable_1, u16 *tx_op_limit_1, u8 *cw_max_1, u8 *cw_min_1, u8 *aifsn_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	*edca_disable_1 = (local_val & ((u32)0x80000000)) >> 31;
	*tx_op_limit_1 = (local_val & ((u32)0x0FFFF000)) >> 12;
	*cw_max_1 = (local_val & ((u32)0x00000F00)) >> 8;
	*cw_min_1 = (local_val & ((u32)0x000000F0)) >> 4;
	*aifsn_1 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_edca_ac_1_edca_disable_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_edca_ac_1_edca_disable_1_setf(struct cl_chip *chip, u8 edcadisable1)
{
	ASSERT_ERR_CHIP((((u32)edcadisable1 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR) & ~((u32)0x80000000)) | ((u32)edcadisable1 << 31));
}

static inline u16 mac_hw_edca_ac_1_tx_op_limit_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	return (u16)((local_val & ((u32)0x0FFFF000)) >> 12);
}

static inline void mac_hw_edca_ac_1_tx_op_limit_1_setf(struct cl_chip *chip, u16 txoplimit1)
{
	ASSERT_ERR_CHIP((((u32)txoplimit1 << 12) & ~((u32)0x0FFFF000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR) & ~((u32)0x0FFFF000)) | ((u32)txoplimit1 << 12));
}

static inline u8 mac_hw_edca_ac_1_cw_max_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_edca_ac_1_cw_max_1_setf(struct cl_chip *chip, u8 cwmax1)
{
	ASSERT_ERR_CHIP((((u32)cwmax1 << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR) & ~((u32)0x00000F00)) | ((u32)cwmax1 << 8));
}

static inline u8 mac_hw_edca_ac_1_cw_min_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_edca_ac_1_cw_min_1_setf(struct cl_chip *chip, u8 cwmin1)
{
	ASSERT_ERR_CHIP((((u32)cwmin1 << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR) & ~((u32)0x000000F0)) | ((u32)cwmin1 << 4));
}

static inline u8 mac_hw_edca_ac_1_aifsn_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_edca_ac_1_aifsn_1_setf(struct cl_chip *chip, u8 aifsn1)
{
	ASSERT_ERR_CHIP((((u32)aifsn1 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_1_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_1_ADDR) & ~((u32)0x0000000F)) | ((u32)aifsn1 << 0));
}

/**
 * @brief EDCA_AC_2 register definition
 *  Contains the AC2 parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EDCA_DISABLE_2            0
 *    27:12 TX_OP_LIMIT_2             0x5E
 *    11:08 CW_MAX_2                  0x4
 *    07:04 CW_MIN_2                  0x3
 *    03:00 AIFSN_2                   0x2
 * </pre>
 */
#define MAC_HW_EDCA_AC_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000208)
#define MAC_HW_EDCA_AC_2_OFFSET      0x00000208
#define MAC_HW_EDCA_AC_2_INDEX       0x00000082
#define MAC_HW_EDCA_AC_2_RESET       0x0005E432

static inline u32 mac_hw_edca_ac_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);
}

static inline void mac_hw_edca_ac_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_2_EDCA_DISABLE_2_BIT    ((u32)0x80000000)
#define MAC_HW_EDCA_AC_2_EDCA_DISABLE_2_POS    31
#define MAC_HW_EDCA_AC_2_TX_OP_LIMIT_2_MASK    ((u32)0x0FFFF000)
#define MAC_HW_EDCA_AC_2_TX_OP_LIMIT_2_LSB    12
#define MAC_HW_EDCA_AC_2_TX_OP_LIMIT_2_WIDTH    ((u32)0x00000010)
#define MAC_HW_EDCA_AC_2_CW_MAX_2_MASK      ((u32)0x00000F00)
#define MAC_HW_EDCA_AC_2_CW_MAX_2_LSB       8
#define MAC_HW_EDCA_AC_2_CW_MAX_2_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_2_CW_MIN_2_MASK      ((u32)0x000000F0)
#define MAC_HW_EDCA_AC_2_CW_MIN_2_LSB       4
#define MAC_HW_EDCA_AC_2_CW_MIN_2_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_2_AIFSN_2_MASK       ((u32)0x0000000F)
#define MAC_HW_EDCA_AC_2_AIFSN_2_LSB        0
#define MAC_HW_EDCA_AC_2_AIFSN_2_WIDTH      ((u32)0x00000004)

#define MAC_HW_EDCA_AC_2_EDCA_DISABLE_2_RST    0x0
#define MAC_HW_EDCA_AC_2_TX_OP_LIMIT_2_RST    0x5E
#define MAC_HW_EDCA_AC_2_CW_MAX_2_RST       0x4
#define MAC_HW_EDCA_AC_2_CW_MIN_2_RST       0x3
#define MAC_HW_EDCA_AC_2_AIFSN_2_RST        0x2

static inline void mac_hw_edca_ac_2_pack(struct cl_chip *chip, u8 edca_disable_2, u16 tx_op_limit_2, u8 cw_max_2, u8 cw_min_2, u8 aifsn_2)
{
	ASSERT_ERR_CHIP((((u32)edca_disable_2 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_op_limit_2 << 12) & ~((u32)0x0FFFF000)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_max_2 << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_min_2 << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)aifsn_2 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, ((u32)edca_disable_2 << 31) | ((u32)tx_op_limit_2 << 12) | ((u32)cw_max_2 << 8) | ((u32)cw_min_2 << 4) | ((u32)aifsn_2 << 0));
}

static inline void mac_hw_edca_ac_2_unpack(struct cl_chip *chip, u8 *edca_disable_2, u16 *tx_op_limit_2, u8 *cw_max_2, u8 *cw_min_2, u8 *aifsn_2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	*edca_disable_2 = (local_val & ((u32)0x80000000)) >> 31;
	*tx_op_limit_2 = (local_val & ((u32)0x0FFFF000)) >> 12;
	*cw_max_2 = (local_val & ((u32)0x00000F00)) >> 8;
	*cw_min_2 = (local_val & ((u32)0x000000F0)) >> 4;
	*aifsn_2 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_edca_ac_2_edca_disable_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_edca_ac_2_edca_disable_2_setf(struct cl_chip *chip, u8 edcadisable2)
{
	ASSERT_ERR_CHIP((((u32)edcadisable2 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR) & ~((u32)0x80000000)) | ((u32)edcadisable2 << 31));
}

static inline u16 mac_hw_edca_ac_2_tx_op_limit_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	return (u16)((local_val & ((u32)0x0FFFF000)) >> 12);
}

static inline void mac_hw_edca_ac_2_tx_op_limit_2_setf(struct cl_chip *chip, u16 txoplimit2)
{
	ASSERT_ERR_CHIP((((u32)txoplimit2 << 12) & ~((u32)0x0FFFF000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR) & ~((u32)0x0FFFF000)) | ((u32)txoplimit2 << 12));
}

static inline u8 mac_hw_edca_ac_2_cw_max_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_edca_ac_2_cw_max_2_setf(struct cl_chip *chip, u8 cwmax2)
{
	ASSERT_ERR_CHIP((((u32)cwmax2 << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR) & ~((u32)0x00000F00)) | ((u32)cwmax2 << 8));
}

static inline u8 mac_hw_edca_ac_2_cw_min_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_edca_ac_2_cw_min_2_setf(struct cl_chip *chip, u8 cwmin2)
{
	ASSERT_ERR_CHIP((((u32)cwmin2 << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR) & ~((u32)0x000000F0)) | ((u32)cwmin2 << 4));
}

static inline u8 mac_hw_edca_ac_2_aifsn_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_edca_ac_2_aifsn_2_setf(struct cl_chip *chip, u8 aifsn2)
{
	ASSERT_ERR_CHIP((((u32)aifsn2 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_2_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_2_ADDR) & ~((u32)0x0000000F)) | ((u32)aifsn2 << 0));
}

/**
 * @brief EDCA_AC_3 register definition
 *  Contains the AC3 parameters. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    EDCA_DISABLE_3            0
 *    27:12 TX_OP_LIMIT_3             0x2F
 *    11:08 CW_MAX_3                  0x3
 *    07:04 CW_MIN_3                  0x2
 *    03:00 AIFSN_3                   0x2
 * </pre>
 */
#define MAC_HW_EDCA_AC_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000020C)
#define MAC_HW_EDCA_AC_3_OFFSET      0x0000020C
#define MAC_HW_EDCA_AC_3_INDEX       0x00000083
#define MAC_HW_EDCA_AC_3_RESET       0x0002F322

static inline u32 mac_hw_edca_ac_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);
}

static inline void mac_hw_edca_ac_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_3_EDCA_DISABLE_3_BIT    ((u32)0x80000000)
#define MAC_HW_EDCA_AC_3_EDCA_DISABLE_3_POS    31
#define MAC_HW_EDCA_AC_3_TX_OP_LIMIT_3_MASK    ((u32)0x0FFFF000)
#define MAC_HW_EDCA_AC_3_TX_OP_LIMIT_3_LSB    12
#define MAC_HW_EDCA_AC_3_TX_OP_LIMIT_3_WIDTH    ((u32)0x00000010)
#define MAC_HW_EDCA_AC_3_CW_MAX_3_MASK      ((u32)0x00000F00)
#define MAC_HW_EDCA_AC_3_CW_MAX_3_LSB       8
#define MAC_HW_EDCA_AC_3_CW_MAX_3_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_3_CW_MIN_3_MASK      ((u32)0x000000F0)
#define MAC_HW_EDCA_AC_3_CW_MIN_3_LSB       4
#define MAC_HW_EDCA_AC_3_CW_MIN_3_WIDTH     ((u32)0x00000004)
#define MAC_HW_EDCA_AC_3_AIFSN_3_MASK       ((u32)0x0000000F)
#define MAC_HW_EDCA_AC_3_AIFSN_3_LSB        0
#define MAC_HW_EDCA_AC_3_AIFSN_3_WIDTH      ((u32)0x00000004)

#define MAC_HW_EDCA_AC_3_EDCA_DISABLE_3_RST    0x0
#define MAC_HW_EDCA_AC_3_TX_OP_LIMIT_3_RST    0x2F
#define MAC_HW_EDCA_AC_3_CW_MAX_3_RST       0x3
#define MAC_HW_EDCA_AC_3_CW_MIN_3_RST       0x2
#define MAC_HW_EDCA_AC_3_AIFSN_3_RST        0x2

static inline void mac_hw_edca_ac_3_pack(struct cl_chip *chip, u8 edca_disable_3, u16 tx_op_limit_3, u8 cw_max_3, u8 cw_min_3, u8 aifsn_3)
{
	ASSERT_ERR_CHIP((((u32)edca_disable_3 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_op_limit_3 << 12) & ~((u32)0x0FFFF000)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_max_3 << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)cw_min_3 << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)aifsn_3 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, ((u32)edca_disable_3 << 31) | ((u32)tx_op_limit_3 << 12) | ((u32)cw_max_3 << 8) | ((u32)cw_min_3 << 4) | ((u32)aifsn_3 << 0));
}

static inline void mac_hw_edca_ac_3_unpack(struct cl_chip *chip, u8 *edca_disable_3, u16 *tx_op_limit_3, u8 *cw_max_3, u8 *cw_min_3, u8 *aifsn_3)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	*edca_disable_3 = (local_val & ((u32)0x80000000)) >> 31;
	*tx_op_limit_3 = (local_val & ((u32)0x0FFFF000)) >> 12;
	*cw_max_3 = (local_val & ((u32)0x00000F00)) >> 8;
	*cw_min_3 = (local_val & ((u32)0x000000F0)) >> 4;
	*aifsn_3 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_edca_ac_3_edca_disable_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_edca_ac_3_edca_disable_3_setf(struct cl_chip *chip, u8 edcadisable3)
{
	ASSERT_ERR_CHIP((((u32)edcadisable3 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR) & ~((u32)0x80000000)) | ((u32)edcadisable3 << 31));
}

static inline u16 mac_hw_edca_ac_3_tx_op_limit_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	return (u16)((local_val & ((u32)0x0FFFF000)) >> 12);
}

static inline void mac_hw_edca_ac_3_tx_op_limit_3_setf(struct cl_chip *chip, u16 txoplimit3)
{
	ASSERT_ERR_CHIP((((u32)txoplimit3 << 12) & ~((u32)0x0FFFF000)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR) & ~((u32)0x0FFFF000)) | ((u32)txoplimit3 << 12));
}

static inline u8 mac_hw_edca_ac_3_cw_max_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_edca_ac_3_cw_max_3_setf(struct cl_chip *chip, u8 cwmax3)
{
	ASSERT_ERR_CHIP((((u32)cwmax3 << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR) & ~((u32)0x00000F00)) | ((u32)cwmax3 << 8));
}

static inline u8 mac_hw_edca_ac_3_cw_min_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline void mac_hw_edca_ac_3_cw_min_3_setf(struct cl_chip *chip, u8 cwmin3)
{
	ASSERT_ERR_CHIP((((u32)cwmin3 << 4) & ~((u32)0x000000F0)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR) & ~((u32)0x000000F0)) | ((u32)cwmin3 << 4));
}

static inline u8 mac_hw_edca_ac_3_aifsn_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_edca_ac_3_aifsn_3_setf(struct cl_chip *chip, u8 aifsn3)
{
	ASSERT_ERR_CHIP((((u32)aifsn3 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_3_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_3_ADDR) & ~((u32)0x0000000F)) | ((u32)aifsn3 << 0));
}

/**
 * @brief TIMINGS_11 register definition
 *  Controls timing and delay parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 ACK_TIME3                 0x20
 *    23:16 ACK_TIME2                 0x44
 *    15:08 ACK_TIME1                 0x2C
 *    07:00 ACK_TIME0                 0x20
 * </pre>
 */
#define MAC_HW_TIMINGS_11_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000210)
#define MAC_HW_TIMINGS_11_OFFSET      0x00000210
#define MAC_HW_TIMINGS_11_INDEX       0x00000084
#define MAC_HW_TIMINGS_11_RESET       0x20442C20

static inline u32 mac_hw_timings_11_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);
}

static inline void mac_hw_timings_11_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_11_ACK_TIME_3_MASK    ((u32)0xFF000000)
#define MAC_HW_TIMINGS_11_ACK_TIME_3_LSB    24
#define MAC_HW_TIMINGS_11_ACK_TIME_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_11_ACK_TIME_2_MASK    ((u32)0x00FF0000)
#define MAC_HW_TIMINGS_11_ACK_TIME_2_LSB    16
#define MAC_HW_TIMINGS_11_ACK_TIME_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_11_ACK_TIME_1_MASK    ((u32)0x0000FF00)
#define MAC_HW_TIMINGS_11_ACK_TIME_1_LSB    8
#define MAC_HW_TIMINGS_11_ACK_TIME_1_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_11_ACK_TIME_0_MASK    ((u32)0x000000FF)
#define MAC_HW_TIMINGS_11_ACK_TIME_0_LSB    0
#define MAC_HW_TIMINGS_11_ACK_TIME_0_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_11_ACK_TIME_3_RST    0x20
#define MAC_HW_TIMINGS_11_ACK_TIME_2_RST    0x44
#define MAC_HW_TIMINGS_11_ACK_TIME_1_RST    0x2C
#define MAC_HW_TIMINGS_11_ACK_TIME_0_RST    0x20

static inline void mac_hw_timings_11_pack(struct cl_chip *chip, u8 ack_time3, u8 ack_time2, u8 ack_time1, u8 ack_time0)
{
	ASSERT_ERR_CHIP((((u32)ack_time3 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time2 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time1 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, ((u32)ack_time3 << 24) | ((u32)ack_time2 << 16) | ((u32)ack_time1 << 8) | ((u32)ack_time0 << 0));
}

static inline void mac_hw_timings_11_unpack(struct cl_chip *chip, u8 *ack_time3, u8 *ack_time2, u8 *ack_time1, u8 *ack_time0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);

	*ack_time3 = (local_val & ((u32)0xFF000000)) >> 24;
	*ack_time2 = (local_val & ((u32)0x00FF0000)) >> 16;
	*ack_time1 = (local_val & ((u32)0x0000FF00)) >> 8;
	*ack_time0 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_11_ack_time_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_timings_11_ack_time_3_setf(struct cl_chip *chip, u8 acktime3)
{
	ASSERT_ERR_CHIP((((u32)acktime3 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR) & ~((u32)0xFF000000)) | ((u32)acktime3 << 24));
}

static inline u8 mac_hw_timings_11_ack_time_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_timings_11_ack_time_2_setf(struct cl_chip *chip, u8 acktime2)
{
	ASSERT_ERR_CHIP((((u32)acktime2 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR) & ~((u32)0x00FF0000)) | ((u32)acktime2 << 16));
}

static inline u8 mac_hw_timings_11_ack_time_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_timings_11_ack_time_1_setf(struct cl_chip *chip, u8 acktime1)
{
	ASSERT_ERR_CHIP((((u32)acktime1 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR) & ~((u32)0x0000FF00)) | ((u32)acktime1 << 8));
}

static inline u8 mac_hw_timings_11_ack_time_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_11_ack_time_0_setf(struct cl_chip *chip, u8 acktime0)
{
	ASSERT_ERR_CHIP((((u32)acktime0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_11_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_11_ADDR) & ~((u32)0x000000FF)) | ((u32)acktime0 << 0));
}

/**
 * @brief TIMINGS_12 register definition
 *  Controls timing and delay parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 ACK_TIME7                 0x20
 *    23:16 ACK_TIME6                 0x1C
 *    15:08 ACK_TIME5                 0x44
 *    07:00 ACK_TIME4                 0x2C
 * </pre>
 */
#define MAC_HW_TIMINGS_12_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000214)
#define MAC_HW_TIMINGS_12_OFFSET      0x00000214
#define MAC_HW_TIMINGS_12_INDEX       0x00000085
#define MAC_HW_TIMINGS_12_RESET       0x201C442C

static inline u32 mac_hw_timings_12_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);
}

static inline void mac_hw_timings_12_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_12_ACK_TIME_7_MASK    ((u32)0xFF000000)
#define MAC_HW_TIMINGS_12_ACK_TIME_7_LSB    24
#define MAC_HW_TIMINGS_12_ACK_TIME_7_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_12_ACK_TIME_6_MASK    ((u32)0x00FF0000)
#define MAC_HW_TIMINGS_12_ACK_TIME_6_LSB    16
#define MAC_HW_TIMINGS_12_ACK_TIME_6_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_12_ACK_TIME_5_MASK    ((u32)0x0000FF00)
#define MAC_HW_TIMINGS_12_ACK_TIME_5_LSB    8
#define MAC_HW_TIMINGS_12_ACK_TIME_5_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_12_ACK_TIME_4_MASK    ((u32)0x000000FF)
#define MAC_HW_TIMINGS_12_ACK_TIME_4_LSB    0
#define MAC_HW_TIMINGS_12_ACK_TIME_4_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_12_ACK_TIME_7_RST    0x20
#define MAC_HW_TIMINGS_12_ACK_TIME_6_RST    0x1C
#define MAC_HW_TIMINGS_12_ACK_TIME_5_RST    0x44
#define MAC_HW_TIMINGS_12_ACK_TIME_4_RST    0x2C

static inline void mac_hw_timings_12_pack(struct cl_chip *chip, u8 ack_time7, u8 ack_time6, u8 ack_time5, u8 ack_time4)
{
	ASSERT_ERR_CHIP((((u32)ack_time7 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time6 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time5 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, ((u32)ack_time7 << 24) | ((u32)ack_time6 << 16) | ((u32)ack_time5 << 8) | ((u32)ack_time4 << 0));
}

static inline void mac_hw_timings_12_unpack(struct cl_chip *chip, u8 *ack_time7, u8 *ack_time6, u8 *ack_time5, u8 *ack_time4)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);

	*ack_time7 = (local_val & ((u32)0xFF000000)) >> 24;
	*ack_time6 = (local_val & ((u32)0x00FF0000)) >> 16;
	*ack_time5 = (local_val & ((u32)0x0000FF00)) >> 8;
	*ack_time4 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_12_ack_time_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_timings_12_ack_time_7_setf(struct cl_chip *chip, u8 acktime7)
{
	ASSERT_ERR_CHIP((((u32)acktime7 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR) & ~((u32)0xFF000000)) | ((u32)acktime7 << 24));
}

static inline u8 mac_hw_timings_12_ack_time_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_timings_12_ack_time_6_setf(struct cl_chip *chip, u8 acktime6)
{
	ASSERT_ERR_CHIP((((u32)acktime6 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR) & ~((u32)0x00FF0000)) | ((u32)acktime6 << 16));
}

static inline u8 mac_hw_timings_12_ack_time_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_timings_12_ack_time_5_setf(struct cl_chip *chip, u8 acktime5)
{
	ASSERT_ERR_CHIP((((u32)acktime5 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR) & ~((u32)0x0000FF00)) | ((u32)acktime5 << 8));
}

static inline u8 mac_hw_timings_12_ack_time_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_12_ack_time_4_setf(struct cl_chip *chip, u8 acktime4)
{
	ASSERT_ERR_CHIP((((u32)acktime4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_12_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_12_ADDR) & ~((u32)0x000000FF)) | ((u32)acktime4 << 0));
}

/**
 * @brief TIMINGS_13 register definition
 *  Controls timing and delay parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 ACK_TIME11                0x2C
 *    23:16 ACK_TIME10                0x20
 *    15:08 ACK_TIME9                 0x1C
 *    07:00 ACK_TIME8                 0x2C
 * </pre>
 */
#define MAC_HW_TIMINGS_13_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000218)
#define MAC_HW_TIMINGS_13_OFFSET      0x00000218
#define MAC_HW_TIMINGS_13_INDEX       0x00000086
#define MAC_HW_TIMINGS_13_RESET       0x2C201C2C

static inline u32 mac_hw_timings_13_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);
}

static inline void mac_hw_timings_13_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_13_ACK_TIME_11_MASK    ((u32)0xFF000000)
#define MAC_HW_TIMINGS_13_ACK_TIME_11_LSB    24
#define MAC_HW_TIMINGS_13_ACK_TIME_11_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_13_ACK_TIME_10_MASK    ((u32)0x00FF0000)
#define MAC_HW_TIMINGS_13_ACK_TIME_10_LSB    16
#define MAC_HW_TIMINGS_13_ACK_TIME_10_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_13_ACK_TIME_9_MASK    ((u32)0x0000FF00)
#define MAC_HW_TIMINGS_13_ACK_TIME_9_LSB    8
#define MAC_HW_TIMINGS_13_ACK_TIME_9_WIDTH    ((u32)0x00000008)
#define MAC_HW_TIMINGS_13_ACK_TIME_8_MASK    ((u32)0x000000FF)
#define MAC_HW_TIMINGS_13_ACK_TIME_8_LSB    0
#define MAC_HW_TIMINGS_13_ACK_TIME_8_WIDTH    ((u32)0x00000008)

#define MAC_HW_TIMINGS_13_ACK_TIME_11_RST    0x2C
#define MAC_HW_TIMINGS_13_ACK_TIME_10_RST    0x20
#define MAC_HW_TIMINGS_13_ACK_TIME_9_RST    0x1C
#define MAC_HW_TIMINGS_13_ACK_TIME_8_RST    0x2C

static inline void mac_hw_timings_13_pack(struct cl_chip *chip, u8 ack_time11, u8 ack_time10, u8 ack_time9, u8 ack_time8)
{
	ASSERT_ERR_CHIP((((u32)ack_time11 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time10 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time9 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time8 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, ((u32)ack_time11 << 24) | ((u32)ack_time10 << 16) | ((u32)ack_time9 << 8) | ((u32)ack_time8 << 0));
}

static inline void mac_hw_timings_13_unpack(struct cl_chip *chip, u8 *ack_time11, u8 *ack_time10, u8 *ack_time9, u8 *ack_time8)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);

	*ack_time11 = (local_val & ((u32)0xFF000000)) >> 24;
	*ack_time10 = (local_val & ((u32)0x00FF0000)) >> 16;
	*ack_time9 = (local_val & ((u32)0x0000FF00)) >> 8;
	*ack_time8 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_timings_13_ack_time_11_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_timings_13_ack_time_11_setf(struct cl_chip *chip, u8 acktime11)
{
	ASSERT_ERR_CHIP((((u32)acktime11 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR) & ~((u32)0xFF000000)) | ((u32)acktime11 << 24));
}

static inline u8 mac_hw_timings_13_ack_time_10_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_timings_13_ack_time_10_setf(struct cl_chip *chip, u8 acktime10)
{
	ASSERT_ERR_CHIP((((u32)acktime10 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR) & ~((u32)0x00FF0000)) | ((u32)acktime10 << 16));
}

static inline u8 mac_hw_timings_13_ack_time_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_timings_13_ack_time_9_setf(struct cl_chip *chip, u8 acktime9)
{
	ASSERT_ERR_CHIP((((u32)acktime9 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR) & ~((u32)0x0000FF00)) | ((u32)acktime9 << 8));
}

static inline u8 mac_hw_timings_13_ack_time_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_timings_13_ack_time_8_setf(struct cl_chip *chip, u8 acktime8)
{
	ASSERT_ERR_CHIP((((u32)acktime8 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_13_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_13_ADDR) & ~((u32)0x000000FF)) | ((u32)acktime8 << 0));
}

/**
 * @brief TIMINGS_14 register definition
 *  Controls timing and delay parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 ACK_TIME14                0x130
 *    19:10 ACK_TIME13                0xF8
 *    09:00 ACK_TIME12                0x98
 * </pre>
 */
#define MAC_HW_TIMINGS_14_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000021C)
#define MAC_HW_TIMINGS_14_OFFSET      0x0000021C
#define MAC_HW_TIMINGS_14_INDEX       0x00000087
#define MAC_HW_TIMINGS_14_RESET       0x1303E098

static inline u32 mac_hw_timings_14_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR);
}

static inline void mac_hw_timings_14_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMINGS_14_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMINGS_14_ACK_TIME_14_MASK    ((u32)0x3FF00000)
#define MAC_HW_TIMINGS_14_ACK_TIME_14_LSB    20
#define MAC_HW_TIMINGS_14_ACK_TIME_14_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_14_ACK_TIME_13_MASK    ((u32)0x000FFC00)
#define MAC_HW_TIMINGS_14_ACK_TIME_13_LSB    10
#define MAC_HW_TIMINGS_14_ACK_TIME_13_WIDTH    ((u32)0x0000000A)
#define MAC_HW_TIMINGS_14_ACK_TIME_12_MASK    ((u32)0x000003FF)
#define MAC_HW_TIMINGS_14_ACK_TIME_12_LSB    0
#define MAC_HW_TIMINGS_14_ACK_TIME_12_WIDTH    ((u32)0x0000000A)

#define MAC_HW_TIMINGS_14_ACK_TIME_14_RST    0x130
#define MAC_HW_TIMINGS_14_ACK_TIME_13_RST    0xF8
#define MAC_HW_TIMINGS_14_ACK_TIME_12_RST    0x98

static inline void mac_hw_timings_14_pack(struct cl_chip *chip, u16 ack_time14, u16 ack_time13, u16 ack_time12)
{
	ASSERT_ERR_CHIP((((u32)ack_time14 << 20) & ~((u32)0x3FF00000)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time13 << 10) & ~((u32)0x000FFC00)) == 0);
	ASSERT_ERR_CHIP((((u32)ack_time12 << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_14_ADDR, ((u32)ack_time14 << 20) | ((u32)ack_time13 << 10) | ((u32)ack_time12 << 0));
}

static inline void mac_hw_timings_14_unpack(struct cl_chip *chip, u16 *ack_time14, u16 *ack_time13, u16 *ack_time12)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR);

	*ack_time14 = (local_val & ((u32)0x3FF00000)) >> 20;
	*ack_time13 = (local_val & ((u32)0x000FFC00)) >> 10;
	*ack_time12 = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_timings_14_ack_time_14_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline void mac_hw_timings_14_ack_time_14_setf(struct cl_chip *chip, u16 acktime14)
{
	ASSERT_ERR_CHIP((((u32)acktime14 << 20) & ~((u32)0x3FF00000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_14_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR) & ~((u32)0x3FF00000)) | ((u32)acktime14 << 20));
}

static inline u16 mac_hw_timings_14_ack_time_13_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline void mac_hw_timings_14_ack_time_13_setf(struct cl_chip *chip, u16 acktime13)
{
	ASSERT_ERR_CHIP((((u32)acktime13 << 10) & ~((u32)0x000FFC00)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_14_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR) & ~((u32)0x000FFC00)) | ((u32)acktime13 << 10));
}

static inline u16 mac_hw_timings_14_ack_time_12_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

static inline void mac_hw_timings_14_ack_time_12_setf(struct cl_chip *chip, u16 acktime12)
{
	ASSERT_ERR_CHIP((((u32)acktime12 << 0) & ~((u32)0x000003FF)) == 0);
	cl_reg_write(chip, MAC_HW_TIMINGS_14_ADDR, (cl_reg_read(chip, MAC_HW_TIMINGS_14_ADDR) & ~((u32)0x000003FF)) | ((u32)acktime12 << 0));
}

/**
 * @brief EDCA_CCA_BUSY register definition
 *  Indicates the CCA busy time. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CCA_BUSY_DUR              0x0
 * </pre>
 */
#define MAC_HW_EDCA_CCA_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000220)
#define MAC_HW_EDCA_CCA_BUSY_OFFSET      0x00000220
#define MAC_HW_EDCA_CCA_BUSY_INDEX       0x00000088
#define MAC_HW_EDCA_CCA_BUSY_RESET       0x00000000

static inline u32 mac_hw_edca_cca_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_CCA_BUSY_ADDR);
}

static inline void mac_hw_edca_cca_busy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_CCA_BUSY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_CCA_BUSY_CCA_BUSY_DUR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_EDCA_CCA_BUSY_CCA_BUSY_DUR_LSB    0
#define MAC_HW_EDCA_CCA_BUSY_CCA_BUSY_DUR_WIDTH    ((u32)0x00000020)

#define MAC_HW_EDCA_CCA_BUSY_CCA_BUSY_DUR_RST    0x0

static inline u32 mac_hw_edca_cca_busy_cca_busy_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CCA_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_edca_cca_busy_cca_busy_dur_setf(struct cl_chip *chip, u32 ccabusydur)
{
	ASSERT_ERR_CHIP((((u32)ccabusydur << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CCA_BUSY_ADDR, (u32)ccabusydur << 0);
}

/**
 * @brief EDCA_CNTRL register definition
 *  Contains various settings for controlling the operation of the core in EDCA. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    05    KEEP_TXOP_OPEN            0
 *    04    REM_TXOP_IN_DUR_FIELD     0
 *    01    SEND_CF_END               0
 *    00    SEND_CF_END_NOW           0
 * </pre>
 */
#define MAC_HW_EDCA_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000224)
#define MAC_HW_EDCA_CNTRL_OFFSET      0x00000224
#define MAC_HW_EDCA_CNTRL_INDEX       0x00000089
#define MAC_HW_EDCA_CNTRL_RESET       0x00000000

static inline u32 mac_hw_edca_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);
}

static inline void mac_hw_edca_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_CNTRL_KEEP_TXOP_OPEN_BIT    ((u32)0x00000020)
#define MAC_HW_EDCA_CNTRL_KEEP_TXOP_OPEN_POS    5
#define MAC_HW_EDCA_CNTRL_REM_TXOP_IN_DUR_FIELD_BIT    ((u32)0x00000010)
#define MAC_HW_EDCA_CNTRL_REM_TXOP_IN_DUR_FIELD_POS    4
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_BIT    ((u32)0x00000002)
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_POS    1
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_NOW_BIT    ((u32)0x00000001)
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_NOW_POS    0

#define MAC_HW_EDCA_CNTRL_KEEP_TXOP_OPEN_RST    0x0
#define MAC_HW_EDCA_CNTRL_REM_TXOP_IN_DUR_FIELD_RST    0x0
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_RST    0x0
#define MAC_HW_EDCA_CNTRL_SEND_CF_END_NOW_RST    0x0

static inline void mac_hw_edca_cntrl_pack(struct cl_chip *chip, u8 keep_txop_open, u8 rem_txop_in_dur_field, u8 send_cf_end, u8 send_cf_end_now)
{
	ASSERT_ERR_CHIP((((u32)keep_txop_open << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rem_txop_in_dur_field << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)send_cf_end << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)send_cf_end_now << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, ((u32)keep_txop_open << 5) | ((u32)rem_txop_in_dur_field << 4) | ((u32)send_cf_end << 1) | ((u32)send_cf_end_now << 0));
}

static inline void mac_hw_edca_cntrl_unpack(struct cl_chip *chip, u8 *keep_txop_open, u8 *rem_txop_in_dur_field, u8 *send_cf_end, u8 *send_cf_end_now)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);

	*keep_txop_open = (local_val & ((u32)0x00000020)) >> 5;
	*rem_txop_in_dur_field = (local_val & ((u32)0x00000010)) >> 4;
	*send_cf_end = (local_val & ((u32)0x00000002)) >> 1;
	*send_cf_end_now = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_edca_cntrl_keep_txop_open_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_edca_cntrl_keep_txop_open_setf(struct cl_chip *chip, u8 keeptxopopen)
{
	ASSERT_ERR_CHIP((((u32)keeptxopopen << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR) & ~((u32)0x00000020)) | ((u32)keeptxopopen << 5));
}

static inline u8 mac_hw_edca_cntrl_rem_txop_in_dur_field_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_edca_cntrl_rem_txop_in_dur_field_setf(struct cl_chip *chip, u8 remtxopindurfield)
{
	ASSERT_ERR_CHIP((((u32)remtxopindurfield << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR) & ~((u32)0x00000010)) | ((u32)remtxopindurfield << 4));
}

static inline u8 mac_hw_edca_cntrl_send_cf_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_edca_cntrl_send_cf_end_setf(struct cl_chip *chip, u8 sendcfend)
{
	ASSERT_ERR_CHIP((((u32)sendcfend << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR) & ~((u32)0x00000002)) | ((u32)sendcfend << 1));
}

static inline u8 mac_hw_edca_cntrl_send_cf_end_now_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_edca_cntrl_send_cf_end_now_setf(struct cl_chip *chip, u8 sendcfendnow)
{
	ASSERT_ERR_CHIP((((u32)sendcfendnow << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_CNTRL_ADDR) & ~((u32)0x00000001)) | ((u32)sendcfendnow << 0));
}

/**
 * @brief RX_BUSY_DELAY register definition
 *  RX Busy parameteres register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:00 RX_PHY_delay              0x33
 * </pre>
 */
#define MAC_HW_RX_BUSY_DELAY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000230)
#define MAC_HW_RX_BUSY_DELAY_OFFSET      0x00000230
#define MAC_HW_RX_BUSY_DELAY_INDEX       0x0000008C
#define MAC_HW_RX_BUSY_DELAY_RESET       0x00000033

static inline u32 mac_hw_rx_busy_delay_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_BUSY_DELAY_ADDR);
}

static inline void mac_hw_rx_busy_delay_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_BUSY_DELAY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_BUSY_DELAY_RX_PHY_DELAY_MASK    ((u32)0x000000FF)
#define MAC_HW_RX_BUSY_DELAY_RX_PHY_DELAY_LSB    0
#define MAC_HW_RX_BUSY_DELAY_RX_PHY_DELAY_WIDTH    ((u32)0x00000008)

#define MAC_HW_RX_BUSY_DELAY_RX_PHY_DELAY_RST    0x33

static inline u8 mac_hw_rx_busy_delay_rx_phy_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_BUSY_DELAY_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_rx_busy_delay_rx_phy_delay_setf(struct cl_chip *chip, u8 rxphydelay)
{
	ASSERT_ERR_CHIP((((u32)rxphydelay << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_BUSY_DELAY_ADDR, (u32)rxphydelay << 0);
}

/**
 * @brief RX_MINE_BUSY register definition
 *  RX Busy time by my frames counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 rx_mine_time              0x0
 * </pre>
 */
#define MAC_HW_RX_MINE_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000234)
#define MAC_HW_RX_MINE_BUSY_OFFSET      0x00000234
#define MAC_HW_RX_MINE_BUSY_INDEX       0x0000008D
#define MAC_HW_RX_MINE_BUSY_RESET       0x00000000

static inline u32 mac_hw_rx_mine_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MINE_BUSY_ADDR);
}

static inline void mac_hw_rx_mine_busy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_MINE_BUSY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_MINE_BUSY_RX_MINE_TIME_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MINE_BUSY_RX_MINE_TIME_LSB    0
#define MAC_HW_RX_MINE_BUSY_RX_MINE_TIME_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MINE_BUSY_RX_MINE_TIME_RST    0x0

static inline u32 mac_hw_rx_mine_busy_rx_mine_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MINE_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_rx_mine_busy_rx_mine_time_setf(struct cl_chip *chip, u32 rxminetime)
{
	ASSERT_ERR_CHIP((((u32)rxminetime << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_MINE_BUSY_ADDR, (u32)rxminetime << 0);
}

/**
 * @brief TX_MINE_BUSY register definition
 *  TX BUSY time by my TX frames register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_MINE_TIME              0x0
 * </pre>
 */
#define MAC_HW_TX_MINE_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000238)
#define MAC_HW_TX_MINE_BUSY_OFFSET      0x00000238
#define MAC_HW_TX_MINE_BUSY_INDEX       0x0000008E
#define MAC_HW_TX_MINE_BUSY_RESET       0x00000000

static inline u32 mac_hw_tx_mine_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_MINE_BUSY_ADDR);
}

static inline void mac_hw_tx_mine_busy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_MINE_BUSY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_MINE_BUSY_TX_MINE_TIME_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_MINE_BUSY_TX_MINE_TIME_LSB    0
#define MAC_HW_TX_MINE_BUSY_TX_MINE_TIME_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_MINE_BUSY_TX_MINE_TIME_RST    0x0

static inline u32 mac_hw_tx_mine_busy_tx_mine_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_MINE_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_mine_busy_tx_mine_time_setf(struct cl_chip *chip, u32 txminetime)
{
	ASSERT_ERR_CHIP((((u32)txminetime << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_MINE_BUSY_ADDR, (u32)txminetime << 0);
}

/**
 * @brief RX_PPDU_DELIM_ERROR_CNT register definition
 *  Indicates RX delimiter error count register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_PPDU_DELIM_ERROR_CNT   0x0
 * </pre>
 */
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000240)
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_OFFSET      0x00000240
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_INDEX       0x00000090
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_RESET       0x00000000

static inline u32 mac_hw_rx_ppdu_delim_error_cnt_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_PPDU_DELIM_ERROR_CNT_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_RX_PPDU_DELIM_ERROR_CNT_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_RX_PPDU_DELIM_ERROR_CNT_LSB    0
#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_RX_PPDU_DELIM_ERROR_CNT_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_PPDU_DELIM_ERROR_CNT_RX_PPDU_DELIM_ERROR_CNT_RST    0x0

static inline u32 mac_hw_rx_ppdu_delim_error_cnt_rx_ppdu_delim_error_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PPDU_DELIM_ERROR_CNT_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_PPDU_FCS_ERROR_CNT register definition
 *  Indicates RX FCS error count register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_PPDU_FCS_ERROR_CNT     0x0
 * </pre>
 */
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000244)
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_OFFSET      0x00000244
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_INDEX       0x00000091
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_RESET       0x00000000

static inline u32 mac_hw_rx_ppdu_fcs_error_cnt_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_PPDU_FCS_ERROR_CNT_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_RX_PPDU_FCS_ERROR_CNT_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_RX_PPDU_FCS_ERROR_CNT_LSB    0
#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_RX_PPDU_FCS_ERROR_CNT_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_PPDU_FCS_ERROR_CNT_RX_PPDU_FCS_ERROR_CNT_RST    0x0

static inline u32 mac_hw_rx_ppdu_fcs_error_cnt_rx_ppdu_fcs_error_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PPDU_FCS_ERROR_CNT_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief EDCA_NAV_BUSY register definition
 *  Indicates the NAV busy time register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 NAV_BUSY_DUR              0x0
 * </pre>
 */
#define MAC_HW_EDCA_NAV_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000248)
#define MAC_HW_EDCA_NAV_BUSY_OFFSET      0x00000248
#define MAC_HW_EDCA_NAV_BUSY_INDEX       0x00000092
#define MAC_HW_EDCA_NAV_BUSY_RESET       0x00000000

static inline u32 mac_hw_edca_nav_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_EDCA_NAV_BUSY_ADDR);
}

static inline void mac_hw_edca_nav_busy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_NAV_BUSY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_NAV_BUSY_NAV_BUSY_DUR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_EDCA_NAV_BUSY_NAV_BUSY_DUR_LSB    0
#define MAC_HW_EDCA_NAV_BUSY_NAV_BUSY_DUR_WIDTH    ((u32)0x00000020)

#define MAC_HW_EDCA_NAV_BUSY_NAV_BUSY_DUR_RST    0x0

static inline u32 mac_hw_edca_nav_busy_nav_busy_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_EDCA_NAV_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_edca_nav_busy_nav_busy_dur_setf(struct cl_chip *chip, u32 navbusydur)
{
	ASSERT_ERR_CHIP((((u32)navbusydur << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_NAV_BUSY_ADDR, (u32)navbusydur << 0);
}

/**
 * @brief CLOCK_CONTROL_1 register definition
 *  Clock gating control 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    01:00 clock_gating_mode         0x2
 * </pre>
 */
#define MAC_HW_CLOCK_CONTROL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000250)
#define MAC_HW_CLOCK_CONTROL_1_OFFSET      0x00000250
#define MAC_HW_CLOCK_CONTROL_1_INDEX       0x00000094
#define MAC_HW_CLOCK_CONTROL_1_RESET       0x00000002

static inline u32 mac_hw_clock_control_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_1_ADDR);
}

static inline void mac_hw_clock_control_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CLOCK_CONTROL_1_CLOCK_GATING_MODE_MASK    ((u32)0x00000003)
#define MAC_HW_CLOCK_CONTROL_1_CLOCK_GATING_MODE_LSB    0
#define MAC_HW_CLOCK_CONTROL_1_CLOCK_GATING_MODE_WIDTH    ((u32)0x00000002)

#define MAC_HW_CLOCK_CONTROL_1_CLOCK_GATING_MODE_RST    0x2

static inline u8 mac_hw_clock_control_1_clock_gating_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_1_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_clock_control_1_clock_gating_mode_setf(struct cl_chip *chip, u8 clockgatingmode)
{
	ASSERT_ERR_CHIP((((u32)clockgatingmode << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_1_ADDR, (u32)clockgatingmode << 0);
}

/**
 * @brief CLOCK_CONTROL_2 register definition
 *  Clock gating control 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:01 clock_turn_on             0x0
 * </pre>
 */
#define MAC_HW_CLOCK_CONTROL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000254)
#define MAC_HW_CLOCK_CONTROL_2_OFFSET      0x00000254
#define MAC_HW_CLOCK_CONTROL_2_INDEX       0x00000095
#define MAC_HW_CLOCK_CONTROL_2_RESET       0x00000000

static inline u32 mac_hw_clock_control_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_2_ADDR);
}

static inline void mac_hw_clock_control_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CLOCK_CONTROL_2_CLOCK_TURN_ON_MASK    ((u32)0x000000FE)
#define MAC_HW_CLOCK_CONTROL_2_CLOCK_TURN_ON_LSB    1
#define MAC_HW_CLOCK_CONTROL_2_CLOCK_TURN_ON_WIDTH    ((u32)0x00000007)

#define MAC_HW_CLOCK_CONTROL_2_CLOCK_TURN_ON_RST    0x0

static inline u8 mac_hw_clock_control_2_clock_turn_on_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_2_ADDR);

	return (u8)(local_val >> 1);
}

static inline void mac_hw_clock_control_2_clock_turn_on_setf(struct cl_chip *chip, u8 clockturnon)
{
	ASSERT_ERR_CHIP((((u32)clockturnon << 1) & ~((u32)0x000000FE)) == 0);
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_2_ADDR, (u32)clockturnon << 1);
}

/**
 * @brief CLOCK_CONTROL_3 register definition
 *  Clock gating control 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:01 clock_turn_off            0x0
 * </pre>
 */
#define MAC_HW_CLOCK_CONTROL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000258)
#define MAC_HW_CLOCK_CONTROL_3_OFFSET      0x00000258
#define MAC_HW_CLOCK_CONTROL_3_INDEX       0x00000096
#define MAC_HW_CLOCK_CONTROL_3_RESET       0x00000000

static inline u32 mac_hw_clock_control_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_3_ADDR);
}

static inline void mac_hw_clock_control_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CLOCK_CONTROL_3_CLOCK_TURN_OFF_MASK    ((u32)0x000000FE)
#define MAC_HW_CLOCK_CONTROL_3_CLOCK_TURN_OFF_LSB    1
#define MAC_HW_CLOCK_CONTROL_3_CLOCK_TURN_OFF_WIDTH    ((u32)0x00000007)

#define MAC_HW_CLOCK_CONTROL_3_CLOCK_TURN_OFF_RST    0x0

static inline u8 mac_hw_clock_control_3_clock_turn_off_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CLOCK_CONTROL_3_ADDR);

	return (u8)(local_val >> 1);
}

static inline void mac_hw_clock_control_3_clock_turn_off_setf(struct cl_chip *chip, u8 clockturnoff)
{
	ASSERT_ERR_CHIP((((u32)clockturnoff << 1) & ~((u32)0x000000FE)) == 0);
	cl_reg_write(chip, MAC_HW_CLOCK_CONTROL_3_ADDR, (u32)clockturnoff << 1);
}

/**
 * @brief CLOCK_STATUS register definition
 *  Clock enable status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:01 clock_enable_state        0x7F
 * </pre>
 */
#define MAC_HW_CLOCK_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000025C)
#define MAC_HW_CLOCK_STATUS_OFFSET      0x0000025C
#define MAC_HW_CLOCK_STATUS_INDEX       0x00000097
#define MAC_HW_CLOCK_STATUS_RESET       0x000000FE

static inline u32 mac_hw_clock_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CLOCK_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_CLOCK_STATUS_CLOCK_ENABLE_STATE_MASK    ((u32)0x000000FE)
#define MAC_HW_CLOCK_STATUS_CLOCK_ENABLE_STATE_LSB    1
#define MAC_HW_CLOCK_STATUS_CLOCK_ENABLE_STATE_WIDTH    ((u32)0x00000007)

#define MAC_HW_CLOCK_STATUS_CLOCK_ENABLE_STATE_RST    0x7F

static inline u8 mac_hw_clock_status_clock_enable_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CLOCK_STATUS_ADDR);

	return (u8)(local_val >> 1);
}

/**
 * @brief NDPA_INFO register definition
 *  Capture NDPA information register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    16    transmit_after_ndp        0
 *    15:08 disallowed_subchannel_bitmap 0x0
 *    07:00 sounding_dialog_token     0x0
 * </pre>
 */
#define MAC_HW_NDPA_INFO_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000260)
#define MAC_HW_NDPA_INFO_OFFSET      0x00000260
#define MAC_HW_NDPA_INFO_INDEX       0x00000098
#define MAC_HW_NDPA_INFO_RESET       0x00000000

static inline u32 mac_hw_ndpa_info_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NDPA_INFO_ADDR);
}

/* Field definitions */
#define MAC_HW_NDPA_INFO_TRANSMIT_AFTER_NDP_BIT    ((u32)0x00010000)
#define MAC_HW_NDPA_INFO_TRANSMIT_AFTER_NDP_POS    16
#define MAC_HW_NDPA_INFO_DISALLOWED_SUBCHANNEL_BITMAP_MASK    ((u32)0x0000FF00)
#define MAC_HW_NDPA_INFO_DISALLOWED_SUBCHANNEL_BITMAP_LSB    8
#define MAC_HW_NDPA_INFO_DISALLOWED_SUBCHANNEL_BITMAP_WIDTH    ((u32)0x00000008)
#define MAC_HW_NDPA_INFO_SOUNDING_DIALOG_TOKEN_MASK    ((u32)0x000000FF)
#define MAC_HW_NDPA_INFO_SOUNDING_DIALOG_TOKEN_LSB    0
#define MAC_HW_NDPA_INFO_SOUNDING_DIALOG_TOKEN_WIDTH    ((u32)0x00000008)

#define MAC_HW_NDPA_INFO_TRANSMIT_AFTER_NDP_RST    0x0
#define MAC_HW_NDPA_INFO_DISALLOWED_SUBCHANNEL_BITMAP_RST    0x0
#define MAC_HW_NDPA_INFO_SOUNDING_DIALOG_TOKEN_RST    0x0

static inline void mac_hw_ndpa_info_unpack(struct cl_chip *chip, u8 *transmit_after_ndp, u8 *disallowed_subchannel_bitmap, u8 *sounding_dialog_token)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NDPA_INFO_ADDR);

	*transmit_after_ndp = (local_val & ((u32)0x00010000)) >> 16;
	*disallowed_subchannel_bitmap = (local_val & ((u32)0x0000FF00)) >> 8;
	*sounding_dialog_token = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_ndpa_info_transmit_after_ndp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NDPA_INFO_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_ndpa_info_disallowed_subchannel_bitmap_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NDPA_INFO_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_ndpa_info_sounding_dialog_token_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NDPA_INFO_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

/**
 * @brief NDPA_STA_INFO register definition
 *  CAPTURE STA INFO in NDPA register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 STA_INFO                  0x0
 * </pre>
 */
#define MAC_HW_NDPA_STA_INFO_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000264)
#define MAC_HW_NDPA_STA_INFO_OFFSET      0x00000264
#define MAC_HW_NDPA_STA_INFO_INDEX       0x00000099
#define MAC_HW_NDPA_STA_INFO_RESET       0x00000000

static inline u32 mac_hw_ndpa_sta_info_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NDPA_STA_INFO_ADDR);
}

/* Field definitions */
#define MAC_HW_NDPA_STA_INFO_STA_INFO_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_NDPA_STA_INFO_STA_INFO_LSB    0
#define MAC_HW_NDPA_STA_INFO_STA_INFO_WIDTH    ((u32)0x00000020)

#define MAC_HW_NDPA_STA_INFO_STA_INFO_RST    0x0

static inline u32 mac_hw_ndpa_sta_info_sta_info_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NDPA_STA_INFO_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief UPLINK_BSSID_LOW register definition
 *  Contains the low part of the uplink BSS ID register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPLINK_BSSID_LOW          0x0
 * </pre>
 */
#define MAC_HW_UPLINK_BSSID_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000268)
#define MAC_HW_UPLINK_BSSID_LOW_OFFSET      0x00000268
#define MAC_HW_UPLINK_BSSID_LOW_INDEX       0x0000009A
#define MAC_HW_UPLINK_BSSID_LOW_RESET       0x00000000

static inline u32 mac_hw_uplink_bssid_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_UPLINK_BSSID_LOW_ADDR);
}

static inline void mac_hw_uplink_bssid_low_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_LOW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_UPLINK_BSSID_LOW_UPLINK_BSSID_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_UPLINK_BSSID_LOW_UPLINK_BSSID_LOW_LSB    0
#define MAC_HW_UPLINK_BSSID_LOW_UPLINK_BSSID_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_UPLINK_BSSID_LOW_UPLINK_BSSID_LOW_RST    0x0

static inline u32 mac_hw_uplink_bssid_low_uplink_bssid_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UPLINK_BSSID_LOW_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_uplink_bssid_low_uplink_bssid_low_setf(struct cl_chip *chip, u32 uplinkbssidlow)
{
	ASSERT_ERR_CHIP((((u32)uplinkbssidlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_LOW_ADDR, (u32)uplinkbssidlow << 0);
}

/**
 * @brief UPLINK_BSSID_HIGH register definition
 *  Contains the high part of the uplink BSS ID register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 UPLINK_BSS_COLOR          0x0
 *    15:00 UPLINK_BSSID_HIGH         0x0
 * </pre>
 */
#define MAC_HW_UPLINK_BSSID_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000026C)
#define MAC_HW_UPLINK_BSSID_HIGH_OFFSET      0x0000026C
#define MAC_HW_UPLINK_BSSID_HIGH_INDEX       0x0000009B
#define MAC_HW_UPLINK_BSSID_HIGH_RESET       0x00000000

static inline u32 mac_hw_uplink_bssid_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR);
}

static inline void mac_hw_uplink_bssid_high_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR, value);
}

/* Field definitions */
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSS_COLOR_MASK    ((u32)0x003F0000)
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSS_COLOR_LSB    16
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSS_COLOR_WIDTH    ((u32)0x00000006)
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSSID_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSSID_HIGH_LSB    0
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSSID_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSS_COLOR_RST    0x0
#define MAC_HW_UPLINK_BSSID_HIGH_UPLINK_BSSID_HIGH_RST    0x0

static inline void mac_hw_uplink_bssid_high_pack(struct cl_chip *chip, u8 uplink_bss_color, u16 uplink_bssid_high)
{
	ASSERT_ERR_CHIP((((u32)uplink_bss_color << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)uplink_bssid_high << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR, ((u32)uplink_bss_color << 16) | ((u32)uplink_bssid_high << 0));
}

static inline void mac_hw_uplink_bssid_high_unpack(struct cl_chip *chip, u8 *uplink_bss_color, u16 *uplink_bssid_high)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR);

	*uplink_bss_color = (local_val & ((u32)0x003F0000)) >> 16;
	*uplink_bssid_high = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_uplink_bssid_high_uplink_bss_color_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_uplink_bssid_high_uplink_bss_color_setf(struct cl_chip *chip, u8 uplinkbsscolor)
{
	ASSERT_ERR_CHIP((((u32)uplinkbsscolor << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR, (cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR) & ~((u32)0x003F0000)) | ((u32)uplinkbsscolor << 16));
}

static inline u16 mac_hw_uplink_bssid_high_uplink_bssid_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_uplink_bssid_high_uplink_bssid_high_setf(struct cl_chip *chip, u16 uplinkbssidhigh)
{
	ASSERT_ERR_CHIP((((u32)uplinkbssidhigh << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR, (cl_reg_read(chip, MAC_HW_UPLINK_BSSID_HIGH_ADDR) & ~((u32)0x0000FFFF)) | ((u32)uplinkbssidhigh << 0));
}

/**
 * @brief UL_BSSID_LOW_MASK register definition
 *  Contains the low order bits of the BSSID mask register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 UPLINK_BSSID_LOW_MASK     0x0
 * </pre>
 */
#define MAC_HW_UL_BSSID_LOW_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000270)
#define MAC_HW_UL_BSSID_LOW_MASK_OFFSET      0x00000270
#define MAC_HW_UL_BSSID_LOW_MASK_INDEX       0x0000009C
#define MAC_HW_UL_BSSID_LOW_MASK_RESET       0x00000000

static inline u32 mac_hw_ul_bssid_low_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_UL_BSSID_LOW_MASK_ADDR);
}

static inline void mac_hw_ul_bssid_low_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_UL_BSSID_LOW_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_UL_BSSID_LOW_MASK_UPLINK_BSSID_LOW_MASK_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_UL_BSSID_LOW_MASK_UPLINK_BSSID_LOW_MASK_LSB    0
#define MAC_HW_UL_BSSID_LOW_MASK_UPLINK_BSSID_LOW_MASK_WIDTH    ((u32)0x00000020)

#define MAC_HW_UL_BSSID_LOW_MASK_UPLINK_BSSID_LOW_MASK_RST    0x0

static inline u32 mac_hw_ul_bssid_low_mask_uplink_bssid_low_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UL_BSSID_LOW_MASK_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_ul_bssid_low_mask_uplink_bssid_low_mask_setf(struct cl_chip *chip, u32 uplinkbssidlowmask)
{
	ASSERT_ERR_CHIP((((u32)uplinkbssidlowmask << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UL_BSSID_LOW_MASK_ADDR, (u32)uplinkbssidlowmask << 0);
}

/**
 * @brief UL_BSSID_HIGH_MASK register definition
 *  Contains the high order bits of the BSSID mask register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 UPLINK_BSS_COLOR_MASK     0x0
 *    15:00 UPLINK_BSSID_HIGH_MASK    0x0
 * </pre>
 */
#define MAC_HW_UL_BSSID_HIGH_MASK_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000274)
#define MAC_HW_UL_BSSID_HIGH_MASK_OFFSET      0x00000274
#define MAC_HW_UL_BSSID_HIGH_MASK_INDEX       0x0000009D
#define MAC_HW_UL_BSSID_HIGH_MASK_RESET       0x00000000

static inline u32 mac_hw_ul_bssid_high_mask_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR);
}

static inline void mac_hw_ul_bssid_high_mask_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR, value);
}

/* Field definitions */
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSS_COLOR_MASK_MASK    ((u32)0x003F0000)
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSS_COLOR_MASK_LSB    16
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSS_COLOR_MASK_WIDTH    ((u32)0x00000006)
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSSID_HIGH_MASK_MASK    ((u32)0x0000FFFF)
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSSID_HIGH_MASK_LSB    0
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSSID_HIGH_MASK_WIDTH    ((u32)0x00000010)

#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSS_COLOR_MASK_RST    0x0
#define MAC_HW_UL_BSSID_HIGH_MASK_UPLINK_BSSID_HIGH_MASK_RST    0x0

static inline void mac_hw_ul_bssid_high_mask_pack(struct cl_chip *chip, u8 uplink_bss_color_mask, u16 uplink_bssid_high_mask)
{
	ASSERT_ERR_CHIP((((u32)uplink_bss_color_mask << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)uplink_bssid_high_mask << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR, ((u32)uplink_bss_color_mask << 16) | ((u32)uplink_bssid_high_mask << 0));
}

static inline void mac_hw_ul_bssid_high_mask_unpack(struct cl_chip *chip, u8 *uplink_bss_color_mask, u16 *uplink_bssid_high_mask)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR);

	*uplink_bss_color_mask = (local_val & ((u32)0x003F0000)) >> 16;
	*uplink_bssid_high_mask = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_ul_bssid_high_mask_uplink_bss_color_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_ul_bssid_high_mask_uplink_bss_color_mask_setf(struct cl_chip *chip, u8 uplinkbsscolormask)
{
	ASSERT_ERR_CHIP((((u32)uplinkbsscolormask << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR, (cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR) & ~((u32)0x003F0000)) | ((u32)uplinkbsscolormask << 16));
}

static inline u16 mac_hw_ul_bssid_high_mask_uplink_bssid_high_mask_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_ul_bssid_high_mask_uplink_bssid_high_mask_setf(struct cl_chip *chip, u16 uplinkbssidhighmask)
{
	ASSERT_ERR_CHIP((((u32)uplinkbssidhighmask << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR, (cl_reg_read(chip, MAC_HW_UL_BSSID_HIGH_MASK_ADDR) & ~((u32)0x0000FFFF)) | ((u32)uplinkbssidhighmask << 0));
}

/**
 * @brief QUIET_ELEMENT_1_A register definition
 *  Contains parameters received in Quiet IEs. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 QUIET_DURATION_1          0x0
 *    15:08 QUIET_PERIOD_1            0x0
 *    07:00 QUIET_COUNT_1             0x0
 * </pre>
 */
#define MAC_HW_QUIET_ELEMENT_1_A_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000280)
#define MAC_HW_QUIET_ELEMENT_1_A_OFFSET      0x00000280
#define MAC_HW_QUIET_ELEMENT_1_A_INDEX       0x000000A0
#define MAC_HW_QUIET_ELEMENT_1_A_RESET       0x00000000

static inline u32 mac_hw_quiet_element_1_a_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR);
}

static inline void mac_hw_quiet_element_1_a_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR, value);
}

/* Field definitions */
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_DURATION_1_MASK    ((u32)0xFFFF0000)
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_DURATION_1_LSB    16
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_DURATION_1_WIDTH    ((u32)0x00000010)
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_PERIOD_1_MASK    ((u32)0x0000FF00)
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_PERIOD_1_LSB    8
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_PERIOD_1_WIDTH    ((u32)0x00000008)
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_COUNT_1_MASK    ((u32)0x000000FF)
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_COUNT_1_LSB    0
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_COUNT_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_DURATION_1_RST    0x0
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_PERIOD_1_RST    0x0
#define MAC_HW_QUIET_ELEMENT_1_A_QUIET_COUNT_1_RST    0x0

static inline void mac_hw_quiet_element_1_a_pack(struct cl_chip *chip, u16 quiet_duration_1, u8 quiet_period_1, u8 quiet_count_1)
{
	ASSERT_ERR_CHIP((((u32)quiet_duration_1 << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)quiet_period_1 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)quiet_count_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR, ((u32)quiet_duration_1 << 16) | ((u32)quiet_period_1 << 8) | ((u32)quiet_count_1 << 0));
}

static inline void mac_hw_quiet_element_1_a_unpack(struct cl_chip *chip, u16 *quiet_duration_1, u8 *quiet_period_1, u8 *quiet_count_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR);

	*quiet_duration_1 = (local_val & ((u32)0xFFFF0000)) >> 16;
	*quiet_period_1 = (local_val & ((u32)0x0000FF00)) >> 8;
	*quiet_count_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_quiet_element_1_a_quiet_duration_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_quiet_element_1_a_quiet_duration_1_setf(struct cl_chip *chip, u16 quietduration1)
{
	ASSERT_ERR_CHIP((((u32)quietduration1 << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR) & ~((u32)0xFFFF0000)) | ((u32)quietduration1 << 16));
}

static inline u8 mac_hw_quiet_element_1_a_quiet_period_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_quiet_element_1_a_quiet_period_1_setf(struct cl_chip *chip, u8 quietperiod1)
{
	ASSERT_ERR_CHIP((((u32)quietperiod1 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR) & ~((u32)0x0000FF00)) | ((u32)quietperiod1 << 8));
}

static inline u8 mac_hw_quiet_element_1_a_quiet_count_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_quiet_element_1_a_quiet_count_1_setf(struct cl_chip *chip, u8 quietcount1)
{
	ASSERT_ERR_CHIP((((u32)quietcount1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_A_ADDR) & ~((u32)0x000000FF)) | ((u32)quietcount1 << 0));
}

/**
 * @brief QUIET_ELEMENT_1_B register definition
 *  Contains parameters received in Quiet IEs. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 QUIET_OFFSET_1            0x0
 * </pre>
 */
#define MAC_HW_QUIET_ELEMENT_1_B_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000284)
#define MAC_HW_QUIET_ELEMENT_1_B_OFFSET      0x00000284
#define MAC_HW_QUIET_ELEMENT_1_B_INDEX       0x000000A1
#define MAC_HW_QUIET_ELEMENT_1_B_RESET       0x00000000

static inline u32 mac_hw_quiet_element_1_b_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_B_ADDR);
}

static inline void mac_hw_quiet_element_1_b_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_B_ADDR, value);
}

/* Field definitions */
#define MAC_HW_QUIET_ELEMENT_1_B_QUIET_OFFSET_1_MASK    ((u32)0x0000FFFF)
#define MAC_HW_QUIET_ELEMENT_1_B_QUIET_OFFSET_1_LSB    0
#define MAC_HW_QUIET_ELEMENT_1_B_QUIET_OFFSET_1_WIDTH    ((u32)0x00000010)

#define MAC_HW_QUIET_ELEMENT_1_B_QUIET_OFFSET_1_RST    0x0

static inline u16 mac_hw_quiet_element_1_b_quiet_offset_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_1_B_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_quiet_element_1_b_quiet_offset_1_setf(struct cl_chip *chip, u16 quietoffset1)
{
	ASSERT_ERR_CHIP((((u32)quietoffset1 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_1_B_ADDR, (u32)quietoffset1 << 0);
}

/**
 * @brief QUIET_ELEMENT_2_A register definition
 *  Contains parameters received in Quiet IEs. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 QUIET_DURATION_2          0x0
 *    15:08 QUIET_PERIOD_2            0x0
 *    07:00 QUIET_COUNT_2             0x0
 * </pre>
 */
#define MAC_HW_QUIET_ELEMENT_2_A_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000288)
#define MAC_HW_QUIET_ELEMENT_2_A_OFFSET      0x00000288
#define MAC_HW_QUIET_ELEMENT_2_A_INDEX       0x000000A2
#define MAC_HW_QUIET_ELEMENT_2_A_RESET       0x00000000

static inline u32 mac_hw_quiet_element_2_a_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR);
}

static inline void mac_hw_quiet_element_2_a_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR, value);
}

/* Field definitions */
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_DURATION_2_MASK    ((u32)0xFFFF0000)
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_DURATION_2_LSB    16
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_DURATION_2_WIDTH    ((u32)0x00000010)
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_PERIOD_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_PERIOD_2_LSB    8
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_PERIOD_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_COUNT_2_MASK    ((u32)0x000000FF)
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_COUNT_2_LSB    0
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_COUNT_2_WIDTH    ((u32)0x00000008)

#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_DURATION_2_RST    0x0
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_PERIOD_2_RST    0x0
#define MAC_HW_QUIET_ELEMENT_2_A_QUIET_COUNT_2_RST    0x0

static inline void mac_hw_quiet_element_2_a_pack(struct cl_chip *chip, u16 quiet_duration_2, u8 quiet_period_2, u8 quiet_count_2)
{
	ASSERT_ERR_CHIP((((u32)quiet_duration_2 << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)quiet_period_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)quiet_count_2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR, ((u32)quiet_duration_2 << 16) | ((u32)quiet_period_2 << 8) | ((u32)quiet_count_2 << 0));
}

static inline void mac_hw_quiet_element_2_a_unpack(struct cl_chip *chip, u16 *quiet_duration_2, u8 *quiet_period_2, u8 *quiet_count_2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR);

	*quiet_duration_2 = (local_val & ((u32)0xFFFF0000)) >> 16;
	*quiet_period_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*quiet_count_2 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_quiet_element_2_a_quiet_duration_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_quiet_element_2_a_quiet_duration_2_setf(struct cl_chip *chip, u16 quietduration2)
{
	ASSERT_ERR_CHIP((((u32)quietduration2 << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR) & ~((u32)0xFFFF0000)) | ((u32)quietduration2 << 16));
}

static inline u8 mac_hw_quiet_element_2_a_quiet_period_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_quiet_element_2_a_quiet_period_2_setf(struct cl_chip *chip, u8 quietperiod2)
{
	ASSERT_ERR_CHIP((((u32)quietperiod2 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR) & ~((u32)0x0000FF00)) | ((u32)quietperiod2 << 8));
}

static inline u8 mac_hw_quiet_element_2_a_quiet_count_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_quiet_element_2_a_quiet_count_2_setf(struct cl_chip *chip, u8 quietcount2)
{
	ASSERT_ERR_CHIP((((u32)quietcount2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR, (cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_A_ADDR) & ~((u32)0x000000FF)) | ((u32)quietcount2 << 0));
}

/**
 * @brief QUIET_ELEMENT_2_B register definition
 *  Contains parameters received in Quiet IEs. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 QUIET_OFFSET_2            0x0
 * </pre>
 */
#define MAC_HW_QUIET_ELEMENT_2_B_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000028C)
#define MAC_HW_QUIET_ELEMENT_2_B_OFFSET      0x0000028C
#define MAC_HW_QUIET_ELEMENT_2_B_INDEX       0x000000A3
#define MAC_HW_QUIET_ELEMENT_2_B_RESET       0x00000000

static inline u32 mac_hw_quiet_element_2_b_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_B_ADDR);
}

static inline void mac_hw_quiet_element_2_b_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_B_ADDR, value);
}

/* Field definitions */
#define MAC_HW_QUIET_ELEMENT_2_B_QUIET_OFFSET_2_MASK    ((u32)0x0000FFFF)
#define MAC_HW_QUIET_ELEMENT_2_B_QUIET_OFFSET_2_LSB    0
#define MAC_HW_QUIET_ELEMENT_2_B_QUIET_OFFSET_2_WIDTH    ((u32)0x00000010)

#define MAC_HW_QUIET_ELEMENT_2_B_QUIET_OFFSET_2_RST    0x0

static inline u16 mac_hw_quiet_element_2_b_quiet_offset_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_QUIET_ELEMENT_2_B_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_quiet_element_2_b_quiet_offset_2_setf(struct cl_chip *chip, u16 quietoffset2)
{
	ASSERT_ERR_CHIP((((u32)quietoffset2 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_QUIET_ELEMENT_2_B_ADDR, (u32)quietoffset2 << 0);
}

/**
 * @brief ADD_CCA_BUSY_SEC_20 register definition
 *  Indicates the CCA on Secondary 20MHz busy time. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CCA_BUSY_DUR_SEC_20       0x0
 * </pre>
 */
#define MAC_HW_ADD_CCA_BUSY_SEC_20_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000290)
#define MAC_HW_ADD_CCA_BUSY_SEC_20_OFFSET      0x00000290
#define MAC_HW_ADD_CCA_BUSY_SEC_20_INDEX       0x000000A4
#define MAC_HW_ADD_CCA_BUSY_SEC_20_RESET       0x00000000

static inline u32 mac_hw_add_cca_busy_sec_20_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_20_ADDR);
}

static inline void mac_hw_add_cca_busy_sec_20_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_20_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ADD_CCA_BUSY_SEC_20_CCA_BUSY_DUR_SEC_20_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ADD_CCA_BUSY_SEC_20_CCA_BUSY_DUR_SEC_20_LSB    0
#define MAC_HW_ADD_CCA_BUSY_SEC_20_CCA_BUSY_DUR_SEC_20_WIDTH    ((u32)0x00000020)

#define MAC_HW_ADD_CCA_BUSY_SEC_20_CCA_BUSY_DUR_SEC_20_RST    0x0

static inline u32 mac_hw_add_cca_busy_sec_20_cca_busy_dur_sec_20_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_20_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_add_cca_busy_sec_20_cca_busy_dur_sec_20_setf(struct cl_chip *chip, u32 ccabusydursec20)
{
	ASSERT_ERR_CHIP((((u32)ccabusydursec20 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_20_ADDR, (u32)ccabusydursec20 << 0);
}

/**
 * @brief ADD_CCA_BUSY_SEC_40 register definition
 *  Indicates the CCA on Secondary 40MHz busy time. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CCA_BUSY_DUR_SEC_40       0x0
 * </pre>
 */
#define MAC_HW_ADD_CCA_BUSY_SEC_40_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000294)
#define MAC_HW_ADD_CCA_BUSY_SEC_40_OFFSET      0x00000294
#define MAC_HW_ADD_CCA_BUSY_SEC_40_INDEX       0x000000A5
#define MAC_HW_ADD_CCA_BUSY_SEC_40_RESET       0x00000000

static inline u32 mac_hw_add_cca_busy_sec_40_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_40_ADDR);
}

static inline void mac_hw_add_cca_busy_sec_40_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_40_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ADD_CCA_BUSY_SEC_40_CCA_BUSY_DUR_SEC_40_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ADD_CCA_BUSY_SEC_40_CCA_BUSY_DUR_SEC_40_LSB    0
#define MAC_HW_ADD_CCA_BUSY_SEC_40_CCA_BUSY_DUR_SEC_40_WIDTH    ((u32)0x00000020)

#define MAC_HW_ADD_CCA_BUSY_SEC_40_CCA_BUSY_DUR_SEC_40_RST    0x0

static inline u32 mac_hw_add_cca_busy_sec_40_cca_busy_dur_sec_40_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_40_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_add_cca_busy_sec_40_cca_busy_dur_sec_40_setf(struct cl_chip *chip, u32 ccabusydursec40)
{
	ASSERT_ERR_CHIP((((u32)ccabusydursec40 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_40_ADDR, (u32)ccabusydursec40 << 0);
}

/**
 * @brief ADD_CCA_BUSY_SEC_80 register definition
 *  Indicates the CCA on Secondary 80MHz busy time. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 CCA_BUSY_DUR_SEC_80       0x0
 * </pre>
 */
#define MAC_HW_ADD_CCA_BUSY_SEC_80_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000298)
#define MAC_HW_ADD_CCA_BUSY_SEC_80_OFFSET      0x00000298
#define MAC_HW_ADD_CCA_BUSY_SEC_80_INDEX       0x000000A6
#define MAC_HW_ADD_CCA_BUSY_SEC_80_RESET       0x00000000

static inline u32 mac_hw_add_cca_busy_sec_80_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_80_ADDR);
}

static inline void mac_hw_add_cca_busy_sec_80_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_80_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ADD_CCA_BUSY_SEC_80_CCA_BUSY_DUR_SEC_80_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ADD_CCA_BUSY_SEC_80_CCA_BUSY_DUR_SEC_80_LSB    0
#define MAC_HW_ADD_CCA_BUSY_SEC_80_CCA_BUSY_DUR_SEC_80_WIDTH    ((u32)0x00000020)

#define MAC_HW_ADD_CCA_BUSY_SEC_80_CCA_BUSY_DUR_SEC_80_RST    0x0

static inline u32 mac_hw_add_cca_busy_sec_80_cca_busy_dur_sec_80_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ADD_CCA_BUSY_SEC_80_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_add_cca_busy_sec_80_cca_busy_dur_sec_80_setf(struct cl_chip *chip, u32 ccabusydursec80)
{
	ASSERT_ERR_CHIP((((u32)ccabusydursec80 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_ADD_CCA_BUSY_SEC_80_ADDR, (u32)ccabusydursec80 << 0);
}

/**
 * @brief BSR_0 register definition
 *  Indicate queue size for TID 0. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002A0)
#define MAC_HW_BSR_0_OFFSET      0x000002A0
#define MAC_HW_BSR_0_INDEX       0x000000A8
#define MAC_HW_BSR_0_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_0_ADDR);
}

static inline void mac_hw_bsr_0_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_0_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_0_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_0_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_0_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_0_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_0_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_0_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_0_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_0_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_1 register definition
 *  Indicate queue size for TID 1. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002A4)
#define MAC_HW_BSR_1_OFFSET      0x000002A4
#define MAC_HW_BSR_1_INDEX       0x000000A9
#define MAC_HW_BSR_1_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_1_ADDR);
}

static inline void mac_hw_bsr_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_1_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_1_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_1_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_1_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_1_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_1_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_1_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_1_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_2 register definition
 *  Indicate queue size for TID 2. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002A8)
#define MAC_HW_BSR_2_OFFSET      0x000002A8
#define MAC_HW_BSR_2_INDEX       0x000000AA
#define MAC_HW_BSR_2_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_2_ADDR);
}

static inline void mac_hw_bsr_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_2_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_2_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_2_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_2_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_2_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_2_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_2_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_2_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_3 register definition
 *  Indicate queue size for TID 3. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002AC)
#define MAC_HW_BSR_3_OFFSET      0x000002AC
#define MAC_HW_BSR_3_INDEX       0x000000AB
#define MAC_HW_BSR_3_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_3_ADDR);
}

static inline void mac_hw_bsr_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_3_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_3_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_3_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_3_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_3_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_3_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_3_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_3_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_4 register definition
 *  Indicate queue size for TID 4. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002B0)
#define MAC_HW_BSR_4_OFFSET      0x000002B0
#define MAC_HW_BSR_4_INDEX       0x000000AC
#define MAC_HW_BSR_4_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_4_ADDR);
}

static inline void mac_hw_bsr_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_4_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_4_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_4_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_4_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_4_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_4_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_4_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_4_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_5 register definition
 *  Indicate queue size for TID 5. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002B4)
#define MAC_HW_BSR_5_OFFSET      0x000002B4
#define MAC_HW_BSR_5_INDEX       0x000000AD
#define MAC_HW_BSR_5_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_5_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_5_ADDR);
}

static inline void mac_hw_bsr_5_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_5_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_5_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_5_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_5_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_5_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_5_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_5_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_5_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_5_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_6 register definition
 *  Indicate queue size for TID 6. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_6_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002B8)
#define MAC_HW_BSR_6_OFFSET      0x000002B8
#define MAC_HW_BSR_6_INDEX       0x000000AE
#define MAC_HW_BSR_6_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_6_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_6_ADDR);
}

static inline void mac_hw_bsr_6_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_6_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_6_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_6_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_6_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_6_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_6_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_6_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_6_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_6_ADDR, (u32)queuesize << 0);
}

/**
 * @brief BSR_7 register definition
 *  Indicate queue size for TID 7. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 queue_size                0xFFFF
 * </pre>
 */
#define MAC_HW_BSR_7_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002BC)
#define MAC_HW_BSR_7_OFFSET      0x000002BC
#define MAC_HW_BSR_7_INDEX       0x000000AF
#define MAC_HW_BSR_7_RESET       0x0000FFFF

static inline u32 mac_hw_bsr_7_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BSR_7_ADDR);
}

static inline void mac_hw_bsr_7_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BSR_7_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BSR_7_QUEUE_SIZE_MASK        ((u32)0x0000FFFF)
#define MAC_HW_BSR_7_QUEUE_SIZE_LSB         0
#define MAC_HW_BSR_7_QUEUE_SIZE_WIDTH       ((u32)0x00000010)

#define MAC_HW_BSR_7_QUEUE_SIZE_RST         0xFFFF

static inline u16 mac_hw_bsr_7_queue_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BSR_7_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_bsr_7_queue_size_setf(struct cl_chip *chip, u16 queuesize)
{
	ASSERT_ERR_CHIP((((u32)queuesize << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BSR_7_ADDR, (u32)queuesize << 0);
}

/**
 * @brief TX_POWER_BW_CALIB_FACTOR register definition
 *  Contains TX power BW calibration factor register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 BW_CALIB_FACTOR_160       0x0
 *    23:16 BW_CALIB_FACTOR_80        0x0
 *    15:08 BW_CALIB_FACTOR_40        0x0
 *    07:00 BW_CALIB_FACTOR_20        0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002C0)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_OFFSET      0x000002C0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_INDEX       0x000000B0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_RESET       0x00000000

static inline u32 mac_hw_tx_power_bw_calib_factor_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);
}

static inline void mac_hw_tx_power_bw_calib_factor_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_160_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_160_LSB    24
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_160_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_80_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_80_LSB    16
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_80_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_40_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_40_LSB    8
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_40_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_20_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_20_LSB    0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_20_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_160_RST    0x0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_80_RST    0x0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_40_RST    0x0
#define MAC_HW_TX_POWER_BW_CALIB_FACTOR_BW_CALIB_FACTOR_20_RST    0x0

static inline void mac_hw_tx_power_bw_calib_factor_pack(struct cl_chip *chip, u8 bw_calib_factor_160, u8 bw_calib_factor_80, u8 bw_calib_factor_40, u8 bw_calib_factor_20)
{
	ASSERT_ERR_CHIP((((u32)bw_calib_factor_160 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bw_calib_factor_80 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bw_calib_factor_40 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)bw_calib_factor_20 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, ((u32)bw_calib_factor_160 << 24) | ((u32)bw_calib_factor_80 << 16) | ((u32)bw_calib_factor_40 << 8) | ((u32)bw_calib_factor_20 << 0));
}

static inline void mac_hw_tx_power_bw_calib_factor_unpack(struct cl_chip *chip, u8 *bw_calib_factor_160, u8 *bw_calib_factor_80, u8 *bw_calib_factor_40, u8 *bw_calib_factor_20)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);

	*bw_calib_factor_160 = (local_val & ((u32)0xFF000000)) >> 24;
	*bw_calib_factor_80 = (local_val & ((u32)0x00FF0000)) >> 16;
	*bw_calib_factor_40 = (local_val & ((u32)0x0000FF00)) >> 8;
	*bw_calib_factor_20 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_power_bw_calib_factor_bw_calib_factor_160_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_power_bw_calib_factor_bw_calib_factor_160_setf(struct cl_chip *chip, u8 bwcalibfactor160)
{
	ASSERT_ERR_CHIP((((u32)bwcalibfactor160 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR) & ~((u32)0xFF000000)) | ((u32)bwcalibfactor160 << 24));
}

static inline u8 mac_hw_tx_power_bw_calib_factor_bw_calib_factor_80_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_power_bw_calib_factor_bw_calib_factor_80_setf(struct cl_chip *chip, u8 bwcalibfactor80)
{
	ASSERT_ERR_CHIP((((u32)bwcalibfactor80 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR) & ~((u32)0x00FF0000)) | ((u32)bwcalibfactor80 << 16));
}

static inline u8 mac_hw_tx_power_bw_calib_factor_bw_calib_factor_40_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_power_bw_calib_factor_bw_calib_factor_40_setf(struct cl_chip *chip, u8 bwcalibfactor40)
{
	ASSERT_ERR_CHIP((((u32)bwcalibfactor40 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR) & ~((u32)0x0000FF00)) | ((u32)bwcalibfactor40 << 8));
}

static inline u8 mac_hw_tx_power_bw_calib_factor_bw_calib_factor_20_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_power_bw_calib_factor_bw_calib_factor_20_setf(struct cl_chip *chip, u8 bwcalibfactor20)
{
	ASSERT_ERR_CHIP((((u32)bwcalibfactor20 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_BW_CALIB_FACTOR_ADDR) & ~((u32)0x000000FF)) | ((u32)bwcalibfactor20 << 0));
}

/**
 * @brief TX_POWER_ANTENNA_FACTOR_1 register definition
 *  Contains TX power compensation for number of TX ch register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 ANTENNA_FACTOR_4          0x30
 *    23:16 ANTENNA_FACTOR_3          0x26
 *    15:08 ANTENNA_FACTOR_2          0x18
 *    07:00 ANTENNA_FACTOR_1          0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002C4)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_OFFSET      0x000002C4
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_INDEX       0x000000B1
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_RESET       0x30261800

static inline u32 mac_hw_tx_power_antenna_factor_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);
}

static inline void mac_hw_tx_power_antenna_factor_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_4_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_4_LSB    24
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_4_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_3_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_3_LSB    16
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_2_LSB    8
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_1_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_1_LSB    0
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_4_RST    0x30
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_3_RST    0x26
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_2_RST    0x18
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ANTENNA_FACTOR_1_RST    0x0

static inline void mac_hw_tx_power_antenna_factor_1_pack(struct cl_chip *chip, u8 antenna_factor_4, u8 antenna_factor_3, u8 antenna_factor_2, u8 antenna_factor_1)
{
	ASSERT_ERR_CHIP((((u32)antenna_factor_4 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_3 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, ((u32)antenna_factor_4 << 24) | ((u32)antenna_factor_3 << 16) | ((u32)antenna_factor_2 << 8) | ((u32)antenna_factor_1 << 0));
}

static inline void mac_hw_tx_power_antenna_factor_1_unpack(struct cl_chip *chip, u8 *antenna_factor_4, u8 *antenna_factor_3, u8 *antenna_factor_2, u8 *antenna_factor_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);

	*antenna_factor_4 = (local_val & ((u32)0xFF000000)) >> 24;
	*antenna_factor_3 = (local_val & ((u32)0x00FF0000)) >> 16;
	*antenna_factor_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*antenna_factor_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_power_antenna_factor_1_antenna_factor_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_power_antenna_factor_1_antenna_factor_4_setf(struct cl_chip *chip, u8 antennafactor4)
{
	ASSERT_ERR_CHIP((((u32)antennafactor4 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR) & ~((u32)0xFF000000)) | ((u32)antennafactor4 << 24));
}

static inline u8 mac_hw_tx_power_antenna_factor_1_antenna_factor_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_power_antenna_factor_1_antenna_factor_3_setf(struct cl_chip *chip, u8 antennafactor3)
{
	ASSERT_ERR_CHIP((((u32)antennafactor3 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR) & ~((u32)0x00FF0000)) | ((u32)antennafactor3 << 16));
}

static inline u8 mac_hw_tx_power_antenna_factor_1_antenna_factor_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_power_antenna_factor_1_antenna_factor_2_setf(struct cl_chip *chip, u8 antennafactor2)
{
	ASSERT_ERR_CHIP((((u32)antennafactor2 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR) & ~((u32)0x0000FF00)) | ((u32)antennafactor2 << 8));
}

static inline u8 mac_hw_tx_power_antenna_factor_1_antenna_factor_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_power_antenna_factor_1_antenna_factor_1_setf(struct cl_chip *chip, u8 antennafactor1)
{
	ASSERT_ERR_CHIP((((u32)antennafactor1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_1_ADDR) & ~((u32)0x000000FF)) | ((u32)antennafactor1 << 0));
}

/**
 * @brief TX_POWER_ANTENNA_FACTOR_2 register definition
 *  Contains TX power compensation for number of TX ch register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 ANTENNA_FACTOR_8          0x48
 *    23:16 ANTENNA_FACTOR_7          0x44
 *    15:08 ANTENNA_FACTOR_6          0x3E
 *    07:00 ANTENNA_FACTOR_5          0x38
 * </pre>
 */
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002C8)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_OFFSET      0x000002C8
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_INDEX       0x000000B2
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_RESET       0x48443E38

static inline u32 mac_hw_tx_power_antenna_factor_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);
}

static inline void mac_hw_tx_power_antenna_factor_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_8_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_8_LSB    24
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_8_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_7_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_7_LSB    16
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_7_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_6_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_6_LSB    8
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_6_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_5_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_5_LSB    0
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_5_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_8_RST    0x48
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_7_RST    0x44
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_6_RST    0x3E
#define MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ANTENNA_FACTOR_5_RST    0x38

static inline void mac_hw_tx_power_antenna_factor_2_pack(struct cl_chip *chip, u8 antenna_factor_8, u8 antenna_factor_7, u8 antenna_factor_6, u8 antenna_factor_5)
{
	ASSERT_ERR_CHIP((((u32)antenna_factor_8 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_7 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_6 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)antenna_factor_5 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, ((u32)antenna_factor_8 << 24) | ((u32)antenna_factor_7 << 16) | ((u32)antenna_factor_6 << 8) | ((u32)antenna_factor_5 << 0));
}

static inline void mac_hw_tx_power_antenna_factor_2_unpack(struct cl_chip *chip, u8 *antenna_factor_8, u8 *antenna_factor_7, u8 *antenna_factor_6, u8 *antenna_factor_5)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);

	*antenna_factor_8 = (local_val & ((u32)0xFF000000)) >> 24;
	*antenna_factor_7 = (local_val & ((u32)0x00FF0000)) >> 16;
	*antenna_factor_6 = (local_val & ((u32)0x0000FF00)) >> 8;
	*antenna_factor_5 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_power_antenna_factor_2_antenna_factor_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_power_antenna_factor_2_antenna_factor_8_setf(struct cl_chip *chip, u8 antennafactor8)
{
	ASSERT_ERR_CHIP((((u32)antennafactor8 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR) & ~((u32)0xFF000000)) | ((u32)antennafactor8 << 24));
}

static inline u8 mac_hw_tx_power_antenna_factor_2_antenna_factor_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_power_antenna_factor_2_antenna_factor_7_setf(struct cl_chip *chip, u8 antennafactor7)
{
	ASSERT_ERR_CHIP((((u32)antennafactor7 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR) & ~((u32)0x00FF0000)) | ((u32)antennafactor7 << 16));
}

static inline u8 mac_hw_tx_power_antenna_factor_2_antenna_factor_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_power_antenna_factor_2_antenna_factor_6_setf(struct cl_chip *chip, u8 antennafactor6)
{
	ASSERT_ERR_CHIP((((u32)antennafactor6 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR) & ~((u32)0x0000FF00)) | ((u32)antennafactor6 << 8));
}

static inline u8 mac_hw_tx_power_antenna_factor_2_antenna_factor_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_power_antenna_factor_2_antenna_factor_5_setf(struct cl_chip *chip, u8 antennafactor5)
{
	ASSERT_ERR_CHIP((((u32)antennafactor5 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_ANTENNA_FACTOR_2_ADDR) & ~((u32)0x000000FF)) | ((u32)antennafactor5 << 0));
}

/**
 * @brief TX_POWER_CTRL register definition
 *  Configures TX power parameters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    09:08 DISTANCE_MSTA             0x0
 *    01:00 DEFAULT_DISTANCE          0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_CTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002CC)
#define MAC_HW_TX_POWER_CTRL_OFFSET      0x000002CC
#define MAC_HW_TX_POWER_CTRL_INDEX       0x000000B3
#define MAC_HW_TX_POWER_CTRL_RESET       0x00000000

static inline u32 mac_hw_tx_power_ctrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR);
}

static inline void mac_hw_tx_power_ctrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_CTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_CTRL_DISTANCE_MSTA_MASK    ((u32)0x00000300)
#define MAC_HW_TX_POWER_CTRL_DISTANCE_MSTA_LSB    8
#define MAC_HW_TX_POWER_CTRL_DISTANCE_MSTA_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_POWER_CTRL_DEFAULT_DISTANCE_MASK    ((u32)0x00000003)
#define MAC_HW_TX_POWER_CTRL_DEFAULT_DISTANCE_LSB    0
#define MAC_HW_TX_POWER_CTRL_DEFAULT_DISTANCE_WIDTH    ((u32)0x00000002)

#define MAC_HW_TX_POWER_CTRL_DISTANCE_MSTA_RST    0x0
#define MAC_HW_TX_POWER_CTRL_DEFAULT_DISTANCE_RST    0x0

static inline void mac_hw_tx_power_ctrl_pack(struct cl_chip *chip, u8 distance_msta, u8 default_distance)
{
	ASSERT_ERR_CHIP((((u32)distance_msta << 8) & ~((u32)0x00000300)) == 0);
	ASSERT_ERR_CHIP((((u32)default_distance << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_CTRL_ADDR, ((u32)distance_msta << 8) | ((u32)default_distance << 0));
}

static inline void mac_hw_tx_power_ctrl_unpack(struct cl_chip *chip, u8 *distance_msta, u8 *default_distance)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR);

	*distance_msta = (local_val & ((u32)0x00000300)) >> 8;
	*default_distance = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_tx_power_ctrl_distance_msta_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000300)) >> 8);
}

static inline void mac_hw_tx_power_ctrl_distance_msta_setf(struct cl_chip *chip, u8 distancemsta)
{
	ASSERT_ERR_CHIP((((u32)distancemsta << 8) & ~((u32)0x00000300)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR) & ~((u32)0x00000300)) | ((u32)distancemsta << 8));
}

static inline u8 mac_hw_tx_power_ctrl_default_distance_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

static inline void mac_hw_tx_power_ctrl_default_distance_setf(struct cl_chip *chip, u8 defaultdistance)
{
	ASSERT_ERR_CHIP((((u32)defaultdistance << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_POWER_CTRL_ADDR) & ~((u32)0x00000003)) | ((u32)defaultdistance << 0));
}

/**
 * @brief TX_POWER_MEM_ADDR register definition
 *  Configures the TX power memory line address  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    06:00 TX_POWER_MEM_ADDR         0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_MEM_ADDR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002D0)
#define MAC_HW_TX_POWER_MEM_ADDR_OFFSET      0x000002D0
#define MAC_HW_TX_POWER_MEM_ADDR_INDEX       0x000000B4
#define MAC_HW_TX_POWER_MEM_ADDR_RESET       0x00000000

static inline u32 mac_hw_tx_power_mem_addr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_MEM_ADDR_ADDR);
}

static inline void mac_hw_tx_power_mem_addr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_MEM_ADDR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_MEM_ADDR_TX_POWER_MEM_ADDR_MASK    ((u32)0x0000007F)
#define MAC_HW_TX_POWER_MEM_ADDR_TX_POWER_MEM_ADDR_LSB    0
#define MAC_HW_TX_POWER_MEM_ADDR_TX_POWER_MEM_ADDR_WIDTH    ((u32)0x00000007)

#define MAC_HW_TX_POWER_MEM_ADDR_TX_POWER_MEM_ADDR_RST    0x0

static inline u8 mac_hw_tx_power_mem_addr_tx_power_mem_addr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_MEM_ADDR_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_tx_power_mem_addr_tx_power_mem_addr_setf(struct cl_chip *chip, u8 txpowermemaddr)
{
	ASSERT_ERR_CHIP((((u32)txpowermemaddr << 0) & ~((u32)0x0000007F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_MEM_ADDR_ADDR, (u32)txpowermemaddr << 0);
}

/**
 * @brief TX_POWER_MEM_DATA register definition
 *  Configures the TX power memory line content register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_POWER_MEM_DATA         0x0
 * </pre>
 */
#define MAC_HW_TX_POWER_MEM_DATA_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002D4)
#define MAC_HW_TX_POWER_MEM_DATA_OFFSET      0x000002D4
#define MAC_HW_TX_POWER_MEM_DATA_INDEX       0x000000B5
#define MAC_HW_TX_POWER_MEM_DATA_RESET       0x00000000

static inline u32 mac_hw_tx_power_mem_data_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_POWER_MEM_DATA_ADDR);
}

static inline void mac_hw_tx_power_mem_data_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_POWER_MEM_DATA_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_POWER_MEM_DATA_TX_POWER_MEM_DATA_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_POWER_MEM_DATA_TX_POWER_MEM_DATA_LSB    0
#define MAC_HW_TX_POWER_MEM_DATA_TX_POWER_MEM_DATA_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_POWER_MEM_DATA_TX_POWER_MEM_DATA_RST    0x0

static inline u32 mac_hw_tx_power_mem_data_tx_power_mem_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_POWER_MEM_DATA_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_power_mem_data_tx_power_mem_data_setf(struct cl_chip *chip, u32 txpowermemdata)
{
	ASSERT_ERR_CHIP((((u32)txpowermemdata << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_POWER_MEM_DATA_ADDR, (u32)txpowermemdata << 0);
}

/**
 * @brief TXOP_TIMER register definition
 *  Indicates the remained TXOP time register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 REMAINED_TXOP_DURATION    0x0
 * </pre>
 */
#define MAC_HW_TXOP_TIMER_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000002E0)
#define MAC_HW_TXOP_TIMER_OFFSET      0x000002E0
#define MAC_HW_TXOP_TIMER_INDEX       0x000000B8
#define MAC_HW_TXOP_TIMER_RESET       0x00000000

static inline u32 mac_hw_txop_timer_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TXOP_TIMER_ADDR);
}

/* Field definitions */
#define MAC_HW_TXOP_TIMER_REMAINED_TXOP_DURATION_MASK    ((u32)0x0000FFFF)
#define MAC_HW_TXOP_TIMER_REMAINED_TXOP_DURATION_LSB    0
#define MAC_HW_TXOP_TIMER_REMAINED_TXOP_DURATION_WIDTH    ((u32)0x00000010)

#define MAC_HW_TXOP_TIMER_REMAINED_TXOP_DURATION_RST    0x0

static inline u16 mac_hw_txop_timer_remained_txop_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TXOP_TIMER_ADDR);

	return (u16)(local_val >> 0);
}

/**
 * @brief STBC_CNTRL register definition
 *  Controls STBC protection functionality. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:25 BASIC_STBCMCS             0x0
 *    24    DUAL_CTS_PROT             0
 *    23:16 CTS_STBC_DUR              0x0
 *    15:00 CF_END_STBC_DUR           0x0
 * </pre>
 */
#define MAC_HW_STBC_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000300)
#define MAC_HW_STBC_CNTRL_OFFSET      0x00000300
#define MAC_HW_STBC_CNTRL_INDEX       0x000000C0
#define MAC_HW_STBC_CNTRL_RESET       0x00000000

static inline u32 mac_hw_stbc_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);
}

static inline void mac_hw_stbc_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_STBC_CNTRL_BASIC_STBCMCS_MASK    ((u32)0xFE000000)
#define MAC_HW_STBC_CNTRL_BASIC_STBCMCS_LSB    25
#define MAC_HW_STBC_CNTRL_BASIC_STBCMCS_WIDTH    ((u32)0x00000007)
#define MAC_HW_STBC_CNTRL_DUAL_CTS_PROT_BIT    ((u32)0x01000000)
#define MAC_HW_STBC_CNTRL_DUAL_CTS_PROT_POS    24
#define MAC_HW_STBC_CNTRL_CTS_STBC_DUR_MASK    ((u32)0x00FF0000)
#define MAC_HW_STBC_CNTRL_CTS_STBC_DUR_LSB    16
#define MAC_HW_STBC_CNTRL_CTS_STBC_DUR_WIDTH    ((u32)0x00000008)
#define MAC_HW_STBC_CNTRL_CF_END_STBC_DUR_MASK    ((u32)0x0000FFFF)
#define MAC_HW_STBC_CNTRL_CF_END_STBC_DUR_LSB    0
#define MAC_HW_STBC_CNTRL_CF_END_STBC_DUR_WIDTH    ((u32)0x00000010)

#define MAC_HW_STBC_CNTRL_BASIC_STBCMCS_RST    0x0
#define MAC_HW_STBC_CNTRL_DUAL_CTS_PROT_RST    0x0
#define MAC_HW_STBC_CNTRL_CTS_STBC_DUR_RST    0x0
#define MAC_HW_STBC_CNTRL_CF_END_STBC_DUR_RST    0x0

static inline void mac_hw_stbc_cntrl_pack(struct cl_chip *chip, u8 basic_stbcmcs, u8 dual_cts_prot, u8 cts_stbc_dur, u16 cf_end_stbc_dur)
{
	ASSERT_ERR_CHIP((((u32)basic_stbcmcs << 25) & ~((u32)0xFE000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dual_cts_prot << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)cts_stbc_dur << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)cf_end_stbc_dur << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, ((u32)basic_stbcmcs << 25) | ((u32)dual_cts_prot << 24) | ((u32)cts_stbc_dur << 16) | ((u32)cf_end_stbc_dur << 0));
}

static inline void mac_hw_stbc_cntrl_unpack(struct cl_chip *chip, u8 *basic_stbcmcs, u8 *dual_cts_prot, u8 *cts_stbc_dur, u16 *cf_end_stbc_dur)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);

	*basic_stbcmcs = (local_val & ((u32)0xFE000000)) >> 25;
	*dual_cts_prot = (local_val & ((u32)0x01000000)) >> 24;
	*cts_stbc_dur = (local_val & ((u32)0x00FF0000)) >> 16;
	*cf_end_stbc_dur = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_stbc_cntrl_basic_stbcmcs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0xFE000000)) >> 25);
}

static inline void mac_hw_stbc_cntrl_basic_stbcmcs_setf(struct cl_chip *chip, u8 basicstbcmcs)
{
	ASSERT_ERR_CHIP((((u32)basicstbcmcs << 25) & ~((u32)0xFE000000)) == 0);
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR) & ~((u32)0xFE000000)) | ((u32)basicstbcmcs << 25));
}

static inline u8 mac_hw_stbc_cntrl_dual_cts_prot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_stbc_cntrl_dual_cts_prot_setf(struct cl_chip *chip, u8 dualctsprot)
{
	ASSERT_ERR_CHIP((((u32)dualctsprot << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR) & ~((u32)0x01000000)) | ((u32)dualctsprot << 24));
}

static inline u8 mac_hw_stbc_cntrl_cts_stbc_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_stbc_cntrl_cts_stbc_dur_setf(struct cl_chip *chip, u8 ctsstbcdur)
{
	ASSERT_ERR_CHIP((((u32)ctsstbcdur << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR) & ~((u32)0x00FF0000)) | ((u32)ctsstbcdur << 16));
}

static inline u16 mac_hw_stbc_cntrl_cf_end_stbc_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_stbc_cntrl_cf_end_stbc_dur_setf(struct cl_chip *chip, u16 cfendstbcdur)
{
	ASSERT_ERR_CHIP((((u32)cfendstbcdur << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_STBC_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_STBC_CNTRL_ADDR) & ~((u32)0x0000FFFF)) | ((u32)cfendstbcdur << 0));
}

/**
 * @brief START_TX_1 register definition
 *  Used to trigger the HW to transmit a control frame at the start of a TXOP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:28 START_TX_BW               0x0
 *    27    START_TX_PRE_TYPE         0
 *    26:24 START_TX_FORMAT_MOD       0x0
 *    23:16 START_TX_MCS_INDEX_0      0x0
 *    15:06 START_TX_KSR_INDEX        0x0
 *    04:03 START_TX_AC               0x0
 *    02:01 START_TX_FRM_EX_TYPE      0x0
 *    00    START_TX_FRAME_EX         0
 * </pre>
 */
#define MAC_HW_START_TX_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000304)
#define MAC_HW_START_TX_1_OFFSET      0x00000304
#define MAC_HW_START_TX_1_INDEX       0x000000C1
#define MAC_HW_START_TX_1_RESET       0x00000000

static inline u32 mac_hw_start_tx_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);
}

static inline void mac_hw_start_tx_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_START_TX_1_START_TX_BW_MASK    ((u32)0x30000000)
#define MAC_HW_START_TX_1_START_TX_BW_LSB    28
#define MAC_HW_START_TX_1_START_TX_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_START_TX_1_START_TX_PRE_TYPE_BIT    ((u32)0x08000000)
#define MAC_HW_START_TX_1_START_TX_PRE_TYPE_POS    27
#define MAC_HW_START_TX_1_START_TX_FORMAT_MOD_MASK    ((u32)0x07000000)
#define MAC_HW_START_TX_1_START_TX_FORMAT_MOD_LSB    24
#define MAC_HW_START_TX_1_START_TX_FORMAT_MOD_WIDTH    ((u32)0x00000003)
#define MAC_HW_START_TX_1_START_TX_MCS_INDEX_0_MASK    ((u32)0x00FF0000)
#define MAC_HW_START_TX_1_START_TX_MCS_INDEX_0_LSB    16
#define MAC_HW_START_TX_1_START_TX_MCS_INDEX_0_WIDTH    ((u32)0x00000008)
#define MAC_HW_START_TX_1_START_TX_KSR_INDEX_MASK    ((u32)0x0000FFC0)
#define MAC_HW_START_TX_1_START_TX_KSR_INDEX_LSB    6
#define MAC_HW_START_TX_1_START_TX_KSR_INDEX_WIDTH    ((u32)0x0000000A)
#define MAC_HW_START_TX_1_START_TX_AC_MASK    ((u32)0x00000018)
#define MAC_HW_START_TX_1_START_TX_AC_LSB    3
#define MAC_HW_START_TX_1_START_TX_AC_WIDTH    ((u32)0x00000002)
#define MAC_HW_START_TX_1_START_TX_FRM_EX_TYPE_MASK    ((u32)0x00000006)
#define MAC_HW_START_TX_1_START_TX_FRM_EX_TYPE_LSB    1
#define MAC_HW_START_TX_1_START_TX_FRM_EX_TYPE_WIDTH    ((u32)0x00000002)
#define MAC_HW_START_TX_1_START_TX_FRAME_EX_BIT    ((u32)0x00000001)
#define MAC_HW_START_TX_1_START_TX_FRAME_EX_POS    0

#define MAC_HW_START_TX_1_START_TX_BW_RST    0x0
#define MAC_HW_START_TX_1_START_TX_PRE_TYPE_RST    0x0
#define MAC_HW_START_TX_1_START_TX_FORMAT_MOD_RST    0x0
#define MAC_HW_START_TX_1_START_TX_MCS_INDEX_0_RST    0x0
#define MAC_HW_START_TX_1_START_TX_KSR_INDEX_RST    0x0
#define MAC_HW_START_TX_1_START_TX_AC_RST    0x0
#define MAC_HW_START_TX_1_START_TX_FRM_EX_TYPE_RST    0x0
#define MAC_HW_START_TX_1_START_TX_FRAME_EX_RST    0x0

static inline void mac_hw_start_tx_1_pack(struct cl_chip *chip, u8 start_tx_bw, u8 start_tx_pre_type, u8 start_tx_format_mod, u8 start_tx_mcs_index_0, u16 start_tx_ksr_index, u8 start_tx_ac, u8 start_tx_frm_ex_type, u8 start_tx_frame_ex)
{
	ASSERT_ERR_CHIP((((u32)start_tx_bw << 28) & ~((u32)0x30000000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_pre_type << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_format_mod << 24) & ~((u32)0x07000000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_mcs_index_0 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_ksr_index << 6) & ~((u32)0x0000FFC0)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_ac << 3) & ~((u32)0x00000018)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_frm_ex_type << 1) & ~((u32)0x00000006)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_frame_ex << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, ((u32)start_tx_bw << 28) | ((u32)start_tx_pre_type << 27) | ((u32)start_tx_format_mod << 24) | ((u32)start_tx_mcs_index_0 << 16) | ((u32)start_tx_ksr_index << 6) | ((u32)start_tx_ac << 3) | ((u32)start_tx_frm_ex_type << 1) | ((u32)start_tx_frame_ex << 0));
}

static inline void mac_hw_start_tx_1_unpack(struct cl_chip *chip, u8 *start_tx_bw, u8 *start_tx_pre_type, u8 *start_tx_format_mod, u8 *start_tx_mcs_index_0, u16 *start_tx_ksr_index, u8 *start_tx_ac, u8 *start_tx_frm_ex_type, u8 *start_tx_frame_ex)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	*start_tx_bw = (local_val & ((u32)0x30000000)) >> 28;
	*start_tx_pre_type = (local_val & ((u32)0x08000000)) >> 27;
	*start_tx_format_mod = (local_val & ((u32)0x07000000)) >> 24;
	*start_tx_mcs_index_0 = (local_val & ((u32)0x00FF0000)) >> 16;
	*start_tx_ksr_index = (local_val & ((u32)0x0000FFC0)) >> 6;
	*start_tx_ac = (local_val & ((u32)0x00000018)) >> 3;
	*start_tx_frm_ex_type = (local_val & ((u32)0x00000006)) >> 1;
	*start_tx_frame_ex = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_start_tx_1_start_tx_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x30000000)) >> 28);
}

static inline void mac_hw_start_tx_1_start_tx_bw_setf(struct cl_chip *chip, u8 starttxbw)
{
	ASSERT_ERR_CHIP((((u32)starttxbw << 28) & ~((u32)0x30000000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x30000000)) | ((u32)starttxbw << 28));
}

static inline u8 mac_hw_start_tx_1_start_tx_pre_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_start_tx_1_start_tx_pre_type_setf(struct cl_chip *chip, u8 starttxpretype)
{
	ASSERT_ERR_CHIP((((u32)starttxpretype << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x08000000)) | ((u32)starttxpretype << 27));
}

static inline u8 mac_hw_start_tx_1_start_tx_format_mod_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x07000000)) >> 24);
}

static inline void mac_hw_start_tx_1_start_tx_format_mod_setf(struct cl_chip *chip, u8 starttxformatmod)
{
	ASSERT_ERR_CHIP((((u32)starttxformatmod << 24) & ~((u32)0x07000000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x07000000)) | ((u32)starttxformatmod << 24));
}

static inline u8 mac_hw_start_tx_1_start_tx_mcs_index_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_start_tx_1_start_tx_mcs_index_0_setf(struct cl_chip *chip, u8 starttxmcsindex0)
{
	ASSERT_ERR_CHIP((((u32)starttxmcsindex0 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x00FF0000)) | ((u32)starttxmcsindex0 << 16));
}

static inline u16 mac_hw_start_tx_1_start_tx_ksr_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFC0)) >> 6);
}

static inline void mac_hw_start_tx_1_start_tx_ksr_index_setf(struct cl_chip *chip, u16 starttxksrindex)
{
	ASSERT_ERR_CHIP((((u32)starttxksrindex << 6) & ~((u32)0x0000FFC0)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x0000FFC0)) | ((u32)starttxksrindex << 6));
}

static inline u8 mac_hw_start_tx_1_start_tx_ac_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x00000018)) >> 3);
}

static inline void mac_hw_start_tx_1_start_tx_ac_setf(struct cl_chip *chip, u8 starttxac)
{
	ASSERT_ERR_CHIP((((u32)starttxac << 3) & ~((u32)0x00000018)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x00000018)) | ((u32)starttxac << 3));
}

static inline u8 mac_hw_start_tx_1_start_tx_frm_ex_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x00000006)) >> 1);
}

static inline void mac_hw_start_tx_1_start_tx_frm_ex_type_setf(struct cl_chip *chip, u8 starttxfrmextype)
{
	ASSERT_ERR_CHIP((((u32)starttxfrmextype << 1) & ~((u32)0x00000006)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x00000006)) | ((u32)starttxfrmextype << 1));
}

static inline u8 mac_hw_start_tx_1_start_tx_frame_ex_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_1_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_start_tx_1_start_tx_frame_ex_setf(struct cl_chip *chip, u8 starttxframeex)
{
	ASSERT_ERR_CHIP((((u32)starttxframeex << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_1_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_1_ADDR) & ~((u32)0x00000001)) | ((u32)starttxframeex << 0));
}

/**
 * @brief START_TX_2 register definition
 *  Used to trigger the HW to transmit a control frame at the start of a TXOP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 DUR_CONTROL_FRM           0xFFFF
 * </pre>
 */
#define MAC_HW_START_TX_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000308)
#define MAC_HW_START_TX_2_OFFSET      0x00000308
#define MAC_HW_START_TX_2_INDEX       0x000000C2
#define MAC_HW_START_TX_2_RESET       0x0000FFFF

static inline u32 mac_hw_start_tx_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_START_TX_2_ADDR);
}

static inline void mac_hw_start_tx_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_START_TX_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_START_TX_2_DUR_CONTROL_FRM_MASK    ((u32)0x0000FFFF)
#define MAC_HW_START_TX_2_DUR_CONTROL_FRM_LSB    0
#define MAC_HW_START_TX_2_DUR_CONTROL_FRM_WIDTH    ((u32)0x00000010)

#define MAC_HW_START_TX_2_DUR_CONTROL_FRM_RST    0xFFFF

static inline u16 mac_hw_start_tx_2_dur_control_frm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_2_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_start_tx_2_dur_control_frm_setf(struct cl_chip *chip, u16 durcontrolfrm)
{
	ASSERT_ERR_CHIP((((u32)durcontrolfrm << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_2_ADDR, (u32)durcontrolfrm << 0);
}

/**
 * @brief START_TX_3 register definition
 *  Used to trigger the HW to transmit a control frame at the start of a TXOP. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 START_TX_SMM_INDEX        0x0
 *    23:16 START_TX_ANTENNA_SET      0x0
 *    13    START_TX_LSTP             0
 *    12    START_TX_SMOOTHING        1
 *    08    START_TX_SHORT_GI         0
 *    07:05 START_TX_N_TX             0x0
 *    04    START_TX_FEC_CODING       0
 *    03:02 START_TX_STBC             0x0
 *    01:00 START_TX_NUM_EXTN_SS      0x0
 * </pre>
 */
#define MAC_HW_START_TX_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000030C)
#define MAC_HW_START_TX_3_OFFSET      0x0000030C
#define MAC_HW_START_TX_3_INDEX       0x000000C3
#define MAC_HW_START_TX_3_RESET       0x00001000

static inline u32 mac_hw_start_tx_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);
}

static inline void mac_hw_start_tx_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_START_TX_3_START_TX_SMM_INDEX_MASK    ((u32)0xFF000000)
#define MAC_HW_START_TX_3_START_TX_SMM_INDEX_LSB    24
#define MAC_HW_START_TX_3_START_TX_SMM_INDEX_WIDTH    ((u32)0x00000008)
#define MAC_HW_START_TX_3_START_TX_ANTENNA_SET_MASK    ((u32)0x00FF0000)
#define MAC_HW_START_TX_3_START_TX_ANTENNA_SET_LSB    16
#define MAC_HW_START_TX_3_START_TX_ANTENNA_SET_WIDTH    ((u32)0x00000008)
#define MAC_HW_START_TX_3_START_TX_LSTP_BIT    ((u32)0x00002000)
#define MAC_HW_START_TX_3_START_TX_LSTP_POS    13
#define MAC_HW_START_TX_3_START_TX_SMOOTHING_BIT    ((u32)0x00001000)
#define MAC_HW_START_TX_3_START_TX_SMOOTHING_POS    12
#define MAC_HW_START_TX_3_START_TX_SHORT_GI_BIT    ((u32)0x00000100)
#define MAC_HW_START_TX_3_START_TX_SHORT_GI_POS    8
#define MAC_HW_START_TX_3_START_TX_N_TX_MASK    ((u32)0x000000E0)
#define MAC_HW_START_TX_3_START_TX_N_TX_LSB    5
#define MAC_HW_START_TX_3_START_TX_N_TX_WIDTH    ((u32)0x00000003)
#define MAC_HW_START_TX_3_START_TX_FEC_CODING_BIT    ((u32)0x00000010)
#define MAC_HW_START_TX_3_START_TX_FEC_CODING_POS    4
#define MAC_HW_START_TX_3_START_TX_STBC_MASK    ((u32)0x0000000C)
#define MAC_HW_START_TX_3_START_TX_STBC_LSB    2
#define MAC_HW_START_TX_3_START_TX_STBC_WIDTH    ((u32)0x00000002)
#define MAC_HW_START_TX_3_START_TX_NUM_EXTN_SS_MASK    ((u32)0x00000003)
#define MAC_HW_START_TX_3_START_TX_NUM_EXTN_SS_LSB    0
#define MAC_HW_START_TX_3_START_TX_NUM_EXTN_SS_WIDTH    ((u32)0x00000002)

#define MAC_HW_START_TX_3_START_TX_SMM_INDEX_RST    0x0
#define MAC_HW_START_TX_3_START_TX_ANTENNA_SET_RST    0x0
#define MAC_HW_START_TX_3_START_TX_LSTP_RST    0x0
#define MAC_HW_START_TX_3_START_TX_SMOOTHING_RST    0x1
#define MAC_HW_START_TX_3_START_TX_SHORT_GI_RST    0x0
#define MAC_HW_START_TX_3_START_TX_N_TX_RST    0x0
#define MAC_HW_START_TX_3_START_TX_FEC_CODING_RST    0x0
#define MAC_HW_START_TX_3_START_TX_STBC_RST    0x0
#define MAC_HW_START_TX_3_START_TX_NUM_EXTN_SS_RST    0x0

static inline void mac_hw_start_tx_3_pack(struct cl_chip *chip, u8 start_tx_smm_index, u8 start_tx_antenna_set, u8 start_tx_lstp, u8 start_tx_smoothing, u8 start_tx_short_gi, u8 start_tx_n_tx, u8 start_tx_fec_coding, u8 start_tx_stbc, u8 start_tx_num_extn_ss)
{
	ASSERT_ERR_CHIP((((u32)start_tx_smm_index << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_antenna_set << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_lstp << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_smoothing << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_short_gi << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_n_tx << 5) & ~((u32)0x000000E0)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_fec_coding << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_stbc << 2) & ~((u32)0x0000000C)) == 0);
	ASSERT_ERR_CHIP((((u32)start_tx_num_extn_ss << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, ((u32)start_tx_smm_index << 24) | ((u32)start_tx_antenna_set << 16) | ((u32)start_tx_lstp << 13) | ((u32)start_tx_smoothing << 12) | ((u32)start_tx_short_gi << 8) | ((u32)start_tx_n_tx << 5) | ((u32)start_tx_fec_coding << 4) | ((u32)start_tx_stbc << 2) | ((u32)start_tx_num_extn_ss << 0));
}

static inline void mac_hw_start_tx_3_unpack(struct cl_chip *chip, u8 *start_tx_smm_index, u8 *start_tx_antenna_set, u8 *start_tx_lstp, u8 *start_tx_smoothing, u8 *start_tx_short_gi, u8 *start_tx_n_tx, u8 *start_tx_fec_coding, u8 *start_tx_stbc, u8 *start_tx_num_extn_ss)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	*start_tx_smm_index = (local_val & ((u32)0xFF000000)) >> 24;
	*start_tx_antenna_set = (local_val & ((u32)0x00FF0000)) >> 16;
	*start_tx_lstp = (local_val & ((u32)0x00002000)) >> 13;
	*start_tx_smoothing = (local_val & ((u32)0x00001000)) >> 12;
	*start_tx_short_gi = (local_val & ((u32)0x00000100)) >> 8;
	*start_tx_n_tx = (local_val & ((u32)0x000000E0)) >> 5;
	*start_tx_fec_coding = (local_val & ((u32)0x00000010)) >> 4;
	*start_tx_stbc = (local_val & ((u32)0x0000000C)) >> 2;
	*start_tx_num_extn_ss = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_start_tx_3_start_tx_smm_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_start_tx_3_start_tx_smm_index_setf(struct cl_chip *chip, u8 starttxsmmindex)
{
	ASSERT_ERR_CHIP((((u32)starttxsmmindex << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0xFF000000)) | ((u32)starttxsmmindex << 24));
}

static inline u8 mac_hw_start_tx_3_start_tx_antenna_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_start_tx_3_start_tx_antenna_set_setf(struct cl_chip *chip, u8 starttxantennaset)
{
	ASSERT_ERR_CHIP((((u32)starttxantennaset << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00FF0000)) | ((u32)starttxantennaset << 16));
}

static inline u8 mac_hw_start_tx_3_start_tx_lstp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_start_tx_3_start_tx_lstp_setf(struct cl_chip *chip, u8 starttxlstp)
{
	ASSERT_ERR_CHIP((((u32)starttxlstp << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00002000)) | ((u32)starttxlstp << 13));
}

static inline u8 mac_hw_start_tx_3_start_tx_smoothing_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_start_tx_3_start_tx_smoothing_setf(struct cl_chip *chip, u8 starttxsmoothing)
{
	ASSERT_ERR_CHIP((((u32)starttxsmoothing << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00001000)) | ((u32)starttxsmoothing << 12));
}

static inline u8 mac_hw_start_tx_3_start_tx_short_gi_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_start_tx_3_start_tx_short_gi_setf(struct cl_chip *chip, u8 starttxshortgi)
{
	ASSERT_ERR_CHIP((((u32)starttxshortgi << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00000100)) | ((u32)starttxshortgi << 8));
}

static inline u8 mac_hw_start_tx_3_start_tx_n_tx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x000000E0)) >> 5);
}

static inline void mac_hw_start_tx_3_start_tx_n_tx_setf(struct cl_chip *chip, u8 starttxntx)
{
	ASSERT_ERR_CHIP((((u32)starttxntx << 5) & ~((u32)0x000000E0)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x000000E0)) | ((u32)starttxntx << 5));
}

static inline u8 mac_hw_start_tx_3_start_tx_fec_coding_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_start_tx_3_start_tx_fec_coding_setf(struct cl_chip *chip, u8 starttxfeccoding)
{
	ASSERT_ERR_CHIP((((u32)starttxfeccoding << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00000010)) | ((u32)starttxfeccoding << 4));
}

static inline u8 mac_hw_start_tx_3_start_tx_stbc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline void mac_hw_start_tx_3_start_tx_stbc_setf(struct cl_chip *chip, u8 starttxstbc)
{
	ASSERT_ERR_CHIP((((u32)starttxstbc << 2) & ~((u32)0x0000000C)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x0000000C)) | ((u32)starttxstbc << 2));
}

static inline u8 mac_hw_start_tx_3_start_tx_num_extn_ss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_START_TX_3_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

static inline void mac_hw_start_tx_3_start_tx_num_extn_ss_setf(struct cl_chip *chip, u8 starttxnumextnss)
{
	ASSERT_ERR_CHIP((((u32)starttxnumextnss << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_START_TX_3_ADDR, (cl_reg_read(chip, MAC_HW_START_TX_3_ADDR) & ~((u32)0x00000003)) | ((u32)starttxnumextnss << 0));
}

/**
 * @brief TX_BW_CNTRL register definition
 *  Controls 40 MHz HW operation register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    17:16 MAX_SUPPORTED_BW          0x3
 *    15:08 A_PPDU_MAX_TIME           0xFF
 *    07    DYN_BW_EN                 0
 *    06:04 NUM_TRY_BW_ACQUISITION    0x1
 *    02:01 DEFAULT_BWTXOP            0x0
 *    00    DEFAULT_BWTXOPV           0
 * </pre>
 */
#define MAC_HW_TX_BW_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000310)
#define MAC_HW_TX_BW_CNTRL_OFFSET      0x00000310
#define MAC_HW_TX_BW_CNTRL_INDEX       0x000000C4
#define MAC_HW_TX_BW_CNTRL_RESET       0x0003FF10

static inline u32 mac_hw_tx_bw_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);
}

static inline void mac_hw_tx_bw_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_BW_CNTRL_MAX_SUPPORTED_BW_MASK    ((u32)0x00030000)
#define MAC_HW_TX_BW_CNTRL_MAX_SUPPORTED_BW_LSB    16
#define MAC_HW_TX_BW_CNTRL_MAX_SUPPORTED_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_BW_CNTRL_A_PPDU_MAX_TIME_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_BW_CNTRL_A_PPDU_MAX_TIME_LSB    8
#define MAC_HW_TX_BW_CNTRL_A_PPDU_MAX_TIME_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_BW_CNTRL_DYN_BW_EN_BIT    ((u32)0x00000080)
#define MAC_HW_TX_BW_CNTRL_DYN_BW_EN_POS    7
#define MAC_HW_TX_BW_CNTRL_NUM_TRY_BW_ACQUISITION_MASK    ((u32)0x00000070)
#define MAC_HW_TX_BW_CNTRL_NUM_TRY_BW_ACQUISITION_LSB    4
#define MAC_HW_TX_BW_CNTRL_NUM_TRY_BW_ACQUISITION_WIDTH    ((u32)0x00000003)
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOP_MASK    ((u32)0x00000006)
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOP_LSB    1
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOP_WIDTH    ((u32)0x00000002)
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOPV_BIT    ((u32)0x00000001)
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOPV_POS    0

#define MAC_HW_TX_BW_CNTRL_MAX_SUPPORTED_BW_RST    0x3
#define MAC_HW_TX_BW_CNTRL_A_PPDU_MAX_TIME_RST    0xFF
#define MAC_HW_TX_BW_CNTRL_DYN_BW_EN_RST    0x0
#define MAC_HW_TX_BW_CNTRL_NUM_TRY_BW_ACQUISITION_RST    0x1
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOP_RST    0x0
#define MAC_HW_TX_BW_CNTRL_DEFAULT_BWTXOPV_RST    0x0

static inline void mac_hw_tx_bw_cntrl_pack(struct cl_chip *chip, u8 max_supported_bw, u8 a_ppdu_max_time, u8 dyn_bw_en, u8 num_try_bw_acquisition, u8 default_bwtxop, u8 default_bwtxopv)
{
	ASSERT_ERR_CHIP((((u32)max_supported_bw << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)a_ppdu_max_time << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)dyn_bw_en << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)num_try_bw_acquisition << 4) & ~((u32)0x00000070)) == 0);
	ASSERT_ERR_CHIP((((u32)default_bwtxop << 1) & ~((u32)0x00000006)) == 0);
	ASSERT_ERR_CHIP((((u32)default_bwtxopv << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, ((u32)max_supported_bw << 16) | ((u32)a_ppdu_max_time << 8) | ((u32)dyn_bw_en << 7) | ((u32)num_try_bw_acquisition << 4) | ((u32)default_bwtxop << 1) | ((u32)default_bwtxopv << 0));
}

static inline void mac_hw_tx_bw_cntrl_unpack(struct cl_chip *chip, u8 *max_supported_bw, u8 *a_ppdu_max_time, u8 *dyn_bw_en, u8 *num_try_bw_acquisition, u8 *default_bwtxop, u8 *default_bwtxopv)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	*max_supported_bw = (local_val & ((u32)0x00030000)) >> 16;
	*a_ppdu_max_time = (local_val & ((u32)0x0000FF00)) >> 8;
	*dyn_bw_en = (local_val & ((u32)0x00000080)) >> 7;
	*num_try_bw_acquisition = (local_val & ((u32)0x00000070)) >> 4;
	*default_bwtxop = (local_val & ((u32)0x00000006)) >> 1;
	*default_bwtxopv = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_tx_bw_cntrl_max_supported_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_tx_bw_cntrl_max_supported_bw_setf(struct cl_chip *chip, u8 maxsupportedbw)
{
	ASSERT_ERR_CHIP((((u32)maxsupportedbw << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x00030000)) | ((u32)maxsupportedbw << 16));
}

static inline u8 mac_hw_tx_bw_cntrl_a_ppdu_max_time_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_bw_cntrl_a_ppdu_max_time_setf(struct cl_chip *chip, u8 appdumaxtime)
{
	ASSERT_ERR_CHIP((((u32)appdumaxtime << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x0000FF00)) | ((u32)appdumaxtime << 8));
}

static inline u8 mac_hw_tx_bw_cntrl_dyn_bw_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_bw_cntrl_dyn_bw_en_setf(struct cl_chip *chip, u8 dynbwen)
{
	ASSERT_ERR_CHIP((((u32)dynbwen << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x00000080)) | ((u32)dynbwen << 7));
}

static inline u8 mac_hw_tx_bw_cntrl_num_try_bw_acquisition_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000070)) >> 4);
}

static inline void mac_hw_tx_bw_cntrl_num_try_bw_acquisition_setf(struct cl_chip *chip, u8 numtrybwacquisition)
{
	ASSERT_ERR_CHIP((((u32)numtrybwacquisition << 4) & ~((u32)0x00000070)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x00000070)) | ((u32)numtrybwacquisition << 4));
}

static inline u8 mac_hw_tx_bw_cntrl_default_bwtxop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000006)) >> 1);
}

static inline void mac_hw_tx_bw_cntrl_default_bwtxop_setf(struct cl_chip *chip, u8 defaultbwtxop)
{
	ASSERT_ERR_CHIP((((u32)defaultbwtxop << 1) & ~((u32)0x00000006)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x00000006)) | ((u32)defaultbwtxop << 1));
}

static inline u8 mac_hw_tx_bw_cntrl_default_bwtxopv_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_tx_bw_cntrl_default_bwtxopv_setf(struct cl_chip *chip, u8 defaultbwtxopv)
{
	ASSERT_ERR_CHIP((((u32)defaultbwtxopv << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BW_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_BW_CNTRL_ADDR) & ~((u32)0x00000001)) | ((u32)defaultbwtxopv << 0));
}

/**
 * @brief HTMCS register definition
 *  Indicates the BSS Basic MCS Set. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 BSS_BASIC_HTMCS_SET_UM    0x0
 *    15:00 BSS_BASIC_HTMCS_SET_EM    0xFFFF
 * </pre>
 */
#define MAC_HW_HTMCS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000314)
#define MAC_HW_HTMCS_OFFSET      0x00000314
#define MAC_HW_HTMCS_INDEX       0x000000C5
#define MAC_HW_HTMCS_RESET       0x0000FFFF

static inline u32 mac_hw_htmcs_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HTMCS_ADDR);
}

static inline void mac_hw_htmcs_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HTMCS_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_UM_MASK    ((u32)0x003F0000)
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_UM_LSB    16
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_UM_WIDTH    ((u32)0x00000006)
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_EM_MASK    ((u32)0x0000FFFF)
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_EM_LSB    0
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_EM_WIDTH    ((u32)0x00000010)

#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_UM_RST    0x0
#define MAC_HW_HTMCS_BSS_BASIC_HTMCS_SET_EM_RST    0xFFFF

static inline void mac_hw_htmcs_pack(struct cl_chip *chip, u8 bss_basic_htmcs_set_um, u16 bss_basic_htmcs_set_em)
{
	ASSERT_ERR_CHIP((((u32)bss_basic_htmcs_set_um << 16) & ~((u32)0x003F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bss_basic_htmcs_set_em << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_HTMCS_ADDR, ((u32)bss_basic_htmcs_set_um << 16) | ((u32)bss_basic_htmcs_set_em << 0));
}

static inline void mac_hw_htmcs_unpack(struct cl_chip *chip, u8 *bss_basic_htmcs_set_um, u16 *bss_basic_htmcs_set_em)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTMCS_ADDR);

	*bss_basic_htmcs_set_um = (local_val & ((u32)0x003F0000)) >> 16;
	*bss_basic_htmcs_set_em = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_htmcs_bss_basic_htmcs_set_um_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTMCS_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline void mac_hw_htmcs_bss_basic_htmcs_set_um_setf(struct cl_chip *chip, u8 bssbasichtmcssetum)
{
	ASSERT_ERR_CHIP((((u32)bssbasichtmcssetum << 16) & ~((u32)0x003F0000)) == 0);
	cl_reg_write(chip, MAC_HW_HTMCS_ADDR, (cl_reg_read(chip, MAC_HW_HTMCS_ADDR) & ~((u32)0x003F0000)) | ((u32)bssbasichtmcssetum << 16));
}

static inline u16 mac_hw_htmcs_bss_basic_htmcs_set_em_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HTMCS_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_htmcs_bss_basic_htmcs_set_em_setf(struct cl_chip *chip, u16 bssbasichtmcssetem)
{
	ASSERT_ERR_CHIP((((u32)bssbasichtmcssetem << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_HTMCS_ADDR, (cl_reg_read(chip, MAC_HW_HTMCS_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bssbasichtmcssetem << 0));
}

/**
 * @brief VHTMCS register definition
 *  Indicates the BSS VHTBasic MCS Set. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 BSS_BASIC_VHTMCS_SET      0xFFFF
 * </pre>
 */
#define MAC_HW_VHTMCS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000031C)
#define MAC_HW_VHTMCS_OFFSET      0x0000031C
#define MAC_HW_VHTMCS_INDEX       0x000000C7
#define MAC_HW_VHTMCS_RESET       0x0000FFFF

static inline u32 mac_hw_vhtmcs_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_VHTMCS_ADDR);
}

static inline void mac_hw_vhtmcs_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_VHTMCS_ADDR, value);
}

/* Field definitions */
#define MAC_HW_VHTMCS_BSS_BASIC_VHTMCS_SET_MASK    ((u32)0x0000FFFF)
#define MAC_HW_VHTMCS_BSS_BASIC_VHTMCS_SET_LSB    0
#define MAC_HW_VHTMCS_BSS_BASIC_VHTMCS_SET_WIDTH    ((u32)0x00000010)

#define MAC_HW_VHTMCS_BSS_BASIC_VHTMCS_SET_RST    0xFFFF

static inline u16 mac_hw_vhtmcs_bss_basic_vhtmcs_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_VHTMCS_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_vhtmcs_bss_basic_vhtmcs_set_setf(struct cl_chip *chip, u16 bssbasicvhtmcsset)
{
	ASSERT_ERR_CHIP((((u32)bssbasicvhtmcsset << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_VHTMCS_ADDR, (u32)bssbasicvhtmcsset << 0);
}

/**
 * @brief LSTP register definition
 *  Used to control LSTP register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    00    SUPPORT_LSTP              0
 * </pre>
 */
#define MAC_HW_LSTP_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000320)
#define MAC_HW_LSTP_OFFSET      0x00000320
#define MAC_HW_LSTP_INDEX       0x000000C8
#define MAC_HW_LSTP_RESET       0x00000000

static inline u32 mac_hw_lstp_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_LSTP_ADDR);
}

static inline void mac_hw_lstp_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_LSTP_ADDR, value);
}

/* Field definitions */
#define MAC_HW_LSTP_SUPPORT_LSTP_BIT        ((u32)0x00000001)
#define MAC_HW_LSTP_SUPPORT_LSTP_POS        0

#define MAC_HW_LSTP_SUPPORT_LSTP_RST        0x0

static inline u8 mac_hw_lstp_support_lstp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_LSTP_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_lstp_support_lstp_setf(struct cl_chip *chip, u8 supportlstp)
{
	ASSERT_ERR_CHIP((((u32)supportlstp << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_LSTP_ADDR, (u32)supportlstp << 0);
}

/**
 * @brief BQR register definition
 *  Contains the data to return in response to BQRP  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    08    BQR_DATA_VALID            0
 *    07:00 BQR_DATA                  0x0
 * </pre>
 */
#define MAC_HW_BQR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000324)
#define MAC_HW_BQR_OFFSET      0x00000324
#define MAC_HW_BQR_INDEX       0x000000C9
#define MAC_HW_BQR_RESET       0x00000000

static inline u32 mac_hw_bqr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BQR_ADDR);
}

static inline void mac_hw_bqr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BQR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BQR_BQR_DATA_VALID_BIT       ((u32)0x00000100)
#define MAC_HW_BQR_BQR_DATA_VALID_POS       8
#define MAC_HW_BQR_BQR_DATA_MASK            ((u32)0x000000FF)
#define MAC_HW_BQR_BQR_DATA_LSB             0
#define MAC_HW_BQR_BQR_DATA_WIDTH           ((u32)0x00000008)

#define MAC_HW_BQR_BQR_DATA_VALID_RST       0x0
#define MAC_HW_BQR_BQR_DATA_RST             0x0

static inline void mac_hw_bqr_pack(struct cl_chip *chip, u8 bqr_data_valid, u8 bqr_data)
{
	ASSERT_ERR_CHIP((((u32)bqr_data_valid << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)bqr_data << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BQR_ADDR, ((u32)bqr_data_valid << 8) | ((u32)bqr_data << 0));
}

static inline void mac_hw_bqr_unpack(struct cl_chip *chip, u8 *bqr_data_valid, u8 *bqr_data)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_ADDR);

	*bqr_data_valid = (local_val & ((u32)0x00000100)) >> 8;
	*bqr_data = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_bqr_bqr_data_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_bqr_bqr_data_valid_setf(struct cl_chip *chip, u8 bqrdatavalid)
{
	ASSERT_ERR_CHIP((((u32)bqrdatavalid << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_BQR_ADDR, (cl_reg_read(chip, MAC_HW_BQR_ADDR) & ~((u32)0x00000100)) | ((u32)bqrdatavalid << 8));
}

static inline u8 mac_hw_bqr_bqr_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_bqr_bqr_data_setf(struct cl_chip *chip, u8 bqrdata)
{
	ASSERT_ERR_CHIP((((u32)bqrdata << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BQR_ADDR, (cl_reg_read(chip, MAC_HW_BQR_ADDR) & ~((u32)0x000000FF)) | ((u32)bqrdata << 0));
}

/**
 * @brief BQR_DEBUG register definition
 *  Indicates available channel bit map status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 AVAIL_CHANNEL_SENT        0x0
 *    07:00 AVAIL_CHANNEL             0x0
 * </pre>
 */
#define MAC_HW_BQR_DEBUG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000328)
#define MAC_HW_BQR_DEBUG_OFFSET      0x00000328
#define MAC_HW_BQR_DEBUG_INDEX       0x000000CA
#define MAC_HW_BQR_DEBUG_RESET       0x00000000

static inline u32 mac_hw_bqr_debug_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BQR_DEBUG_ADDR);
}

/* Field definitions */
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_SENT_MASK    ((u32)0x0000FF00)
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_SENT_LSB    8
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_SENT_WIDTH    ((u32)0x00000008)
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_MASK    ((u32)0x000000FF)
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_LSB    0
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_WIDTH    ((u32)0x00000008)

#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_SENT_RST    0x0
#define MAC_HW_BQR_DEBUG_AVAIL_CHANNEL_RST    0x0

static inline void mac_hw_bqr_debug_unpack(struct cl_chip *chip, u8 *avail_channel_sent, u8 *avail_channel)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_DEBUG_ADDR);

	*avail_channel_sent = (local_val & ((u32)0x0000FF00)) >> 8;
	*avail_channel = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_bqr_debug_avail_channel_sent_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_DEBUG_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_bqr_debug_avail_channel_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BQR_DEBUG_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

/**
 * @brief SENSING_CONTROL_1 register definition
 *  sensing control 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:24 RETRY_INTERVAL            0x9
 *    17:16 MIN_CHBW_1                0x3
 *    15:00 SENSING_RETRY_LIMIT_1     0x9
 * </pre>
 */
#define MAC_HW_SENSING_CONTROL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000032C)
#define MAC_HW_SENSING_CONTROL_1_OFFSET      0x0000032C
#define MAC_HW_SENSING_CONTROL_1_INDEX       0x000000CB
#define MAC_HW_SENSING_CONTROL_1_RESET       0x09030009

static inline u32 mac_hw_sensing_control_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR);
}

static inline void mac_hw_sensing_control_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_CONTROL_1_RETRY_INTERVAL_MASK    ((u32)0x3F000000)
#define MAC_HW_SENSING_CONTROL_1_RETRY_INTERVAL_LSB    24
#define MAC_HW_SENSING_CONTROL_1_RETRY_INTERVAL_WIDTH    ((u32)0x00000006)
#define MAC_HW_SENSING_CONTROL_1_MIN_CHBW_1_MASK    ((u32)0x00030000)
#define MAC_HW_SENSING_CONTROL_1_MIN_CHBW_1_LSB    16
#define MAC_HW_SENSING_CONTROL_1_MIN_CHBW_1_WIDTH    ((u32)0x00000002)
#define MAC_HW_SENSING_CONTROL_1_SENSING_RETRY_LIMIT_1_MASK    ((u32)0x0000FFFF)
#define MAC_HW_SENSING_CONTROL_1_SENSING_RETRY_LIMIT_1_LSB    0
#define MAC_HW_SENSING_CONTROL_1_SENSING_RETRY_LIMIT_1_WIDTH    ((u32)0x00000010)

#define MAC_HW_SENSING_CONTROL_1_RETRY_INTERVAL_RST    0x9
#define MAC_HW_SENSING_CONTROL_1_MIN_CHBW_1_RST    0x3
#define MAC_HW_SENSING_CONTROL_1_SENSING_RETRY_LIMIT_1_RST    0x9

static inline void mac_hw_sensing_control_1_pack(struct cl_chip *chip, u8 retry_interval, u8 min_chbw_1, u16 sensing_retry_limit_1)
{
	ASSERT_ERR_CHIP((((u32)retry_interval << 24) & ~((u32)0x3F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)min_chbw_1 << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)sensing_retry_limit_1 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_1_ADDR, ((u32)retry_interval << 24) | ((u32)min_chbw_1 << 16) | ((u32)sensing_retry_limit_1 << 0));
}

static inline void mac_hw_sensing_control_1_unpack(struct cl_chip *chip, u8 *retry_interval, u8 *min_chbw_1, u16 *sensing_retry_limit_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR);

	*retry_interval = (local_val & ((u32)0x3F000000)) >> 24;
	*min_chbw_1 = (local_val & ((u32)0x00030000)) >> 16;
	*sensing_retry_limit_1 = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_sensing_control_1_retry_interval_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x3F000000)) >> 24);
}

static inline void mac_hw_sensing_control_1_retry_interval_setf(struct cl_chip *chip, u8 retryinterval)
{
	ASSERT_ERR_CHIP((((u32)retryinterval << 24) & ~((u32)0x3F000000)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR) & ~((u32)0x3F000000)) | ((u32)retryinterval << 24));
}

static inline u8 mac_hw_sensing_control_1_min_chbw_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_sensing_control_1_min_chbw_1_setf(struct cl_chip *chip, u8 minchbw1)
{
	ASSERT_ERR_CHIP((((u32)minchbw1 << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR) & ~((u32)0x00030000)) | ((u32)minchbw1 << 16));
}

static inline u16 mac_hw_sensing_control_1_sensing_retry_limit_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_sensing_control_1_sensing_retry_limit_1_setf(struct cl_chip *chip, u16 sensingretrylimit1)
{
	ASSERT_ERR_CHIP((((u32)sensingretrylimit1 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_1_ADDR) & ~((u32)0x0000FFFF)) | ((u32)sensingretrylimit1 << 0));
}

/**
 * @brief SENSING_CONTROL_2 register definition
 *  sensing control 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:24 CCA_evaluation_window     0x19
 *    17:16 MIN_CHBW_2                0x2
 *    15:00 SENSING_RETRY_LIMIT_2     0x9
 * </pre>
 */
#define MAC_HW_SENSING_CONTROL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000330)
#define MAC_HW_SENSING_CONTROL_2_OFFSET      0x00000330
#define MAC_HW_SENSING_CONTROL_2_INDEX       0x000000CC
#define MAC_HW_SENSING_CONTROL_2_RESET       0x19020009

static inline u32 mac_hw_sensing_control_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR);
}

static inline void mac_hw_sensing_control_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_CONTROL_2_CCA_EVALUATION_WINDOW_MASK    ((u32)0x3F000000)
#define MAC_HW_SENSING_CONTROL_2_CCA_EVALUATION_WINDOW_LSB    24
#define MAC_HW_SENSING_CONTROL_2_CCA_EVALUATION_WINDOW_WIDTH    ((u32)0x00000006)
#define MAC_HW_SENSING_CONTROL_2_MIN_CHBW_2_MASK    ((u32)0x00030000)
#define MAC_HW_SENSING_CONTROL_2_MIN_CHBW_2_LSB    16
#define MAC_HW_SENSING_CONTROL_2_MIN_CHBW_2_WIDTH    ((u32)0x00000002)
#define MAC_HW_SENSING_CONTROL_2_SENSING_RETRY_LIMIT_2_MASK    ((u32)0x0000FFFF)
#define MAC_HW_SENSING_CONTROL_2_SENSING_RETRY_LIMIT_2_LSB    0
#define MAC_HW_SENSING_CONTROL_2_SENSING_RETRY_LIMIT_2_WIDTH    ((u32)0x00000010)

#define MAC_HW_SENSING_CONTROL_2_CCA_EVALUATION_WINDOW_RST    0x19
#define MAC_HW_SENSING_CONTROL_2_MIN_CHBW_2_RST    0x2
#define MAC_HW_SENSING_CONTROL_2_SENSING_RETRY_LIMIT_2_RST    0x9

static inline void mac_hw_sensing_control_2_pack(struct cl_chip *chip, u8 cca_evaluation_window, u8 min_chbw_2, u16 sensing_retry_limit_2)
{
	ASSERT_ERR_CHIP((((u32)cca_evaluation_window << 24) & ~((u32)0x3F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)min_chbw_2 << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)sensing_retry_limit_2 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_2_ADDR, ((u32)cca_evaluation_window << 24) | ((u32)min_chbw_2 << 16) | ((u32)sensing_retry_limit_2 << 0));
}

static inline void mac_hw_sensing_control_2_unpack(struct cl_chip *chip, u8 *cca_evaluation_window, u8 *min_chbw_2, u16 *sensing_retry_limit_2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR);

	*cca_evaluation_window = (local_val & ((u32)0x3F000000)) >> 24;
	*min_chbw_2 = (local_val & ((u32)0x00030000)) >> 16;
	*sensing_retry_limit_2 = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_sensing_control_2_cca_evaluation_window_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x3F000000)) >> 24);
}

static inline void mac_hw_sensing_control_2_cca_evaluation_window_setf(struct cl_chip *chip, u8 ccaevaluationwindow)
{
	ASSERT_ERR_CHIP((((u32)ccaevaluationwindow << 24) & ~((u32)0x3F000000)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR) & ~((u32)0x3F000000)) | ((u32)ccaevaluationwindow << 24));
}

static inline u8 mac_hw_sensing_control_2_min_chbw_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_sensing_control_2_min_chbw_2_setf(struct cl_chip *chip, u8 minchbw2)
{
	ASSERT_ERR_CHIP((((u32)minchbw2 << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR) & ~((u32)0x00030000)) | ((u32)minchbw2 << 16));
}

static inline u16 mac_hw_sensing_control_2_sensing_retry_limit_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_sensing_control_2_sensing_retry_limit_2_setf(struct cl_chip *chip, u16 sensingretrylimit2)
{
	ASSERT_ERR_CHIP((((u32)sensingretrylimit2 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_2_ADDR) & ~((u32)0x0000FFFF)) | ((u32)sensingretrylimit2 << 0));
}

/**
 * @brief SENSING_CONTROL_3 register definition
 *  sensing control 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    02    DISABLE_SENSING_INTERVAL_COUNTER 0
 *    01    CLEAR_SENSING_INTERVAL_COUNTER 0
 * </pre>
 */
#define MAC_HW_SENSING_CONTROL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000334)
#define MAC_HW_SENSING_CONTROL_3_OFFSET      0x00000334
#define MAC_HW_SENSING_CONTROL_3_INDEX       0x000000CD
#define MAC_HW_SENSING_CONTROL_3_RESET       0x00000000

static inline u32 mac_hw_sensing_control_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_CONTROL_3_ADDR);
}

static inline void mac_hw_sensing_control_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_CONTROL_3_DISABLE_SENSING_INTERVAL_COUNTER_BIT    ((u32)0x00000004)
#define MAC_HW_SENSING_CONTROL_3_DISABLE_SENSING_INTERVAL_COUNTER_POS    2
#define MAC_HW_SENSING_CONTROL_3_CLEAR_SENSING_INTERVAL_COUNTER_BIT    ((u32)0x00000002)
#define MAC_HW_SENSING_CONTROL_3_CLEAR_SENSING_INTERVAL_COUNTER_POS    1

#define MAC_HW_SENSING_CONTROL_3_DISABLE_SENSING_INTERVAL_COUNTER_RST    0x0
#define MAC_HW_SENSING_CONTROL_3_CLEAR_SENSING_INTERVAL_COUNTER_RST    0x0

static inline void mac_hw_sensing_control_3_pack(struct cl_chip *chip, u8 disable_sensing_interval_counter, u8 clear_sensing_interval_counter)
{
	ASSERT_ERR_CHIP((((u32)disable_sensing_interval_counter << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_sensing_interval_counter << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_3_ADDR, ((u32)disable_sensing_interval_counter << 2) | ((u32)clear_sensing_interval_counter << 1));
}

static inline void mac_hw_sensing_control_3_unpack(struct cl_chip *chip, u8 *disable_sensing_interval_counter, u8 *clear_sensing_interval_counter)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_3_ADDR);

	*disable_sensing_interval_counter = (local_val & ((u32)0x00000004)) >> 2;
	*clear_sensing_interval_counter = (local_val & ((u32)0x00000002)) >> 1;
}

static inline u8 mac_hw_sensing_control_3_disable_sensing_interval_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_sensing_control_3_disable_sensing_interval_counter_setf(struct cl_chip *chip, u8 disablesensingintervalcounter)
{
	ASSERT_ERR_CHIP((((u32)disablesensingintervalcounter << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_3_ADDR) & ~((u32)0x00000004)) | ((u32)disablesensingintervalcounter << 2));
}

static inline void mac_hw_sensing_control_3_clear_sensing_interval_counter_setf(struct cl_chip *chip, u8 clearsensingintervalcounter)
{
	ASSERT_ERR_CHIP((((u32)clearsensingintervalcounter << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_SENSING_CONTROL_3_ADDR) & ~((u32)0x00000002)) | ((u32)clearsensingintervalcounter << 1));
}

/**
 * @brief SENSING_CONTROL_4 register definition
 *  sensing control 4 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    17:00 rx_Req_rise_delay         0x0
 * </pre>
 */
#define MAC_HW_SENSING_CONTROL_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000338)
#define MAC_HW_SENSING_CONTROL_4_OFFSET      0x00000338
#define MAC_HW_SENSING_CONTROL_4_INDEX       0x000000CE
#define MAC_HW_SENSING_CONTROL_4_RESET       0x00000000

static inline u32 mac_hw_sensing_control_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_CONTROL_4_ADDR);
}

static inline void mac_hw_sensing_control_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_CONTROL_4_RX_REQ_RISE_DELAY_MASK    ((u32)0x0003FFFF)
#define MAC_HW_SENSING_CONTROL_4_RX_REQ_RISE_DELAY_LSB    0
#define MAC_HW_SENSING_CONTROL_4_RX_REQ_RISE_DELAY_WIDTH    ((u32)0x00000012)

#define MAC_HW_SENSING_CONTROL_4_RX_REQ_RISE_DELAY_RST    0x0

static inline u32 mac_hw_sensing_control_4_rx_req_rise_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_CONTROL_4_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_sensing_control_4_rx_req_rise_delay_setf(struct cl_chip *chip, u32 rxreqrisedelay)
{
	ASSERT_ERR_CHIP((((u32)rxreqrisedelay << 0) & ~((u32)0x0003FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_CONTROL_4_ADDR, (u32)rxreqrisedelay << 0);
}

/**
 * @brief SENSING_STATUS_1 register definition
 *  sensing status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    17:00 SENSING_RETRY_COUNTER     0x0
 * </pre>
 */
#define MAC_HW_SENSING_STATUS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000033C)
#define MAC_HW_SENSING_STATUS_1_OFFSET      0x0000033C
#define MAC_HW_SENSING_STATUS_1_INDEX       0x000000CF
#define MAC_HW_SENSING_STATUS_1_RESET       0x00000000

static inline u32 mac_hw_sensing_status_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_STATUS_1_ADDR);
}

/* Field definitions */
#define MAC_HW_SENSING_STATUS_1_SENSING_RETRY_COUNTER_MASK    ((u32)0x0003FFFF)
#define MAC_HW_SENSING_STATUS_1_SENSING_RETRY_COUNTER_LSB    0
#define MAC_HW_SENSING_STATUS_1_SENSING_RETRY_COUNTER_WIDTH    ((u32)0x00000012)

#define MAC_HW_SENSING_STATUS_1_SENSING_RETRY_COUNTER_RST    0x0

static inline u32 mac_hw_sensing_status_1_sensing_retry_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_STATUS_1_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief SENSING_STATISTICS_1 register definition
 *  sensing statistic 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SENSING_PULSE_SKIPPED_COUNTER 0x0
 * </pre>
 */
#define MAC_HW_SENSING_STATISTICS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000340)
#define MAC_HW_SENSING_STATISTICS_1_OFFSET      0x00000340
#define MAC_HW_SENSING_STATISTICS_1_INDEX       0x000000D0
#define MAC_HW_SENSING_STATISTICS_1_RESET       0x00000000

static inline u32 mac_hw_sensing_statistics_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_1_ADDR);
}

static inline void mac_hw_sensing_statistics_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_STATISTICS_1_SENSING_PULSE_SKIPPED_COUNTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_SENSING_STATISTICS_1_SENSING_PULSE_SKIPPED_COUNTER_LSB    0
#define MAC_HW_SENSING_STATISTICS_1_SENSING_PULSE_SKIPPED_COUNTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_SENSING_STATISTICS_1_SENSING_PULSE_SKIPPED_COUNTER_RST    0x0

static inline u32 mac_hw_sensing_statistics_1_sensing_pulse_skipped_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_1_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_sensing_statistics_1_sensing_pulse_skipped_counter_setf(struct cl_chip *chip, u32 sensingpulseskippedcounter)
{
	ASSERT_ERR_CHIP((((u32)sensingpulseskippedcounter << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_1_ADDR, (u32)sensingpulseskippedcounter << 0);
}

/**
 * @brief SENSING_STATISTICS_2 register definition
 *  sensing statistic 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SENSING_RETRY_CCA_COUNTER 0x0
 * </pre>
 */
#define MAC_HW_SENSING_STATISTICS_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000344)
#define MAC_HW_SENSING_STATISTICS_2_OFFSET      0x00000344
#define MAC_HW_SENSING_STATISTICS_2_INDEX       0x000000D1
#define MAC_HW_SENSING_STATISTICS_2_RESET       0x00000000

static inline u32 mac_hw_sensing_statistics_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_2_ADDR);
}

static inline void mac_hw_sensing_statistics_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_STATISTICS_2_SENSING_RETRY_CCA_COUNTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_SENSING_STATISTICS_2_SENSING_RETRY_CCA_COUNTER_LSB    0
#define MAC_HW_SENSING_STATISTICS_2_SENSING_RETRY_CCA_COUNTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_SENSING_STATISTICS_2_SENSING_RETRY_CCA_COUNTER_RST    0x0

static inline u32 mac_hw_sensing_statistics_2_sensing_retry_cca_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_2_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_sensing_statistics_2_sensing_retry_cca_counter_setf(struct cl_chip *chip, u32 sensingretryccacounter)
{
	ASSERT_ERR_CHIP((((u32)sensingretryccacounter << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_2_ADDR, (u32)sensingretryccacounter << 0);
}

/**
 * @brief SENSING_STATISTICS_3 register definition
 *  sensing statistic 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SENSING_RETRY_PTA_COUNTER 0x0
 * </pre>
 */
#define MAC_HW_SENSING_STATISTICS_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000348)
#define MAC_HW_SENSING_STATISTICS_3_OFFSET      0x00000348
#define MAC_HW_SENSING_STATISTICS_3_INDEX       0x000000D2
#define MAC_HW_SENSING_STATISTICS_3_RESET       0x00000000

static inline u32 mac_hw_sensing_statistics_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_3_ADDR);
}

static inline void mac_hw_sensing_statistics_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_STATISTICS_3_SENSING_RETRY_PTA_COUNTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_SENSING_STATISTICS_3_SENSING_RETRY_PTA_COUNTER_LSB    0
#define MAC_HW_SENSING_STATISTICS_3_SENSING_RETRY_PTA_COUNTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_SENSING_STATISTICS_3_SENSING_RETRY_PTA_COUNTER_RST    0x0

static inline u32 mac_hw_sensing_statistics_3_sensing_retry_pta_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_3_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_sensing_statistics_3_sensing_retry_pta_counter_setf(struct cl_chip *chip, u32 sensingretryptacounter)
{
	ASSERT_ERR_CHIP((((u32)sensingretryptacounter << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_3_ADDR, (u32)sensingretryptacounter << 0);
}

/**
 * @brief SENSING_STATISTICS_4 register definition
 *  sensing statistic 4 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 SENSING_MISSING_THD_COUNTER 0x0
 * </pre>
 */
#define MAC_HW_SENSING_STATISTICS_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000034C)
#define MAC_HW_SENSING_STATISTICS_4_OFFSET      0x0000034C
#define MAC_HW_SENSING_STATISTICS_4_INDEX       0x000000D3
#define MAC_HW_SENSING_STATISTICS_4_RESET       0x00000000

static inline u32 mac_hw_sensing_statistics_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_4_ADDR);
}

static inline void mac_hw_sensing_statistics_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SENSING_STATISTICS_4_SENSING_MISSING_THD_COUNTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_SENSING_STATISTICS_4_SENSING_MISSING_THD_COUNTER_LSB    0
#define MAC_HW_SENSING_STATISTICS_4_SENSING_MISSING_THD_COUNTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_SENSING_STATISTICS_4_SENSING_MISSING_THD_COUNTER_RST    0x0

static inline u32 mac_hw_sensing_statistics_4_sensing_missing_thd_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SENSING_STATISTICS_4_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_sensing_statistics_4_sensing_missing_thd_counter_setf(struct cl_chip *chip, u32 sensingmissingthdcounter)
{
	ASSERT_ERR_CHIP((((u32)sensingmissingthdcounter << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SENSING_STATISTICS_4_ADDR, (u32)sensingmissingthdcounter << 0);
}

/**
 * @brief PTA_CONTROL_1 register definition
 *  Contains PTA control fields register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25:24 Frame_bw_bcn              0x0
 *    23:22 Frame_bw_ac3              0x0
 *    21:20 Frame_bw_ac2              0x0
 *    19:18 Frame_bw_ac1              0x0
 *    17:16 Frame_bw_ac0              0x0
 *    12    Ignore_pta_gnt_BCN        0
 *    11    Ignore_pta_gnt_AC3        0
 *    10    Ignore_pta_gnt_AC2        0
 *    09    Ignore_pta_gnt_AC1        0
 *    08    Ignore_pta_gnt_AC0        0
 *    04    Priority_BCN              0
 *    03    Priority_AC3              0
 *    02    Priority_AC2              0
 *    01    Priority_AC1              0
 *    00    Priority_AC0              0
 * </pre>
 */
#define MAC_HW_PTA_CONTROL_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000350)
#define MAC_HW_PTA_CONTROL_1_OFFSET      0x00000350
#define MAC_HW_PTA_CONTROL_1_INDEX       0x000000D4
#define MAC_HW_PTA_CONTROL_1_RESET       0x00000000

static inline u32 mac_hw_pta_control_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);
}

static inline void mac_hw_pta_control_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_BCN_MASK    ((u32)0x03000000)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_BCN_LSB    24
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_BCN_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_3_MASK    ((u32)0x00C00000)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_3_LSB    22
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_3_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_2_MASK    ((u32)0x00300000)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_2_LSB    20
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_2_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_1_MASK    ((u32)0x000C0000)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_1_LSB    18
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_1_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_0_MASK    ((u32)0x00030000)
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_0_LSB    16
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_0_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_BCN_BIT    ((u32)0x00001000)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_BCN_POS    12
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_3_BIT    ((u32)0x00000800)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_3_POS    11
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_2_BIT    ((u32)0x00000400)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_2_POS    10
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_1_BIT    ((u32)0x00000200)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_1_POS    9
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_0_BIT    ((u32)0x00000100)
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_0_POS    8
#define MAC_HW_PTA_CONTROL_1_PRIORITY_BCN_BIT    ((u32)0x00000010)
#define MAC_HW_PTA_CONTROL_1_PRIORITY_BCN_POS    4
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_3_BIT    ((u32)0x00000008)
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_3_POS    3
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_2_BIT    ((u32)0x00000004)
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_2_POS    2
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_1_BIT    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_1_POS    1
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_0_BIT    ((u32)0x00000001)
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_0_POS    0

#define MAC_HW_PTA_CONTROL_1_FRAME_BW_BCN_RST    0x0
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_3_RST    0x0
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_2_RST    0x0
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_1_RST    0x0
#define MAC_HW_PTA_CONTROL_1_FRAME_BW_AC_0_RST    0x0
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_BCN_RST    0x0
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_3_RST    0x0
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_2_RST    0x0
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_1_RST    0x0
#define MAC_HW_PTA_CONTROL_1_IGNORE_PTA_GNT_AC_0_RST    0x0
#define MAC_HW_PTA_CONTROL_1_PRIORITY_BCN_RST    0x0
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_3_RST    0x0
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_2_RST    0x0
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_1_RST    0x0
#define MAC_HW_PTA_CONTROL_1_PRIORITY_AC_0_RST    0x0

static inline void mac_hw_pta_control_1_pack(struct cl_chip *chip, u8 frame_bw_bcn, u8 frame_bw_ac3, u8 frame_bw_ac2, u8 frame_bw_ac1, u8 frame_bw_ac0, u8 ignore_pta_gnt_bcn, u8 ignore_pta_gnt_ac3, u8 ignore_pta_gnt_ac2, u8 ignore_pta_gnt_ac1, u8 ignore_pta_gnt_ac0, u8 priority_bcn, u8 priority_ac3, u8 priority_ac2, u8 priority_ac1, u8 priority_ac0)
{
	ASSERT_ERR_CHIP((((u32)frame_bw_bcn << 24) & ~((u32)0x03000000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_bw_ac3 << 22) & ~((u32)0x00C00000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_bw_ac2 << 20) & ~((u32)0x00300000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_bw_ac1 << 18) & ~((u32)0x000C0000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_bw_ac0 << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_bcn << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ac3 << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ac2 << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ac1 << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ac0 << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_bcn << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ac3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ac2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ac1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ac0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, ((u32)frame_bw_bcn << 24) | ((u32)frame_bw_ac3 << 22) | ((u32)frame_bw_ac2 << 20) | ((u32)frame_bw_ac1 << 18) | ((u32)frame_bw_ac0 << 16) | ((u32)ignore_pta_gnt_bcn << 12) | ((u32)ignore_pta_gnt_ac3 << 11) | ((u32)ignore_pta_gnt_ac2 << 10) | ((u32)ignore_pta_gnt_ac1 << 9) | ((u32)ignore_pta_gnt_ac0 << 8) | ((u32)priority_bcn << 4) | ((u32)priority_ac3 << 3) | ((u32)priority_ac2 << 2) | ((u32)priority_ac1 << 1) | ((u32)priority_ac0 << 0));
}

static inline void mac_hw_pta_control_1_unpack(struct cl_chip *chip, u8 *frame_bw_bcn, u8 *frame_bw_ac3, u8 *frame_bw_ac2, u8 *frame_bw_ac1, u8 *frame_bw_ac0, u8 *ignore_pta_gnt_bcn, u8 *ignore_pta_gnt_ac3, u8 *ignore_pta_gnt_ac2, u8 *ignore_pta_gnt_ac1, u8 *ignore_pta_gnt_ac0, u8 *priority_bcn, u8 *priority_ac3, u8 *priority_ac2, u8 *priority_ac1, u8 *priority_ac0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	*frame_bw_bcn = (local_val & ((u32)0x03000000)) >> 24;
	*frame_bw_ac3 = (local_val & ((u32)0x00C00000)) >> 22;
	*frame_bw_ac2 = (local_val & ((u32)0x00300000)) >> 20;
	*frame_bw_ac1 = (local_val & ((u32)0x000C0000)) >> 18;
	*frame_bw_ac0 = (local_val & ((u32)0x00030000)) >> 16;
	*ignore_pta_gnt_bcn = (local_val & ((u32)0x00001000)) >> 12;
	*ignore_pta_gnt_ac3 = (local_val & ((u32)0x00000800)) >> 11;
	*ignore_pta_gnt_ac2 = (local_val & ((u32)0x00000400)) >> 10;
	*ignore_pta_gnt_ac1 = (local_val & ((u32)0x00000200)) >> 9;
	*ignore_pta_gnt_ac0 = (local_val & ((u32)0x00000100)) >> 8;
	*priority_bcn = (local_val & ((u32)0x00000010)) >> 4;
	*priority_ac3 = (local_val & ((u32)0x00000008)) >> 3;
	*priority_ac2 = (local_val & ((u32)0x00000004)) >> 2;
	*priority_ac1 = (local_val & ((u32)0x00000002)) >> 1;
	*priority_ac0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_pta_control_1_frame_bw_bcn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x03000000)) >> 24);
}

static inline void mac_hw_pta_control_1_frame_bw_bcn_setf(struct cl_chip *chip, u8 framebwbcn)
{
	ASSERT_ERR_CHIP((((u32)framebwbcn << 24) & ~((u32)0x03000000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x03000000)) | ((u32)framebwbcn << 24));
}

static inline u8 mac_hw_pta_control_1_frame_bw_ac_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00C00000)) >> 22);
}

static inline void mac_hw_pta_control_1_frame_bw_ac_3_setf(struct cl_chip *chip, u8 framebwac3)
{
	ASSERT_ERR_CHIP((((u32)framebwac3 << 22) & ~((u32)0x00C00000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00C00000)) | ((u32)framebwac3 << 22));
}

static inline u8 mac_hw_pta_control_1_frame_bw_ac_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00300000)) >> 20);
}

static inline void mac_hw_pta_control_1_frame_bw_ac_2_setf(struct cl_chip *chip, u8 framebwac2)
{
	ASSERT_ERR_CHIP((((u32)framebwac2 << 20) & ~((u32)0x00300000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00300000)) | ((u32)framebwac2 << 20));
}

static inline u8 mac_hw_pta_control_1_frame_bw_ac_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x000C0000)) >> 18);
}

static inline void mac_hw_pta_control_1_frame_bw_ac_1_setf(struct cl_chip *chip, u8 framebwac1)
{
	ASSERT_ERR_CHIP((((u32)framebwac1 << 18) & ~((u32)0x000C0000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x000C0000)) | ((u32)framebwac1 << 18));
}

static inline u8 mac_hw_pta_control_1_frame_bw_ac_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_pta_control_1_frame_bw_ac_0_setf(struct cl_chip *chip, u8 framebwac0)
{
	ASSERT_ERR_CHIP((((u32)framebwac0 << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00030000)) | ((u32)framebwac0 << 16));
}

static inline u8 mac_hw_pta_control_1_ignore_pta_gnt_bcn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_pta_control_1_ignore_pta_gnt_bcn_setf(struct cl_chip *chip, u8 ignoreptagntbcn)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntbcn << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00001000)) | ((u32)ignoreptagntbcn << 12));
}

static inline u8 mac_hw_pta_control_1_ignore_pta_gnt_ac_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_pta_control_1_ignore_pta_gnt_ac_3_setf(struct cl_chip *chip, u8 ignoreptagntac3)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntac3 << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000800)) | ((u32)ignoreptagntac3 << 11));
}

static inline u8 mac_hw_pta_control_1_ignore_pta_gnt_ac_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_pta_control_1_ignore_pta_gnt_ac_2_setf(struct cl_chip *chip, u8 ignoreptagntac2)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntac2 << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000400)) | ((u32)ignoreptagntac2 << 10));
}

static inline u8 mac_hw_pta_control_1_ignore_pta_gnt_ac_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_pta_control_1_ignore_pta_gnt_ac_1_setf(struct cl_chip *chip, u8 ignoreptagntac1)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntac1 << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000200)) | ((u32)ignoreptagntac1 << 9));
}

static inline u8 mac_hw_pta_control_1_ignore_pta_gnt_ac_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_pta_control_1_ignore_pta_gnt_ac_0_setf(struct cl_chip *chip, u8 ignoreptagntac0)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntac0 << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000100)) | ((u32)ignoreptagntac0 << 8));
}

static inline u8 mac_hw_pta_control_1_priority_bcn_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_pta_control_1_priority_bcn_setf(struct cl_chip *chip, u8 prioritybcn)
{
	ASSERT_ERR_CHIP((((u32)prioritybcn << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000010)) | ((u32)prioritybcn << 4));
}

static inline u8 mac_hw_pta_control_1_priority_ac_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_pta_control_1_priority_ac_3_setf(struct cl_chip *chip, u8 priorityac3)
{
	ASSERT_ERR_CHIP((((u32)priorityac3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000008)) | ((u32)priorityac3 << 3));
}

static inline u8 mac_hw_pta_control_1_priority_ac_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_pta_control_1_priority_ac_2_setf(struct cl_chip *chip, u8 priorityac2)
{
	ASSERT_ERR_CHIP((((u32)priorityac2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000004)) | ((u32)priorityac2 << 2));
}

static inline u8 mac_hw_pta_control_1_priority_ac_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_pta_control_1_priority_ac_1_setf(struct cl_chip *chip, u8 priorityac1)
{
	ASSERT_ERR_CHIP((((u32)priorityac1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000002)) | ((u32)priorityac1 << 1));
}

static inline u8 mac_hw_pta_control_1_priority_ac_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_pta_control_1_priority_ac_0_setf(struct cl_chip *chip, u8 priorityac0)
{
	ASSERT_ERR_CHIP((((u32)priorityac0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_1_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_1_ADDR) & ~((u32)0x00000001)) | ((u32)priorityac0 << 0));
}

/**
 * @brief PTA_CONTROL_2 register definition
 *  Contains PTA control fields register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    Priority_RX_HE_SU_ER      0
 *    24    Priority_RX_HE_TB         0
 *    23    Priority_RX_HE_MU         0
 *    22    Priority_RX_HE_SU         0
 *    21    Priority_RX_VHT           0
 *    20    Priority_RX_HT_AMPDU      0
 *    19    Priority_RX_HT_SMPDU      0
 *    18    Priority_RX_non_HT        0
 *    17    Priority_RX_11b           0
 *    16    Priority_RX_default       0
 *    11    Priority_HTP_BFR          0
 *    10    Priority_HTP_BQR          0
 *    09    Priority_HTP_BSR          0
 *    08    Priority_HTP_BA           0
 *    07    Priority_HTP_DATA         0
 *    06    Priority_MU_CTS           0
 *    05    Priority_BFR2             0
 *    04    Priority_BFR1             0
 *    03    Priority_CF_END           0
 *    02    Priority_BA               0
 *    01    Priority_ACK              0
 *    00    Priority_CTS              0
 * </pre>
 */
#define MAC_HW_PTA_CONTROL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000354)
#define MAC_HW_PTA_CONTROL_2_OFFSET      0x00000354
#define MAC_HW_PTA_CONTROL_2_INDEX       0x000000D5
#define MAC_HW_PTA_CONTROL_2_RESET       0x00000000

static inline u32 mac_hw_pta_control_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);
}

static inline void mac_hw_pta_control_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_ER_BIT    ((u32)0x02000000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_ER_POS    25
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_TB_BIT    ((u32)0x01000000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_TB_POS    24
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_MU_BIT    ((u32)0x00800000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_MU_POS    23
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_BIT    ((u32)0x00400000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_POS    22
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_VHT_BIT    ((u32)0x00200000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_VHT_POS    21
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_AMPDU_BIT    ((u32)0x00100000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_AMPDU_POS    20
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_SMPDU_BIT    ((u32)0x00080000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_SMPDU_POS    19
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_NON_HT_BIT    ((u32)0x00040000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_NON_HT_POS    18
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_11_B_BIT    ((u32)0x00020000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_11_B_POS    17
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_DEFAULT_BIT    ((u32)0x00010000)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_DEFAULT_POS    16
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BFR_BIT    ((u32)0x00000800)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BFR_POS    11
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BQR_BIT    ((u32)0x00000400)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BQR_POS    10
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BSR_BIT    ((u32)0x00000200)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BSR_POS    9
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BA_BIT    ((u32)0x00000100)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BA_POS    8
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_DATA_BIT    ((u32)0x00000080)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_DATA_POS    7
#define MAC_HW_PTA_CONTROL_2_PRIORITY_MU_CTS_BIT    ((u32)0x00000040)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_MU_CTS_POS    6
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_2_BIT    ((u32)0x00000020)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_2_POS    5
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_1_BIT    ((u32)0x00000010)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_1_POS    4
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CF_END_BIT    ((u32)0x00000008)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CF_END_POS    3
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BA_BIT    ((u32)0x00000004)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BA_POS    2
#define MAC_HW_PTA_CONTROL_2_PRIORITY_ACK_BIT    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_ACK_POS    1
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CTS_BIT    ((u32)0x00000001)
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CTS_POS    0

#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_ER_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_TB_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_MU_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HE_SU_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_VHT_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_AMPDU_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_HT_SMPDU_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_NON_HT_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_11_B_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_RX_DEFAULT_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BFR_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BQR_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BSR_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_BA_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_HTP_DATA_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_MU_CTS_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_2_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BFR_1_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CF_END_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_BA_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_ACK_RST    0x0
#define MAC_HW_PTA_CONTROL_2_PRIORITY_CTS_RST    0x0

static inline void mac_hw_pta_control_2_pack(struct cl_chip *chip, u8 priority_rx_he_su_er, u8 priority_rx_he_tb, u8 priority_rx_he_mu, u8 priority_rx_he_su, u8 priority_rx_vht, u8 priority_rx_ht_ampdu, u8 priority_rx_ht_smpdu, u8 priority_rx_non_ht, u8 priority_rx_11b, u8 priority_rx_default, u8 priority_htp_bfr, u8 priority_htp_bqr, u8 priority_htp_bsr, u8 priority_htp_ba, u8 priority_htp_data, u8 priority_mu_cts, u8 priority_bfr2, u8 priority_bfr1, u8 priority_cf_end, u8 priority_ba, u8 priority_ack, u8 priority_cts)
{
	ASSERT_ERR_CHIP((((u32)priority_rx_he_su_er << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_he_tb << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_he_mu << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_he_su << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_vht << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_ht_ampdu << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_ht_smpdu << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_non_ht << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_11b << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_rx_default << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_htp_bfr << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_htp_bqr << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_htp_bsr << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_htp_ba << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_htp_data << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_mu_cts << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_bfr2 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_bfr1 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_cf_end << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ba << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_ack << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)priority_cts << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, ((u32)priority_rx_he_su_er << 25) | ((u32)priority_rx_he_tb << 24) | ((u32)priority_rx_he_mu << 23) | ((u32)priority_rx_he_su << 22) | ((u32)priority_rx_vht << 21) | ((u32)priority_rx_ht_ampdu << 20) | ((u32)priority_rx_ht_smpdu << 19) | ((u32)priority_rx_non_ht << 18) | ((u32)priority_rx_11b << 17) | ((u32)priority_rx_default << 16) | ((u32)priority_htp_bfr << 11) | ((u32)priority_htp_bqr << 10) | ((u32)priority_htp_bsr << 9) | ((u32)priority_htp_ba << 8) | ((u32)priority_htp_data << 7) | ((u32)priority_mu_cts << 6) | ((u32)priority_bfr2 << 5) | ((u32)priority_bfr1 << 4) | ((u32)priority_cf_end << 3) | ((u32)priority_ba << 2) | ((u32)priority_ack << 1) | ((u32)priority_cts << 0));
}

static inline void mac_hw_pta_control_2_unpack(struct cl_chip *chip, u8 *priority_rx_he_su_er, u8 *priority_rx_he_tb, u8 *priority_rx_he_mu, u8 *priority_rx_he_su, u8 *priority_rx_vht, u8 *priority_rx_ht_ampdu, u8 *priority_rx_ht_smpdu, u8 *priority_rx_non_ht, u8 *priority_rx_11b, u8 *priority_rx_default, u8 *priority_htp_bfr, u8 *priority_htp_bqr, u8 *priority_htp_bsr, u8 *priority_htp_ba, u8 *priority_htp_data, u8 *priority_mu_cts, u8 *priority_bfr2, u8 *priority_bfr1, u8 *priority_cf_end, u8 *priority_ba, u8 *priority_ack, u8 *priority_cts)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	*priority_rx_he_su_er = (local_val & ((u32)0x02000000)) >> 25;
	*priority_rx_he_tb = (local_val & ((u32)0x01000000)) >> 24;
	*priority_rx_he_mu = (local_val & ((u32)0x00800000)) >> 23;
	*priority_rx_he_su = (local_val & ((u32)0x00400000)) >> 22;
	*priority_rx_vht = (local_val & ((u32)0x00200000)) >> 21;
	*priority_rx_ht_ampdu = (local_val & ((u32)0x00100000)) >> 20;
	*priority_rx_ht_smpdu = (local_val & ((u32)0x00080000)) >> 19;
	*priority_rx_non_ht = (local_val & ((u32)0x00040000)) >> 18;
	*priority_rx_11b = (local_val & ((u32)0x00020000)) >> 17;
	*priority_rx_default = (local_val & ((u32)0x00010000)) >> 16;
	*priority_htp_bfr = (local_val & ((u32)0x00000800)) >> 11;
	*priority_htp_bqr = (local_val & ((u32)0x00000400)) >> 10;
	*priority_htp_bsr = (local_val & ((u32)0x00000200)) >> 9;
	*priority_htp_ba = (local_val & ((u32)0x00000100)) >> 8;
	*priority_htp_data = (local_val & ((u32)0x00000080)) >> 7;
	*priority_mu_cts = (local_val & ((u32)0x00000040)) >> 6;
	*priority_bfr2 = (local_val & ((u32)0x00000020)) >> 5;
	*priority_bfr1 = (local_val & ((u32)0x00000010)) >> 4;
	*priority_cf_end = (local_val & ((u32)0x00000008)) >> 3;
	*priority_ba = (local_val & ((u32)0x00000004)) >> 2;
	*priority_ack = (local_val & ((u32)0x00000002)) >> 1;
	*priority_cts = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_pta_control_2_priority_rx_he_su_er_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_pta_control_2_priority_rx_he_su_er_setf(struct cl_chip *chip, u8 priorityrxhesuer)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhesuer << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x02000000)) | ((u32)priorityrxhesuer << 25));
}

static inline u8 mac_hw_pta_control_2_priority_rx_he_tb_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_pta_control_2_priority_rx_he_tb_setf(struct cl_chip *chip, u8 priorityrxhetb)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhetb << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x01000000)) | ((u32)priorityrxhetb << 24));
}

static inline u8 mac_hw_pta_control_2_priority_rx_he_mu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_pta_control_2_priority_rx_he_mu_setf(struct cl_chip *chip, u8 priorityrxhemu)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhemu << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00800000)) | ((u32)priorityrxhemu << 23));
}

static inline u8 mac_hw_pta_control_2_priority_rx_he_su_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_pta_control_2_priority_rx_he_su_setf(struct cl_chip *chip, u8 priorityrxhesu)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhesu << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00400000)) | ((u32)priorityrxhesu << 22));
}

static inline u8 mac_hw_pta_control_2_priority_rx_vht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_pta_control_2_priority_rx_vht_setf(struct cl_chip *chip, u8 priorityrxvht)
{
	ASSERT_ERR_CHIP((((u32)priorityrxvht << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00200000)) | ((u32)priorityrxvht << 21));
}

static inline u8 mac_hw_pta_control_2_priority_rx_ht_ampdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_pta_control_2_priority_rx_ht_ampdu_setf(struct cl_chip *chip, u8 priorityrxhtampdu)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhtampdu << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00100000)) | ((u32)priorityrxhtampdu << 20));
}

static inline u8 mac_hw_pta_control_2_priority_rx_ht_smpdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_pta_control_2_priority_rx_ht_smpdu_setf(struct cl_chip *chip, u8 priorityrxhtsmpdu)
{
	ASSERT_ERR_CHIP((((u32)priorityrxhtsmpdu << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00080000)) | ((u32)priorityrxhtsmpdu << 19));
}

static inline u8 mac_hw_pta_control_2_priority_rx_non_ht_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_pta_control_2_priority_rx_non_ht_setf(struct cl_chip *chip, u8 priorityrxnonht)
{
	ASSERT_ERR_CHIP((((u32)priorityrxnonht << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00040000)) | ((u32)priorityrxnonht << 18));
}

static inline u8 mac_hw_pta_control_2_priority_rx_11_b_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_pta_control_2_priority_rx_11_b_setf(struct cl_chip *chip, u8 priorityrx11b)
{
	ASSERT_ERR_CHIP((((u32)priorityrx11b << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00020000)) | ((u32)priorityrx11b << 17));
}

static inline u8 mac_hw_pta_control_2_priority_rx_default_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_pta_control_2_priority_rx_default_setf(struct cl_chip *chip, u8 priorityrxdefault)
{
	ASSERT_ERR_CHIP((((u32)priorityrxdefault << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00010000)) | ((u32)priorityrxdefault << 16));
}

static inline u8 mac_hw_pta_control_2_priority_htp_bfr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_pta_control_2_priority_htp_bfr_setf(struct cl_chip *chip, u8 priorityhtpbfr)
{
	ASSERT_ERR_CHIP((((u32)priorityhtpbfr << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000800)) | ((u32)priorityhtpbfr << 11));
}

static inline u8 mac_hw_pta_control_2_priority_htp_bqr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_pta_control_2_priority_htp_bqr_setf(struct cl_chip *chip, u8 priorityhtpbqr)
{
	ASSERT_ERR_CHIP((((u32)priorityhtpbqr << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000400)) | ((u32)priorityhtpbqr << 10));
}

static inline u8 mac_hw_pta_control_2_priority_htp_bsr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_pta_control_2_priority_htp_bsr_setf(struct cl_chip *chip, u8 priorityhtpbsr)
{
	ASSERT_ERR_CHIP((((u32)priorityhtpbsr << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000200)) | ((u32)priorityhtpbsr << 9));
}

static inline u8 mac_hw_pta_control_2_priority_htp_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_pta_control_2_priority_htp_ba_setf(struct cl_chip *chip, u8 priorityhtpba)
{
	ASSERT_ERR_CHIP((((u32)priorityhtpba << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000100)) | ((u32)priorityhtpba << 8));
}

static inline u8 mac_hw_pta_control_2_priority_htp_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_pta_control_2_priority_htp_data_setf(struct cl_chip *chip, u8 priorityhtpdata)
{
	ASSERT_ERR_CHIP((((u32)priorityhtpdata << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000080)) | ((u32)priorityhtpdata << 7));
}

static inline u8 mac_hw_pta_control_2_priority_mu_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_pta_control_2_priority_mu_cts_setf(struct cl_chip *chip, u8 prioritymucts)
{
	ASSERT_ERR_CHIP((((u32)prioritymucts << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000040)) | ((u32)prioritymucts << 6));
}

static inline u8 mac_hw_pta_control_2_priority_bfr_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_pta_control_2_priority_bfr_2_setf(struct cl_chip *chip, u8 prioritybfr2)
{
	ASSERT_ERR_CHIP((((u32)prioritybfr2 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000020)) | ((u32)prioritybfr2 << 5));
}

static inline u8 mac_hw_pta_control_2_priority_bfr_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_pta_control_2_priority_bfr_1_setf(struct cl_chip *chip, u8 prioritybfr1)
{
	ASSERT_ERR_CHIP((((u32)prioritybfr1 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000010)) | ((u32)prioritybfr1 << 4));
}

static inline u8 mac_hw_pta_control_2_priority_cf_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_pta_control_2_priority_cf_end_setf(struct cl_chip *chip, u8 prioritycfend)
{
	ASSERT_ERR_CHIP((((u32)prioritycfend << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000008)) | ((u32)prioritycfend << 3));
}

static inline u8 mac_hw_pta_control_2_priority_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_pta_control_2_priority_ba_setf(struct cl_chip *chip, u8 priorityba)
{
	ASSERT_ERR_CHIP((((u32)priorityba << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000004)) | ((u32)priorityba << 2));
}

static inline u8 mac_hw_pta_control_2_priority_ack_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_pta_control_2_priority_ack_setf(struct cl_chip *chip, u8 priorityack)
{
	ASSERT_ERR_CHIP((((u32)priorityack << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000002)) | ((u32)priorityack << 1));
}

static inline u8 mac_hw_pta_control_2_priority_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_pta_control_2_priority_cts_setf(struct cl_chip *chip, u8 prioritycts)
{
	ASSERT_ERR_CHIP((((u32)prioritycts << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_2_ADDR) & ~((u32)0x00000001)) | ((u32)prioritycts << 0));
}

/**
 * @brief PTA_CONTROL_3 register definition
 *  Contains PTA control fields register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    11    Ignore_pta_gnt_HTP_BFR    0
 *    10    Ignore_pta_gnt_HTP_BQR    0
 *    09    Ignore_pta_gnt_HTP_BSR    0
 *    08    Ignore_pta_gnt_HTP_BA     0
 *    07    Ignore_pta_gnt_HTP_DATA   0
 *    06    Ignore_pta_gnt_MU_CTS     0
 *    05    Ignore_pta_gnt_BFR2       0
 *    04    Ignore_pta_gnt_BFR1       0
 *    03    Ignore_pta_gnt_CF_END     0
 *    02    Ignore_pta_gnt_BA         0
 *    01    Ignore_pta_gnt_ACK        0
 *    00    Ignore_pta_gnt_CTS        0
 * </pre>
 */
#define MAC_HW_PTA_CONTROL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000358)
#define MAC_HW_PTA_CONTROL_3_OFFSET      0x00000358
#define MAC_HW_PTA_CONTROL_3_INDEX       0x000000D6
#define MAC_HW_PTA_CONTROL_3_RESET       0x00000000

static inline u32 mac_hw_pta_control_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);
}

static inline void mac_hw_pta_control_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BFR_BIT    ((u32)0x00000800)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BFR_POS    11
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BQR_BIT    ((u32)0x00000400)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BQR_POS    10
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BSR_BIT    ((u32)0x00000200)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BSR_POS    9
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BA_BIT    ((u32)0x00000100)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BA_POS    8
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_DATA_BIT    ((u32)0x00000080)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_DATA_POS    7
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_MU_CTS_BIT    ((u32)0x00000040)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_MU_CTS_POS    6
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_2_BIT    ((u32)0x00000020)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_2_POS    5
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_1_BIT    ((u32)0x00000010)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_1_POS    4
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CF_END_BIT    ((u32)0x00000008)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CF_END_POS    3
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BA_BIT    ((u32)0x00000004)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BA_POS    2
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_ACK_BIT    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_ACK_POS    1
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CTS_BIT    ((u32)0x00000001)
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CTS_POS    0

#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BFR_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BQR_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BSR_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_BA_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_HTP_DATA_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_MU_CTS_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_2_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BFR_1_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CF_END_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_BA_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_ACK_RST    0x0
#define MAC_HW_PTA_CONTROL_3_IGNORE_PTA_GNT_CTS_RST    0x0

static inline void mac_hw_pta_control_3_pack(struct cl_chip *chip, u8 ignore_pta_gnt_htp_bfr, u8 ignore_pta_gnt_htp_bqr, u8 ignore_pta_gnt_htp_bsr, u8 ignore_pta_gnt_htp_ba, u8 ignore_pta_gnt_htp_data, u8 ignore_pta_gnt_mu_cts, u8 ignore_pta_gnt_bfr2, u8 ignore_pta_gnt_bfr1, u8 ignore_pta_gnt_cf_end, u8 ignore_pta_gnt_ba, u8 ignore_pta_gnt_ack, u8 ignore_pta_gnt_cts)
{
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_htp_bfr << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_htp_bqr << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_htp_bsr << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_htp_ba << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_htp_data << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_mu_cts << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_bfr2 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_bfr1 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_cf_end << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ba << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_ack << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_pta_gnt_cts << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, ((u32)ignore_pta_gnt_htp_bfr << 11) | ((u32)ignore_pta_gnt_htp_bqr << 10) | ((u32)ignore_pta_gnt_htp_bsr << 9) | ((u32)ignore_pta_gnt_htp_ba << 8) | ((u32)ignore_pta_gnt_htp_data << 7) | ((u32)ignore_pta_gnt_mu_cts << 6) | ((u32)ignore_pta_gnt_bfr2 << 5) | ((u32)ignore_pta_gnt_bfr1 << 4) | ((u32)ignore_pta_gnt_cf_end << 3) | ((u32)ignore_pta_gnt_ba << 2) | ((u32)ignore_pta_gnt_ack << 1) | ((u32)ignore_pta_gnt_cts << 0));
}

static inline void mac_hw_pta_control_3_unpack(struct cl_chip *chip, u8 *ignore_pta_gnt_htp_bfr, u8 *ignore_pta_gnt_htp_bqr, u8 *ignore_pta_gnt_htp_bsr, u8 *ignore_pta_gnt_htp_ba, u8 *ignore_pta_gnt_htp_data, u8 *ignore_pta_gnt_mu_cts, u8 *ignore_pta_gnt_bfr2, u8 *ignore_pta_gnt_bfr1, u8 *ignore_pta_gnt_cf_end, u8 *ignore_pta_gnt_ba, u8 *ignore_pta_gnt_ack, u8 *ignore_pta_gnt_cts)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	*ignore_pta_gnt_htp_bfr = (local_val & ((u32)0x00000800)) >> 11;
	*ignore_pta_gnt_htp_bqr = (local_val & ((u32)0x00000400)) >> 10;
	*ignore_pta_gnt_htp_bsr = (local_val & ((u32)0x00000200)) >> 9;
	*ignore_pta_gnt_htp_ba = (local_val & ((u32)0x00000100)) >> 8;
	*ignore_pta_gnt_htp_data = (local_val & ((u32)0x00000080)) >> 7;
	*ignore_pta_gnt_mu_cts = (local_val & ((u32)0x00000040)) >> 6;
	*ignore_pta_gnt_bfr2 = (local_val & ((u32)0x00000020)) >> 5;
	*ignore_pta_gnt_bfr1 = (local_val & ((u32)0x00000010)) >> 4;
	*ignore_pta_gnt_cf_end = (local_val & ((u32)0x00000008)) >> 3;
	*ignore_pta_gnt_ba = (local_val & ((u32)0x00000004)) >> 2;
	*ignore_pta_gnt_ack = (local_val & ((u32)0x00000002)) >> 1;
	*ignore_pta_gnt_cts = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_htp_bfr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_htp_bfr_setf(struct cl_chip *chip, u8 ignoreptagnthtpbfr)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagnthtpbfr << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000800)) | ((u32)ignoreptagnthtpbfr << 11));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_htp_bqr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_htp_bqr_setf(struct cl_chip *chip, u8 ignoreptagnthtpbqr)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagnthtpbqr << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000400)) | ((u32)ignoreptagnthtpbqr << 10));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_htp_bsr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_htp_bsr_setf(struct cl_chip *chip, u8 ignoreptagnthtpbsr)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagnthtpbsr << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000200)) | ((u32)ignoreptagnthtpbsr << 9));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_htp_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_htp_ba_setf(struct cl_chip *chip, u8 ignoreptagnthtpba)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagnthtpba << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000100)) | ((u32)ignoreptagnthtpba << 8));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_htp_data_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_htp_data_setf(struct cl_chip *chip, u8 ignoreptagnthtpdata)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagnthtpdata << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000080)) | ((u32)ignoreptagnthtpdata << 7));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_mu_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_mu_cts_setf(struct cl_chip *chip, u8 ignoreptagntmucts)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntmucts << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000040)) | ((u32)ignoreptagntmucts << 6));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_bfr_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_bfr_2_setf(struct cl_chip *chip, u8 ignoreptagntbfr2)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntbfr2 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000020)) | ((u32)ignoreptagntbfr2 << 5));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_bfr_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_bfr_1_setf(struct cl_chip *chip, u8 ignoreptagntbfr1)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntbfr1 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000010)) | ((u32)ignoreptagntbfr1 << 4));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_cf_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_cf_end_setf(struct cl_chip *chip, u8 ignoreptagntcfend)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntcfend << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000008)) | ((u32)ignoreptagntcfend << 3));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_ba_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_ba_setf(struct cl_chip *chip, u8 ignoreptagntba)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntba << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000004)) | ((u32)ignoreptagntba << 2));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_ack_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_ack_setf(struct cl_chip *chip, u8 ignoreptagntack)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntack << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000002)) | ((u32)ignoreptagntack << 1));
}

static inline u8 mac_hw_pta_control_3_ignore_pta_gnt_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_pta_control_3_ignore_pta_gnt_cts_setf(struct cl_chip *chip, u8 ignoreptagntcts)
{
	ASSERT_ERR_CHIP((((u32)ignoreptagntcts << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_3_ADDR) & ~((u32)0x00000001)) | ((u32)ignoreptagntcts << 0));
}

/**
 * @brief PTA_CONTROL_4 register definition
 *  Contains PTA control fields register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 RX_REQ_FORCE_LOW_INTERVAL 0x1E
 *    23:16 RX_REQ_HOLD               0x20
 *    08    PTA_REQ_OVERLAP_AVOIDANCE 0
 *    07:06 RX_seq_protection         0x1
 *    05:04 Sounding_seq_protection   0x0
 *    03:02 ndpa_protection           0x0
 *    01:00 Default_frame_BW          0x0
 * </pre>
 */
#define MAC_HW_PTA_CONTROL_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000035C)
#define MAC_HW_PTA_CONTROL_4_OFFSET      0x0000035C
#define MAC_HW_PTA_CONTROL_4_INDEX       0x000000D7
#define MAC_HW_PTA_CONTROL_4_RESET       0x1E200040

static inline u32 mac_hw_pta_control_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);
}

static inline void mac_hw_pta_control_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PTA_CONTROL_4_RX_REQ_FORCE_LOW_INTERVAL_MASK    ((u32)0xFF000000)
#define MAC_HW_PTA_CONTROL_4_RX_REQ_FORCE_LOW_INTERVAL_LSB    24
#define MAC_HW_PTA_CONTROL_4_RX_REQ_FORCE_LOW_INTERVAL_WIDTH    ((u32)0x00000008)
#define MAC_HW_PTA_CONTROL_4_RX_REQ_HOLD_MASK    ((u32)0x00FF0000)
#define MAC_HW_PTA_CONTROL_4_RX_REQ_HOLD_LSB    16
#define MAC_HW_PTA_CONTROL_4_RX_REQ_HOLD_WIDTH    ((u32)0x00000008)
#define MAC_HW_PTA_CONTROL_4_PTA_REQ_OVERLAP_AVOIDANCE_BIT    ((u32)0x00000100)
#define MAC_HW_PTA_CONTROL_4_PTA_REQ_OVERLAP_AVOIDANCE_POS    8
#define MAC_HW_PTA_CONTROL_4_RX_SEQ_PROTECTION_MASK    ((u32)0x000000C0)
#define MAC_HW_PTA_CONTROL_4_RX_SEQ_PROTECTION_LSB    6
#define MAC_HW_PTA_CONTROL_4_RX_SEQ_PROTECTION_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_4_SOUNDING_SEQ_PROTECTION_MASK    ((u32)0x00000030)
#define MAC_HW_PTA_CONTROL_4_SOUNDING_SEQ_PROTECTION_LSB    4
#define MAC_HW_PTA_CONTROL_4_SOUNDING_SEQ_PROTECTION_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_4_NDPA_PROTECTION_MASK    ((u32)0x0000000C)
#define MAC_HW_PTA_CONTROL_4_NDPA_PROTECTION_LSB    2
#define MAC_HW_PTA_CONTROL_4_NDPA_PROTECTION_WIDTH    ((u32)0x00000002)
#define MAC_HW_PTA_CONTROL_4_DEFAULT_FRAME_BW_MASK    ((u32)0x00000003)
#define MAC_HW_PTA_CONTROL_4_DEFAULT_FRAME_BW_LSB    0
#define MAC_HW_PTA_CONTROL_4_DEFAULT_FRAME_BW_WIDTH    ((u32)0x00000002)

#define MAC_HW_PTA_CONTROL_4_RX_REQ_FORCE_LOW_INTERVAL_RST    0x1E
#define MAC_HW_PTA_CONTROL_4_RX_REQ_HOLD_RST    0x20
#define MAC_HW_PTA_CONTROL_4_PTA_REQ_OVERLAP_AVOIDANCE_RST    0x0
#define MAC_HW_PTA_CONTROL_4_RX_SEQ_PROTECTION_RST    0x1
#define MAC_HW_PTA_CONTROL_4_SOUNDING_SEQ_PROTECTION_RST    0x0
#define MAC_HW_PTA_CONTROL_4_NDPA_PROTECTION_RST    0x0
#define MAC_HW_PTA_CONTROL_4_DEFAULT_FRAME_BW_RST    0x0

static inline void mac_hw_pta_control_4_pack(struct cl_chip *chip, u8 rx_req_force_low_interval, u8 rx_req_hold, u8 pta_req_overlap_avoidance, u8 rx_seq_protection, u8 sounding_seq_protection, u8 ndpa_protection, u8 default_frame_bw)
{
	ASSERT_ERR_CHIP((((u32)rx_req_force_low_interval << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_req_hold << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)pta_req_overlap_avoidance << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_seq_protection << 6) & ~((u32)0x000000C0)) == 0);
	ASSERT_ERR_CHIP((((u32)sounding_seq_protection << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)ndpa_protection << 2) & ~((u32)0x0000000C)) == 0);
	ASSERT_ERR_CHIP((((u32)default_frame_bw << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, ((u32)rx_req_force_low_interval << 24) | ((u32)rx_req_hold << 16) | ((u32)pta_req_overlap_avoidance << 8) | ((u32)rx_seq_protection << 6) | ((u32)sounding_seq_protection << 4) | ((u32)ndpa_protection << 2) | ((u32)default_frame_bw << 0));
}

static inline void mac_hw_pta_control_4_unpack(struct cl_chip *chip, u8 *rx_req_force_low_interval, u8 *rx_req_hold, u8 *pta_req_overlap_avoidance, u8 *rx_seq_protection, u8 *sounding_seq_protection, u8 *ndpa_protection, u8 *default_frame_bw)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	*rx_req_force_low_interval = (local_val & ((u32)0xFF000000)) >> 24;
	*rx_req_hold = (local_val & ((u32)0x00FF0000)) >> 16;
	*pta_req_overlap_avoidance = (local_val & ((u32)0x00000100)) >> 8;
	*rx_seq_protection = (local_val & ((u32)0x000000C0)) >> 6;
	*sounding_seq_protection = (local_val & ((u32)0x00000030)) >> 4;
	*ndpa_protection = (local_val & ((u32)0x0000000C)) >> 2;
	*default_frame_bw = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_pta_control_4_rx_req_force_low_interval_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_pta_control_4_rx_req_force_low_interval_setf(struct cl_chip *chip, u8 rxreqforcelowinterval)
{
	ASSERT_ERR_CHIP((((u32)rxreqforcelowinterval << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0xFF000000)) | ((u32)rxreqforcelowinterval << 24));
}

static inline u8 mac_hw_pta_control_4_rx_req_hold_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_pta_control_4_rx_req_hold_setf(struct cl_chip *chip, u8 rxreqhold)
{
	ASSERT_ERR_CHIP((((u32)rxreqhold << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x00FF0000)) | ((u32)rxreqhold << 16));
}

static inline u8 mac_hw_pta_control_4_pta_req_overlap_avoidance_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_pta_control_4_pta_req_overlap_avoidance_setf(struct cl_chip *chip, u8 ptareqoverlapavoidance)
{
	ASSERT_ERR_CHIP((((u32)ptareqoverlapavoidance << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x00000100)) | ((u32)ptareqoverlapavoidance << 8));
}

static inline u8 mac_hw_pta_control_4_rx_seq_protection_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x000000C0)) >> 6);
}

static inline void mac_hw_pta_control_4_rx_seq_protection_setf(struct cl_chip *chip, u8 rxseqprotection)
{
	ASSERT_ERR_CHIP((((u32)rxseqprotection << 6) & ~((u32)0x000000C0)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x000000C0)) | ((u32)rxseqprotection << 6));
}

static inline u8 mac_hw_pta_control_4_sounding_seq_protection_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_pta_control_4_sounding_seq_protection_setf(struct cl_chip *chip, u8 soundingseqprotection)
{
	ASSERT_ERR_CHIP((((u32)soundingseqprotection << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x00000030)) | ((u32)soundingseqprotection << 4));
}

static inline u8 mac_hw_pta_control_4_ndpa_protection_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline void mac_hw_pta_control_4_ndpa_protection_setf(struct cl_chip *chip, u8 ndpaprotection)
{
	ASSERT_ERR_CHIP((((u32)ndpaprotection << 2) & ~((u32)0x0000000C)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x0000000C)) | ((u32)ndpaprotection << 2));
}

static inline u8 mac_hw_pta_control_4_default_frame_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

static inline void mac_hw_pta_control_4_default_frame_bw_setf(struct cl_chip *chip, u8 defaultframebw)
{
	ASSERT_ERR_CHIP((((u32)defaultframebw << 0) & ~((u32)0x00000003)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_4_ADDR, (cl_reg_read(chip, MAC_HW_PTA_CONTROL_4_ADDR) & ~((u32)0x00000003)) | ((u32)defaultframebw << 0));
}

/**
 * @brief TX_RESP_FAILED_PTA_COUNT register definition
 *  Contains TX_RESPONSE_FAILED_PTA counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_RESP_FAILED_PTA_COUNT  0x0
 * </pre>
 */
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000360)
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_OFFSET      0x00000360
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_INDEX       0x000000D8
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_RESET       0x00000000

static inline u32 mac_hw_tx_resp_failed_pta_count_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_RESP_FAILED_PTA_COUNT_ADDR);
}

static inline void mac_hw_tx_resp_failed_pta_count_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_RESP_FAILED_PTA_COUNT_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_TX_RESP_FAILED_PTA_COUNT_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_TX_RESP_FAILED_PTA_COUNT_LSB    0
#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_TX_RESP_FAILED_PTA_COUNT_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_RESP_FAILED_PTA_COUNT_TX_RESP_FAILED_PTA_COUNT_RST    0x0

static inline u32 mac_hw_tx_resp_failed_pta_count_tx_resp_failed_pta_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_RESP_FAILED_PTA_COUNT_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_resp_failed_pta_count_tx_resp_failed_pta_count_setf(struct cl_chip *chip, u32 txrespfailedptacount)
{
	ASSERT_ERR_CHIP((((u32)txrespfailedptacount << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_RESP_FAILED_PTA_COUNT_ADDR, (u32)txrespfailedptacount << 0);
}

/**
 * @brief PTA_CONTROL_5 register definition
 *  PTA control 5 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    00    set_tx_not_allowed        0
 * </pre>
 */
#define MAC_HW_PTA_CONTROL_5_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000364)
#define MAC_HW_PTA_CONTROL_5_OFFSET      0x00000364
#define MAC_HW_PTA_CONTROL_5_INDEX       0x000000D9
#define MAC_HW_PTA_CONTROL_5_RESET       0x00000000

static inline void mac_hw_pta_control_5_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_5_ADDR, value);
}

/* Field definitions */
#define MAC_HW_PTA_CONTROL_5_SET_TX_NOT_ALLOWED_BIT    ((u32)0x00000001)
#define MAC_HW_PTA_CONTROL_5_SET_TX_NOT_ALLOWED_POS    0

#define MAC_HW_PTA_CONTROL_5_SET_TX_NOT_ALLOWED_RST    0x0

static inline void mac_hw_pta_control_5_set_tx_not_allowed_setf(struct cl_chip *chip, u8 settxnotallowed)
{
	ASSERT_ERR_CHIP((((u32)settxnotallowed << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_PTA_CONTROL_5_ADDR, (u32)settxnotallowed << 0);
}

/**
 * @brief SMA_HE_TB_VALID register definition
 *  Indicates the validity of the SMA pointers register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 SMA_VALID                 0x0
 * </pre>
 */
#define MAC_HW_SMA_HE_TB_VALID_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000368)
#define MAC_HW_SMA_HE_TB_VALID_OFFSET      0x00000368
#define MAC_HW_SMA_HE_TB_VALID_INDEX       0x000000DA
#define MAC_HW_SMA_HE_TB_VALID_RESET       0x00000000

static inline u32 mac_hw_sma_he_tb_valid_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SMA_HE_TB_VALID_ADDR);
}

static inline void mac_hw_sma_he_tb_valid_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_VALID_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SMA_HE_TB_VALID_SMA_VALID_MASK    ((u32)0x0000FFFF)
#define MAC_HW_SMA_HE_TB_VALID_SMA_VALID_LSB    0
#define MAC_HW_SMA_HE_TB_VALID_SMA_VALID_WIDTH    ((u32)0x00000010)

#define MAC_HW_SMA_HE_TB_VALID_SMA_VALID_RST    0x0

static inline u16 mac_hw_sma_he_tb_valid_sma_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_VALID_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_sma_he_tb_valid_sma_valid_setf(struct cl_chip *chip, u16 smavalid)
{
	ASSERT_ERR_CHIP((((u32)smavalid << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_VALID_ADDR, (u32)smavalid << 0);
}

/**
 * @brief SMA_HE_TB_1 register definition
 *  Contains the SMA pointers for 20MHz UL_CH register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SMA_20_4                  0x0
 *    23:16 SMA_20_3                  0x0
 *    15:08 SMA_20_2                  0x0
 *    07:00 SMA_20_1                  0x0
 * </pre>
 */
#define MAC_HW_SMA_HE_TB_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000036C)
#define MAC_HW_SMA_HE_TB_1_OFFSET      0x0000036C
#define MAC_HW_SMA_HE_TB_1_INDEX       0x000000DB
#define MAC_HW_SMA_HE_TB_1_RESET       0x00000000

static inline u32 mac_hw_sma_he_tb_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);
}

static inline void mac_hw_sma_he_tb_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SMA_HE_TB_1_SMA_20_4_MASK    ((u32)0xFF000000)
#define MAC_HW_SMA_HE_TB_1_SMA_20_4_LSB     24
#define MAC_HW_SMA_HE_TB_1_SMA_20_4_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_1_SMA_20_3_MASK    ((u32)0x00FF0000)
#define MAC_HW_SMA_HE_TB_1_SMA_20_3_LSB     16
#define MAC_HW_SMA_HE_TB_1_SMA_20_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_1_SMA_20_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_SMA_HE_TB_1_SMA_20_2_LSB     8
#define MAC_HW_SMA_HE_TB_1_SMA_20_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_1_SMA_20_1_MASK    ((u32)0x000000FF)
#define MAC_HW_SMA_HE_TB_1_SMA_20_1_LSB     0
#define MAC_HW_SMA_HE_TB_1_SMA_20_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_SMA_HE_TB_1_SMA_20_4_RST     0x0
#define MAC_HW_SMA_HE_TB_1_SMA_20_3_RST     0x0
#define MAC_HW_SMA_HE_TB_1_SMA_20_2_RST     0x0
#define MAC_HW_SMA_HE_TB_1_SMA_20_1_RST     0x0

static inline void mac_hw_sma_he_tb_1_pack(struct cl_chip *chip, u8 sma_20_4, u8 sma_20_3, u8 sma_20_2, u8 sma_20_1)
{
	ASSERT_ERR_CHIP((((u32)sma_20_4 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_20_3 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_20_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_20_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, ((u32)sma_20_4 << 24) | ((u32)sma_20_3 << 16) | ((u32)sma_20_2 << 8) | ((u32)sma_20_1 << 0));
}

static inline void mac_hw_sma_he_tb_1_unpack(struct cl_chip *chip, u8 *sma_20_4, u8 *sma_20_3, u8 *sma_20_2, u8 *sma_20_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);

	*sma_20_4 = (local_val & ((u32)0xFF000000)) >> 24;
	*sma_20_3 = (local_val & ((u32)0x00FF0000)) >> 16;
	*sma_20_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*sma_20_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_sma_he_tb_1_sma_20_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_sma_he_tb_1_sma_20_4_setf(struct cl_chip *chip, u8 sma204)
{
	ASSERT_ERR_CHIP((((u32)sma204 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR) & ~((u32)0xFF000000)) | ((u32)sma204 << 24));
}

static inline u8 mac_hw_sma_he_tb_1_sma_20_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_sma_he_tb_1_sma_20_3_setf(struct cl_chip *chip, u8 sma203)
{
	ASSERT_ERR_CHIP((((u32)sma203 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR) & ~((u32)0x00FF0000)) | ((u32)sma203 << 16));
}

static inline u8 mac_hw_sma_he_tb_1_sma_20_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_sma_he_tb_1_sma_20_2_setf(struct cl_chip *chip, u8 sma202)
{
	ASSERT_ERR_CHIP((((u32)sma202 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR) & ~((u32)0x0000FF00)) | ((u32)sma202 << 8));
}

static inline u8 mac_hw_sma_he_tb_1_sma_20_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_sma_he_tb_1_sma_20_1_setf(struct cl_chip *chip, u8 sma201)
{
	ASSERT_ERR_CHIP((((u32)sma201 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_1_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_1_ADDR) & ~((u32)0x000000FF)) | ((u32)sma201 << 0));
}

/**
 * @brief SMA_HE_TB_2 register definition
 *  Contains the SMA pointers for 40MHz UL_CH register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SMA_40_4                  0x0
 *    23:16 SMA_40_3                  0x0
 *    15:08 SMA_40_2                  0x0
 *    07:00 SMA_40_1                  0x0
 * </pre>
 */
#define MAC_HW_SMA_HE_TB_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000370)
#define MAC_HW_SMA_HE_TB_2_OFFSET      0x00000370
#define MAC_HW_SMA_HE_TB_2_INDEX       0x000000DC
#define MAC_HW_SMA_HE_TB_2_RESET       0x00000000

static inline u32 mac_hw_sma_he_tb_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);
}

static inline void mac_hw_sma_he_tb_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SMA_HE_TB_2_SMA_40_4_MASK    ((u32)0xFF000000)
#define MAC_HW_SMA_HE_TB_2_SMA_40_4_LSB     24
#define MAC_HW_SMA_HE_TB_2_SMA_40_4_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_2_SMA_40_3_MASK    ((u32)0x00FF0000)
#define MAC_HW_SMA_HE_TB_2_SMA_40_3_LSB     16
#define MAC_HW_SMA_HE_TB_2_SMA_40_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_2_SMA_40_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_SMA_HE_TB_2_SMA_40_2_LSB     8
#define MAC_HW_SMA_HE_TB_2_SMA_40_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_2_SMA_40_1_MASK    ((u32)0x000000FF)
#define MAC_HW_SMA_HE_TB_2_SMA_40_1_LSB     0
#define MAC_HW_SMA_HE_TB_2_SMA_40_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_SMA_HE_TB_2_SMA_40_4_RST     0x0
#define MAC_HW_SMA_HE_TB_2_SMA_40_3_RST     0x0
#define MAC_HW_SMA_HE_TB_2_SMA_40_2_RST     0x0
#define MAC_HW_SMA_HE_TB_2_SMA_40_1_RST     0x0

static inline void mac_hw_sma_he_tb_2_pack(struct cl_chip *chip, u8 sma_40_4, u8 sma_40_3, u8 sma_40_2, u8 sma_40_1)
{
	ASSERT_ERR_CHIP((((u32)sma_40_4 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_40_3 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_40_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_40_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, ((u32)sma_40_4 << 24) | ((u32)sma_40_3 << 16) | ((u32)sma_40_2 << 8) | ((u32)sma_40_1 << 0));
}

static inline void mac_hw_sma_he_tb_2_unpack(struct cl_chip *chip, u8 *sma_40_4, u8 *sma_40_3, u8 *sma_40_2, u8 *sma_40_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);

	*sma_40_4 = (local_val & ((u32)0xFF000000)) >> 24;
	*sma_40_3 = (local_val & ((u32)0x00FF0000)) >> 16;
	*sma_40_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*sma_40_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_sma_he_tb_2_sma_40_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_sma_he_tb_2_sma_40_4_setf(struct cl_chip *chip, u8 sma404)
{
	ASSERT_ERR_CHIP((((u32)sma404 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR) & ~((u32)0xFF000000)) | ((u32)sma404 << 24));
}

static inline u8 mac_hw_sma_he_tb_2_sma_40_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_sma_he_tb_2_sma_40_3_setf(struct cl_chip *chip, u8 sma403)
{
	ASSERT_ERR_CHIP((((u32)sma403 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR) & ~((u32)0x00FF0000)) | ((u32)sma403 << 16));
}

static inline u8 mac_hw_sma_he_tb_2_sma_40_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_sma_he_tb_2_sma_40_2_setf(struct cl_chip *chip, u8 sma402)
{
	ASSERT_ERR_CHIP((((u32)sma402 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR) & ~((u32)0x0000FF00)) | ((u32)sma402 << 8));
}

static inline u8 mac_hw_sma_he_tb_2_sma_40_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_sma_he_tb_2_sma_40_1_setf(struct cl_chip *chip, u8 sma401)
{
	ASSERT_ERR_CHIP((((u32)sma401 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_2_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_2_ADDR) & ~((u32)0x000000FF)) | ((u32)sma401 << 0));
}

/**
 * @brief SMA_HE_TB_3 register definition
 *  Contains the SMA pointers for 80MHz UL_CH register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SMA_80_4                  0x0
 *    23:16 SMA_80_3                  0x0
 *    15:08 SMA_80_2                  0x0
 *    07:00 SMA_80_1                  0x0
 * </pre>
 */
#define MAC_HW_SMA_HE_TB_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000374)
#define MAC_HW_SMA_HE_TB_3_OFFSET      0x00000374
#define MAC_HW_SMA_HE_TB_3_INDEX       0x000000DD
#define MAC_HW_SMA_HE_TB_3_RESET       0x00000000

static inline u32 mac_hw_sma_he_tb_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);
}

static inline void mac_hw_sma_he_tb_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SMA_HE_TB_3_SMA_80_4_MASK    ((u32)0xFF000000)
#define MAC_HW_SMA_HE_TB_3_SMA_80_4_LSB     24
#define MAC_HW_SMA_HE_TB_3_SMA_80_4_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_3_SMA_80_3_MASK    ((u32)0x00FF0000)
#define MAC_HW_SMA_HE_TB_3_SMA_80_3_LSB     16
#define MAC_HW_SMA_HE_TB_3_SMA_80_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_3_SMA_80_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_SMA_HE_TB_3_SMA_80_2_LSB     8
#define MAC_HW_SMA_HE_TB_3_SMA_80_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_3_SMA_80_1_MASK    ((u32)0x000000FF)
#define MAC_HW_SMA_HE_TB_3_SMA_80_1_LSB     0
#define MAC_HW_SMA_HE_TB_3_SMA_80_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_SMA_HE_TB_3_SMA_80_4_RST     0x0
#define MAC_HW_SMA_HE_TB_3_SMA_80_3_RST     0x0
#define MAC_HW_SMA_HE_TB_3_SMA_80_2_RST     0x0
#define MAC_HW_SMA_HE_TB_3_SMA_80_1_RST     0x0

static inline void mac_hw_sma_he_tb_3_pack(struct cl_chip *chip, u8 sma_80_4, u8 sma_80_3, u8 sma_80_2, u8 sma_80_1)
{
	ASSERT_ERR_CHIP((((u32)sma_80_4 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_80_3 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_80_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_80_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, ((u32)sma_80_4 << 24) | ((u32)sma_80_3 << 16) | ((u32)sma_80_2 << 8) | ((u32)sma_80_1 << 0));
}

static inline void mac_hw_sma_he_tb_3_unpack(struct cl_chip *chip, u8 *sma_80_4, u8 *sma_80_3, u8 *sma_80_2, u8 *sma_80_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);

	*sma_80_4 = (local_val & ((u32)0xFF000000)) >> 24;
	*sma_80_3 = (local_val & ((u32)0x00FF0000)) >> 16;
	*sma_80_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*sma_80_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_sma_he_tb_3_sma_80_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_sma_he_tb_3_sma_80_4_setf(struct cl_chip *chip, u8 sma804)
{
	ASSERT_ERR_CHIP((((u32)sma804 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR) & ~((u32)0xFF000000)) | ((u32)sma804 << 24));
}

static inline u8 mac_hw_sma_he_tb_3_sma_80_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_sma_he_tb_3_sma_80_3_setf(struct cl_chip *chip, u8 sma803)
{
	ASSERT_ERR_CHIP((((u32)sma803 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR) & ~((u32)0x00FF0000)) | ((u32)sma803 << 16));
}

static inline u8 mac_hw_sma_he_tb_3_sma_80_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_sma_he_tb_3_sma_80_2_setf(struct cl_chip *chip, u8 sma802)
{
	ASSERT_ERR_CHIP((((u32)sma802 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR) & ~((u32)0x0000FF00)) | ((u32)sma802 << 8));
}

static inline u8 mac_hw_sma_he_tb_3_sma_80_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_sma_he_tb_3_sma_80_1_setf(struct cl_chip *chip, u8 sma801)
{
	ASSERT_ERR_CHIP((((u32)sma801 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_3_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_3_ADDR) & ~((u32)0x000000FF)) | ((u32)sma801 << 0));
}

/**
 * @brief SMA_HE_TB_4 register definition
 *  Contains the SMA pointers for 160MHz UL_CH register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 SMA_160_4                 0x0
 *    23:16 SMA_160_3                 0x0
 *    15:08 SMA_160_2                 0x0
 *    07:00 SMA_160_1                 0x0
 * </pre>
 */
#define MAC_HW_SMA_HE_TB_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000378)
#define MAC_HW_SMA_HE_TB_4_OFFSET      0x00000378
#define MAC_HW_SMA_HE_TB_4_INDEX       0x000000DE
#define MAC_HW_SMA_HE_TB_4_RESET       0x00000000

static inline u32 mac_hw_sma_he_tb_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);
}

static inline void mac_hw_sma_he_tb_4_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SMA_HE_TB_4_SMA_160_4_MASK    ((u32)0xFF000000)
#define MAC_HW_SMA_HE_TB_4_SMA_160_4_LSB    24
#define MAC_HW_SMA_HE_TB_4_SMA_160_4_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_4_SMA_160_3_MASK    ((u32)0x00FF0000)
#define MAC_HW_SMA_HE_TB_4_SMA_160_3_LSB    16
#define MAC_HW_SMA_HE_TB_4_SMA_160_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_4_SMA_160_2_MASK    ((u32)0x0000FF00)
#define MAC_HW_SMA_HE_TB_4_SMA_160_2_LSB    8
#define MAC_HW_SMA_HE_TB_4_SMA_160_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_SMA_HE_TB_4_SMA_160_1_MASK    ((u32)0x000000FF)
#define MAC_HW_SMA_HE_TB_4_SMA_160_1_LSB    0
#define MAC_HW_SMA_HE_TB_4_SMA_160_1_WIDTH    ((u32)0x00000008)

#define MAC_HW_SMA_HE_TB_4_SMA_160_4_RST    0x0
#define MAC_HW_SMA_HE_TB_4_SMA_160_3_RST    0x0
#define MAC_HW_SMA_HE_TB_4_SMA_160_2_RST    0x0
#define MAC_HW_SMA_HE_TB_4_SMA_160_1_RST    0x0

static inline void mac_hw_sma_he_tb_4_pack(struct cl_chip *chip, u8 sma_160_4, u8 sma_160_3, u8 sma_160_2, u8 sma_160_1)
{
	ASSERT_ERR_CHIP((((u32)sma_160_4 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_160_3 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_160_2 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)sma_160_1 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, ((u32)sma_160_4 << 24) | ((u32)sma_160_3 << 16) | ((u32)sma_160_2 << 8) | ((u32)sma_160_1 << 0));
}

static inline void mac_hw_sma_he_tb_4_unpack(struct cl_chip *chip, u8 *sma_160_4, u8 *sma_160_3, u8 *sma_160_2, u8 *sma_160_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);

	*sma_160_4 = (local_val & ((u32)0xFF000000)) >> 24;
	*sma_160_3 = (local_val & ((u32)0x00FF0000)) >> 16;
	*sma_160_2 = (local_val & ((u32)0x0000FF00)) >> 8;
	*sma_160_1 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_sma_he_tb_4_sma_160_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_sma_he_tb_4_sma_160_4_setf(struct cl_chip *chip, u8 sma1604)
{
	ASSERT_ERR_CHIP((((u32)sma1604 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR) & ~((u32)0xFF000000)) | ((u32)sma1604 << 24));
}

static inline u8 mac_hw_sma_he_tb_4_sma_160_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_sma_he_tb_4_sma_160_3_setf(struct cl_chip *chip, u8 sma1603)
{
	ASSERT_ERR_CHIP((((u32)sma1603 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR) & ~((u32)0x00FF0000)) | ((u32)sma1603 << 16));
}

static inline u8 mac_hw_sma_he_tb_4_sma_160_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_sma_he_tb_4_sma_160_2_setf(struct cl_chip *chip, u8 sma1602)
{
	ASSERT_ERR_CHIP((((u32)sma1602 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR) & ~((u32)0x0000FF00)) | ((u32)sma1602 << 8));
}

static inline u8 mac_hw_sma_he_tb_4_sma_160_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_sma_he_tb_4_sma_160_1_setf(struct cl_chip *chip, u8 sma1601)
{
	ASSERT_ERR_CHIP((((u32)sma1601 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_SMA_HE_TB_4_ADDR, (cl_reg_read(chip, MAC_HW_SMA_HE_TB_4_ADDR) & ~((u32)0x000000FF)) | ((u32)sma1601 << 0));
}

/**
 * @brief TX_HALT_CTRL register definition
 *  Controls global halt after txop register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 GLOBAL_HALT_AFTER_TXOP    0x0
 * </pre>
 */
#define MAC_HW_TX_HALT_CTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000037C)
#define MAC_HW_TX_HALT_CTRL_OFFSET      0x0000037C
#define MAC_HW_TX_HALT_CTRL_INDEX       0x000000DF
#define MAC_HW_TX_HALT_CTRL_RESET       0x00000000

static inline u32 mac_hw_tx_halt_ctrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_HALT_CTRL_ADDR);
}

static inline void mac_hw_tx_halt_ctrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_HALT_CTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_HALT_CTRL_GLOBAL_HALT_AFTER_TXOP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_HALT_CTRL_GLOBAL_HALT_AFTER_TXOP_LSB    0
#define MAC_HW_TX_HALT_CTRL_GLOBAL_HALT_AFTER_TXOP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_HALT_CTRL_GLOBAL_HALT_AFTER_TXOP_RST    0x0

static inline u32 mac_hw_tx_halt_ctrl_global_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_HALT_CTRL_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_halt_ctrl_global_halt_after_txop_setf(struct cl_chip *chip, u32 globalhaltaftertxop)
{
	ASSERT_ERR_CHIP((((u32)globalhaltaftertxop << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_HALT_CTRL_ADDR, (u32)globalhaltaftertxop << 0);
}

/**
 * @brief TX_CTRL register definition
 *  Tx Controls currently includes Chicken bits register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    19:08 CODEWORD_SIZE             0xFA
 *    07    BLOCK_RX_DISABLE          0
 *    06    BW_DECISION_CB            1
 *    05    PREVENT_BAR_THD_STAT_EN   1
 *    04    ORIGINAL_RESP_TO_EN       0
 *    03    FORCE_STRT_DLY_PT_EN      0
 *    02    STOP_RX_RESP_TO           0
 *    01    INTERNAL_COLLISION_MODE   0
 *    00    BAR_SKIP_MODE             0
 * </pre>
 */
#define MAC_HW_TX_CTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000380)
#define MAC_HW_TX_CTRL_OFFSET      0x00000380
#define MAC_HW_TX_CTRL_INDEX       0x000000E0
#define MAC_HW_TX_CTRL_RESET       0x0000FA60

static inline u32 mac_hw_tx_ctrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);
}

static inline void mac_hw_tx_ctrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_CTRL_CODEWORD_SIZE_MASK    ((u32)0x000FFF00)
#define MAC_HW_TX_CTRL_CODEWORD_SIZE_LSB    8
#define MAC_HW_TX_CTRL_CODEWORD_SIZE_WIDTH    ((u32)0x0000000C)
#define MAC_HW_TX_CTRL_BLOCK_RX_DISABLE_BIT    ((u32)0x00000080)
#define MAC_HW_TX_CTRL_BLOCK_RX_DISABLE_POS    7
#define MAC_HW_TX_CTRL_BW_DECISION_CB_BIT    ((u32)0x00000040)
#define MAC_HW_TX_CTRL_BW_DECISION_CB_POS    6
#define MAC_HW_TX_CTRL_PREVENT_BAR_THD_STAT_EN_BIT    ((u32)0x00000020)
#define MAC_HW_TX_CTRL_PREVENT_BAR_THD_STAT_EN_POS    5
#define MAC_HW_TX_CTRL_ORIGINAL_RESP_TO_EN_BIT    ((u32)0x00000010)
#define MAC_HW_TX_CTRL_ORIGINAL_RESP_TO_EN_POS    4
#define MAC_HW_TX_CTRL_FORCE_STRT_DLY_PT_EN_BIT    ((u32)0x00000008)
#define MAC_HW_TX_CTRL_FORCE_STRT_DLY_PT_EN_POS    3
#define MAC_HW_TX_CTRL_STOP_RX_RESP_TO_BIT    ((u32)0x00000004)
#define MAC_HW_TX_CTRL_STOP_RX_RESP_TO_POS    2
#define MAC_HW_TX_CTRL_INTERNAL_COLLISION_MODE_BIT    ((u32)0x00000002)
#define MAC_HW_TX_CTRL_INTERNAL_COLLISION_MODE_POS    1
#define MAC_HW_TX_CTRL_BAR_SKIP_MODE_BIT    ((u32)0x00000001)
#define MAC_HW_TX_CTRL_BAR_SKIP_MODE_POS    0

#define MAC_HW_TX_CTRL_CODEWORD_SIZE_RST    0xFA
#define MAC_HW_TX_CTRL_BLOCK_RX_DISABLE_RST    0x0
#define MAC_HW_TX_CTRL_BW_DECISION_CB_RST    0x1
#define MAC_HW_TX_CTRL_PREVENT_BAR_THD_STAT_EN_RST    0x1
#define MAC_HW_TX_CTRL_ORIGINAL_RESP_TO_EN_RST    0x0
#define MAC_HW_TX_CTRL_FORCE_STRT_DLY_PT_EN_RST    0x0
#define MAC_HW_TX_CTRL_STOP_RX_RESP_TO_RST    0x0
#define MAC_HW_TX_CTRL_INTERNAL_COLLISION_MODE_RST    0x0
#define MAC_HW_TX_CTRL_BAR_SKIP_MODE_RST    0x0

static inline void mac_hw_tx_ctrl_pack(struct cl_chip *chip, u16 codeword_size, u8 block_rx_disable, u8 bw_decision_cb, u8 prevent_bar_thd_stat_en, u8 original_resp_to_en, u8 force_strt_dly_pt_en, u8 stop_rx_resp_to, u8 internal_collision_mode, u8 bar_skip_mode)
{
	ASSERT_ERR_CHIP((((u32)codeword_size << 8) & ~((u32)0x000FFF00)) == 0);
	ASSERT_ERR_CHIP((((u32)block_rx_disable << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)bw_decision_cb << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)prevent_bar_thd_stat_en << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)original_resp_to_en << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)force_strt_dly_pt_en << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)stop_rx_resp_to << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)internal_collision_mode << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)bar_skip_mode << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, ((u32)codeword_size << 8) | ((u32)block_rx_disable << 7) | ((u32)bw_decision_cb << 6) | ((u32)prevent_bar_thd_stat_en << 5) | ((u32)original_resp_to_en << 4) | ((u32)force_strt_dly_pt_en << 3) | ((u32)stop_rx_resp_to << 2) | ((u32)internal_collision_mode << 1) | ((u32)bar_skip_mode << 0));
}

static inline void mac_hw_tx_ctrl_unpack(struct cl_chip *chip, u16 *codeword_size, u8 *block_rx_disable, u8 *bw_decision_cb, u8 *prevent_bar_thd_stat_en, u8 *original_resp_to_en, u8 *force_strt_dly_pt_en, u8 *stop_rx_resp_to, u8 *internal_collision_mode, u8 *bar_skip_mode)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	*codeword_size = (local_val & ((u32)0x000FFF00)) >> 8;
	*block_rx_disable = (local_val & ((u32)0x00000080)) >> 7;
	*bw_decision_cb = (local_val & ((u32)0x00000040)) >> 6;
	*prevent_bar_thd_stat_en = (local_val & ((u32)0x00000020)) >> 5;
	*original_resp_to_en = (local_val & ((u32)0x00000010)) >> 4;
	*force_strt_dly_pt_en = (local_val & ((u32)0x00000008)) >> 3;
	*stop_rx_resp_to = (local_val & ((u32)0x00000004)) >> 2;
	*internal_collision_mode = (local_val & ((u32)0x00000002)) >> 1;
	*bar_skip_mode = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u16 mac_hw_tx_ctrl_codeword_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u16)((local_val & ((u32)0x000FFF00)) >> 8);
}

static inline void mac_hw_tx_ctrl_codeword_size_setf(struct cl_chip *chip, u16 codewordsize)
{
	ASSERT_ERR_CHIP((((u32)codewordsize << 8) & ~((u32)0x000FFF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x000FFF00)) | ((u32)codewordsize << 8));
}

static inline u8 mac_hw_tx_ctrl_block_rx_disable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_ctrl_block_rx_disable_setf(struct cl_chip *chip, u8 blockrxdisable)
{
	ASSERT_ERR_CHIP((((u32)blockrxdisable << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000080)) | ((u32)blockrxdisable << 7));
}

static inline u8 mac_hw_tx_ctrl_bw_decision_cb_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_tx_ctrl_bw_decision_cb_setf(struct cl_chip *chip, u8 bwdecisioncb)
{
	ASSERT_ERR_CHIP((((u32)bwdecisioncb << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000040)) | ((u32)bwdecisioncb << 6));
}

static inline u8 mac_hw_tx_ctrl_prevent_bar_thd_stat_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_tx_ctrl_prevent_bar_thd_stat_en_setf(struct cl_chip *chip, u8 preventbarthdstaten)
{
	ASSERT_ERR_CHIP((((u32)preventbarthdstaten << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000020)) | ((u32)preventbarthdstaten << 5));
}

static inline u8 mac_hw_tx_ctrl_original_resp_to_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_tx_ctrl_original_resp_to_en_setf(struct cl_chip *chip, u8 originalresptoen)
{
	ASSERT_ERR_CHIP((((u32)originalresptoen << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000010)) | ((u32)originalresptoen << 4));
}

static inline u8 mac_hw_tx_ctrl_force_strt_dly_pt_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_tx_ctrl_force_strt_dly_pt_en_setf(struct cl_chip *chip, u8 forcestrtdlypten)
{
	ASSERT_ERR_CHIP((((u32)forcestrtdlypten << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000008)) | ((u32)forcestrtdlypten << 3));
}

static inline u8 mac_hw_tx_ctrl_stop_rx_resp_to_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_tx_ctrl_stop_rx_resp_to_setf(struct cl_chip *chip, u8 stoprxrespto)
{
	ASSERT_ERR_CHIP((((u32)stoprxrespto << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000004)) | ((u32)stoprxrespto << 2));
}

static inline u8 mac_hw_tx_ctrl_internal_collision_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_tx_ctrl_internal_collision_mode_setf(struct cl_chip *chip, u8 internalcollisionmode)
{
	ASSERT_ERR_CHIP((((u32)internalcollisionmode << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000002)) | ((u32)internalcollisionmode << 1));
}

static inline u8 mac_hw_tx_ctrl_bar_skip_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_tx_ctrl_bar_skip_mode_setf(struct cl_chip *chip, u8 barskipmode)
{
	ASSERT_ERR_CHIP((((u32)barskipmode << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_TX_CTRL_ADDR, (cl_reg_read(chip, MAC_HW_TX_CTRL_ADDR) & ~((u32)0x00000001)) | ((u32)barskipmode << 0));
}

/**
 * @brief REPEATER_CONF register definition
 *  Repeater configurations register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    02    UPDATE_TSF_AS_REPEATER_ENABLE 1
 *    01    REPEATER_MODE             0
 *    00    REPEATER_MODE_KSR         0
 * </pre>
 */
#define MAC_HW_REPEATER_CONF_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000384)
#define MAC_HW_REPEATER_CONF_OFFSET      0x00000384
#define MAC_HW_REPEATER_CONF_INDEX       0x000000E1
#define MAC_HW_REPEATER_CONF_RESET       0x00000004

static inline u32 mac_hw_repeater_conf_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR);
}

static inline void mac_hw_repeater_conf_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_REPEATER_CONF_ADDR, value);
}

/* Field definitions */
#define MAC_HW_REPEATER_CONF_UPDATE_TSF_AS_REPEATER_ENABLE_BIT    ((u32)0x00000004)
#define MAC_HW_REPEATER_CONF_UPDATE_TSF_AS_REPEATER_ENABLE_POS    2
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_BIT    ((u32)0x00000002)
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_POS    1
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_KSR_BIT    ((u32)0x00000001)
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_KSR_POS    0

#define MAC_HW_REPEATER_CONF_UPDATE_TSF_AS_REPEATER_ENABLE_RST    0x1
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_RST    0x0
#define MAC_HW_REPEATER_CONF_REPEATER_MODE_KSR_RST    0x0

static inline void mac_hw_repeater_conf_pack(struct cl_chip *chip, u8 update_tsf_as_repeater_enable, u8 repeater_mode, u8 repeater_mode_ksr)
{
	ASSERT_ERR_CHIP((((u32)update_tsf_as_repeater_enable << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)repeater_mode << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)repeater_mode_ksr << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_REPEATER_CONF_ADDR, ((u32)update_tsf_as_repeater_enable << 2) | ((u32)repeater_mode << 1) | ((u32)repeater_mode_ksr << 0));
}

static inline void mac_hw_repeater_conf_unpack(struct cl_chip *chip, u8 *update_tsf_as_repeater_enable, u8 *repeater_mode, u8 *repeater_mode_ksr)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR);

	*update_tsf_as_repeater_enable = (local_val & ((u32)0x00000004)) >> 2;
	*repeater_mode = (local_val & ((u32)0x00000002)) >> 1;
	*repeater_mode_ksr = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_repeater_conf_update_tsf_as_repeater_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_repeater_conf_update_tsf_as_repeater_enable_setf(struct cl_chip *chip, u8 updatetsfasrepeaterenable)
{
	ASSERT_ERR_CHIP((((u32)updatetsfasrepeaterenable << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_REPEATER_CONF_ADDR, (cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR) & ~((u32)0x00000004)) | ((u32)updatetsfasrepeaterenable << 2));
}

static inline u8 mac_hw_repeater_conf_repeater_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_repeater_conf_repeater_mode_setf(struct cl_chip *chip, u8 repeatermode)
{
	ASSERT_ERR_CHIP((((u32)repeatermode << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_REPEATER_CONF_ADDR, (cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR) & ~((u32)0x00000002)) | ((u32)repeatermode << 1));
}

static inline u8 mac_hw_repeater_conf_repeater_mode_ksr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_repeater_conf_repeater_mode_ksr_setf(struct cl_chip *chip, u8 repeatermodeksr)
{
	ASSERT_ERR_CHIP((((u32)repeatermodeksr << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_REPEATER_CONF_ADDR, (cl_reg_read(chip, MAC_HW_REPEATER_CONF_ADDR) & ~((u32)0x00000001)) | ((u32)repeatermodeksr << 0));
}

/**
 * @brief DEF_START_PTR register definition
 *  Default start pointer address register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 PTR                       0x60000000
 * </pre>
 */
#define MAC_HW_DEF_START_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000388)
#define MAC_HW_DEF_START_PTR_OFFSET      0x00000388
#define MAC_HW_DEF_START_PTR_INDEX       0x000000E2
#define MAC_HW_DEF_START_PTR_RESET       0x60000000

static inline u32 mac_hw_def_start_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEF_START_PTR_ADDR);
}

static inline void mac_hw_def_start_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEF_START_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEF_START_PTR_PTR_MASK       ((u32)0xFFFFFFFF)
#define MAC_HW_DEF_START_PTR_PTR_LSB        0
#define MAC_HW_DEF_START_PTR_PTR_WIDTH      ((u32)0x00000020)

#define MAC_HW_DEF_START_PTR_PTR_RST        0x60000000

static inline u32 mac_hw_def_start_ptr_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEF_START_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_def_start_ptr_ptr_setf(struct cl_chip *chip, u32 ptr)
{
	ASSERT_ERR_CHIP((((u32)ptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_DEF_START_PTR_ADDR, (u32)ptr << 0);
}

/**
 * @brief RX_CLASS_RULE_A register definition
 *  Includes Rx class rules 0 and 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RX_CLASS_RULE_1           0x0
 *    15:00 RX_CLASS_RULE_0           0x0
 * </pre>
 */
#define MAC_HW_RX_CLASS_RULE_A_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003C0)
#define MAC_HW_RX_CLASS_RULE_A_OFFSET      0x000003C0
#define MAC_HW_RX_CLASS_RULE_A_INDEX       0x000000F0
#define MAC_HW_RX_CLASS_RULE_A_RESET       0x00000000

static inline u32 mac_hw_rx_class_rule_a_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR);
}

static inline void mac_hw_rx_class_rule_a_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_A_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_1_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_1_LSB    16
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_1_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_0_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_0_LSB    0
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_0_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_CLASS_RULE_A_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_class_rule_a_pack(struct cl_chip *chip, u16 rx_class_rule_1, u16 rx_class_rule_0)
{
	ASSERT_ERR_CHIP((((u32)rx_class_rule_1 << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule_0 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_A_ADDR, ((u32)rx_class_rule_1 << 16) | ((u32)rx_class_rule_0 << 0));
}

static inline void mac_hw_rx_class_rule_a_unpack(struct cl_chip *chip, u16 *rx_class_rule_1, u16 *rx_class_rule_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR);

	*rx_class_rule_1 = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_class_rule_0 = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_class_rule_a_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_rx_class_rule_a_rx_class_rule_1_setf(struct cl_chip *chip, u16 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_A_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR) & ~((u32)0xFFFF0000)) | ((u32)rxclassrule1 << 16));
}

static inline u16 mac_hw_rx_class_rule_a_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_class_rule_a_rx_class_rule_0_setf(struct cl_chip *chip, u16 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_A_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_A_ADDR) & ~((u32)0x0000FFFF)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief RX_CLASS_RULE_B register definition
 *  Includes Rx class rules 2 and 3 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RX_CLASS_RULE_3           0x0
 *    15:00 RX_CLASS_RULE_2           0x0
 * </pre>
 */
#define MAC_HW_RX_CLASS_RULE_B_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003C4)
#define MAC_HW_RX_CLASS_RULE_B_OFFSET      0x000003C4
#define MAC_HW_RX_CLASS_RULE_B_INDEX       0x000000F1
#define MAC_HW_RX_CLASS_RULE_B_RESET       0x00000000

static inline u32 mac_hw_rx_class_rule_b_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR);
}

static inline void mac_hw_rx_class_rule_b_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_B_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_3_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_3_LSB    16
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_3_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_2_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_2_LSB    0
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_2_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_CLASS_RULE_B_RX_CLASS_RULE_2_RST    0x0

static inline void mac_hw_rx_class_rule_b_pack(struct cl_chip *chip, u16 rx_class_rule_3, u16 rx_class_rule_2)
{
	ASSERT_ERR_CHIP((((u32)rx_class_rule_3 << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule_2 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_B_ADDR, ((u32)rx_class_rule_3 << 16) | ((u32)rx_class_rule_2 << 0));
}

static inline void mac_hw_rx_class_rule_b_unpack(struct cl_chip *chip, u16 *rx_class_rule_3, u16 *rx_class_rule_2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR);

	*rx_class_rule_3 = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_class_rule_2 = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_class_rule_b_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_rx_class_rule_b_rx_class_rule_3_setf(struct cl_chip *chip, u16 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_B_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR) & ~((u32)0xFFFF0000)) | ((u32)rxclassrule3 << 16));
}

static inline u16 mac_hw_rx_class_rule_b_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_class_rule_b_rx_class_rule_2_setf(struct cl_chip *chip, u16 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_B_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_B_ADDR) & ~((u32)0x0000FFFF)) | ((u32)rxclassrule2 << 0));
}

/**
 * @brief RX_CLASS_RULE_C register definition
 *  Includes Rx class rules 4 and 5 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 RX_CLASS_RULE_5           0x0
 *    15:00 RX_CLASS_RULE_4           0x0
 * </pre>
 */
#define MAC_HW_RX_CLASS_RULE_C_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003C8)
#define MAC_HW_RX_CLASS_RULE_C_OFFSET      0x000003C8
#define MAC_HW_RX_CLASS_RULE_C_INDEX       0x000000F2
#define MAC_HW_RX_CLASS_RULE_C_RESET       0x00000000

static inline u32 mac_hw_rx_class_rule_c_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR);
}

static inline void mac_hw_rx_class_rule_c_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_C_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_5_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_5_LSB    16
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_5_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_4_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_4_LSB    0
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_4_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_CLASS_RULE_C_RX_CLASS_RULE_4_RST    0x0

static inline void mac_hw_rx_class_rule_c_pack(struct cl_chip *chip, u16 rx_class_rule_5, u16 rx_class_rule_4)
{
	ASSERT_ERR_CHIP((((u32)rx_class_rule_5 << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule_4 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_C_ADDR, ((u32)rx_class_rule_5 << 16) | ((u32)rx_class_rule_4 << 0));
}

static inline void mac_hw_rx_class_rule_c_unpack(struct cl_chip *chip, u16 *rx_class_rule_5, u16 *rx_class_rule_4)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR);

	*rx_class_rule_5 = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_class_rule_4 = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_class_rule_c_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_rx_class_rule_c_rx_class_rule_5_setf(struct cl_chip *chip, u16 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_C_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR) & ~((u32)0xFFFF0000)) | ((u32)rxclassrule5 << 16));
}

static inline u16 mac_hw_rx_class_rule_c_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_rx_class_rule_c_rx_class_rule_4_setf(struct cl_chip *chip, u16 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_RX_CLASS_RULE_C_ADDR, (cl_reg_read(chip, MAC_HW_RX_CLASS_RULE_C_ADDR) & ~((u32)0x0000FFFF)) | ((u32)rxclassrule4 << 0));
}

/**
 * @brief RX_VECTOR_2_SET_0_LOW register definition
 *  Rx Vecrtor2 register set 0 lower part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RXVEC2_L                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003D0)
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_OFFSET      0x000003D0
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_INDEX       0x000000F4
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_0_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_LOW_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_RXVEC_2_L_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_RXVEC_2_L_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_0_LOW_RXVEC_2_L_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_VECTOR_2_SET_0_LOW_RXVEC_2_L_RST    0x0

static inline u32 mac_hw_rx_vector_2_set_0_low_rxvec_2_l_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_LOW_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_0_HIGH register definition
 *  Rx Vecrtor2 register set 0 higher part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RHD_INDEX                 0x0
 *    27:00 RXVEC2_H                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003D4)
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_OFFSET      0x000003D4
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_INDEX       0x000000F5
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_0_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_HIGH_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RHD_INDEX_MASK    ((u32)0xF0000000)
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RHD_INDEX_LSB    28
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RHD_INDEX_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RXVEC_2_H_MASK    ((u32)0x0FFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RXVEC_2_H_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RXVEC_2_H_WIDTH    ((u32)0x0000001C)

#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RHD_INDEX_RST    0x0
#define MAC_HW_RX_VECTOR_2_SET_0_HIGH_RXVEC_2_H_RST    0x0

static inline void mac_hw_rx_vector_2_set_0_high_unpack(struct cl_chip *chip, u8 *rhd_index, u32 *rxvec2_h)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_HIGH_ADDR);

	*rhd_index = (local_val & ((u32)0xF0000000)) >> 28;
	*rxvec2_h = (local_val & ((u32)0x0FFFFFFF)) >> 0;
}

static inline u8 mac_hw_rx_vector_2_set_0_high_rhd_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_HIGH_ADDR);

	return (u8)((local_val & ((u32)0xF0000000)) >> 28);
}

static inline u32 mac_hw_rx_vector_2_set_0_high_rxvec_2_h_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_0_HIGH_ADDR);

	return (u32)((local_val & ((u32)0x0FFFFFFF)) >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_1_LOW register definition
 *  Rx Vecrtor2 register set 1 lower part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RXVEC2_L                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003D8)
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_OFFSET      0x000003D8
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_INDEX       0x000000F6
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_1_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_LOW_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_RXVEC_2_L_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_RXVEC_2_L_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_1_LOW_RXVEC_2_L_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_VECTOR_2_SET_1_LOW_RXVEC_2_L_RST    0x0

static inline u32 mac_hw_rx_vector_2_set_1_low_rxvec_2_l_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_LOW_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_1_HIGH register definition
 *  Rx Vecrtor2 register set 1 higher part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RHD_INDEX                 0x0
 *    27:00 RXVEC2_H                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003DC)
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_OFFSET      0x000003DC
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_INDEX       0x000000F7
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_1_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_HIGH_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RHD_INDEX_MASK    ((u32)0xF0000000)
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RHD_INDEX_LSB    28
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RHD_INDEX_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RXVEC_2_H_MASK    ((u32)0x0FFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RXVEC_2_H_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RXVEC_2_H_WIDTH    ((u32)0x0000001C)

#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RHD_INDEX_RST    0x0
#define MAC_HW_RX_VECTOR_2_SET_1_HIGH_RXVEC_2_H_RST    0x0

static inline void mac_hw_rx_vector_2_set_1_high_unpack(struct cl_chip *chip, u8 *rhd_index, u32 *rxvec2_h)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_HIGH_ADDR);

	*rhd_index = (local_val & ((u32)0xF0000000)) >> 28;
	*rxvec2_h = (local_val & ((u32)0x0FFFFFFF)) >> 0;
}

static inline u8 mac_hw_rx_vector_2_set_1_high_rhd_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_HIGH_ADDR);

	return (u8)((local_val & ((u32)0xF0000000)) >> 28);
}

static inline u32 mac_hw_rx_vector_2_set_1_high_rxvec_2_h_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_1_HIGH_ADDR);

	return (u32)((local_val & ((u32)0x0FFFFFFF)) >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_2_LOW register definition
 *  Rx Vecrtor2 register set 2 lower part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RXVEC2_L                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003E0)
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_OFFSET      0x000003E0
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_INDEX       0x000000F8
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_2_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_LOW_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_RXVEC_2_L_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_RXVEC_2_L_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_2_LOW_RXVEC_2_L_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_VECTOR_2_SET_2_LOW_RXVEC_2_L_RST    0x0

static inline u32 mac_hw_rx_vector_2_set_2_low_rxvec_2_l_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_LOW_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_2_HIGH register definition
 *  Rx Vecrtor2 register set 2 higher part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RHD_INDEX                 0x0
 *    27:00 RXVEC2_H                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003E4)
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_OFFSET      0x000003E4
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_INDEX       0x000000F9
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_2_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_HIGH_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RHD_INDEX_MASK    ((u32)0xF0000000)
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RHD_INDEX_LSB    28
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RHD_INDEX_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RXVEC_2_H_MASK    ((u32)0x0FFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RXVEC_2_H_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RXVEC_2_H_WIDTH    ((u32)0x0000001C)

#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RHD_INDEX_RST    0x0
#define MAC_HW_RX_VECTOR_2_SET_2_HIGH_RXVEC_2_H_RST    0x0

static inline void mac_hw_rx_vector_2_set_2_high_unpack(struct cl_chip *chip, u8 *rhd_index, u32 *rxvec2_h)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_HIGH_ADDR);

	*rhd_index = (local_val & ((u32)0xF0000000)) >> 28;
	*rxvec2_h = (local_val & ((u32)0x0FFFFFFF)) >> 0;
}

static inline u8 mac_hw_rx_vector_2_set_2_high_rhd_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_HIGH_ADDR);

	return (u8)((local_val & ((u32)0xF0000000)) >> 28);
}

static inline u32 mac_hw_rx_vector_2_set_2_high_rxvec_2_h_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_2_HIGH_ADDR);

	return (u32)((local_val & ((u32)0x0FFFFFFF)) >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_3_LOW register definition
 *  Rx Vecrtor2 register set 3 lower part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RXVEC2_L                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003E8)
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_OFFSET      0x000003E8
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_INDEX       0x000000FA
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_3_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_LOW_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_RXVEC_2_L_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_RXVEC_2_L_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_3_LOW_RXVEC_2_L_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_VECTOR_2_SET_3_LOW_RXVEC_2_L_RST    0x0

static inline u32 mac_hw_rx_vector_2_set_3_low_rxvec_2_l_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_LOW_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_VECTOR_2_SET_3_HIGH register definition
 *  Rx Vecrtor2 register set 3 higher part register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:28 RHD_INDEX                 0x0
 *    27:00 RXVEC2_H                  0x0
 * </pre>
 */
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003EC)
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_OFFSET      0x000003EC
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_INDEX       0x000000FB
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RESET       0x00000000

static inline u32 mac_hw_rx_vector_2_set_3_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_HIGH_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RHD_INDEX_MASK    ((u32)0xF0000000)
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RHD_INDEX_LSB    28
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RHD_INDEX_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RXVEC_2_H_MASK    ((u32)0x0FFFFFFF)
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RXVEC_2_H_LSB    0
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RXVEC_2_H_WIDTH    ((u32)0x0000001C)

#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RHD_INDEX_RST    0x0
#define MAC_HW_RX_VECTOR_2_SET_3_HIGH_RXVEC_2_H_RST    0x0

static inline void mac_hw_rx_vector_2_set_3_high_unpack(struct cl_chip *chip, u8 *rhd_index, u32 *rxvec2_h)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_HIGH_ADDR);

	*rhd_index = (local_val & ((u32)0xF0000000)) >> 28;
	*rxvec2_h = (local_val & ((u32)0x0FFFFFFF)) >> 0;
}

static inline u8 mac_hw_rx_vector_2_set_3_high_rhd_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_HIGH_ADDR);

	return (u8)((local_val & ((u32)0xF0000000)) >> 28);
}

static inline u32 mac_hw_rx_vector_2_set_3_high_rxvec_2_h_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_VECTOR_2_SET_3_HIGH_ADDR);

	return (u32)((local_val & ((u32)0x0FFFFFFF)) >> 0);
}

/**
 * @brief RX_MPDU_COUNT_ARRAY_0 register definition
 *  Contains the accumulated MPDU counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MPDU_COUNT_ENTRY_0        0x0
 * </pre>
 */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003F0)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_OFFSET      0x000003F0
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_INDEX       0x000000FC
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_RESET       0x00000000

static inline u32 mac_hw_rx_mpdu_count_array_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_0_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_MPDU_COUNT_ENTRY_0_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_MPDU_COUNT_ENTRY_0_LSB    0
#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_MPDU_COUNT_ENTRY_0_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MPDU_COUNT_ARRAY_0_MPDU_COUNT_ENTRY_0_RST    0x0

static inline u32 mac_hw_rx_mpdu_count_array_0_mpdu_count_entry_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_0_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_MPDU_COUNT_ARRAY_1 register definition
 *  Contains the accumulated MPDU counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MPDU_COUNT_ENTRY_1        0x0
 * </pre>
 */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003F4)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_OFFSET      0x000003F4
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_INDEX       0x000000FD
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_RESET       0x00000000

static inline u32 mac_hw_rx_mpdu_count_array_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_1_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_MPDU_COUNT_ENTRY_1_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_MPDU_COUNT_ENTRY_1_LSB    0
#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_MPDU_COUNT_ENTRY_1_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MPDU_COUNT_ARRAY_1_MPDU_COUNT_ENTRY_1_RST    0x0

static inline u32 mac_hw_rx_mpdu_count_array_1_mpdu_count_entry_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_1_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_MPDU_COUNT_ARRAY_2 register definition
 *  Contains the accumulated MPDU counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MPDU_COUNT_ENTRY_2        0x0
 * </pre>
 */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003F8)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_OFFSET      0x000003F8
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_INDEX       0x000000FE
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_RESET       0x00000000

static inline u32 mac_hw_rx_mpdu_count_array_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_2_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_MPDU_COUNT_ENTRY_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_MPDU_COUNT_ENTRY_2_LSB    0
#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_MPDU_COUNT_ENTRY_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MPDU_COUNT_ARRAY_2_MPDU_COUNT_ENTRY_2_RST    0x0

static inline u32 mac_hw_rx_mpdu_count_array_2_mpdu_count_entry_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_2_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_MPDU_COUNT_ARRAY_3 register definition
 *  Contains the accumulated MPDU counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MPDU_COUNT_ENTRY_3        0x0
 * </pre>
 */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000003FC)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_OFFSET      0x000003FC
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_INDEX       0x000000FF
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_RESET       0x00000000

static inline u32 mac_hw_rx_mpdu_count_array_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_3_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_MPDU_COUNT_ENTRY_3_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_MPDU_COUNT_ENTRY_3_LSB    0
#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_MPDU_COUNT_ENTRY_3_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MPDU_COUNT_ARRAY_3_MPDU_COUNT_ENTRY_3_RST    0x0

static inline u32 mac_hw_rx_mpdu_count_array_3_mpdu_count_entry_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ARRAY_3_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_MPDU_COUNT register definition
 *  Contains the accumulated MPDU counter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 MPDU_COUNT                0x0
 * </pre>
 */
#define MAC_HW_RX_MPDU_COUNT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000400)
#define MAC_HW_RX_MPDU_COUNT_OFFSET      0x00000400
#define MAC_HW_RX_MPDU_COUNT_INDEX       0x00000100
#define MAC_HW_RX_MPDU_COUNT_RESET       0x00000000

static inline u32 mac_hw_rx_mpdu_count_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_MPDU_COUNT_MPDU_COUNT_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_MPDU_COUNT_MPDU_COUNT_LSB    0
#define MAC_HW_RX_MPDU_COUNT_MPDU_COUNT_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_MPDU_COUNT_MPDU_COUNT_RST    0x0

static inline u32 mac_hw_rx_mpdu_count_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_MPDU_COUNT_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_RV_2_INDEX register definition
 *  Contains RV2 index register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    03:00 RV2_INDEX                 0x0
 * </pre>
 */
#define MAC_HW_RX_RV_2_INDEX_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000404)
#define MAC_HW_RX_RV_2_INDEX_OFFSET      0x00000404
#define MAC_HW_RX_RV_2_INDEX_INDEX       0x00000101
#define MAC_HW_RX_RV_2_INDEX_RESET       0x00000000

static inline u32 mac_hw_rx_rv_2_index_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_RV_2_INDEX_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_RV_2_INDEX_RV_2_INDEX_MASK    ((u32)0x0000000F)
#define MAC_HW_RX_RV_2_INDEX_RV_2_INDEX_LSB    0
#define MAC_HW_RX_RV_2_INDEX_RV_2_INDEX_WIDTH    ((u32)0x00000004)

#define MAC_HW_RX_RV_2_INDEX_RV_2_INDEX_RST    0x0

static inline u8 mac_hw_rx_rv_2_index_rv_2_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_RV_2_INDEX_ADDR);

	return (u8)(local_val >> 0);
}

/**
 * @brief INTRA_BSS_NAV_BUSY register definition
 *  Count intra BSS NAV busy period register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INTRA_BSS_NAV_BUSY_DUR    0x0
 * </pre>
 */
#define MAC_HW_INTRA_BSS_NAV_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000408)
#define MAC_HW_INTRA_BSS_NAV_BUSY_OFFSET      0x00000408
#define MAC_HW_INTRA_BSS_NAV_BUSY_INDEX       0x00000102
#define MAC_HW_INTRA_BSS_NAV_BUSY_RESET       0x00000000

static inline u32 mac_hw_intra_bss_nav_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_BUSY_ADDR);
}

/* Field definitions */
#define MAC_HW_INTRA_BSS_NAV_BUSY_INTRA_BSS_NAV_BUSY_DUR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_INTRA_BSS_NAV_BUSY_INTRA_BSS_NAV_BUSY_DUR_LSB    0
#define MAC_HW_INTRA_BSS_NAV_BUSY_INTRA_BSS_NAV_BUSY_DUR_WIDTH    ((u32)0x00000020)

#define MAC_HW_INTRA_BSS_NAV_BUSY_INTRA_BSS_NAV_BUSY_DUR_RST    0x0

static inline u32 mac_hw_intra_bss_nav_busy_intra_bss_nav_busy_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief INTER_BSS_NAV_BUSY register definition
 *  Count inter BSS NAV busy period register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INTER_BSS_NAV_BUSY_DUR    0x0
 * </pre>
 */
#define MAC_HW_INTER_BSS_NAV_BUSY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000040C)
#define MAC_HW_INTER_BSS_NAV_BUSY_OFFSET      0x0000040C
#define MAC_HW_INTER_BSS_NAV_BUSY_INDEX       0x00000103
#define MAC_HW_INTER_BSS_NAV_BUSY_RESET       0x00000000

static inline u32 mac_hw_inter_bss_nav_busy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_INTER_BSS_NAV_BUSY_ADDR);
}

/* Field definitions */
#define MAC_HW_INTER_BSS_NAV_BUSY_INTER_BSS_NAV_BUSY_DUR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_INTER_BSS_NAV_BUSY_INTER_BSS_NAV_BUSY_DUR_LSB    0
#define MAC_HW_INTER_BSS_NAV_BUSY_INTER_BSS_NAV_BUSY_DUR_WIDTH    ((u32)0x00000020)

#define MAC_HW_INTER_BSS_NAV_BUSY_INTER_BSS_NAV_BUSY_DUR_RST    0x0

static inline u32 mac_hw_inter_bss_nav_busy_inter_bss_nav_busy_dur_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_INTER_BSS_NAV_BUSY_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief INTRA_BSS_NAV_VALUE register definition
 *  Reflect the current NAV count register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25:00 NAV_COUNTER               0x0
 * </pre>
 */
#define MAC_HW_INTRA_BSS_NAV_VALUE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000410)
#define MAC_HW_INTRA_BSS_NAV_VALUE_OFFSET      0x00000410
#define MAC_HW_INTRA_BSS_NAV_VALUE_INDEX       0x00000104
#define MAC_HW_INTRA_BSS_NAV_VALUE_RESET       0x00000000

static inline u32 mac_hw_intra_bss_nav_value_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_VALUE_ADDR);
}

/* Field definitions */
#define MAC_HW_INTRA_BSS_NAV_VALUE_NAV_COUNTER_MASK    ((u32)0x03FFFFFF)
#define MAC_HW_INTRA_BSS_NAV_VALUE_NAV_COUNTER_LSB    0
#define MAC_HW_INTRA_BSS_NAV_VALUE_NAV_COUNTER_WIDTH    ((u32)0x0000001A)

#define MAC_HW_INTRA_BSS_NAV_VALUE_NAV_COUNTER_RST    0x0

static inline u32 mac_hw_intra_bss_nav_value_nav_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_VALUE_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_INTRA_BSS_TXOP_HOLDER_LOW register definition
 *  Contains the low part of the intra BSS TXOP holder register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TXOP_HOLDER_LOW           0x0
 * </pre>
 */
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000414)
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_OFFSET      0x00000414
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_INDEX       0x00000105
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_RESET       0x00000000

static inline u32 mac_hw_debug_intra_bss_txop_holder_low_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_TXOP_HOLDER_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_TXOP_HOLDER_LOW_LSB    0
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_TXOP_HOLDER_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_TXOP_HOLDER_LOW_RST    0x0

static inline u32 mac_hw_debug_intra_bss_txop_holder_low_txop_holder_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_LOW_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH register definition
 *  Contains the hi part of the intra BSS TXOP holder register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 TXOP_HOLDER_HIGH          0x0
 * </pre>
 */
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000418)
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_OFFSET      0x00000418
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_INDEX       0x00000106
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_RESET       0x00000000

static inline u32 mac_hw_debug_intra_bss_txop_holder_high_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_TXOP_HOLDER_HIGH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_TXOP_HOLDER_HIGH_LSB    0
#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_TXOP_HOLDER_HIGH_WIDTH    ((u32)0x00000010)

#define MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_TXOP_HOLDER_HIGH_RST    0x0

static inline u16 mac_hw_debug_intra_bss_txop_holder_high_txop_holder_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_INTRA_BSS_TXOP_HOLDER_HIGH_ADDR);

	return (u16)(local_val >> 0);
}

/**
 * @brief INTRA_BSS_NAV_LIMIT register definition
 *  Control intra BSS NAV limit register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 NAV_LIMIT                 0x0
 * </pre>
 */
#define MAC_HW_INTRA_BSS_NAV_LIMIT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000041C)
#define MAC_HW_INTRA_BSS_NAV_LIMIT_OFFSET      0x0000041C
#define MAC_HW_INTRA_BSS_NAV_LIMIT_INDEX       0x00000107
#define MAC_HW_INTRA_BSS_NAV_LIMIT_RESET       0x00000000

static inline u32 mac_hw_intra_bss_nav_limit_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_LIMIT_ADDR);
}

static inline void mac_hw_intra_bss_nav_limit_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_INTRA_BSS_NAV_LIMIT_ADDR, value);
}

/* Field definitions */
#define MAC_HW_INTRA_BSS_NAV_LIMIT_NAV_LIMIT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_INTRA_BSS_NAV_LIMIT_NAV_LIMIT_LSB    0
#define MAC_HW_INTRA_BSS_NAV_LIMIT_NAV_LIMIT_WIDTH    ((u32)0x00000010)

#define MAC_HW_INTRA_BSS_NAV_LIMIT_NAV_LIMIT_RST    0x0

static inline u16 mac_hw_intra_bss_nav_limit_nav_limit_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_LIMIT_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_intra_bss_nav_limit_nav_limit_setf(struct cl_chip *chip, u16 navlimit)
{
	ASSERT_ERR_CHIP((((u32)navlimit << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_INTRA_BSS_NAV_LIMIT_ADDR, (u32)navlimit << 0);
}

/**
 * @brief INTRA_BSS_NAV_OVERRIDE register definition
 *  Contains intra BSS NAV override value register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 NAV_VALUE_SET             0x0
 * </pre>
 */
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000420)
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_OFFSET      0x00000420
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_INDEX       0x00000108
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_RESET       0x00000000

static inline u32 mac_hw_intra_bss_nav_override_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_OVERRIDE_ADDR);
}

static inline void mac_hw_intra_bss_nav_override_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_INTRA_BSS_NAV_OVERRIDE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_NAV_VALUE_SET_MASK    ((u32)0x0000FFFF)
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_NAV_VALUE_SET_LSB    0
#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_NAV_VALUE_SET_WIDTH    ((u32)0x00000010)

#define MAC_HW_INTRA_BSS_NAV_OVERRIDE_NAV_VALUE_SET_RST    0x0

static inline u16 mac_hw_intra_bss_nav_override_nav_value_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_INTRA_BSS_NAV_OVERRIDE_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_intra_bss_nav_override_nav_value_set_setf(struct cl_chip *chip, u16 navvalueset)
{
	ASSERT_ERR_CHIP((((u32)navvalueset << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_INTRA_BSS_NAV_OVERRIDE_ADDR, (u32)navvalueset << 0);
}

/**
 * @brief DUAL_NAV_CONFIG register definition
 *  Dual NAV configuration register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    22    consider_intra_nav_for_cts 0
 *    21    consider_intra_nav_for_he_trigger 0
 *    20    consider_intra_nav_for_backoff 1
 *    18    consider_basic_nav_for_cts 1
 *    17    consider_basic_nav_for_he_trigger 1
 *    16    consider_basic_nav_for_backoff 1
 *    13    Ignore_classify_intra_rule_5 0
 *    12    Ignore_classify_intra_rule_4 0
 *    11    Ignore_classify_intra_rule_3 0
 *    10    Ignore_classify_intra_rule_2 0
 *    09    Ignore_classify_intra_rule_1 0
 *    06    Ignore_classify_inter_rule_6 0
 *    05    Ignore_classify_inter_rule_5 0
 *    04    Ignore_classify_inter_rule_4 0
 *    03    Ignore_classify_inter_rule_3 0
 *    02    Ignore_classify_inter_rule_2 0
 *    01    Ignore_classify_inter_rule_1 0
 * </pre>
 */
#define MAC_HW_DUAL_NAV_CONFIG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000424)
#define MAC_HW_DUAL_NAV_CONFIG_OFFSET      0x00000424
#define MAC_HW_DUAL_NAV_CONFIG_INDEX       0x00000109
#define MAC_HW_DUAL_NAV_CONFIG_RESET       0x00170000

static inline u32 mac_hw_dual_nav_config_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);
}

static inline void mac_hw_dual_nav_config_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_CTS_BIT    ((u32)0x00400000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_CTS_POS    22
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_HE_TRIGGER_BIT    ((u32)0x00200000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_HE_TRIGGER_POS    21
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_BACKOFF_BIT    ((u32)0x00100000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_BACKOFF_POS    20
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_CTS_BIT    ((u32)0x00040000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_CTS_POS    18
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_HE_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_HE_TRIGGER_POS    17
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_BACKOFF_BIT    ((u32)0x00010000)
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_BACKOFF_POS    16
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_5_BIT    ((u32)0x00002000)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_5_POS    13
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_4_BIT    ((u32)0x00001000)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_4_POS    12
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_3_BIT    ((u32)0x00000800)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_3_POS    11
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_2_BIT    ((u32)0x00000400)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_2_POS    10
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_1_BIT    ((u32)0x00000200)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_1_POS    9
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_6_BIT    ((u32)0x00000040)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_6_POS    6
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_5_POS    5
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_4_POS    4
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_3_POS    3
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_2_POS    2
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_1_POS    1

#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_CTS_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_HE_TRIGGER_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_INTRA_NAV_FOR_BACKOFF_RST    0x1
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_CTS_RST    0x1
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_HE_TRIGGER_RST    0x1
#define MAC_HW_DUAL_NAV_CONFIG_CONSIDER_BASIC_NAV_FOR_BACKOFF_RST    0x1
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_5_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_4_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_3_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_2_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTRA_RULE_1_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_6_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_5_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_4_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_3_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_2_RST    0x0
#define MAC_HW_DUAL_NAV_CONFIG_IGNORE_CLASSIFY_INTER_RULE_1_RST    0x0

static inline void mac_hw_dual_nav_config_pack(struct cl_chip *chip, u8 consider_intra_nav_for_cts, u8 consider_intra_nav_for_he_trigger, u8 consider_intra_nav_for_backoff, u8 consider_basic_nav_for_cts, u8 consider_basic_nav_for_he_trigger, u8 consider_basic_nav_for_backoff, u8 ignore_classify_intra_rule_5, u8 ignore_classify_intra_rule_4, u8 ignore_classify_intra_rule_3, u8 ignore_classify_intra_rule_2, u8 ignore_classify_intra_rule_1, u8 ignore_classify_inter_rule_6, u8 ignore_classify_inter_rule_5, u8 ignore_classify_inter_rule_4, u8 ignore_classify_inter_rule_3, u8 ignore_classify_inter_rule_2, u8 ignore_classify_inter_rule_1)
{
	ASSERT_ERR_CHIP((((u32)consider_intra_nav_for_cts << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)consider_intra_nav_for_he_trigger << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)consider_intra_nav_for_backoff << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)consider_basic_nav_for_cts << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)consider_basic_nav_for_he_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)consider_basic_nav_for_backoff << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_intra_rule_5 << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_intra_rule_4 << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_intra_rule_3 << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_intra_rule_2 << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_intra_rule_1 << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_6 << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ignore_classify_inter_rule_1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, ((u32)consider_intra_nav_for_cts << 22) | ((u32)consider_intra_nav_for_he_trigger << 21) | ((u32)consider_intra_nav_for_backoff << 20) | ((u32)consider_basic_nav_for_cts << 18) | ((u32)consider_basic_nav_for_he_trigger << 17) | ((u32)consider_basic_nav_for_backoff << 16) | ((u32)ignore_classify_intra_rule_5 << 13) | ((u32)ignore_classify_intra_rule_4 << 12) | ((u32)ignore_classify_intra_rule_3 << 11) | ((u32)ignore_classify_intra_rule_2 << 10) | ((u32)ignore_classify_intra_rule_1 << 9) | ((u32)ignore_classify_inter_rule_6 << 6) | ((u32)ignore_classify_inter_rule_5 << 5) | ((u32)ignore_classify_inter_rule_4 << 4) | ((u32)ignore_classify_inter_rule_3 << 3) | ((u32)ignore_classify_inter_rule_2 << 2) | ((u32)ignore_classify_inter_rule_1 << 1));
}

static inline void mac_hw_dual_nav_config_unpack(struct cl_chip *chip, u8 *consider_intra_nav_for_cts, u8 *consider_intra_nav_for_he_trigger, u8 *consider_intra_nav_for_backoff, u8 *consider_basic_nav_for_cts, u8 *consider_basic_nav_for_he_trigger, u8 *consider_basic_nav_for_backoff, u8 *ignore_classify_intra_rule_5, u8 *ignore_classify_intra_rule_4, u8 *ignore_classify_intra_rule_3, u8 *ignore_classify_intra_rule_2, u8 *ignore_classify_intra_rule_1, u8 *ignore_classify_inter_rule_6, u8 *ignore_classify_inter_rule_5, u8 *ignore_classify_inter_rule_4, u8 *ignore_classify_inter_rule_3, u8 *ignore_classify_inter_rule_2, u8 *ignore_classify_inter_rule_1)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	*consider_intra_nav_for_cts = (local_val & ((u32)0x00400000)) >> 22;
	*consider_intra_nav_for_he_trigger = (local_val & ((u32)0x00200000)) >> 21;
	*consider_intra_nav_for_backoff = (local_val & ((u32)0x00100000)) >> 20;
	*consider_basic_nav_for_cts = (local_val & ((u32)0x00040000)) >> 18;
	*consider_basic_nav_for_he_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*consider_basic_nav_for_backoff = (local_val & ((u32)0x00010000)) >> 16;
	*ignore_classify_intra_rule_5 = (local_val & ((u32)0x00002000)) >> 13;
	*ignore_classify_intra_rule_4 = (local_val & ((u32)0x00001000)) >> 12;
	*ignore_classify_intra_rule_3 = (local_val & ((u32)0x00000800)) >> 11;
	*ignore_classify_intra_rule_2 = (local_val & ((u32)0x00000400)) >> 10;
	*ignore_classify_intra_rule_1 = (local_val & ((u32)0x00000200)) >> 9;
	*ignore_classify_inter_rule_6 = (local_val & ((u32)0x00000040)) >> 6;
	*ignore_classify_inter_rule_5 = (local_val & ((u32)0x00000020)) >> 5;
	*ignore_classify_inter_rule_4 = (local_val & ((u32)0x00000010)) >> 4;
	*ignore_classify_inter_rule_3 = (local_val & ((u32)0x00000008)) >> 3;
	*ignore_classify_inter_rule_2 = (local_val & ((u32)0x00000004)) >> 2;
	*ignore_classify_inter_rule_1 = (local_val & ((u32)0x00000002)) >> 1;
}

static inline u8 mac_hw_dual_nav_config_consider_intra_nav_for_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_dual_nav_config_consider_intra_nav_for_cts_setf(struct cl_chip *chip, u8 considerintranavforcts)
{
	ASSERT_ERR_CHIP((((u32)considerintranavforcts << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00400000)) | ((u32)considerintranavforcts << 22));
}

static inline u8 mac_hw_dual_nav_config_consider_intra_nav_for_he_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_dual_nav_config_consider_intra_nav_for_he_trigger_setf(struct cl_chip *chip, u8 considerintranavforhetrigger)
{
	ASSERT_ERR_CHIP((((u32)considerintranavforhetrigger << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00200000)) | ((u32)considerintranavforhetrigger << 21));
}

static inline u8 mac_hw_dual_nav_config_consider_intra_nav_for_backoff_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_dual_nav_config_consider_intra_nav_for_backoff_setf(struct cl_chip *chip, u8 considerintranavforbackoff)
{
	ASSERT_ERR_CHIP((((u32)considerintranavforbackoff << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00100000)) | ((u32)considerintranavforbackoff << 20));
}

static inline u8 mac_hw_dual_nav_config_consider_basic_nav_for_cts_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_dual_nav_config_consider_basic_nav_for_cts_setf(struct cl_chip *chip, u8 considerbasicnavforcts)
{
	ASSERT_ERR_CHIP((((u32)considerbasicnavforcts << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00040000)) | ((u32)considerbasicnavforcts << 18));
}

static inline u8 mac_hw_dual_nav_config_consider_basic_nav_for_he_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_dual_nav_config_consider_basic_nav_for_he_trigger_setf(struct cl_chip *chip, u8 considerbasicnavforhetrigger)
{
	ASSERT_ERR_CHIP((((u32)considerbasicnavforhetrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00020000)) | ((u32)considerbasicnavforhetrigger << 17));
}

static inline u8 mac_hw_dual_nav_config_consider_basic_nav_for_backoff_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_dual_nav_config_consider_basic_nav_for_backoff_setf(struct cl_chip *chip, u8 considerbasicnavforbackoff)
{
	ASSERT_ERR_CHIP((((u32)considerbasicnavforbackoff << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00010000)) | ((u32)considerbasicnavforbackoff << 16));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_intra_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_dual_nav_config_ignore_classify_intra_rule_5_setf(struct cl_chip *chip, u8 ignoreclassifyintrarule5)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyintrarule5 << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00002000)) | ((u32)ignoreclassifyintrarule5 << 13));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_intra_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_dual_nav_config_ignore_classify_intra_rule_4_setf(struct cl_chip *chip, u8 ignoreclassifyintrarule4)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyintrarule4 << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00001000)) | ((u32)ignoreclassifyintrarule4 << 12));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_intra_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_dual_nav_config_ignore_classify_intra_rule_3_setf(struct cl_chip *chip, u8 ignoreclassifyintrarule3)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyintrarule3 << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000800)) | ((u32)ignoreclassifyintrarule3 << 11));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_intra_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_dual_nav_config_ignore_classify_intra_rule_2_setf(struct cl_chip *chip, u8 ignoreclassifyintrarule2)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyintrarule2 << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000400)) | ((u32)ignoreclassifyintrarule2 << 10));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_intra_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_dual_nav_config_ignore_classify_intra_rule_1_setf(struct cl_chip *chip, u8 ignoreclassifyintrarule1)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyintrarule1 << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000200)) | ((u32)ignoreclassifyintrarule1 << 9));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_6_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule6)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule6 << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000040)) | ((u32)ignoreclassifyinterrule6 << 6));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_5_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule5)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000020)) | ((u32)ignoreclassifyinterrule5 << 5));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_4_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule4)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000010)) | ((u32)ignoreclassifyinterrule4 << 4));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_3_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule3)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000008)) | ((u32)ignoreclassifyinterrule3 << 3));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_2_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule2)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000004)) | ((u32)ignoreclassifyinterrule2 << 2));
}

static inline u8 mac_hw_dual_nav_config_ignore_classify_inter_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_dual_nav_config_ignore_classify_inter_rule_1_setf(struct cl_chip *chip, u8 ignoreclassifyinterrule1)
{
	ASSERT_ERR_CHIP((((u32)ignoreclassifyinterrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_DUAL_NAV_CONFIG_ADDR) & ~((u32)0x00000002)) | ((u32)ignoreclassifyinterrule1 << 1));
}

/**
 * @brief GCMP_CONTROL register definition
 *  Controls max number of contexts register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    num_Ctx_In_Tx_SWValid     0
 *    30    num_Ctx_In_Rx_SWValid     0
 *    06:04 num_Ctx_In_Tx_SW          0x0
 *    02:00 num_Ctx_In_Rx_SW          0x0
 * </pre>
 */
#define MAC_HW_GCMP_CONTROL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000428)
#define MAC_HW_GCMP_CONTROL_OFFSET      0x00000428
#define MAC_HW_GCMP_CONTROL_INDEX       0x0000010A
#define MAC_HW_GCMP_CONTROL_RESET       0x00000000

static inline u32 mac_hw_gcmp_control_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);
}

static inline void mac_hw_gcmp_control_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SWVALID_BIT    ((u32)0x80000000)
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SWVALID_POS    31
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SWVALID_BIT    ((u32)0x40000000)
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SWVALID_POS    30
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SW_MASK    ((u32)0x00000070)
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SW_LSB    4
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SW_WIDTH    ((u32)0x00000003)
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SW_MASK    ((u32)0x00000007)
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SW_LSB    0
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SW_WIDTH    ((u32)0x00000003)

#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SWVALID_RST    0x0
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SWVALID_RST    0x0
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_TX_SW_RST    0x0
#define MAC_HW_GCMP_CONTROL_NUM_CTX_IN_RX_SW_RST    0x0

static inline void mac_hw_gcmp_control_pack(struct cl_chip *chip, u8 num_ctx_in_tx_swvalid, u8 num_ctx_in_rx_swvalid, u8 num_ctx_in_tx_sw, u8 num_ctx_in_rx_sw)
{
	ASSERT_ERR_CHIP((((u32)num_ctx_in_tx_swvalid << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)num_ctx_in_rx_swvalid << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)num_ctx_in_tx_sw << 4) & ~((u32)0x00000070)) == 0);
	ASSERT_ERR_CHIP((((u32)num_ctx_in_rx_sw << 0) & ~((u32)0x00000007)) == 0);
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, ((u32)num_ctx_in_tx_swvalid << 31) | ((u32)num_ctx_in_rx_swvalid << 30) | ((u32)num_ctx_in_tx_sw << 4) | ((u32)num_ctx_in_rx_sw << 0));
}

static inline void mac_hw_gcmp_control_unpack(struct cl_chip *chip, u8 *num_ctx_in_tx_swvalid, u8 *num_ctx_in_rx_swvalid, u8 *num_ctx_in_tx_sw, u8 *num_ctx_in_rx_sw)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);

	*num_ctx_in_tx_swvalid = (local_val & ((u32)0x80000000)) >> 31;
	*num_ctx_in_rx_swvalid = (local_val & ((u32)0x40000000)) >> 30;
	*num_ctx_in_tx_sw = (local_val & ((u32)0x00000070)) >> 4;
	*num_ctx_in_rx_sw = (local_val & ((u32)0x00000007)) >> 0;
}

static inline u8 mac_hw_gcmp_control_num_ctx_in_tx_swvalid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_gcmp_control_num_ctx_in_tx_swvalid_setf(struct cl_chip *chip, u8 numctxintxswvalid)
{
	ASSERT_ERR_CHIP((((u32)numctxintxswvalid << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR) & ~((u32)0x80000000)) | ((u32)numctxintxswvalid << 31));
}

static inline u8 mac_hw_gcmp_control_num_ctx_in_rx_swvalid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_gcmp_control_num_ctx_in_rx_swvalid_setf(struct cl_chip *chip, u8 numctxinrxswvalid)
{
	ASSERT_ERR_CHIP((((u32)numctxinrxswvalid << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR) & ~((u32)0x40000000)) | ((u32)numctxinrxswvalid << 30));
}

static inline u8 mac_hw_gcmp_control_num_ctx_in_tx_sw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x00000070)) >> 4);
}

static inline void mac_hw_gcmp_control_num_ctx_in_tx_sw_setf(struct cl_chip *chip, u8 numctxintxsw)
{
	ASSERT_ERR_CHIP((((u32)numctxintxsw << 4) & ~((u32)0x00000070)) == 0);
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR) & ~((u32)0x00000070)) | ((u32)numctxintxsw << 4));
}

static inline u8 mac_hw_gcmp_control_num_ctx_in_rx_sw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x00000007)) >> 0);
}

static inline void mac_hw_gcmp_control_num_ctx_in_rx_sw_setf(struct cl_chip *chip, u8 numctxinrxsw)
{
	ASSERT_ERR_CHIP((((u32)numctxinrxsw << 0) & ~((u32)0x00000007)) == 0);
	cl_reg_write(chip, MAC_HW_GCMP_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_GCMP_CONTROL_ADDR) & ~((u32)0x00000007)) | ((u32)numctxinrxsw << 0));
}

/**
 * @brief RX_EVENT_COUNT_1_ARRAY_0 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 INCORRECT_RECIEVED_MPDU_COUNT 0x0
 *    19:10 CORRECT_RECIEVED_MPDU_COUNT 0x0
 *    09:00 DISCARDED_MPDU_COUNT      0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000440)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_OFFSET      0x00000440
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_INDEX       0x00000110
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_1_array_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_INCORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x3FF00000)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_INCORRECT_RECIEVED_MPDU_COUNT_LSB    20
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_INCORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_CORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x000FFC00)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_CORRECT_RECIEVED_MPDU_COUNT_LSB    10
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_CORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_DISCARDED_MPDU_COUNT_MASK    ((u32)0x000003FF)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)

#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_INCORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_CORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_1_array_0_unpack(struct cl_chip *chip, u16 *incorrect_recieved_mpdu_count, u16 *correct_recieved_mpdu_count, u16 *discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR);

	*incorrect_recieved_mpdu_count = (local_val & ((u32)0x3FF00000)) >> 20;
	*correct_recieved_mpdu_count = (local_val & ((u32)0x000FFC00)) >> 10;
	*discarded_mpdu_count = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_1_array_0_incorrect_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline u16 mac_hw_rx_event_count_1_array_0_correct_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline u16 mac_hw_rx_event_count_1_array_0_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_0_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_2_ARRAY_0 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 INCORRECT_DELIMITER_COUNT 0x0
 *    15:00 RX_DISCARDED_MPDU_COUNT   0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000444)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_OFFSET      0x00000444
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_INDEX       0x00000111
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_2_array_0_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_INCORRECT_DELIMITER_COUNT_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_INCORRECT_DELIMITER_COUNT_LSB    16
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_INCORRECT_DELIMITER_COUNT_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_RX_DISCARDED_MPDU_COUNT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_RX_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_RX_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_INCORRECT_DELIMITER_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_RX_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_2_array_0_unpack(struct cl_chip *chip, u16 *incorrect_delimiter_count, u16 *rx_discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_ADDR);

	*incorrect_delimiter_count = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_discarded_mpdu_count = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_2_array_0_incorrect_delimiter_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_rx_event_count_2_array_0_rx_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_0_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_1_ARRAY_1 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 INCORRECT_RECIEVED_MPDU_COUNT 0x0
 *    19:10 CORRECT_RECIEVED_MPDU_COUNT 0x0
 *    09:00 DISCARDED_MPDU_COUNT      0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000448)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_OFFSET      0x00000448
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_INDEX       0x00000112
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_1_array_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_INCORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x3FF00000)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_INCORRECT_RECIEVED_MPDU_COUNT_LSB    20
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_INCORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_CORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x000FFC00)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_CORRECT_RECIEVED_MPDU_COUNT_LSB    10
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_CORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_DISCARDED_MPDU_COUNT_MASK    ((u32)0x000003FF)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)

#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_INCORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_CORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_1_array_1_unpack(struct cl_chip *chip, u16 *incorrect_recieved_mpdu_count, u16 *correct_recieved_mpdu_count, u16 *discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR);

	*incorrect_recieved_mpdu_count = (local_val & ((u32)0x3FF00000)) >> 20;
	*correct_recieved_mpdu_count = (local_val & ((u32)0x000FFC00)) >> 10;
	*discarded_mpdu_count = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_1_array_1_incorrect_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline u16 mac_hw_rx_event_count_1_array_1_correct_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline u16 mac_hw_rx_event_count_1_array_1_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_1_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_2_ARRAY_1 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 INCORRECT_DELIMITER_COUNT 0x0
 *    15:00 RX_DISCARDED_MPDU_COUNT   0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000044C)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_OFFSET      0x0000044C
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_INDEX       0x00000113
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_2_array_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_INCORRECT_DELIMITER_COUNT_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_INCORRECT_DELIMITER_COUNT_LSB    16
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_INCORRECT_DELIMITER_COUNT_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_RX_DISCARDED_MPDU_COUNT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_RX_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_RX_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_INCORRECT_DELIMITER_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_RX_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_2_array_1_unpack(struct cl_chip *chip, u16 *incorrect_delimiter_count, u16 *rx_discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_ADDR);

	*incorrect_delimiter_count = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_discarded_mpdu_count = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_2_array_1_incorrect_delimiter_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_rx_event_count_2_array_1_rx_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_1_ARRAY_2 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 INCORRECT_RECIEVED_MPDU_COUNT 0x0
 *    19:10 CORRECT_RECIEVED_MPDU_COUNT 0x0
 *    09:00 DISCARDED_MPDU_COUNT      0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000450)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_OFFSET      0x00000450
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_INDEX       0x00000114
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_1_array_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_INCORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x3FF00000)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_INCORRECT_RECIEVED_MPDU_COUNT_LSB    20
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_INCORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_CORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x000FFC00)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_CORRECT_RECIEVED_MPDU_COUNT_LSB    10
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_CORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_DISCARDED_MPDU_COUNT_MASK    ((u32)0x000003FF)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)

#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_INCORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_CORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_1_array_2_unpack(struct cl_chip *chip, u16 *incorrect_recieved_mpdu_count, u16 *correct_recieved_mpdu_count, u16 *discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR);

	*incorrect_recieved_mpdu_count = (local_val & ((u32)0x3FF00000)) >> 20;
	*correct_recieved_mpdu_count = (local_val & ((u32)0x000FFC00)) >> 10;
	*discarded_mpdu_count = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_1_array_2_incorrect_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline u16 mac_hw_rx_event_count_1_array_2_correct_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline u16 mac_hw_rx_event_count_1_array_2_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_2_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_2_ARRAY_2 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 INCORRECT_DELIMITER_COUNT 0x0
 *    15:00 RX_DISCARDED_MPDU_COUNT   0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000454)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_OFFSET      0x00000454
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_INDEX       0x00000115
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_2_array_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_INCORRECT_DELIMITER_COUNT_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_INCORRECT_DELIMITER_COUNT_LSB    16
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_INCORRECT_DELIMITER_COUNT_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_RX_DISCARDED_MPDU_COUNT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_RX_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_RX_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_INCORRECT_DELIMITER_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_RX_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_2_array_2_unpack(struct cl_chip *chip, u16 *incorrect_delimiter_count, u16 *rx_discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_ADDR);

	*incorrect_delimiter_count = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_discarded_mpdu_count = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_2_array_2_incorrect_delimiter_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_rx_event_count_2_array_2_rx_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_2_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_1_ARRAY_3 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:20 INCORRECT_RECIEVED_MPDU_COUNT 0x0
 *    19:10 CORRECT_RECIEVED_MPDU_COUNT 0x0
 *    09:00 DISCARDED_MPDU_COUNT      0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000458)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_OFFSET      0x00000458
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_INDEX       0x00000116
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_1_array_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_INCORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x3FF00000)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_INCORRECT_RECIEVED_MPDU_COUNT_LSB    20
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_INCORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_CORRECT_RECIEVED_MPDU_COUNT_MASK    ((u32)0x000FFC00)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_CORRECT_RECIEVED_MPDU_COUNT_LSB    10
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_CORRECT_RECIEVED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_DISCARDED_MPDU_COUNT_MASK    ((u32)0x000003FF)
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x0000000A)

#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_INCORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_CORRECT_RECIEVED_MPDU_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_1_array_3_unpack(struct cl_chip *chip, u16 *incorrect_recieved_mpdu_count, u16 *correct_recieved_mpdu_count, u16 *discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR);

	*incorrect_recieved_mpdu_count = (local_val & ((u32)0x3FF00000)) >> 20;
	*correct_recieved_mpdu_count = (local_val & ((u32)0x000FFC00)) >> 10;
	*discarded_mpdu_count = (local_val & ((u32)0x000003FF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_1_array_3_incorrect_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR);

	return (u16)((local_val & ((u32)0x3FF00000)) >> 20);
}

static inline u16 mac_hw_rx_event_count_1_array_3_correct_recieved_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR);

	return (u16)((local_val & ((u32)0x000FFC00)) >> 10);
}

static inline u16 mac_hw_rx_event_count_1_array_3_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_1_ARRAY_3_ADDR);

	return (u16)((local_val & ((u32)0x000003FF)) >> 0);
}

/**
 * @brief RX_EVENT_COUNT_2_ARRAY_3 register definition
 *  Contains per PPDU statistics counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 INCORRECT_DELIMITER_COUNT 0x0
 *    15:00 RX_DISCARDED_MPDU_COUNT   0x0
 * </pre>
 */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000045C)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_OFFSET      0x0000045C
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_INDEX       0x00000117
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_RESET       0x00000000

static inline u32 mac_hw_rx_event_count_2_array_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_INCORRECT_DELIMITER_COUNT_MASK    ((u32)0xFFFF0000)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_INCORRECT_DELIMITER_COUNT_LSB    16
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_INCORRECT_DELIMITER_COUNT_WIDTH    ((u32)0x00000010)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_RX_DISCARDED_MPDU_COUNT_MASK    ((u32)0x0000FFFF)
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_RX_DISCARDED_MPDU_COUNT_LSB    0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_RX_DISCARDED_MPDU_COUNT_WIDTH    ((u32)0x00000010)

#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_INCORRECT_DELIMITER_COUNT_RST    0x0
#define MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_RX_DISCARDED_MPDU_COUNT_RST    0x0

static inline void mac_hw_rx_event_count_2_array_3_unpack(struct cl_chip *chip, u16 *incorrect_delimiter_count, u16 *rx_discarded_mpdu_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_ADDR);

	*incorrect_delimiter_count = (local_val & ((u32)0xFFFF0000)) >> 16;
	*rx_discarded_mpdu_count = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_rx_event_count_2_array_3_incorrect_delimiter_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_rx_event_count_2_array_3_rx_discarded_mpdu_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_EVENT_COUNT_2_ARRAY_3_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief DEBUG_HWSM_1 register definition
 *  Used to observe the MAC HW state machines. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30:24 MAC_CONTROL_LS            0x0
 *    16:08 TX_CONTROL_LS             0x0
 *    04:00 RX_CONTROL_LS             0x0
 * </pre>
 */
#define MAC_HW_DEBUG_HWSM_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000500)
#define MAC_HW_DEBUG_HWSM_1_OFFSET      0x00000500
#define MAC_HW_DEBUG_HWSM_1_INDEX       0x00000140
#define MAC_HW_DEBUG_HWSM_1_RESET       0x00000000

static inline u32 mac_hw_debug_hwsm_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_HWSM_1_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_HWSM_1_MAC_CONTROL_LS_MASK    ((u32)0x7F000000)
#define MAC_HW_DEBUG_HWSM_1_MAC_CONTROL_LS_LSB    24
#define MAC_HW_DEBUG_HWSM_1_MAC_CONTROL_LS_WIDTH    ((u32)0x00000007)
#define MAC_HW_DEBUG_HWSM_1_TX_CONTROL_LS_MASK    ((u32)0x0001FF00)
#define MAC_HW_DEBUG_HWSM_1_TX_CONTROL_LS_LSB    8
#define MAC_HW_DEBUG_HWSM_1_TX_CONTROL_LS_WIDTH    ((u32)0x00000009)
#define MAC_HW_DEBUG_HWSM_1_RX_CONTROL_LS_MASK    ((u32)0x0000001F)
#define MAC_HW_DEBUG_HWSM_1_RX_CONTROL_LS_LSB    0
#define MAC_HW_DEBUG_HWSM_1_RX_CONTROL_LS_WIDTH    ((u32)0x00000005)

#define MAC_HW_DEBUG_HWSM_1_MAC_CONTROL_LS_RST    0x0
#define MAC_HW_DEBUG_HWSM_1_TX_CONTROL_LS_RST    0x0
#define MAC_HW_DEBUG_HWSM_1_RX_CONTROL_LS_RST    0x0

static inline void mac_hw_debug_hwsm_1_unpack(struct cl_chip *chip, u8 *mac_control_ls, u16 *tx_control_ls, u8 *rx_control_ls)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_1_ADDR);

	*mac_control_ls = (local_val & ((u32)0x7F000000)) >> 24;
	*tx_control_ls = (local_val & ((u32)0x0001FF00)) >> 8;
	*rx_control_ls = (local_val & ((u32)0x0000001F)) >> 0;
}

static inline u8 mac_hw_debug_hwsm_1_mac_control_ls_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_1_ADDR);

	return (u8)((local_val & ((u32)0x7F000000)) >> 24);
}

static inline u16 mac_hw_debug_hwsm_1_tx_control_ls_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_1_ADDR);

	return (u16)((local_val & ((u32)0x0001FF00)) >> 8);
}

static inline u8 mac_hw_debug_hwsm_1_rx_control_ls_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_1_ADDR);

	return (u8)((local_val & ((u32)0x0000001F)) >> 0);
}

/**
 * @brief DEBUG_HWSM_2 register definition
 *  Used to observe the MAC HW state machines. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:23 TX_CONTROL_CS             0x0
 *    22:18 MAC_CONTROL_TX_CS         0x0
 *    17:14 MAC_CONTROL_MASTER_CS     0x0
 *    13:10 DEAGGREGATOR_CS           0x0
 *    09:04 RX_CONTROL_CS             0x0
 *    03:00 MAC_CONTROL_RX_CS         0x0
 * </pre>
 */
#define MAC_HW_DEBUG_HWSM_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000504)
#define MAC_HW_DEBUG_HWSM_2_OFFSET      0x00000504
#define MAC_HW_DEBUG_HWSM_2_INDEX       0x00000141
#define MAC_HW_DEBUG_HWSM_2_RESET       0x00000000

static inline u32 mac_hw_debug_hwsm_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_HWSM_2_TX_CONTROL_CS_MASK    ((u32)0xFF800000)
#define MAC_HW_DEBUG_HWSM_2_TX_CONTROL_CS_LSB    23
#define MAC_HW_DEBUG_HWSM_2_TX_CONTROL_CS_WIDTH    ((u32)0x00000009)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_TX_CS_MASK    ((u32)0x007C0000)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_TX_CS_LSB    18
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_TX_CS_WIDTH    ((u32)0x00000005)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_MASTER_CS_MASK    ((u32)0x0003C000)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_MASTER_CS_LSB    14
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_MASTER_CS_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_HWSM_2_DEAGGREGATOR_CS_MASK    ((u32)0x00003C00)
#define MAC_HW_DEBUG_HWSM_2_DEAGGREGATOR_CS_LSB    10
#define MAC_HW_DEBUG_HWSM_2_DEAGGREGATOR_CS_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_HWSM_2_RX_CONTROL_CS_MASK    ((u32)0x000003F0)
#define MAC_HW_DEBUG_HWSM_2_RX_CONTROL_CS_LSB    4
#define MAC_HW_DEBUG_HWSM_2_RX_CONTROL_CS_WIDTH    ((u32)0x00000006)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_RX_CS_MASK    ((u32)0x0000000F)
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_RX_CS_LSB    0
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_RX_CS_WIDTH    ((u32)0x00000004)

#define MAC_HW_DEBUG_HWSM_2_TX_CONTROL_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_TX_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_MASTER_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_2_DEAGGREGATOR_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_2_RX_CONTROL_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_2_MAC_CONTROL_RX_CS_RST    0x0

static inline void mac_hw_debug_hwsm_2_unpack(struct cl_chip *chip, u16 *tx_control_cs, u8 *mac_control_tx_cs, u8 *mac_control_master_cs, u8 *deaggregator_cs, u8 *rx_control_cs, u8 *mac_control_rx_cs)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	*tx_control_cs = (local_val & ((u32)0xFF800000)) >> 23;
	*mac_control_tx_cs = (local_val & ((u32)0x007C0000)) >> 18;
	*mac_control_master_cs = (local_val & ((u32)0x0003C000)) >> 14;
	*deaggregator_cs = (local_val & ((u32)0x00003C00)) >> 10;
	*rx_control_cs = (local_val & ((u32)0x000003F0)) >> 4;
	*mac_control_rx_cs = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u16 mac_hw_debug_hwsm_2_tx_control_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u16)((local_val & ((u32)0xFF800000)) >> 23);
}

static inline u8 mac_hw_debug_hwsm_2_mac_control_tx_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u8)((local_val & ((u32)0x007C0000)) >> 18);
}

static inline u8 mac_hw_debug_hwsm_2_mac_control_master_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u8)((local_val & ((u32)0x0003C000)) >> 14);
}

static inline u8 mac_hw_debug_hwsm_2_deaggregator_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u8)((local_val & ((u32)0x00003C00)) >> 10);
}

static inline u8 mac_hw_debug_hwsm_2_rx_control_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u8)((local_val & ((u32)0x000003F0)) >> 4);
}

static inline u8 mac_hw_debug_hwsm_2_mac_control_rx_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_2_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

/**
 * @brief DEBUG_HWSM_3 register definition
 *  Used to observe the MAC HW state machines. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    24:20 RX_LIST_PROC_FSM_CS       0x0
 *    19:16 DEAGGREGATOR_FSM_CS       0x0
 *    13:08 RX_CONTROLLER_FSM_CS      0x0
 *    07:04 ENCRYPT_RX_CNTRL_FSM_CS   0x0
 *    02:00 DECRYPT_FSM_CS            0x0
 * </pre>
 */
#define MAC_HW_DEBUG_HWSM_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000508)
#define MAC_HW_DEBUG_HWSM_3_OFFSET      0x00000508
#define MAC_HW_DEBUG_HWSM_3_INDEX       0x00000142
#define MAC_HW_DEBUG_HWSM_3_RESET       0x00000000

static inline u32 mac_hw_debug_hwsm_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_HWSM_3_RX_LIST_PROC_FSM_CS_MASK    ((u32)0x01F00000)
#define MAC_HW_DEBUG_HWSM_3_RX_LIST_PROC_FSM_CS_LSB    20
#define MAC_HW_DEBUG_HWSM_3_RX_LIST_PROC_FSM_CS_WIDTH    ((u32)0x00000005)
#define MAC_HW_DEBUG_HWSM_3_DEAGGREGATOR_FSM_CS_MASK    ((u32)0x000F0000)
#define MAC_HW_DEBUG_HWSM_3_DEAGGREGATOR_FSM_CS_LSB    16
#define MAC_HW_DEBUG_HWSM_3_DEAGGREGATOR_FSM_CS_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_HWSM_3_RX_CONTROLLER_FSM_CS_MASK    ((u32)0x00003F00)
#define MAC_HW_DEBUG_HWSM_3_RX_CONTROLLER_FSM_CS_LSB    8
#define MAC_HW_DEBUG_HWSM_3_RX_CONTROLLER_FSM_CS_WIDTH    ((u32)0x00000006)
#define MAC_HW_DEBUG_HWSM_3_ENCRYPT_RX_CNTRL_FSM_CS_MASK    ((u32)0x000000F0)
#define MAC_HW_DEBUG_HWSM_3_ENCRYPT_RX_CNTRL_FSM_CS_LSB    4
#define MAC_HW_DEBUG_HWSM_3_ENCRYPT_RX_CNTRL_FSM_CS_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_HWSM_3_DECRYPT_FSM_CS_MASK    ((u32)0x00000007)
#define MAC_HW_DEBUG_HWSM_3_DECRYPT_FSM_CS_LSB    0
#define MAC_HW_DEBUG_HWSM_3_DECRYPT_FSM_CS_WIDTH    ((u32)0x00000003)

#define MAC_HW_DEBUG_HWSM_3_RX_LIST_PROC_FSM_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_3_DEAGGREGATOR_FSM_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_3_RX_CONTROLLER_FSM_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_3_ENCRYPT_RX_CNTRL_FSM_CS_RST    0x0
#define MAC_HW_DEBUG_HWSM_3_DECRYPT_FSM_CS_RST    0x0

static inline void mac_hw_debug_hwsm_3_unpack(struct cl_chip *chip, u8 *rx_list_proc_fsm_cs, u8 *deaggregator_fsm_cs, u8 *rx_controller_fsm_cs, u8 *encrypt_rx_cntrl_fsm_cs, u8 *decrypt_fsm_cs)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	*rx_list_proc_fsm_cs = (local_val & ((u32)0x01F00000)) >> 20;
	*deaggregator_fsm_cs = (local_val & ((u32)0x000F0000)) >> 16;
	*rx_controller_fsm_cs = (local_val & ((u32)0x00003F00)) >> 8;
	*encrypt_rx_cntrl_fsm_cs = (local_val & ((u32)0x000000F0)) >> 4;
	*decrypt_fsm_cs = (local_val & ((u32)0x00000007)) >> 0;
}

static inline u8 mac_hw_debug_hwsm_3_rx_list_proc_fsm_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	return (u8)((local_val & ((u32)0x01F00000)) >> 20);
}

static inline u8 mac_hw_debug_hwsm_3_deaggregator_fsm_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	return (u8)((local_val & ((u32)0x000F0000)) >> 16);
}

static inline u8 mac_hw_debug_hwsm_3_rx_controller_fsm_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	return (u8)((local_val & ((u32)0x00003F00)) >> 8);
}

static inline u8 mac_hw_debug_hwsm_3_encrypt_rx_cntrl_fsm_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline u8 mac_hw_debug_hwsm_3_decrypt_fsm_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HWSM_3_ADDR);

	return (u8)((local_val & ((u32)0x00000007)) >> 0);
}

/**
 * @brief DEBUG_PORT_VALUE register definition
 *  Return the current value of the debugPort register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 DEBUG_PORT_READ           0x0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_VALUE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000050C)
#define MAC_HW_DEBUG_PORT_VALUE_OFFSET      0x0000050C
#define MAC_HW_DEBUG_PORT_VALUE_INDEX       0x00000143
#define MAC_HW_DEBUG_PORT_VALUE_RESET       0x00000000

static inline u32 mac_hw_debug_port_value_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_VALUE_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_VALUE_DEBUG_PORT_READ_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_PORT_VALUE_DEBUG_PORT_READ_LSB    0
#define MAC_HW_DEBUG_PORT_VALUE_DEBUG_PORT_READ_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_PORT_VALUE_DEBUG_PORT_READ_RST    0x0

static inline u32 mac_hw_debug_port_value_debug_port_read_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_VALUE_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_PORT_SEL_A register definition
 *  Used to multiplex different sets of signals on the debug pins. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 DEBUG_PORT_SEL_1          0x0
 *    07:00 DEBUG_PORT_SEL_0          0x0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_SEL_A_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000510)
#define MAC_HW_DEBUG_PORT_SEL_A_OFFSET      0x00000510
#define MAC_HW_DEBUG_PORT_SEL_A_INDEX       0x00000144
#define MAC_HW_DEBUG_PORT_SEL_A_RESET       0x00000000

static inline u32 mac_hw_debug_port_sel_a_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR);
}

static inline void mac_hw_debug_port_sel_a_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_1_MASK    ((u32)0x0000FF00)
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_1_LSB    8
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_1_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_0_MASK    ((u32)0x000000FF)
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_0_LSB    0
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_0_WIDTH    ((u32)0x00000008)

#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_1_RST    0x0
#define MAC_HW_DEBUG_PORT_SEL_A_DEBUG_PORT_SEL_0_RST    0x0

static inline void mac_hw_debug_port_sel_a_pack(struct cl_chip *chip, u8 debug_port_sel_1, u8 debug_port_sel_0)
{
	ASSERT_ERR_CHIP((((u32)debug_port_sel_1 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)debug_port_sel_0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR, ((u32)debug_port_sel_1 << 8) | ((u32)debug_port_sel_0 << 0));
}

static inline void mac_hw_debug_port_sel_a_unpack(struct cl_chip *chip, u8 *debug_port_sel_1, u8 *debug_port_sel_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR);

	*debug_port_sel_1 = (local_val & ((u32)0x0000FF00)) >> 8;
	*debug_port_sel_0 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_debug_port_sel_a_debug_port_sel_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_debug_port_sel_a_debug_port_sel_1_setf(struct cl_chip *chip, u8 debugportsel1)
{
	ASSERT_ERR_CHIP((((u32)debugportsel1 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR) & ~((u32)0x0000FF00)) | ((u32)debugportsel1 << 8));
}

static inline u8 mac_hw_debug_port_sel_a_debug_port_sel_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_debug_port_sel_a_debug_port_sel_0_setf(struct cl_chip *chip, u8 debugportsel0)
{
	ASSERT_ERR_CHIP((((u32)debugportsel0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_A_ADDR) & ~((u32)0x000000FF)) | ((u32)debugportsel0 << 0));
}

/**
 * @brief NAV_VALUE register definition
 *  Current value of the NAV and CW for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25:00 NAV_COUNTER               0x0
 * </pre>
 */
#define MAC_HW_NAV_VALUE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000514)
#define MAC_HW_NAV_VALUE_OFFSET      0x00000514
#define MAC_HW_NAV_VALUE_INDEX       0x00000145
#define MAC_HW_NAV_VALUE_RESET       0x00000000

static inline u32 mac_hw_nav_value_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NAV_VALUE_ADDR);
}

/* Field definitions */
#define MAC_HW_NAV_VALUE_NAV_COUNTER_MASK    ((u32)0x03FFFFFF)
#define MAC_HW_NAV_VALUE_NAV_COUNTER_LSB    0
#define MAC_HW_NAV_VALUE_NAV_COUNTER_WIDTH    ((u32)0x0000001A)

#define MAC_HW_NAV_VALUE_NAV_COUNTER_RST    0x0

static inline u32 mac_hw_nav_value_nav_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NAV_VALUE_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_CW register definition
 *  Current value of the NAV and CW for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25:24 BACKOFF_OFFSET            0x0
 *    18:16 ACTIVE_AC                 0x0
 *    15:12 CURRENT_CW_3              0x2
 *    11:08 CURRENT_CW_2              0x3
 *    07:04 CURRENT_CW_1              0x4
 *    03:00 CURRENT_CW_0              0x4
 * </pre>
 */
#define MAC_HW_DEBUG_CW_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000518)
#define MAC_HW_DEBUG_CW_OFFSET      0x00000518
#define MAC_HW_DEBUG_CW_INDEX       0x00000146
#define MAC_HW_DEBUG_CW_RESET       0x00002344

static inline u32 mac_hw_debug_cw_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);
}

static inline void mac_hw_debug_cw_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_CW_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_CW_BACKOFF_OFFSET_MASK    ((u32)0x03000000)
#define MAC_HW_DEBUG_CW_BACKOFF_OFFSET_LSB    24
#define MAC_HW_DEBUG_CW_BACKOFF_OFFSET_WIDTH    ((u32)0x00000002)
#define MAC_HW_DEBUG_CW_ACTIVE_AC_MASK      ((u32)0x00070000)
#define MAC_HW_DEBUG_CW_ACTIVE_AC_LSB       16
#define MAC_HW_DEBUG_CW_ACTIVE_AC_WIDTH     ((u32)0x00000003)
#define MAC_HW_DEBUG_CW_CURRENT_CW_3_MASK    ((u32)0x0000F000)
#define MAC_HW_DEBUG_CW_CURRENT_CW_3_LSB    12
#define MAC_HW_DEBUG_CW_CURRENT_CW_3_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_CW_CURRENT_CW_2_MASK    ((u32)0x00000F00)
#define MAC_HW_DEBUG_CW_CURRENT_CW_2_LSB    8
#define MAC_HW_DEBUG_CW_CURRENT_CW_2_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_CW_CURRENT_CW_1_MASK    ((u32)0x000000F0)
#define MAC_HW_DEBUG_CW_CURRENT_CW_1_LSB    4
#define MAC_HW_DEBUG_CW_CURRENT_CW_1_WIDTH    ((u32)0x00000004)
#define MAC_HW_DEBUG_CW_CURRENT_CW_0_MASK    ((u32)0x0000000F)
#define MAC_HW_DEBUG_CW_CURRENT_CW_0_LSB    0
#define MAC_HW_DEBUG_CW_CURRENT_CW_0_WIDTH    ((u32)0x00000004)

#define MAC_HW_DEBUG_CW_BACKOFF_OFFSET_RST    0x0
#define MAC_HW_DEBUG_CW_ACTIVE_AC_RST       0x0
#define MAC_HW_DEBUG_CW_CURRENT_CW_3_RST    0x2
#define MAC_HW_DEBUG_CW_CURRENT_CW_2_RST    0x3
#define MAC_HW_DEBUG_CW_CURRENT_CW_1_RST    0x4
#define MAC_HW_DEBUG_CW_CURRENT_CW_0_RST    0x4

static inline void mac_hw_debug_cw_pack(struct cl_chip *chip, u8 backoff_offset, u8 active_ac, u8 current_cw_3, u8 current_cw_2, u8 current_cw_1, u8 current_cw_0)
{
	ASSERT_ERR_CHIP((((u32)backoff_offset << 24) & ~((u32)0x03000000)) == 0);
	ASSERT_ERR_CHIP((((u32)active_ac << 16) & ~((u32)0x00070000)) == 0);
	ASSERT_ERR_CHIP((((u32)current_cw_3 << 12) & ~((u32)0x0000F000)) == 0);
	ASSERT_ERR_CHIP((((u32)current_cw_2 << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)current_cw_1 << 4) & ~((u32)0x000000F0)) == 0);
	ASSERT_ERR_CHIP((((u32)current_cw_0 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_CW_ADDR, ((u32)backoff_offset << 24) | ((u32)active_ac << 16) | ((u32)current_cw_3 << 12) | ((u32)current_cw_2 << 8) | ((u32)current_cw_1 << 4) | ((u32)current_cw_0 << 0));
}

static inline void mac_hw_debug_cw_unpack(struct cl_chip *chip, u8 *backoff_offset, u8 *active_ac, u8 *current_cw_3, u8 *current_cw_2, u8 *current_cw_1, u8 *current_cw_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	*backoff_offset = (local_val & ((u32)0x03000000)) >> 24;
	*active_ac = (local_val & ((u32)0x00070000)) >> 16;
	*current_cw_3 = (local_val & ((u32)0x0000F000)) >> 12;
	*current_cw_2 = (local_val & ((u32)0x00000F00)) >> 8;
	*current_cw_1 = (local_val & ((u32)0x000000F0)) >> 4;
	*current_cw_0 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_debug_cw_backoff_offset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x03000000)) >> 24);
}

static inline void mac_hw_debug_cw_backoff_offset_setf(struct cl_chip *chip, u8 backoffoffset)
{
	ASSERT_ERR_CHIP((((u32)backoffoffset << 24) & ~((u32)0x03000000)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_CW_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR) & ~((u32)0x03000000)) | ((u32)backoffoffset << 24));
}

static inline u8 mac_hw_debug_cw_active_ac_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x00070000)) >> 16);
}

static inline u8 mac_hw_debug_cw_current_cw_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x0000F000)) >> 12);
}

static inline u8 mac_hw_debug_cw_current_cw_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline u8 mac_hw_debug_cw_current_cw_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x000000F0)) >> 4);
}

static inline u8 mac_hw_debug_cw_current_cw_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_CW_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

/**
 * @brief DEBUG_QSRC register definition
 *  Current value of the QoS Station Short Retry Counter for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 AC_3_QSRC                 0x0
 *    23:16 AC_2_QSRC                 0x0
 *    15:08 AC_1_QSRC                 0x0
 *    07:00 AC_0_QSRC                 0x0
 * </pre>
 */
#define MAC_HW_DEBUG_QSRC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000051C)
#define MAC_HW_DEBUG_QSRC_OFFSET      0x0000051C
#define MAC_HW_DEBUG_QSRC_INDEX       0x00000147
#define MAC_HW_DEBUG_QSRC_RESET       0x00000000

static inline u32 mac_hw_debug_qsrc_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_QSRC_AC_3_QSRC_MASK    ((u32)0xFF000000)
#define MAC_HW_DEBUG_QSRC_AC_3_QSRC_LSB     24
#define MAC_HW_DEBUG_QSRC_AC_3_QSRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QSRC_AC_2_QSRC_MASK    ((u32)0x00FF0000)
#define MAC_HW_DEBUG_QSRC_AC_2_QSRC_LSB     16
#define MAC_HW_DEBUG_QSRC_AC_2_QSRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QSRC_AC_1_QSRC_MASK    ((u32)0x0000FF00)
#define MAC_HW_DEBUG_QSRC_AC_1_QSRC_LSB     8
#define MAC_HW_DEBUG_QSRC_AC_1_QSRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QSRC_AC_0_QSRC_MASK    ((u32)0x000000FF)
#define MAC_HW_DEBUG_QSRC_AC_0_QSRC_LSB     0
#define MAC_HW_DEBUG_QSRC_AC_0_QSRC_WIDTH    ((u32)0x00000008)

#define MAC_HW_DEBUG_QSRC_AC_3_QSRC_RST     0x0
#define MAC_HW_DEBUG_QSRC_AC_2_QSRC_RST     0x0
#define MAC_HW_DEBUG_QSRC_AC_1_QSRC_RST     0x0
#define MAC_HW_DEBUG_QSRC_AC_0_QSRC_RST     0x0

static inline void mac_hw_debug_qsrc_unpack(struct cl_chip *chip, u8 *ac_3_qsrc, u8 *ac_2_qsrc, u8 *ac_1_qsrc, u8 *ac_0_qsrc)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);

	*ac_3_qsrc = (local_val & ((u32)0xFF000000)) >> 24;
	*ac_2_qsrc = (local_val & ((u32)0x00FF0000)) >> 16;
	*ac_1_qsrc = (local_val & ((u32)0x0000FF00)) >> 8;
	*ac_0_qsrc = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_debug_qsrc_ac_3_qsrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline u8 mac_hw_debug_qsrc_ac_2_qsrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline u8 mac_hw_debug_qsrc_ac_1_qsrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_debug_qsrc_ac_0_qsrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QSRC_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

/**
 * @brief DEBUG_QLRC register definition
 *  Current value of the QoS Station Long Retry Counter for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 AC_3_QLRC                 0x0
 *    23:16 AC_2_QLRC                 0x0
 *    15:08 AC_1_QLRC                 0x0
 *    07:00 AC_0_QLRC                 0x0
 * </pre>
 */
#define MAC_HW_DEBUG_QLRC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000520)
#define MAC_HW_DEBUG_QLRC_OFFSET      0x00000520
#define MAC_HW_DEBUG_QLRC_INDEX       0x00000148
#define MAC_HW_DEBUG_QLRC_RESET       0x00000000

static inline u32 mac_hw_debug_qlrc_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_QLRC_AC_3_QLRC_MASK    ((u32)0xFF000000)
#define MAC_HW_DEBUG_QLRC_AC_3_QLRC_LSB     24
#define MAC_HW_DEBUG_QLRC_AC_3_QLRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QLRC_AC_2_QLRC_MASK    ((u32)0x00FF0000)
#define MAC_HW_DEBUG_QLRC_AC_2_QLRC_LSB     16
#define MAC_HW_DEBUG_QLRC_AC_2_QLRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QLRC_AC_1_QLRC_MASK    ((u32)0x0000FF00)
#define MAC_HW_DEBUG_QLRC_AC_1_QLRC_LSB     8
#define MAC_HW_DEBUG_QLRC_AC_1_QLRC_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_QLRC_AC_0_QLRC_MASK    ((u32)0x000000FF)
#define MAC_HW_DEBUG_QLRC_AC_0_QLRC_LSB     0
#define MAC_HW_DEBUG_QLRC_AC_0_QLRC_WIDTH    ((u32)0x00000008)

#define MAC_HW_DEBUG_QLRC_AC_3_QLRC_RST     0x0
#define MAC_HW_DEBUG_QLRC_AC_2_QLRC_RST     0x0
#define MAC_HW_DEBUG_QLRC_AC_1_QLRC_RST     0x0
#define MAC_HW_DEBUG_QLRC_AC_0_QLRC_RST     0x0

static inline void mac_hw_debug_qlrc_unpack(struct cl_chip *chip, u8 *ac_3_qlrc, u8 *ac_2_qlrc, u8 *ac_1_qlrc, u8 *ac_0_qlrc)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);

	*ac_3_qlrc = (local_val & ((u32)0xFF000000)) >> 24;
	*ac_2_qlrc = (local_val & ((u32)0x00FF0000)) >> 16;
	*ac_1_qlrc = (local_val & ((u32)0x0000FF00)) >> 8;
	*ac_0_qlrc = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_debug_qlrc_ac_3_qlrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline u8 mac_hw_debug_qlrc_ac_2_qlrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline u8 mac_hw_debug_qlrc_ac_1_qlrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_debug_qlrc_ac_0_qlrc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_QLRC_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

/**
 * @brief DEBUG_PORT_SEL_B register definition
 *  Used to multiplex different sets of signals on the register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 DEBUG_PORT_SEL_3          0x0
 *    07:00 DEBUG_PORT_SEL_2          0x0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_SEL_B_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000530)
#define MAC_HW_DEBUG_PORT_SEL_B_OFFSET      0x00000530
#define MAC_HW_DEBUG_PORT_SEL_B_INDEX       0x0000014C
#define MAC_HW_DEBUG_PORT_SEL_B_RESET       0x00000000

static inline u32 mac_hw_debug_port_sel_b_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR);
}

static inline void mac_hw_debug_port_sel_b_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_3_MASK    ((u32)0x0000FF00)
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_3_LSB    8
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_2_MASK    ((u32)0x000000FF)
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_2_LSB    0
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_2_WIDTH    ((u32)0x00000008)

#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_3_RST    0x0
#define MAC_HW_DEBUG_PORT_SEL_B_DEBUG_PORT_SEL_2_RST    0x0

static inline void mac_hw_debug_port_sel_b_pack(struct cl_chip *chip, u8 debug_port_sel_3, u8 debug_port_sel_2)
{
	ASSERT_ERR_CHIP((((u32)debug_port_sel_3 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)debug_port_sel_2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR, ((u32)debug_port_sel_3 << 8) | ((u32)debug_port_sel_2 << 0));
}

static inline void mac_hw_debug_port_sel_b_unpack(struct cl_chip *chip, u8 *debug_port_sel_3, u8 *debug_port_sel_2)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR);

	*debug_port_sel_3 = (local_val & ((u32)0x0000FF00)) >> 8;
	*debug_port_sel_2 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_debug_port_sel_b_debug_port_sel_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_debug_port_sel_b_debug_port_sel_3_setf(struct cl_chip *chip, u8 debugportsel3)
{
	ASSERT_ERR_CHIP((((u32)debugportsel3 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR) & ~((u32)0x0000FF00)) | ((u32)debugportsel3 << 8));
}

static inline u8 mac_hw_debug_port_sel_b_debug_port_sel_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_debug_port_sel_b_debug_port_sel_2_setf(struct cl_chip *chip, u8 debugportsel2)
{
	ASSERT_ERR_CHIP((((u32)debugportsel2 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_B_ADDR) & ~((u32)0x000000FF)) | ((u32)debugportsel2 << 0));
}

/**
 * @brief DEBUG_PORT_SEL_C register definition
 *  Used to multiplex different sets of signals on the register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:08 DEBUG_PORT_SEL_5          0x0
 *    07:00 DEBUG_PORT_SEL_4          0x0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_SEL_C_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000534)
#define MAC_HW_DEBUG_PORT_SEL_C_OFFSET      0x00000534
#define MAC_HW_DEBUG_PORT_SEL_C_INDEX       0x0000014D
#define MAC_HW_DEBUG_PORT_SEL_C_RESET       0x00000000

static inline u32 mac_hw_debug_port_sel_c_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR);
}

static inline void mac_hw_debug_port_sel_c_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_5_MASK    ((u32)0x0000FF00)
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_5_LSB    8
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_5_WIDTH    ((u32)0x00000008)
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_4_MASK    ((u32)0x000000FF)
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_4_LSB    0
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_4_WIDTH    ((u32)0x00000008)

#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_5_RST    0x0
#define MAC_HW_DEBUG_PORT_SEL_C_DEBUG_PORT_SEL_4_RST    0x0

static inline void mac_hw_debug_port_sel_c_pack(struct cl_chip *chip, u8 debug_port_sel_5, u8 debug_port_sel_4)
{
	ASSERT_ERR_CHIP((((u32)debug_port_sel_5 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)debug_port_sel_4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR, ((u32)debug_port_sel_5 << 8) | ((u32)debug_port_sel_4 << 0));
}

static inline void mac_hw_debug_port_sel_c_unpack(struct cl_chip *chip, u8 *debug_port_sel_5, u8 *debug_port_sel_4)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR);

	*debug_port_sel_5 = (local_val & ((u32)0x0000FF00)) >> 8;
	*debug_port_sel_4 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_debug_port_sel_c_debug_port_sel_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_debug_port_sel_c_debug_port_sel_5_setf(struct cl_chip *chip, u8 debugportsel5)
{
	ASSERT_ERR_CHIP((((u32)debugportsel5 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR) & ~((u32)0x0000FF00)) | ((u32)debugportsel5 << 8));
}

static inline u8 mac_hw_debug_port_sel_c_debug_port_sel_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_debug_port_sel_c_debug_port_sel_4_setf(struct cl_chip *chip, u8 debugportsel4)
{
	ASSERT_ERR_CHIP((((u32)debugportsel4 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_SEL_C_ADDR) & ~((u32)0x000000FF)) | ((u32)debugportsel4 << 0));
}

/**
 * @brief DEBUG_PORT_EN register definition
 *  Used to determine which debug ports are enabled register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    05    EN5                       0
 *    04    EN4                       0
 *    03    EN3                       0
 *    02    EN2                       0
 *    01    EN1                       0
 *    00    EN0                       0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_EN_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000538)
#define MAC_HW_DEBUG_PORT_EN_OFFSET      0x00000538
#define MAC_HW_DEBUG_PORT_EN_INDEX       0x0000014E
#define MAC_HW_DEBUG_PORT_EN_RESET       0x00000000

static inline u32 mac_hw_debug_port_en_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);
}

static inline void mac_hw_debug_port_en_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_EN_EN_5_BIT       ((u32)0x00000020)
#define MAC_HW_DEBUG_PORT_EN_EN_5_POS       5
#define MAC_HW_DEBUG_PORT_EN_EN_4_BIT       ((u32)0x00000010)
#define MAC_HW_DEBUG_PORT_EN_EN_4_POS       4
#define MAC_HW_DEBUG_PORT_EN_EN_3_BIT       ((u32)0x00000008)
#define MAC_HW_DEBUG_PORT_EN_EN_3_POS       3
#define MAC_HW_DEBUG_PORT_EN_EN_2_BIT       ((u32)0x00000004)
#define MAC_HW_DEBUG_PORT_EN_EN_2_POS       2
#define MAC_HW_DEBUG_PORT_EN_EN_1_BIT       ((u32)0x00000002)
#define MAC_HW_DEBUG_PORT_EN_EN_1_POS       1
#define MAC_HW_DEBUG_PORT_EN_EN_0_BIT       ((u32)0x00000001)
#define MAC_HW_DEBUG_PORT_EN_EN_0_POS       0

#define MAC_HW_DEBUG_PORT_EN_EN_5_RST       0x0
#define MAC_HW_DEBUG_PORT_EN_EN_4_RST       0x0
#define MAC_HW_DEBUG_PORT_EN_EN_3_RST       0x0
#define MAC_HW_DEBUG_PORT_EN_EN_2_RST       0x0
#define MAC_HW_DEBUG_PORT_EN_EN_1_RST       0x0
#define MAC_HW_DEBUG_PORT_EN_EN_0_RST       0x0

static inline void mac_hw_debug_port_en_pack(struct cl_chip *chip, u8 en5, u8 en4, u8 en3, u8 en2, u8 en1, u8 en0)
{
	ASSERT_ERR_CHIP((((u32)en5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)en4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)en3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)en2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)en1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)en0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, ((u32)en5 << 5) | ((u32)en4 << 4) | ((u32)en3 << 3) | ((u32)en2 << 2) | ((u32)en1 << 1) | ((u32)en0 << 0));
}

static inline void mac_hw_debug_port_en_unpack(struct cl_chip *chip, u8 *en5, u8 *en4, u8 *en3, u8 *en2, u8 *en1, u8 *en0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	*en5 = (local_val & ((u32)0x00000020)) >> 5;
	*en4 = (local_val & ((u32)0x00000010)) >> 4;
	*en3 = (local_val & ((u32)0x00000008)) >> 3;
	*en2 = (local_val & ((u32)0x00000004)) >> 2;
	*en1 = (local_val & ((u32)0x00000002)) >> 1;
	*en0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_debug_port_en_en_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_debug_port_en_en_5_setf(struct cl_chip *chip, u8 en5)
{
	ASSERT_ERR_CHIP((((u32)en5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000020)) | ((u32)en5 << 5));
}

static inline u8 mac_hw_debug_port_en_en_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_debug_port_en_en_4_setf(struct cl_chip *chip, u8 en4)
{
	ASSERT_ERR_CHIP((((u32)en4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000010)) | ((u32)en4 << 4));
}

static inline u8 mac_hw_debug_port_en_en_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_debug_port_en_en_3_setf(struct cl_chip *chip, u8 en3)
{
	ASSERT_ERR_CHIP((((u32)en3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000008)) | ((u32)en3 << 3));
}

static inline u8 mac_hw_debug_port_en_en_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_debug_port_en_en_2_setf(struct cl_chip *chip, u8 en2)
{
	ASSERT_ERR_CHIP((((u32)en2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000004)) | ((u32)en2 << 2));
}

static inline u8 mac_hw_debug_port_en_en_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_debug_port_en_en_1_setf(struct cl_chip *chip, u8 en1)
{
	ASSERT_ERR_CHIP((((u32)en1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000002)) | ((u32)en1 << 1));
}

static inline u8 mac_hw_debug_port_en_en_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_debug_port_en_en_0_setf(struct cl_chip *chip, u8 en0)
{
	ASSERT_ERR_CHIP((((u32)en0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_EN_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_EN_ADDR) & ~((u32)0x00000001)) | ((u32)en0 << 0));
}

/**
 * @brief DEBUG_PORT_CNTRL register definition
 *  Control debug port width and mux register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    09    MPIF_DEBUG_ENABLE         0
 *    08    DEBUG_BUS_MODE            0
 *    03:00 DEBUG_TOP_SELECT          0x0
 * </pre>
 */
#define MAC_HW_DEBUG_PORT_CNTRL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000053C)
#define MAC_HW_DEBUG_PORT_CNTRL_OFFSET      0x0000053C
#define MAC_HW_DEBUG_PORT_CNTRL_INDEX       0x0000014F
#define MAC_HW_DEBUG_PORT_CNTRL_RESET       0x00000000

static inline u32 mac_hw_debug_port_cntrl_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR);
}

static inline void mac_hw_debug_port_cntrl_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PORT_CNTRL_MPIF_DEBUG_ENABLE_BIT    ((u32)0x00000200)
#define MAC_HW_DEBUG_PORT_CNTRL_MPIF_DEBUG_ENABLE_POS    9
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_BUS_MODE_BIT    ((u32)0x00000100)
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_BUS_MODE_POS    8
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_TOP_SELECT_MASK    ((u32)0x0000000F)
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_TOP_SELECT_LSB    0
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_TOP_SELECT_WIDTH    ((u32)0x00000004)

#define MAC_HW_DEBUG_PORT_CNTRL_MPIF_DEBUG_ENABLE_RST    0x0
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_BUS_MODE_RST    0x0
#define MAC_HW_DEBUG_PORT_CNTRL_DEBUG_TOP_SELECT_RST    0x0

static inline void mac_hw_debug_port_cntrl_pack(struct cl_chip *chip, u8 mpif_debug_enable, u8 debug_bus_mode, u8 debug_top_select)
{
	ASSERT_ERR_CHIP((((u32)mpif_debug_enable << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)debug_bus_mode << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)debug_top_select << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR, ((u32)mpif_debug_enable << 9) | ((u32)debug_bus_mode << 8) | ((u32)debug_top_select << 0));
}

static inline void mac_hw_debug_port_cntrl_unpack(struct cl_chip *chip, u8 *mpif_debug_enable, u8 *debug_bus_mode, u8 *debug_top_select)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR);

	*mpif_debug_enable = (local_val & ((u32)0x00000200)) >> 9;
	*debug_bus_mode = (local_val & ((u32)0x00000100)) >> 8;
	*debug_top_select = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_debug_port_cntrl_mpif_debug_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_debug_port_cntrl_mpif_debug_enable_setf(struct cl_chip *chip, u8 mpifdebugenable)
{
	ASSERT_ERR_CHIP((((u32)mpifdebugenable << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR) & ~((u32)0x00000200)) | ((u32)mpifdebugenable << 9));
}

static inline u8 mac_hw_debug_port_cntrl_debug_bus_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_debug_port_cntrl_debug_bus_mode_setf(struct cl_chip *chip, u8 debugbusmode)
{
	ASSERT_ERR_CHIP((((u32)debugbusmode << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR) & ~((u32)0x00000100)) | ((u32)debugbusmode << 8));
}

static inline u8 mac_hw_debug_port_cntrl_debug_top_select_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_debug_port_cntrl_debug_top_select_setf(struct cl_chip *chip, u8 debugtopselect)
{
	ASSERT_ERR_CHIP((((u32)debugtopselect << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PORT_CNTRL_ADDR) & ~((u32)0x0000000F)) | ((u32)debugtopselect << 0));
}

/**
 * @brief DEBUG_TXOP_HOLDER_LOW_ADD register definition
 *  Indicates TXOP HOLDER ADDR LOW register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TXOP_HOLDER_LOW_ADDR      0x0
 * </pre>
 */
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000540)
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_OFFSET      0x00000540
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_INDEX       0x00000150
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_RESET       0x00000000

static inline u32 mac_hw_debug_txop_holder_low_add_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_TXOP_HOLDER_LOW_ADDR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_TXOP_HOLDER_LOW_ADDR_LSB    0
#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_TXOP_HOLDER_LOW_ADDR_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_TXOP_HOLDER_LOW_ADDR_RST    0x0

static inline u32 mac_hw_debug_txop_holder_low_add_txop_holder_low_addr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_TXOP_HOLDER_LOW_ADD_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_TXOP_HOLDER_HIGH_AD register definition
 *  Indicates TXOP HOLDER ADDR HIGH register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 TXOP_HOLDER_HIGH_ADDR     0x0
 * </pre>
 */
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000544)
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_OFFSET      0x00000544
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_INDEX       0x00000151
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_RESET       0x00000000

static inline u32 mac_hw_debug_txop_holder_high_ad_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_TXOP_HOLDER_HIGH_ADDR_MASK    ((u32)0x0000FFFF)
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_TXOP_HOLDER_HIGH_ADDR_LSB    0
#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_TXOP_HOLDER_HIGH_ADDR_WIDTH    ((u32)0x00000010)

#define MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_TXOP_HOLDER_HIGH_ADDR_RST    0x0

static inline u16 mac_hw_debug_txop_holder_high_ad_txop_holder_high_addr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_TXOP_HOLDER_HIGH_AD_ADDR);

	return (u16)(local_val >> 0);
}

/**
 * @brief DEBUG_PHY register definition
 *  Used to observe the DMA HW state machines. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    05:04 CCA_FILTER_CONFIG         0x0
 *    02    RX_REQ_ALWAYS_ON          0
 *    01    FORCE_RX_REQ_ACK_MATCH    1
 *    00    RX_REQ_FORCE_DEASSERTION  0
 * </pre>
 */
#define MAC_HW_DEBUG_PHY_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000055C)
#define MAC_HW_DEBUG_PHY_OFFSET      0x0000055C
#define MAC_HW_DEBUG_PHY_INDEX       0x00000157
#define MAC_HW_DEBUG_PHY_RESET       0x00000002

static inline u32 mac_hw_debug_phy_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);
}

static inline void mac_hw_debug_phy_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DEBUG_PHY_CCA_FILTER_CONFIG_MASK    ((u32)0x00000030)
#define MAC_HW_DEBUG_PHY_CCA_FILTER_CONFIG_LSB    4
#define MAC_HW_DEBUG_PHY_CCA_FILTER_CONFIG_WIDTH    ((u32)0x00000002)
#define MAC_HW_DEBUG_PHY_RX_REQ_ALWAYS_ON_BIT    ((u32)0x00000004)
#define MAC_HW_DEBUG_PHY_RX_REQ_ALWAYS_ON_POS    2
#define MAC_HW_DEBUG_PHY_FORCE_RX_REQ_ACK_MATCH_BIT    ((u32)0x00000002)
#define MAC_HW_DEBUG_PHY_FORCE_RX_REQ_ACK_MATCH_POS    1
#define MAC_HW_DEBUG_PHY_RX_REQ_FORCE_DEASSERTION_BIT    ((u32)0x00000001)
#define MAC_HW_DEBUG_PHY_RX_REQ_FORCE_DEASSERTION_POS    0

#define MAC_HW_DEBUG_PHY_CCA_FILTER_CONFIG_RST    0x0
#define MAC_HW_DEBUG_PHY_RX_REQ_ALWAYS_ON_RST    0x0
#define MAC_HW_DEBUG_PHY_FORCE_RX_REQ_ACK_MATCH_RST    0x1
#define MAC_HW_DEBUG_PHY_RX_REQ_FORCE_DEASSERTION_RST    0x0

static inline void mac_hw_debug_phy_pack(struct cl_chip *chip, u8 cca_filter_config, u8 rx_req_always_on, u8 force_rx_req_ack_match, u8 rx_req_force_deassertion)
{
	ASSERT_ERR_CHIP((((u32)cca_filter_config << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_req_always_on << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)force_rx_req_ack_match << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_req_force_deassertion << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, ((u32)cca_filter_config << 4) | ((u32)rx_req_always_on << 2) | ((u32)force_rx_req_ack_match << 1) | ((u32)rx_req_force_deassertion << 0));
}

static inline void mac_hw_debug_phy_unpack(struct cl_chip *chip, u8 *cca_filter_config, u8 *rx_req_always_on, u8 *force_rx_req_ack_match, u8 *rx_req_force_deassertion)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);

	*cca_filter_config = (local_val & ((u32)0x00000030)) >> 4;
	*rx_req_always_on = (local_val & ((u32)0x00000004)) >> 2;
	*force_rx_req_ack_match = (local_val & ((u32)0x00000002)) >> 1;
	*rx_req_force_deassertion = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_debug_phy_cca_filter_config_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_debug_phy_cca_filter_config_setf(struct cl_chip *chip, u8 ccafilterconfig)
{
	ASSERT_ERR_CHIP((((u32)ccafilterconfig << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR) & ~((u32)0x00000030)) | ((u32)ccafilterconfig << 4));
}

static inline u8 mac_hw_debug_phy_rx_req_always_on_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_debug_phy_rx_req_always_on_setf(struct cl_chip *chip, u8 rxreqalwayson)
{
	ASSERT_ERR_CHIP((((u32)rxreqalwayson << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR) & ~((u32)0x00000004)) | ((u32)rxreqalwayson << 2));
}

static inline u8 mac_hw_debug_phy_force_rx_req_ack_match_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_debug_phy_force_rx_req_ack_match_setf(struct cl_chip *chip, u8 forcerxreqackmatch)
{
	ASSERT_ERR_CHIP((((u32)forcerxreqackmatch << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR) & ~((u32)0x00000002)) | ((u32)forcerxreqackmatch << 1));
}

static inline u8 mac_hw_debug_phy_rx_req_force_deassertion_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_debug_phy_rx_req_force_deassertion_setf(struct cl_chip *chip, u8 rxreqforcedeassertion)
{
	ASSERT_ERR_CHIP((((u32)rxreqforcedeassertion << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DEBUG_PHY_ADDR, (cl_reg_read(chip, MAC_HW_DEBUG_PHY_ADDR) & ~((u32)0x00000001)) | ((u32)rxreqforcedeassertion << 0));
}

/**
 * @brief BFR_TX_PCI_1 register definition
 *  BeamForming Report TX parameters 1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    16:15 user_Position             0x0
 *    14    fec_Coding_PT             0
 *    13:12 stbc_PT                   0x0
 *    11:08 PAdetect                  0x0
 *    07:00 tx_Pwr_Level_PT           0x0
 * </pre>
 */
#define MAC_HW_BFR_TX_PCI_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000560)
#define MAC_HW_BFR_TX_PCI_1_OFFSET      0x00000560
#define MAC_HW_BFR_TX_PCI_1_INDEX       0x00000158
#define MAC_HW_BFR_TX_PCI_1_RESET       0x00000000

static inline u32 mac_hw_bfr_tx_pci_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);
}

static inline void mac_hw_bfr_tx_pci_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_TX_PCI_1_USER_POSITION_MASK    ((u32)0x00018000)
#define MAC_HW_BFR_TX_PCI_1_USER_POSITION_LSB    15
#define MAC_HW_BFR_TX_PCI_1_USER_POSITION_WIDTH    ((u32)0x00000002)
#define MAC_HW_BFR_TX_PCI_1_FEC_CODING_PT_BIT    ((u32)0x00004000)
#define MAC_HW_BFR_TX_PCI_1_FEC_CODING_PT_POS    14
#define MAC_HW_BFR_TX_PCI_1_STBC_PT_MASK    ((u32)0x00003000)
#define MAC_HW_BFR_TX_PCI_1_STBC_PT_LSB     12
#define MAC_HW_BFR_TX_PCI_1_STBC_PT_WIDTH    ((u32)0x00000002)
#define MAC_HW_BFR_TX_PCI_1_PADETECT_MASK    ((u32)0x00000F00)
#define MAC_HW_BFR_TX_PCI_1_PADETECT_LSB    8
#define MAC_HW_BFR_TX_PCI_1_PADETECT_WIDTH    ((u32)0x00000004)
#define MAC_HW_BFR_TX_PCI_1_TX_PWR_LEVEL_PT_MASK    ((u32)0x000000FF)
#define MAC_HW_BFR_TX_PCI_1_TX_PWR_LEVEL_PT_LSB    0
#define MAC_HW_BFR_TX_PCI_1_TX_PWR_LEVEL_PT_WIDTH    ((u32)0x00000008)

#define MAC_HW_BFR_TX_PCI_1_USER_POSITION_RST    0x0
#define MAC_HW_BFR_TX_PCI_1_FEC_CODING_PT_RST    0x0
#define MAC_HW_BFR_TX_PCI_1_STBC_PT_RST     0x0
#define MAC_HW_BFR_TX_PCI_1_PADETECT_RST    0x0
#define MAC_HW_BFR_TX_PCI_1_TX_PWR_LEVEL_PT_RST    0x0

static inline void mac_hw_bfr_tx_pci_1_pack(struct cl_chip *chip, u8 user_position, u8 fec_coding_pt, u8 stbc_pt, u8 padetect, u8 tx_pwr_level_pt)
{
	ASSERT_ERR_CHIP((((u32)user_position << 15) & ~((u32)0x00018000)) == 0);
	ASSERT_ERR_CHIP((((u32)fec_coding_pt << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)stbc_pt << 12) & ~((u32)0x00003000)) == 0);
	ASSERT_ERR_CHIP((((u32)padetect << 8) & ~((u32)0x00000F00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_pwr_level_pt << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, ((u32)user_position << 15) | ((u32)fec_coding_pt << 14) | ((u32)stbc_pt << 12) | ((u32)padetect << 8) | ((u32)tx_pwr_level_pt << 0));
}

static inline void mac_hw_bfr_tx_pci_1_unpack(struct cl_chip *chip, u8 *user_position, u8 *fec_coding_pt, u8 *stbc_pt, u8 *padetect, u8 *tx_pwr_level_pt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	*user_position = (local_val & ((u32)0x00018000)) >> 15;
	*fec_coding_pt = (local_val & ((u32)0x00004000)) >> 14;
	*stbc_pt = (local_val & ((u32)0x00003000)) >> 12;
	*padetect = (local_val & ((u32)0x00000F00)) >> 8;
	*tx_pwr_level_pt = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_bfr_tx_pci_1_user_position_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	return (u8)((local_val & ((u32)0x00018000)) >> 15);
}

static inline void mac_hw_bfr_tx_pci_1_user_position_setf(struct cl_chip *chip, u8 userposition)
{
	ASSERT_ERR_CHIP((((u32)userposition << 15) & ~((u32)0x00018000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR) & ~((u32)0x00018000)) | ((u32)userposition << 15));
}

static inline u8 mac_hw_bfr_tx_pci_1_fec_coding_pt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_bfr_tx_pci_1_fec_coding_pt_setf(struct cl_chip *chip, u8 feccodingpt)
{
	ASSERT_ERR_CHIP((((u32)feccodingpt << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR) & ~((u32)0x00004000)) | ((u32)feccodingpt << 14));
}

static inline u8 mac_hw_bfr_tx_pci_1_stbc_pt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	return (u8)((local_val & ((u32)0x00003000)) >> 12);
}

static inline void mac_hw_bfr_tx_pci_1_stbc_pt_setf(struct cl_chip *chip, u8 stbcpt)
{
	ASSERT_ERR_CHIP((((u32)stbcpt << 12) & ~((u32)0x00003000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR) & ~((u32)0x00003000)) | ((u32)stbcpt << 12));
}

static inline u8 mac_hw_bfr_tx_pci_1_padetect_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	return (u8)((local_val & ((u32)0x00000F00)) >> 8);
}

static inline void mac_hw_bfr_tx_pci_1_padetect_setf(struct cl_chip *chip, u8 padetect)
{
	ASSERT_ERR_CHIP((((u32)padetect << 8) & ~((u32)0x00000F00)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR) & ~((u32)0x00000F00)) | ((u32)padetect << 8));
}

static inline u8 mac_hw_bfr_tx_pci_1_tx_pwr_level_pt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_bfr_tx_pci_1_tx_pwr_level_pt_setf(struct cl_chip *chip, u8 txpwrlevelpt)
{
	ASSERT_ERR_CHIP((((u32)txpwrlevelpt << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_1_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_1_ADDR) & ~((u32)0x000000FF)) | ((u32)txpwrlevelpt << 0));
}

/**
 * @brief BFR_TX_PCI_2 register definition
 *  BeamForming Report TX parameters 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    26:18 partil_Aif                0x0
 *    17    auto_Response             1
 *    16:09 active_Tx_Chains          0x0
 *    08:01 bf_Index                  0x0
 *    00    beam_Formed_PT            0
 * </pre>
 */
#define MAC_HW_BFR_TX_PCI_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000564)
#define MAC_HW_BFR_TX_PCI_2_OFFSET      0x00000564
#define MAC_HW_BFR_TX_PCI_2_INDEX       0x00000159
#define MAC_HW_BFR_TX_PCI_2_RESET       0x00020000

static inline u32 mac_hw_bfr_tx_pci_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);
}

static inline void mac_hw_bfr_tx_pci_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_TX_PCI_2_PARTIL_AIF_MASK    ((u32)0x07FC0000)
#define MAC_HW_BFR_TX_PCI_2_PARTIL_AIF_LSB    18
#define MAC_HW_BFR_TX_PCI_2_PARTIL_AIF_WIDTH    ((u32)0x00000009)
#define MAC_HW_BFR_TX_PCI_2_AUTO_RESPONSE_BIT    ((u32)0x00020000)
#define MAC_HW_BFR_TX_PCI_2_AUTO_RESPONSE_POS    17
#define MAC_HW_BFR_TX_PCI_2_ACTIVE_TX_CHAINS_MASK    ((u32)0x0001FE00)
#define MAC_HW_BFR_TX_PCI_2_ACTIVE_TX_CHAINS_LSB    9
#define MAC_HW_BFR_TX_PCI_2_ACTIVE_TX_CHAINS_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_TX_PCI_2_BF_INDEX_MASK    ((u32)0x000001FE)
#define MAC_HW_BFR_TX_PCI_2_BF_INDEX_LSB    1
#define MAC_HW_BFR_TX_PCI_2_BF_INDEX_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_TX_PCI_2_BEAM_FORMED_PT_BIT    ((u32)0x00000001)
#define MAC_HW_BFR_TX_PCI_2_BEAM_FORMED_PT_POS    0

#define MAC_HW_BFR_TX_PCI_2_PARTIL_AIF_RST    0x0
#define MAC_HW_BFR_TX_PCI_2_AUTO_RESPONSE_RST    0x1
#define MAC_HW_BFR_TX_PCI_2_ACTIVE_TX_CHAINS_RST    0x0
#define MAC_HW_BFR_TX_PCI_2_BF_INDEX_RST    0x0
#define MAC_HW_BFR_TX_PCI_2_BEAM_FORMED_PT_RST    0x0

static inline void mac_hw_bfr_tx_pci_2_pack(struct cl_chip *chip, u16 partil_aif, u8 auto_response, u8 active_tx_chains, u8 bf_index, u8 beam_formed_pt)
{
	ASSERT_ERR_CHIP((((u32)partil_aif << 18) & ~((u32)0x07FC0000)) == 0);
	ASSERT_ERR_CHIP((((u32)auto_response << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)active_tx_chains << 9) & ~((u32)0x0001FE00)) == 0);
	ASSERT_ERR_CHIP((((u32)bf_index << 1) & ~((u32)0x000001FE)) == 0);
	ASSERT_ERR_CHIP((((u32)beam_formed_pt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, ((u32)partil_aif << 18) | ((u32)auto_response << 17) | ((u32)active_tx_chains << 9) | ((u32)bf_index << 1) | ((u32)beam_formed_pt << 0));
}

static inline void mac_hw_bfr_tx_pci_2_unpack(struct cl_chip *chip, u16 *partil_aif, u8 *auto_response, u8 *active_tx_chains, u8 *bf_index, u8 *beam_formed_pt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	*partil_aif = (local_val & ((u32)0x07FC0000)) >> 18;
	*auto_response = (local_val & ((u32)0x00020000)) >> 17;
	*active_tx_chains = (local_val & ((u32)0x0001FE00)) >> 9;
	*bf_index = (local_val & ((u32)0x000001FE)) >> 1;
	*beam_formed_pt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u16 mac_hw_bfr_tx_pci_2_partil_aif_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	return (u16)((local_val & ((u32)0x07FC0000)) >> 18);
}

static inline void mac_hw_bfr_tx_pci_2_partil_aif_setf(struct cl_chip *chip, u16 partilaif)
{
	ASSERT_ERR_CHIP((((u32)partilaif << 18) & ~((u32)0x07FC0000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR) & ~((u32)0x07FC0000)) | ((u32)partilaif << 18));
}

static inline u8 mac_hw_bfr_tx_pci_2_auto_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_bfr_tx_pci_2_auto_response_setf(struct cl_chip *chip, u8 autoresponse)
{
	ASSERT_ERR_CHIP((((u32)autoresponse << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR) & ~((u32)0x00020000)) | ((u32)autoresponse << 17));
}

static inline u8 mac_hw_bfr_tx_pci_2_active_tx_chains_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	return (u8)((local_val & ((u32)0x0001FE00)) >> 9);
}

static inline void mac_hw_bfr_tx_pci_2_active_tx_chains_setf(struct cl_chip *chip, u8 activetxchains)
{
	ASSERT_ERR_CHIP((((u32)activetxchains << 9) & ~((u32)0x0001FE00)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR) & ~((u32)0x0001FE00)) | ((u32)activetxchains << 9));
}

static inline u8 mac_hw_bfr_tx_pci_2_bf_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	return (u8)((local_val & ((u32)0x000001FE)) >> 1);
}

static inline void mac_hw_bfr_tx_pci_2_bf_index_setf(struct cl_chip *chip, u8 bfindex)
{
	ASSERT_ERR_CHIP((((u32)bfindex << 1) & ~((u32)0x000001FE)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR) & ~((u32)0x000001FE)) | ((u32)bfindex << 1));
}

static inline u8 mac_hw_bfr_tx_pci_2_beam_formed_pt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_bfr_tx_pci_2_beam_formed_pt_setf(struct cl_chip *chip, u8 beamformedpt)
{
	ASSERT_ERR_CHIP((((u32)beamformedpt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_PCI_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_PCI_2_ADDR) & ~((u32)0x00000001)) | ((u32)beamformedpt << 0));
}

/**
 * @brief BFR_TX_RC register definition
 *  BeamForming Report TX rate control register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    13    Smoothing                 1
 *    12:06 mcs_Index_Tx_RCX          0x0
 *    05:04 bw_Tx_RCX                 0x0
 *    03    short_GITx_RCX            0
 *    02:00 format_Mod_Tx_RCS         0x0
 * </pre>
 */
#define MAC_HW_BFR_TX_RC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000568)
#define MAC_HW_BFR_TX_RC_OFFSET      0x00000568
#define MAC_HW_BFR_TX_RC_INDEX       0x0000015A
#define MAC_HW_BFR_TX_RC_RESET       0x00002000

static inline u32 mac_hw_bfr_tx_rc_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);
}

static inline void mac_hw_bfr_tx_rc_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_TX_RC_SMOOTHING_BIT      ((u32)0x00002000)
#define MAC_HW_BFR_TX_RC_SMOOTHING_POS      13
#define MAC_HW_BFR_TX_RC_MCS_INDEX_TX_RCX_MASK    ((u32)0x00001FC0)
#define MAC_HW_BFR_TX_RC_MCS_INDEX_TX_RCX_LSB    6
#define MAC_HW_BFR_TX_RC_MCS_INDEX_TX_RCX_WIDTH    ((u32)0x00000007)
#define MAC_HW_BFR_TX_RC_BW_TX_RCX_MASK     ((u32)0x00000030)
#define MAC_HW_BFR_TX_RC_BW_TX_RCX_LSB      4
#define MAC_HW_BFR_TX_RC_BW_TX_RCX_WIDTH    ((u32)0x00000002)
#define MAC_HW_BFR_TX_RC_SHORT_GITX_RCX_BIT    ((u32)0x00000008)
#define MAC_HW_BFR_TX_RC_SHORT_GITX_RCX_POS    3
#define MAC_HW_BFR_TX_RC_FORMAT_MOD_TX_RCS_MASK    ((u32)0x00000007)
#define MAC_HW_BFR_TX_RC_FORMAT_MOD_TX_RCS_LSB    0
#define MAC_HW_BFR_TX_RC_FORMAT_MOD_TX_RCS_WIDTH    ((u32)0x00000003)

#define MAC_HW_BFR_TX_RC_SMOOTHING_RST      0x1
#define MAC_HW_BFR_TX_RC_MCS_INDEX_TX_RCX_RST    0x0
#define MAC_HW_BFR_TX_RC_BW_TX_RCX_RST      0x0
#define MAC_HW_BFR_TX_RC_SHORT_GITX_RCX_RST    0x0
#define MAC_HW_BFR_TX_RC_FORMAT_MOD_TX_RCS_RST    0x0

static inline void mac_hw_bfr_tx_rc_pack(struct cl_chip *chip, u8 smoothing, u8 mcs_index_tx_rcx, u8 bw_tx_rcx, u8 short_gitx_rcx, u8 format_mod_tx_rcs)
{
	ASSERT_ERR_CHIP((((u32)smoothing << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)mcs_index_tx_rcx << 6) & ~((u32)0x00001FC0)) == 0);
	ASSERT_ERR_CHIP((((u32)bw_tx_rcx << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)short_gitx_rcx << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)format_mod_tx_rcs << 0) & ~((u32)0x00000007)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, ((u32)smoothing << 13) | ((u32)mcs_index_tx_rcx << 6) | ((u32)bw_tx_rcx << 4) | ((u32)short_gitx_rcx << 3) | ((u32)format_mod_tx_rcs << 0));
}

static inline void mac_hw_bfr_tx_rc_unpack(struct cl_chip *chip, u8 *smoothing, u8 *mcs_index_tx_rcx, u8 *bw_tx_rcx, u8 *short_gitx_rcx, u8 *format_mod_tx_rcs)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	*smoothing = (local_val & ((u32)0x00002000)) >> 13;
	*mcs_index_tx_rcx = (local_val & ((u32)0x00001FC0)) >> 6;
	*bw_tx_rcx = (local_val & ((u32)0x00000030)) >> 4;
	*short_gitx_rcx = (local_val & ((u32)0x00000008)) >> 3;
	*format_mod_tx_rcs = (local_val & ((u32)0x00000007)) >> 0;
}

static inline u8 mac_hw_bfr_tx_rc_smoothing_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_bfr_tx_rc_smoothing_setf(struct cl_chip *chip, u8 smoothing)
{
	ASSERT_ERR_CHIP((((u32)smoothing << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR) & ~((u32)0x00002000)) | ((u32)smoothing << 13));
}

static inline u8 mac_hw_bfr_tx_rc_mcs_index_tx_rcx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	return (u8)((local_val & ((u32)0x00001FC0)) >> 6);
}

static inline void mac_hw_bfr_tx_rc_mcs_index_tx_rcx_setf(struct cl_chip *chip, u8 mcsindextxrcx)
{
	ASSERT_ERR_CHIP((((u32)mcsindextxrcx << 6) & ~((u32)0x00001FC0)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR) & ~((u32)0x00001FC0)) | ((u32)mcsindextxrcx << 6));
}

static inline u8 mac_hw_bfr_tx_rc_bw_tx_rcx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_bfr_tx_rc_bw_tx_rcx_setf(struct cl_chip *chip, u8 bwtxrcx)
{
	ASSERT_ERR_CHIP((((u32)bwtxrcx << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR) & ~((u32)0x00000030)) | ((u32)bwtxrcx << 4));
}

static inline u8 mac_hw_bfr_tx_rc_short_gitx_rcx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_bfr_tx_rc_short_gitx_rcx_setf(struct cl_chip *chip, u8 shortgitxrcx)
{
	ASSERT_ERR_CHIP((((u32)shortgitxrcx << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR) & ~((u32)0x00000008)) | ((u32)shortgitxrcx << 3));
}

static inline u8 mac_hw_bfr_tx_rc_format_mod_tx_rcs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR);

	return (u8)((local_val & ((u32)0x00000007)) >> 0);
}

static inline void mac_hw_bfr_tx_rc_format_mod_tx_rcs_setf(struct cl_chip *chip, u8 formatmodtxrcs)
{
	ASSERT_ERR_CHIP((((u32)formatmodtxrcs << 0) & ~((u32)0x00000007)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_TX_RC_ADDR, (cl_reg_read(chip, MAC_HW_BFR_TX_RC_ADDR) & ~((u32)0x00000007)) | ((u32)formatmodtxrcs << 0));
}

/**
 * @brief BFR_CONTROL register definition
 *  BeamForming Report control register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 BFRError_Length           0x40
 *    22:18 reserve                   0x0
 *    17    clear_all_events          0
 *    16    Clear_all_counter         0
 *    15:00 BFR_sequence_number       0x0
 * </pre>
 */
#define MAC_HW_BFR_CONTROL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000056C)
#define MAC_HW_BFR_CONTROL_OFFSET      0x0000056C
#define MAC_HW_BFR_CONTROL_INDEX       0x0000015B
#define MAC_HW_BFR_CONTROL_RESET       0x40000000

static inline u32 mac_hw_bfr_control_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);
}

static inline void mac_hw_bfr_control_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_CONTROL_BFRERROR_LENGTH_MASK    ((u32)0xFF000000)
#define MAC_HW_BFR_CONTROL_BFRERROR_LENGTH_LSB    24
#define MAC_HW_BFR_CONTROL_BFRERROR_LENGTH_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_CONTROL_RESERVE_MASK     ((u32)0x007C0000)
#define MAC_HW_BFR_CONTROL_RESERVE_LSB      18
#define MAC_HW_BFR_CONTROL_RESERVE_WIDTH    ((u32)0x00000005)
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_EVENTS_BIT    ((u32)0x00020000)
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_EVENTS_POS    17
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_COUNTER_BIT    ((u32)0x00010000)
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_COUNTER_POS    16
#define MAC_HW_BFR_CONTROL_BFR_SEQUENCE_NUMBER_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BFR_CONTROL_BFR_SEQUENCE_NUMBER_LSB    0
#define MAC_HW_BFR_CONTROL_BFR_SEQUENCE_NUMBER_WIDTH    ((u32)0x00000010)

#define MAC_HW_BFR_CONTROL_BFRERROR_LENGTH_RST    0x40
#define MAC_HW_BFR_CONTROL_RESERVE_RST      0x0
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_EVENTS_RST    0x0
#define MAC_HW_BFR_CONTROL_CLEAR_ALL_COUNTER_RST    0x0
#define MAC_HW_BFR_CONTROL_BFR_SEQUENCE_NUMBER_RST    0x0

static inline void mac_hw_bfr_control_pack(struct cl_chip *chip, u8 bfrerror_length, u8 reserve, u8 clear_all_events, u8 clear_all_counter, u16 bfr_sequence_number)
{
	ASSERT_ERR_CHIP((((u32)bfrerror_length << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)reserve << 18) & ~((u32)0x007C0000)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_all_events << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)clear_all_counter << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_sequence_number << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, ((u32)bfrerror_length << 24) | ((u32)reserve << 18) | ((u32)clear_all_events << 17) | ((u32)clear_all_counter << 16) | ((u32)bfr_sequence_number << 0));
}

static inline void mac_hw_bfr_control_unpack(struct cl_chip *chip, u8 *bfrerror_length, u8 *reserve, u8 *clear_all_events, u8 *clear_all_counter, u16 *bfr_sequence_number)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	*bfrerror_length = (local_val & ((u32)0xFF000000)) >> 24;
	*reserve = (local_val & ((u32)0x007C0000)) >> 18;
	*clear_all_events = (local_val & ((u32)0x00020000)) >> 17;
	*clear_all_counter = (local_val & ((u32)0x00010000)) >> 16;
	*bfr_sequence_number = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bfr_control_bfrerror_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_bfr_control_bfrerror_length_setf(struct cl_chip *chip, u8 bfrerrorlength)
{
	ASSERT_ERR_CHIP((((u32)bfrerrorlength << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR) & ~((u32)0xFF000000)) | ((u32)bfrerrorlength << 24));
}

static inline u8 mac_hw_bfr_control_reserve_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x007C0000)) >> 18);
}

static inline void mac_hw_bfr_control_reserve_setf(struct cl_chip *chip, u8 reserve)
{
	ASSERT_ERR_CHIP((((u32)reserve << 18) & ~((u32)0x007C0000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR) & ~((u32)0x007C0000)) | ((u32)reserve << 18));
}

static inline u8 mac_hw_bfr_control_clear_all_events_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_bfr_control_clear_all_events_setf(struct cl_chip *chip, u8 clearallevents)
{
	ASSERT_ERR_CHIP((((u32)clearallevents << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR) & ~((u32)0x00020000)) | ((u32)clearallevents << 17));
}

static inline u8 mac_hw_bfr_control_clear_all_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_bfr_control_clear_all_counter_setf(struct cl_chip *chip, u8 clearallcounter)
{
	ASSERT_ERR_CHIP((((u32)clearallcounter << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR) & ~((u32)0x00010000)) | ((u32)clearallcounter << 16));
}

static inline u16 mac_hw_bfr_control_bfr_sequence_number_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bfr_control_bfr_sequence_number_setf(struct cl_chip *chip, u16 bfrsequencenumber)
{
	ASSERT_ERR_CHIP((((u32)bfrsequencenumber << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bfrsequencenumber << 0));
}

/**
 * @brief BFR_STATUS register definition
 *  BFR status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    HTC                       0
 *    30:24 bodyaction                0x0
 *    23:16 bodycategory              0x0
 *    15:00 HT_length                 0x0
 * </pre>
 */
#define MAC_HW_BFR_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000570)
#define MAC_HW_BFR_STATUS_OFFSET      0x00000570
#define MAC_HW_BFR_STATUS_INDEX       0x0000015C
#define MAC_HW_BFR_STATUS_RESET       0x00000000

static inline u32 mac_hw_bfr_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_BFR_STATUS_HTC_BIT           ((u32)0x80000000)
#define MAC_HW_BFR_STATUS_HTC_POS           31
#define MAC_HW_BFR_STATUS_BODYACTION_MASK    ((u32)0x7F000000)
#define MAC_HW_BFR_STATUS_BODYACTION_LSB    24
#define MAC_HW_BFR_STATUS_BODYACTION_WIDTH    ((u32)0x00000007)
#define MAC_HW_BFR_STATUS_BODYCATEGORY_MASK    ((u32)0x00FF0000)
#define MAC_HW_BFR_STATUS_BODYCATEGORY_LSB    16
#define MAC_HW_BFR_STATUS_BODYCATEGORY_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_STATUS_HT_LENGTH_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BFR_STATUS_HT_LENGTH_LSB     0
#define MAC_HW_BFR_STATUS_HT_LENGTH_WIDTH    ((u32)0x00000010)

#define MAC_HW_BFR_STATUS_HTC_RST           0x0
#define MAC_HW_BFR_STATUS_BODYACTION_RST    0x0
#define MAC_HW_BFR_STATUS_BODYCATEGORY_RST    0x0
#define MAC_HW_BFR_STATUS_HT_LENGTH_RST     0x0

static inline void mac_hw_bfr_status_unpack(struct cl_chip *chip, u8 *htc, u8 *bodyaction, u8 *bodycategory, u16 *ht_length)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);

	*htc = (local_val & ((u32)0x80000000)) >> 31;
	*bodyaction = (local_val & ((u32)0x7F000000)) >> 24;
	*bodycategory = (local_val & ((u32)0x00FF0000)) >> 16;
	*ht_length = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bfr_status_htc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_bfr_status_bodyaction_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x7F000000)) >> 24);
}

static inline u8 mac_hw_bfr_status_bodycategory_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline u16 mac_hw_bfr_status_ht_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_STATUS_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief BFR_EVENTS_COUNTERS register definition
 *  BFR events counters register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 underflo_event_counter    0x0
 *    23:16 BFRerrorcounter           0x0
 *    15:08 r_Late_Length_Conter      0x0
 *    07:00 Report_delivered_correctly_counter 0x0
 * </pre>
 */
#define MAC_HW_BFR_EVENTS_COUNTERS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000574)
#define MAC_HW_BFR_EVENTS_COUNTERS_OFFSET      0x00000574
#define MAC_HW_BFR_EVENTS_COUNTERS_INDEX       0x0000015D
#define MAC_HW_BFR_EVENTS_COUNTERS_RESET       0x00000000

static inline u32 mac_hw_bfr_events_counters_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);
}

/* Field definitions */
#define MAC_HW_BFR_EVENTS_COUNTERS_UNDERFLO_EVENT_COUNTER_MASK    ((u32)0xFF000000)
#define MAC_HW_BFR_EVENTS_COUNTERS_UNDERFLO_EVENT_COUNTER_LSB    24
#define MAC_HW_BFR_EVENTS_COUNTERS_UNDERFLO_EVENT_COUNTER_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_EVENTS_COUNTERS_BFRERRORCOUNTER_MASK    ((u32)0x00FF0000)
#define MAC_HW_BFR_EVENTS_COUNTERS_BFRERRORCOUNTER_LSB    16
#define MAC_HW_BFR_EVENTS_COUNTERS_BFRERRORCOUNTER_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_EVENTS_COUNTERS_R_LATE_LENGTH_CONTER_MASK    ((u32)0x0000FF00)
#define MAC_HW_BFR_EVENTS_COUNTERS_R_LATE_LENGTH_CONTER_LSB    8
#define MAC_HW_BFR_EVENTS_COUNTERS_R_LATE_LENGTH_CONTER_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_EVENTS_COUNTERS_REPORT_DELIVERED_CORRECTLY_COUNTER_MASK    ((u32)0x000000FF)
#define MAC_HW_BFR_EVENTS_COUNTERS_REPORT_DELIVERED_CORRECTLY_COUNTER_LSB    0
#define MAC_HW_BFR_EVENTS_COUNTERS_REPORT_DELIVERED_CORRECTLY_COUNTER_WIDTH    ((u32)0x00000008)

#define MAC_HW_BFR_EVENTS_COUNTERS_UNDERFLO_EVENT_COUNTER_RST    0x0
#define MAC_HW_BFR_EVENTS_COUNTERS_BFRERRORCOUNTER_RST    0x0
#define MAC_HW_BFR_EVENTS_COUNTERS_R_LATE_LENGTH_CONTER_RST    0x0
#define MAC_HW_BFR_EVENTS_COUNTERS_REPORT_DELIVERED_CORRECTLY_COUNTER_RST    0x0

static inline void mac_hw_bfr_events_counters_unpack(struct cl_chip *chip, u8 *underflo_event_counter, u8 *bfrerrorcounter, u8 *r_late_length_conter, u8 *report_delivered_correctly_counter)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);

	*underflo_event_counter = (local_val & ((u32)0xFF000000)) >> 24;
	*bfrerrorcounter = (local_val & ((u32)0x00FF0000)) >> 16;
	*r_late_length_conter = (local_val & ((u32)0x0000FF00)) >> 8;
	*report_delivered_correctly_counter = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_bfr_events_counters_underflo_event_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline u8 mac_hw_bfr_events_counters_bfrerrorcounter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline u8 mac_hw_bfr_events_counters_r_late_length_conter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline u8 mac_hw_bfr_events_counters_report_delivered_correctly_counter_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_EVENTS_COUNTERS_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

/**
 * @brief RX_NDPA_STAT register definition
 *  MU NDPA STAINFO decoding register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 NDPA2_NDPTimeot_Cnt       0x0
 *    23:07 reserv                    0x0
 *    06    error_NDPAMu_Su           0
 *    05    error_NDPAn_BCMu          0
 *    04    error_NDPABCSu            0
 *    03:00 match_Sta_Num             0x0
 * </pre>
 */
#define MAC_HW_RX_NDPA_STAT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000578)
#define MAC_HW_RX_NDPA_STAT_OFFSET      0x00000578
#define MAC_HW_RX_NDPA_STAT_INDEX       0x0000015E
#define MAC_HW_RX_NDPA_STAT_RESET       0x00000000

static inline u32 mac_hw_rx_ndpa_stat_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_NDPA_STAT_NDPA_2_NDPTIMEOT_CNT_MASK    ((u32)0xFF000000)
#define MAC_HW_RX_NDPA_STAT_NDPA_2_NDPTIMEOT_CNT_LSB    24
#define MAC_HW_RX_NDPA_STAT_NDPA_2_NDPTIMEOT_CNT_WIDTH    ((u32)0x00000008)
#define MAC_HW_RX_NDPA_STAT_RESERV_MASK     ((u32)0x00FFFF80)
#define MAC_HW_RX_NDPA_STAT_RESERV_LSB      7
#define MAC_HW_RX_NDPA_STAT_RESERV_WIDTH    ((u32)0x00000011)
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAMU_SU_BIT    ((u32)0x00000040)
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAMU_SU_POS    6
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAN_BCMU_BIT    ((u32)0x00000020)
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAN_BCMU_POS    5
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPABCSU_BIT    ((u32)0x00000010)
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPABCSU_POS    4
#define MAC_HW_RX_NDPA_STAT_MATCH_STA_NUM_MASK    ((u32)0x0000000F)
#define MAC_HW_RX_NDPA_STAT_MATCH_STA_NUM_LSB    0
#define MAC_HW_RX_NDPA_STAT_MATCH_STA_NUM_WIDTH    ((u32)0x00000004)

#define MAC_HW_RX_NDPA_STAT_NDPA_2_NDPTIMEOT_CNT_RST    0x0
#define MAC_HW_RX_NDPA_STAT_RESERV_RST      0x0
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAMU_SU_RST    0x0
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPAN_BCMU_RST    0x0
#define MAC_HW_RX_NDPA_STAT_ERROR_NDPABCSU_RST    0x0
#define MAC_HW_RX_NDPA_STAT_MATCH_STA_NUM_RST    0x0

static inline void mac_hw_rx_ndpa_stat_unpack(struct cl_chip *chip, u8 *ndpa2_ndptimeot_cnt, u32 *reserv, u8 *error_ndpamu_su, u8 *error_ndpan_bcmu, u8 *error_ndpabcsu, u8 *match_sta_num)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	*ndpa2_ndptimeot_cnt = (local_val & ((u32)0xFF000000)) >> 24;
	*reserv = (local_val & ((u32)0x00FFFF80)) >> 7;
	*error_ndpamu_su = (local_val & ((u32)0x00000040)) >> 6;
	*error_ndpan_bcmu = (local_val & ((u32)0x00000020)) >> 5;
	*error_ndpabcsu = (local_val & ((u32)0x00000010)) >> 4;
	*match_sta_num = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_rx_ndpa_stat_ndpa_2_ndptimeot_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline u32 mac_hw_rx_ndpa_stat_reserv_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u32)((local_val & ((u32)0x00FFFF80)) >> 7);
}

static inline u8 mac_hw_rx_ndpa_stat_error_ndpamu_su_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_rx_ndpa_stat_error_ndpan_bcmu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_rx_ndpa_stat_error_ndpabcsu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_rx_ndpa_stat_match_sta_num_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_NDPA_STAT_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

/**
 * @brief BFR_CONTROL_2 register definition
 *  Bfr control register 2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    REDUCED_TX_FIFO_ENABLE    1
 *    27:16 AID                       0x0
 *    15:00 BFR_DURATION              0x0
 * </pre>
 */
#define MAC_HW_BFR_CONTROL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000580)
#define MAC_HW_BFR_CONTROL_2_OFFSET      0x00000580
#define MAC_HW_BFR_CONTROL_2_INDEX       0x00000160
#define MAC_HW_BFR_CONTROL_2_RESET       0x80000000

static inline u32 mac_hw_bfr_control_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR);
}

static inline void mac_hw_bfr_control_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_CONTROL_2_REDUCED_TX_FIFO_ENABLE_BIT    ((u32)0x80000000)
#define MAC_HW_BFR_CONTROL_2_REDUCED_TX_FIFO_ENABLE_POS    31
#define MAC_HW_BFR_CONTROL_2_AID_MASK       ((u32)0x0FFF0000)
#define MAC_HW_BFR_CONTROL_2_AID_LSB        16
#define MAC_HW_BFR_CONTROL_2_AID_WIDTH      ((u32)0x0000000C)
#define MAC_HW_BFR_CONTROL_2_BFR_DURATION_MASK    ((u32)0x0000FFFF)
#define MAC_HW_BFR_CONTROL_2_BFR_DURATION_LSB    0
#define MAC_HW_BFR_CONTROL_2_BFR_DURATION_WIDTH    ((u32)0x00000010)

#define MAC_HW_BFR_CONTROL_2_REDUCED_TX_FIFO_ENABLE_RST    0x1
#define MAC_HW_BFR_CONTROL_2_AID_RST        0x0
#define MAC_HW_BFR_CONTROL_2_BFR_DURATION_RST    0x0

static inline void mac_hw_bfr_control_2_pack(struct cl_chip *chip, u8 reduced_tx_fifo_enable, u16 aid, u16 bfr_duration)
{
	ASSERT_ERR_CHIP((((u32)reduced_tx_fifo_enable << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)aid << 16) & ~((u32)0x0FFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_duration << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_2_ADDR, ((u32)reduced_tx_fifo_enable << 31) | ((u32)aid << 16) | ((u32)bfr_duration << 0));
}

static inline void mac_hw_bfr_control_2_unpack(struct cl_chip *chip, u8 *reduced_tx_fifo_enable, u16 *aid, u16 *bfr_duration)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR);

	*reduced_tx_fifo_enable = (local_val & ((u32)0x80000000)) >> 31;
	*aid = (local_val & ((u32)0x0FFF0000)) >> 16;
	*bfr_duration = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_bfr_control_2_reduced_tx_fifo_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_bfr_control_2_reduced_tx_fifo_enable_setf(struct cl_chip *chip, u8 reducedtxfifoenable)
{
	ASSERT_ERR_CHIP((((u32)reducedtxfifoenable << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR) & ~((u32)0x80000000)) | ((u32)reducedtxfifoenable << 31));
}

static inline u16 mac_hw_bfr_control_2_aid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR);

	return (u16)((local_val & ((u32)0x0FFF0000)) >> 16);
}

static inline void mac_hw_bfr_control_2_aid_setf(struct cl_chip *chip, u16 aid)
{
	ASSERT_ERR_CHIP((((u32)aid << 16) & ~((u32)0x0FFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR) & ~((u32)0x0FFF0000)) | ((u32)aid << 16));
}

static inline u16 mac_hw_bfr_control_2_bfr_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

static inline void mac_hw_bfr_control_2_bfr_duration_setf(struct cl_chip *chip, u16 bfrduration)
{
	ASSERT_ERR_CHIP((((u32)bfrduration << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_2_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_2_ADDR) & ~((u32)0x0000FFFF)) | ((u32)bfrduration << 0));
}

/**
 * @brief BFR_CONTROL_3 register definition
 *  BFR timing control register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    disable_Wait_For_NDP      0
 *    20    skip_Ndpa_Addr_Match      0
 *    17:16 max_BFRch_BW              0x3
 *    12:08 BFRLength_Delay           0x8
 *    04:00 BFRData_Delay             0xA
 * </pre>
 */
#define MAC_HW_BFR_CONTROL_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000584)
#define MAC_HW_BFR_CONTROL_3_OFFSET      0x00000584
#define MAC_HW_BFR_CONTROL_3_INDEX       0x00000161
#define MAC_HW_BFR_CONTROL_3_RESET       0x0003080A

static inline u32 mac_hw_bfr_control_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);
}

static inline void mac_hw_bfr_control_3_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_CONTROL_3_DISABLE_WAIT_FOR_NDP_BIT    ((u32)0x00200000)
#define MAC_HW_BFR_CONTROL_3_DISABLE_WAIT_FOR_NDP_POS    21
#define MAC_HW_BFR_CONTROL_3_SKIP_NDPA_ADDR_MATCH_BIT    ((u32)0x00100000)
#define MAC_HW_BFR_CONTROL_3_SKIP_NDPA_ADDR_MATCH_POS    20
#define MAC_HW_BFR_CONTROL_3_MAX_BFRCH_BW_MASK    ((u32)0x00030000)
#define MAC_HW_BFR_CONTROL_3_MAX_BFRCH_BW_LSB    16
#define MAC_HW_BFR_CONTROL_3_MAX_BFRCH_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_BFR_CONTROL_3_BFRLENGTH_DELAY_MASK    ((u32)0x00001F00)
#define MAC_HW_BFR_CONTROL_3_BFRLENGTH_DELAY_LSB    8
#define MAC_HW_BFR_CONTROL_3_BFRLENGTH_DELAY_WIDTH    ((u32)0x00000005)
#define MAC_HW_BFR_CONTROL_3_BFRDATA_DELAY_MASK    ((u32)0x0000001F)
#define MAC_HW_BFR_CONTROL_3_BFRDATA_DELAY_LSB    0
#define MAC_HW_BFR_CONTROL_3_BFRDATA_DELAY_WIDTH    ((u32)0x00000005)

#define MAC_HW_BFR_CONTROL_3_DISABLE_WAIT_FOR_NDP_RST    0x0
#define MAC_HW_BFR_CONTROL_3_SKIP_NDPA_ADDR_MATCH_RST    0x0
#define MAC_HW_BFR_CONTROL_3_MAX_BFRCH_BW_RST    0x3
#define MAC_HW_BFR_CONTROL_3_BFRLENGTH_DELAY_RST    0x8
#define MAC_HW_BFR_CONTROL_3_BFRDATA_DELAY_RST    0xA

static inline void mac_hw_bfr_control_3_pack(struct cl_chip *chip, u8 disable_wait_for_ndp, u8 skip_ndpa_addr_match, u8 max_bfrch_bw, u8 bfrlength_delay, u8 bfrdata_delay)
{
	ASSERT_ERR_CHIP((((u32)disable_wait_for_ndp << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)skip_ndpa_addr_match << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)max_bfrch_bw << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)bfrlength_delay << 8) & ~((u32)0x00001F00)) == 0);
	ASSERT_ERR_CHIP((((u32)bfrdata_delay << 0) & ~((u32)0x0000001F)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, ((u32)disable_wait_for_ndp << 21) | ((u32)skip_ndpa_addr_match << 20) | ((u32)max_bfrch_bw << 16) | ((u32)bfrlength_delay << 8) | ((u32)bfrdata_delay << 0));
}

static inline void mac_hw_bfr_control_3_unpack(struct cl_chip *chip, u8 *disable_wait_for_ndp, u8 *skip_ndpa_addr_match, u8 *max_bfrch_bw, u8 *bfrlength_delay, u8 *bfrdata_delay)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	*disable_wait_for_ndp = (local_val & ((u32)0x00200000)) >> 21;
	*skip_ndpa_addr_match = (local_val & ((u32)0x00100000)) >> 20;
	*max_bfrch_bw = (local_val & ((u32)0x00030000)) >> 16;
	*bfrlength_delay = (local_val & ((u32)0x00001F00)) >> 8;
	*bfrdata_delay = (local_val & ((u32)0x0000001F)) >> 0;
}

static inline u8 mac_hw_bfr_control_3_disable_wait_for_ndp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_bfr_control_3_disable_wait_for_ndp_setf(struct cl_chip *chip, u8 disablewaitforndp)
{
	ASSERT_ERR_CHIP((((u32)disablewaitforndp << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR) & ~((u32)0x00200000)) | ((u32)disablewaitforndp << 21));
}

static inline u8 mac_hw_bfr_control_3_skip_ndpa_addr_match_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_bfr_control_3_skip_ndpa_addr_match_setf(struct cl_chip *chip, u8 skipndpaaddrmatch)
{
	ASSERT_ERR_CHIP((((u32)skipndpaaddrmatch << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR) & ~((u32)0x00100000)) | ((u32)skipndpaaddrmatch << 20));
}

static inline u8 mac_hw_bfr_control_3_max_bfrch_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_bfr_control_3_max_bfrch_bw_setf(struct cl_chip *chip, u8 maxbfrchbw)
{
	ASSERT_ERR_CHIP((((u32)maxbfrchbw << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR) & ~((u32)0x00030000)) | ((u32)maxbfrchbw << 16));
}

static inline u8 mac_hw_bfr_control_3_bfrlength_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x00001F00)) >> 8);
}

static inline void mac_hw_bfr_control_3_bfrlength_delay_setf(struct cl_chip *chip, u8 bfrlengthdelay)
{
	ASSERT_ERR_CHIP((((u32)bfrlengthdelay << 8) & ~((u32)0x00001F00)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR) & ~((u32)0x00001F00)) | ((u32)bfrlengthdelay << 8));
}

static inline u8 mac_hw_bfr_control_3_bfrdata_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR);

	return (u8)((local_val & ((u32)0x0000001F)) >> 0);
}

static inline void mac_hw_bfr_control_3_bfrdata_delay_setf(struct cl_chip *chip, u8 bfrdatadelay)
{
	ASSERT_ERR_CHIP((((u32)bfrdatadelay << 0) & ~((u32)0x0000001F)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_CONTROL_3_ADDR, (cl_reg_read(chip, MAC_HW_BFR_CONTROL_3_ADDR) & ~((u32)0x0000001F)) | ((u32)bfrdatadelay << 0));
}

/**
 * @brief BFR_GENERAL register definition
 *  General purpose indication from BFR to TxVector register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 antenna_Set               0x0
 *    15:08 general_RC0               0x0
 *    07:00 general_Mac_Ctrl0         0x0
 * </pre>
 */
#define MAC_HW_BFR_GENERAL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000588)
#define MAC_HW_BFR_GENERAL_OFFSET      0x00000588
#define MAC_HW_BFR_GENERAL_INDEX       0x00000162
#define MAC_HW_BFR_GENERAL_RESET       0x00000000

static inline u32 mac_hw_bfr_general_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR);
}

static inline void mac_hw_bfr_general_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_BFR_GENERAL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_BFR_GENERAL_ANTENNA_SET_MASK    ((u32)0xFFFF0000)
#define MAC_HW_BFR_GENERAL_ANTENNA_SET_LSB    16
#define MAC_HW_BFR_GENERAL_ANTENNA_SET_WIDTH    ((u32)0x00000010)
#define MAC_HW_BFR_GENERAL_GENERAL_RC_0_MASK    ((u32)0x0000FF00)
#define MAC_HW_BFR_GENERAL_GENERAL_RC_0_LSB    8
#define MAC_HW_BFR_GENERAL_GENERAL_RC_0_WIDTH    ((u32)0x00000008)
#define MAC_HW_BFR_GENERAL_GENERAL_MAC_CTRL_0_MASK    ((u32)0x000000FF)
#define MAC_HW_BFR_GENERAL_GENERAL_MAC_CTRL_0_LSB    0
#define MAC_HW_BFR_GENERAL_GENERAL_MAC_CTRL_0_WIDTH    ((u32)0x00000008)

#define MAC_HW_BFR_GENERAL_ANTENNA_SET_RST    0x0
#define MAC_HW_BFR_GENERAL_GENERAL_RC_0_RST    0x0
#define MAC_HW_BFR_GENERAL_GENERAL_MAC_CTRL_0_RST    0x0

static inline void mac_hw_bfr_general_pack(struct cl_chip *chip, u16 antenna_set, u8 general_rc0, u8 general_mac_ctrl0)
{
	ASSERT_ERR_CHIP((((u32)antenna_set << 16) & ~((u32)0xFFFF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)general_rc0 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)general_mac_ctrl0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_GENERAL_ADDR, ((u32)antenna_set << 16) | ((u32)general_rc0 << 8) | ((u32)general_mac_ctrl0 << 0));
}

static inline void mac_hw_bfr_general_unpack(struct cl_chip *chip, u16 *antenna_set, u8 *general_rc0, u8 *general_mac_ctrl0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR);

	*antenna_set = (local_val & ((u32)0xFFFF0000)) >> 16;
	*general_rc0 = (local_val & ((u32)0x0000FF00)) >> 8;
	*general_mac_ctrl0 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u16 mac_hw_bfr_general_antenna_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline void mac_hw_bfr_general_antenna_set_setf(struct cl_chip *chip, u16 antennaset)
{
	ASSERT_ERR_CHIP((((u32)antennaset << 16) & ~((u32)0xFFFF0000)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_GENERAL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR) & ~((u32)0xFFFF0000)) | ((u32)antennaset << 16));
}

static inline u8 mac_hw_bfr_general_general_rc_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_bfr_general_general_rc_0_setf(struct cl_chip *chip, u8 generalrc0)
{
	ASSERT_ERR_CHIP((((u32)generalrc0 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_GENERAL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR) & ~((u32)0x0000FF00)) | ((u32)generalrc0 << 8));
}

static inline u8 mac_hw_bfr_general_general_mac_ctrl_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_bfr_general_general_mac_ctrl_0_setf(struct cl_chip *chip, u8 generalmacctrl0)
{
	ASSERT_ERR_CHIP((((u32)generalmacctrl0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_BFR_GENERAL_ADDR, (cl_reg_read(chip, MAC_HW_BFR_GENERAL_ADDR) & ~((u32)0x000000FF)) | ((u32)generalmacctrl0 << 0));
}

/**
 * @brief NAV_LIMIT register definition
 *  Indicates the NAV upper LIMIT register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 NAV_LIMIT                 0x0
 * </pre>
 */
#define MAC_HW_NAV_LIMIT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000590)
#define MAC_HW_NAV_LIMIT_OFFSET      0x00000590
#define MAC_HW_NAV_LIMIT_INDEX       0x00000164
#define MAC_HW_NAV_LIMIT_RESET       0x00000000

static inline u32 mac_hw_nav_limit_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NAV_LIMIT_ADDR);
}

static inline void mac_hw_nav_limit_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_NAV_LIMIT_ADDR, value);
}

/* Field definitions */
#define MAC_HW_NAV_LIMIT_NAV_LIMIT_MASK     ((u32)0x0000FFFF)
#define MAC_HW_NAV_LIMIT_NAV_LIMIT_LSB      0
#define MAC_HW_NAV_LIMIT_NAV_LIMIT_WIDTH    ((u32)0x00000010)

#define MAC_HW_NAV_LIMIT_NAV_LIMIT_RST      0x0

static inline u16 mac_hw_nav_limit_nav_limit_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NAV_LIMIT_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_nav_limit_nav_limit_setf(struct cl_chip *chip, u16 navlimit)
{
	ASSERT_ERR_CHIP((((u32)navlimit << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_NAV_LIMIT_ADDR, (u32)navlimit << 0);
}

/**
 * @brief NAV_OVERRIDE register definition
 *  Indicates NAV override value register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    15:00 NAV_VALUE_SET             0x0
 * </pre>
 */
#define MAC_HW_NAV_OVERRIDE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000594)
#define MAC_HW_NAV_OVERRIDE_OFFSET      0x00000594
#define MAC_HW_NAV_OVERRIDE_INDEX       0x00000165
#define MAC_HW_NAV_OVERRIDE_RESET       0x00000000

static inline u32 mac_hw_nav_override_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NAV_OVERRIDE_ADDR);
}

static inline void mac_hw_nav_override_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_NAV_OVERRIDE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_NAV_OVERRIDE_NAV_VALUE_SET_MASK    ((u32)0x0000FFFF)
#define MAC_HW_NAV_OVERRIDE_NAV_VALUE_SET_LSB    0
#define MAC_HW_NAV_OVERRIDE_NAV_VALUE_SET_WIDTH    ((u32)0x00000010)

#define MAC_HW_NAV_OVERRIDE_NAV_VALUE_SET_RST    0x0

static inline u16 mac_hw_nav_override_nav_value_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NAV_OVERRIDE_ADDR);

	return (u16)(local_val >> 0);
}

static inline void mac_hw_nav_override_nav_value_set_setf(struct cl_chip *chip, u16 navvalueset)
{
	ASSERT_ERR_CHIP((((u32)navvalueset << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_NAV_OVERRIDE_ADDR, (u32)navvalueset << 0);
}

/**
 * @brief MAC_HW_SPARE_1_REG register definition
 *  spare register to be used for ECO fixes register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:04 SPARE                     0x0
 *    03:00 SEC_TRIG_SRC              0x0
 * </pre>
 */
#define MAC_HW_MAC_HW_SPARE_1_REG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000600)
#define MAC_HW_MAC_HW_SPARE_1_REG_OFFSET      0x00000600
#define MAC_HW_MAC_HW_SPARE_1_REG_INDEX       0x00000180
#define MAC_HW_MAC_HW_SPARE_1_REG_RESET       0x00000000

static inline u32 mac_hw_mac_hw_spare_1_reg_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR);
}

static inline void mac_hw_mac_hw_spare_1_reg_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_HW_SPARE_1_REG_SPARE_MASK    ((u32)0xFFFFFFF0)
#define MAC_HW_MAC_HW_SPARE_1_REG_SPARE_LSB    4
#define MAC_HW_MAC_HW_SPARE_1_REG_SPARE_WIDTH    ((u32)0x0000001C)
#define MAC_HW_MAC_HW_SPARE_1_REG_SEC_TRIG_SRC_MASK    ((u32)0x0000000F)
#define MAC_HW_MAC_HW_SPARE_1_REG_SEC_TRIG_SRC_LSB    0
#define MAC_HW_MAC_HW_SPARE_1_REG_SEC_TRIG_SRC_WIDTH    ((u32)0x00000004)

#define MAC_HW_MAC_HW_SPARE_1_REG_SPARE_RST    0x0
#define MAC_HW_MAC_HW_SPARE_1_REG_SEC_TRIG_SRC_RST    0x0

static inline void mac_hw_mac_hw_spare_1_reg_pack(struct cl_chip *chip, u32 spare, u8 sec_trig_src)
{
	ASSERT_ERR_CHIP((((u32)spare << 4) & ~((u32)0xFFFFFFF0)) == 0);
	ASSERT_ERR_CHIP((((u32)sec_trig_src << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR, ((u32)spare << 4) | ((u32)sec_trig_src << 0));
}

static inline void mac_hw_mac_hw_spare_1_reg_unpack(struct cl_chip *chip, u32 *spare, u8 *sec_trig_src)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR);

	*spare = (local_val & ((u32)0xFFFFFFF0)) >> 4;
	*sec_trig_src = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u32 mac_hw_mac_hw_spare_1_reg_spare_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFFF0)) >> 4);
}

static inline void mac_hw_mac_hw_spare_1_reg_spare_setf(struct cl_chip *chip, u32 spare)
{
	ASSERT_ERR_CHIP((((u32)spare << 4) & ~((u32)0xFFFFFFF0)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR) & ~((u32)0xFFFFFFF0)) | ((u32)spare << 4));
}

static inline u8 mac_hw_mac_hw_spare_1_reg_sec_trig_src_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_mac_hw_spare_1_reg_sec_trig_src_setf(struct cl_chip *chip, u8 sectrigsrc)
{
	ASSERT_ERR_CHIP((((u32)sectrigsrc << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_1_REG_ADDR) & ~((u32)0x0000000F)) | ((u32)sectrigsrc << 0));
}

/**
 * @brief ERROR_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused LMAC Error interrupt register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008000)
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_OFFSET      0x00008000
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_INDEX       0x00002000
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_error_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief GEN_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused LMAC General interrupt register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008004)
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_OFFSET      0x00008004
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_INDEX       0x00002001
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_GEN_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_gen_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief HIGH_PRI_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused LMAC Hi Priority inter register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008008)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_OFFSET      0x00008008
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_INDEX       0x00002002
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_high_pri_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused the LMAC RX interrupt register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000800C)
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_OFFSET      0x0000800C
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_INDEX       0x00002003
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_rx_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TIMER_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused LMAC Timer interrupt register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008010)
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_OFFSET      0x00008010
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_INDEX       0x00002004
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_timer_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TX_INT_MAC_SOURCE_LMAC register definition
 *  Indicates which MAC caused the LMAC TX interrupt register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008014)
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_OFFSET      0x00008014
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_INDEX       0x00002005
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_mac_source_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_INT_MAC_SOURCE_LMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_tx_int_mac_source_lmac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_LMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief NEXT_TBTT register definition
 *  Indicates the remaining time until the next TBTT register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25:00 NEXT_TBTT                 0x0
 * </pre>
 */
#define MAC_HW_NEXT_TBTT_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008040)
#define MAC_HW_NEXT_TBTT_OFFSET      0x00008040
#define MAC_HW_NEXT_TBTT_INDEX       0x00002010
#define MAC_HW_NEXT_TBTT_RESET       0x00000000

static inline u32 mac_hw_next_tbtt_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_NEXT_TBTT_ADDR);
}

/* Field definitions */
#define MAC_HW_NEXT_TBTT_NEXT_TBTT_MASK     ((u32)0x03FFFFFF)
#define MAC_HW_NEXT_TBTT_NEXT_TBTT_LSB      0
#define MAC_HW_NEXT_TBTT_NEXT_TBTT_WIDTH    ((u32)0x0000001A)

#define MAC_HW_NEXT_TBTT_NEXT_TBTT_RST      0x0

static inline u32 mac_hw_next_tbtt_next_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_NEXT_TBTT_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DOZE_CNTRL_2 register definition
 *  Contains settings for controlling DOZE state. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    WAKE_UP_FROM_DOZE         0
 *    00    WAKE_UP_SW                1
 * </pre>
 */
#define MAC_HW_DOZE_CNTRL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008048)
#define MAC_HW_DOZE_CNTRL_2_OFFSET      0x00008048
#define MAC_HW_DOZE_CNTRL_2_INDEX       0x00002012
#define MAC_HW_DOZE_CNTRL_2_RESET       0x00000001

static inline u32 mac_hw_doze_cntrl_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR);
}

static inline void mac_hw_doze_cntrl_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_FROM_DOZE_BIT    ((u32)0x80000000)
#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_FROM_DOZE_POS    31
#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_SW_BIT    ((u32)0x00000001)
#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_SW_POS    0

#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_FROM_DOZE_RST    0x0
#define MAC_HW_DOZE_CNTRL_2_WAKE_UP_SW_RST    0x1

static inline void mac_hw_doze_cntrl_2_pack(struct cl_chip *chip, u8 wake_up_from_doze, u8 wake_up_sw)
{
	ASSERT_ERR_CHIP((((u32)wake_up_from_doze << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)wake_up_sw << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_2_ADDR, ((u32)wake_up_from_doze << 31) | ((u32)wake_up_sw << 0));
}

static inline void mac_hw_doze_cntrl_2_unpack(struct cl_chip *chip, u8 *wake_up_from_doze, u8 *wake_up_sw)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR);

	*wake_up_from_doze = (local_val & ((u32)0x80000000)) >> 31;
	*wake_up_sw = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_doze_cntrl_2_wake_up_from_doze_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_doze_cntrl_2_wake_up_from_doze_setf(struct cl_chip *chip, u8 wakeupfromdoze)
{
	ASSERT_ERR_CHIP((((u32)wakeupfromdoze << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR) & ~((u32)0x80000000)) | ((u32)wakeupfromdoze << 31));
}

static inline u8 mac_hw_doze_cntrl_2_wake_up_sw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_doze_cntrl_2_wake_up_sw_setf(struct cl_chip *chip, u8 wakeupsw)
{
	ASSERT_ERR_CHIP((((u32)wakeupsw << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DOZE_CNTRL_2_ADDR, (cl_reg_read(chip, MAC_HW_DOZE_CNTRL_2_ADDR) & ~((u32)0x00000001)) | ((u32)wakeupsw << 0));
}

/**
 * @brief MAC_CNTRL_2 register definition
 *  Contains various settings for controlling the operation of the core. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    00    SOFT_RESET                0
 * </pre>
 */
#define MAC_HW_MAC_CNTRL_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008050)
#define MAC_HW_MAC_CNTRL_2_OFFSET      0x00008050
#define MAC_HW_MAC_CNTRL_2_INDEX       0x00002014
#define MAC_HW_MAC_CNTRL_2_RESET       0x00000000

static inline u32 mac_hw_mac_cntrl_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_CNTRL_2_ADDR);
}

static inline void mac_hw_mac_cntrl_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_CNTRL_2_SOFT_RESET_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_CNTRL_2_SOFT_RESET_POS    0

#define MAC_HW_MAC_CNTRL_2_SOFT_RESET_RST    0x0

static inline u8 mac_hw_mac_cntrl_2_soft_reset_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_CNTRL_2_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_mac_cntrl_2_soft_reset_setf(struct cl_chip *chip, u8 softreset)
{
	ASSERT_ERR_CHIP((((u32)softreset << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_CNTRL_2_ADDR, (u32)softreset << 0);
}

/**
 * @brief TSF_LO register definition
 *  Contains the TSF bits. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TSF_TIMER_LOW             0x0
 * </pre>
 */
#define MAC_HW_TSF_LO_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080A4)
#define MAC_HW_TSF_LO_OFFSET      0x000080A4
#define MAC_HW_TSF_LO_INDEX       0x00002029
#define MAC_HW_TSF_LO_RESET       0x00000000

static inline u32 mac_hw_tsf_lo_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TSF_LO_ADDR);
}

static inline void mac_hw_tsf_lo_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TSF_LO_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TSF_LO_TSF_TIMER_LOW_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TSF_LO_TSF_TIMER_LOW_LSB     0
#define MAC_HW_TSF_LO_TSF_TIMER_LOW_WIDTH    ((u32)0x00000020)

#define MAC_HW_TSF_LO_TSF_TIMER_LOW_RST     0x0

static inline u32 mac_hw_tsf_lo_tsf_timer_low_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TSF_LO_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tsf_lo_tsf_timer_low_setf(struct cl_chip *chip, u32 tsftimerlow)
{
	ASSERT_ERR_CHIP((((u32)tsftimerlow << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TSF_LO_ADDR, (u32)tsftimerlow << 0);
}

/**
 * @brief TSF_HI register definition
 *  Contains the TSF bits. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TSF_TIMER_HIGH            0x0
 * </pre>
 */
#define MAC_HW_TSF_HI_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080A8)
#define MAC_HW_TSF_HI_OFFSET      0x000080A8
#define MAC_HW_TSF_HI_INDEX       0x0000202A
#define MAC_HW_TSF_HI_RESET       0x00000000

static inline u32 mac_hw_tsf_hi_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TSF_HI_ADDR);
}

static inline void mac_hw_tsf_hi_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TSF_HI_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TSF_HI_TSF_TIMER_HIGH_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TSF_HI_TSF_TIMER_HIGH_LSB    0
#define MAC_HW_TSF_HI_TSF_TIMER_HIGH_WIDTH    ((u32)0x00000020)

#define MAC_HW_TSF_HI_TSF_TIMER_HIGH_RST    0x0

static inline u32 mac_hw_tsf_hi_tsf_timer_high_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TSF_HI_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tsf_hi_tsf_timer_high_setf(struct cl_chip *chip, u32 tsftimerhigh)
{
	ASSERT_ERR_CHIP((((u32)tsftimerhigh << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TSF_HI_ADDR, (u32)tsftimerhigh << 0);
}

/**
 * @brief AGGR_STATUS register definition
 *  Shows status debug information for the agg closing register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21:16 tx_Data_Delay_Cnt         0x0
 *    15    tx_Data_Delay_TC          1
 *    12:08 tx_List_Proc_Cs           0x0
 *    07    wait_For_Natt             0
 *    06    natt_Start                0
 *    05:04 available_BW              0x0
 *    03:02 bw_Tx                     0x0
 *    01:00 Ch_BW                     0x0
 * </pre>
 */
#define MAC_HW_AGGR_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080B8)
#define MAC_HW_AGGR_STATUS_OFFSET      0x000080B8
#define MAC_HW_AGGR_STATUS_INDEX       0x0000202E
#define MAC_HW_AGGR_STATUS_RESET       0x00008000

static inline u32 mac_hw_aggr_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_CNT_MASK    ((u32)0x003F0000)
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_CNT_LSB    16
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_CNT_WIDTH    ((u32)0x00000006)
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_TC_BIT    ((u32)0x00008000)
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_TC_POS    15
#define MAC_HW_AGGR_STATUS_TX_LIST_PROC_CS_MASK    ((u32)0x00001F00)
#define MAC_HW_AGGR_STATUS_TX_LIST_PROC_CS_LSB    8
#define MAC_HW_AGGR_STATUS_TX_LIST_PROC_CS_WIDTH    ((u32)0x00000005)
#define MAC_HW_AGGR_STATUS_WAIT_FOR_NATT_BIT    ((u32)0x00000080)
#define MAC_HW_AGGR_STATUS_WAIT_FOR_NATT_POS    7
#define MAC_HW_AGGR_STATUS_NATT_START_BIT    ((u32)0x00000040)
#define MAC_HW_AGGR_STATUS_NATT_START_POS    6
#define MAC_HW_AGGR_STATUS_AVAILABLE_BW_MASK    ((u32)0x00000030)
#define MAC_HW_AGGR_STATUS_AVAILABLE_BW_LSB    4
#define MAC_HW_AGGR_STATUS_AVAILABLE_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_AGGR_STATUS_BW_TX_MASK       ((u32)0x0000000C)
#define MAC_HW_AGGR_STATUS_BW_TX_LSB        2
#define MAC_HW_AGGR_STATUS_BW_TX_WIDTH      ((u32)0x00000002)
#define MAC_HW_AGGR_STATUS_CH_BW_MASK       ((u32)0x00000003)
#define MAC_HW_AGGR_STATUS_CH_BW_LSB        0
#define MAC_HW_AGGR_STATUS_CH_BW_WIDTH      ((u32)0x00000002)

#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_CNT_RST    0x0
#define MAC_HW_AGGR_STATUS_TX_DATA_DELAY_TC_RST    0x1
#define MAC_HW_AGGR_STATUS_TX_LIST_PROC_CS_RST    0x0
#define MAC_HW_AGGR_STATUS_WAIT_FOR_NATT_RST    0x0
#define MAC_HW_AGGR_STATUS_NATT_START_RST    0x0
#define MAC_HW_AGGR_STATUS_AVAILABLE_BW_RST    0x0
#define MAC_HW_AGGR_STATUS_BW_TX_RST        0x0
#define MAC_HW_AGGR_STATUS_CH_BW_RST        0x0

static inline void mac_hw_aggr_status_unpack(struct cl_chip *chip, u8 *tx_data_delay_cnt, u8 *tx_data_delay_tc, u8 *tx_list_proc_cs, u8 *wait_for_natt, u8 *natt_start, u8 *available_bw, u8 *bw_tx, u8 *ch_bw)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	*tx_data_delay_cnt = (local_val & ((u32)0x003F0000)) >> 16;
	*tx_data_delay_tc = (local_val & ((u32)0x00008000)) >> 15;
	*tx_list_proc_cs = (local_val & ((u32)0x00001F00)) >> 8;
	*wait_for_natt = (local_val & ((u32)0x00000080)) >> 7;
	*natt_start = (local_val & ((u32)0x00000040)) >> 6;
	*available_bw = (local_val & ((u32)0x00000030)) >> 4;
	*bw_tx = (local_val & ((u32)0x0000000C)) >> 2;
	*ch_bw = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_aggr_status_tx_data_delay_cnt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x003F0000)) >> 16);
}

static inline u8 mac_hw_aggr_status_tx_data_delay_tc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_aggr_status_tx_list_proc_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00001F00)) >> 8);
}

static inline u8 mac_hw_aggr_status_wait_for_natt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_aggr_status_natt_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_aggr_status_available_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline u8 mac_hw_aggr_status_bw_tx_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x0000000C)) >> 2);
}

static inline u8 mac_hw_aggr_status_ch_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

/**
 * @brief AGGR_CONFIG register definition
 *  Configurations for aggregation closing register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23    PRE_TYPE_PROT_TX_CONF     0
 *    22:16 MCS_INDEX0_PROT_TX_CONF   0x4
 *    13    MULTIPLE_AMPDU            1
 *    12:10 FORMAT_MOD_PROT_TX_CONF   0x1
 *    09:04 TX_DATA_DELAY             0x0
 *    03    MEDIUM_TIME_ENABLED       0
 *    02    FAILED_BW_SIGNALING_DIS   0
 *    01    CL2400_MACPHYIFMODE       0
 *    00    CL2400_RCMODE             0
 * </pre>
 */
#define MAC_HW_AGGR_CONFIG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080BC)
#define MAC_HW_AGGR_CONFIG_OFFSET      0x000080BC
#define MAC_HW_AGGR_CONFIG_INDEX       0x0000202F
#define MAC_HW_AGGR_CONFIG_RESET       0x0F042400

static inline u32 mac_hw_aggr_config_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);
}

static inline void mac_hw_aggr_config_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, value);
}

/* Field definitions */
#define MAC_HW_AGGR_CONFIG_PRE_TYPE_PROT_TX_CONF_BIT    ((u32)0x00800000)
#define MAC_HW_AGGR_CONFIG_PRE_TYPE_PROT_TX_CONF_POS    23
#define MAC_HW_AGGR_CONFIG_MCS_INDEX_0_PROT_TX_CONF_MASK    ((u32)0x007F0000)
#define MAC_HW_AGGR_CONFIG_MCS_INDEX_0_PROT_TX_CONF_LSB    16
#define MAC_HW_AGGR_CONFIG_MCS_INDEX_0_PROT_TX_CONF_WIDTH    ((u32)0x00000007)
#define MAC_HW_AGGR_CONFIG_MULTIPLE_AMPDU_BIT    ((u32)0x00002000)
#define MAC_HW_AGGR_CONFIG_MULTIPLE_AMPDU_POS    13
#define MAC_HW_AGGR_CONFIG_FORMAT_MOD_PROT_TX_CONF_MASK    ((u32)0x00001C00)
#define MAC_HW_AGGR_CONFIG_FORMAT_MOD_PROT_TX_CONF_LSB    10
#define MAC_HW_AGGR_CONFIG_FORMAT_MOD_PROT_TX_CONF_WIDTH    ((u32)0x00000003)
#define MAC_HW_AGGR_CONFIG_TX_DATA_DELAY_MASK    ((u32)0x000003F0)
#define MAC_HW_AGGR_CONFIG_TX_DATA_DELAY_LSB    4
#define MAC_HW_AGGR_CONFIG_TX_DATA_DELAY_WIDTH    ((u32)0x00000006)
#define MAC_HW_AGGR_CONFIG_MEDIUM_TIME_ENABLED_BIT    ((u32)0x00000008)
#define MAC_HW_AGGR_CONFIG_MEDIUM_TIME_ENABLED_POS    3
#define MAC_HW_AGGR_CONFIG_FAILED_BW_SIGNALING_DIS_BIT    ((u32)0x00000004)
#define MAC_HW_AGGR_CONFIG_FAILED_BW_SIGNALING_DIS_POS    2
#define MAC_HW_AGGR_CONFIG_CL_2400_MACPHYIFMODE_BIT    ((u32)0x00000002)
#define MAC_HW_AGGR_CONFIG_CL_2400_MACPHYIFMODE_POS    1
#define MAC_HW_AGGR_CONFIG_CL_2400_RCMODE_BIT    ((u32)0x00000001)
#define MAC_HW_AGGR_CONFIG_CL_2400_RCMODE_POS    0

#define MAC_HW_AGGR_CONFIG_PRE_TYPE_PROT_TX_CONF_RST    0x0
#define MAC_HW_AGGR_CONFIG_MCS_INDEX_0_PROT_TX_CONF_RST    0x4
#define MAC_HW_AGGR_CONFIG_MULTIPLE_AMPDU_RST    0x1
#define MAC_HW_AGGR_CONFIG_FORMAT_MOD_PROT_TX_CONF_RST    0x1
#define MAC_HW_AGGR_CONFIG_TX_DATA_DELAY_RST    0x0
#define MAC_HW_AGGR_CONFIG_MEDIUM_TIME_ENABLED_RST    0x0
#define MAC_HW_AGGR_CONFIG_FAILED_BW_SIGNALING_DIS_RST    0x0
#define MAC_HW_AGGR_CONFIG_CL_2400_MACPHYIFMODE_RST    0x0
#define MAC_HW_AGGR_CONFIG_CL_2400_RCMODE_RST    0x0

static inline void mac_hw_aggr_config_pack(struct cl_chip *chip, u8 pre_type_prot_tx_conf, u8 mcs_index0_prot_tx_conf, u8 multiple_ampdu, u8 format_mod_prot_tx_conf, u8 tx_data_delay, u8 medium_time_enabled, u8 failed_bw_signaling_dis, u8 cl2400_macphyifmode, u8 cl2400_rcmode)
{
	ASSERT_ERR_CHIP((((u32)pre_type_prot_tx_conf << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)mcs_index0_prot_tx_conf << 16) & ~((u32)0x007F0000)) == 0);
	ASSERT_ERR_CHIP((((u32)multiple_ampdu << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)format_mod_prot_tx_conf << 10) & ~((u32)0x00001C00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_data_delay << 4) & ~((u32)0x000003F0)) == 0);
	ASSERT_ERR_CHIP((((u32)medium_time_enabled << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)failed_bw_signaling_dis << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)cl2400_macphyifmode << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)cl2400_rcmode << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, ((u32)pre_type_prot_tx_conf << 23) | ((u32)mcs_index0_prot_tx_conf << 16) | ((u32)multiple_ampdu << 13) | ((u32)format_mod_prot_tx_conf << 10) | ((u32)tx_data_delay << 4) | ((u32)medium_time_enabled << 3) | ((u32)failed_bw_signaling_dis << 2) | ((u32)cl2400_macphyifmode << 1) | ((u32)cl2400_rcmode << 0));
}

static inline void mac_hw_aggr_config_unpack(struct cl_chip *chip, u8 *pre_type_prot_tx_conf, u8 *mcs_index0_prot_tx_conf, u8 *multiple_ampdu, u8 *format_mod_prot_tx_conf, u8 *tx_data_delay, u8 *medium_time_enabled, u8 *failed_bw_signaling_dis, u8 *cl2400_macphyifmode, u8 *cl2400_rcmode)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	*pre_type_prot_tx_conf = (local_val & ((u32)0x00800000)) >> 23;
	*mcs_index0_prot_tx_conf = (local_val & ((u32)0x007F0000)) >> 16;
	*multiple_ampdu = (local_val & ((u32)0x00002000)) >> 13;
	*format_mod_prot_tx_conf = (local_val & ((u32)0x00001C00)) >> 10;
	*tx_data_delay = (local_val & ((u32)0x000003F0)) >> 4;
	*medium_time_enabled = (local_val & ((u32)0x00000008)) >> 3;
	*failed_bw_signaling_dis = (local_val & ((u32)0x00000004)) >> 2;
	*cl2400_macphyifmode = (local_val & ((u32)0x00000002)) >> 1;
	*cl2400_rcmode = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_aggr_config_pre_type_prot_tx_conf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_aggr_config_pre_type_prot_tx_conf_setf(struct cl_chip *chip, u8 pretypeprottxconf)
{
	ASSERT_ERR_CHIP((((u32)pretypeprottxconf << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00800000)) | ((u32)pretypeprottxconf << 23));
}

static inline u8 mac_hw_aggr_config_mcs_index_0_prot_tx_conf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x007F0000)) >> 16);
}

static inline void mac_hw_aggr_config_mcs_index_0_prot_tx_conf_setf(struct cl_chip *chip, u8 mcsindex0prottxconf)
{
	ASSERT_ERR_CHIP((((u32)mcsindex0prottxconf << 16) & ~((u32)0x007F0000)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x007F0000)) | ((u32)mcsindex0prottxconf << 16));
}

static inline u8 mac_hw_aggr_config_multiple_ampdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_aggr_config_multiple_ampdu_setf(struct cl_chip *chip, u8 multipleampdu)
{
	ASSERT_ERR_CHIP((((u32)multipleampdu << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00002000)) | ((u32)multipleampdu << 13));
}

static inline u8 mac_hw_aggr_config_format_mod_prot_tx_conf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00001C00)) >> 10);
}

static inline void mac_hw_aggr_config_format_mod_prot_tx_conf_setf(struct cl_chip *chip, u8 formatmodprottxconf)
{
	ASSERT_ERR_CHIP((((u32)formatmodprottxconf << 10) & ~((u32)0x00001C00)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00001C00)) | ((u32)formatmodprottxconf << 10));
}

static inline u8 mac_hw_aggr_config_tx_data_delay_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x000003F0)) >> 4);
}

static inline void mac_hw_aggr_config_tx_data_delay_setf(struct cl_chip *chip, u8 txdatadelay)
{
	ASSERT_ERR_CHIP((((u32)txdatadelay << 4) & ~((u32)0x000003F0)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x000003F0)) | ((u32)txdatadelay << 4));
}

static inline u8 mac_hw_aggr_config_medium_time_enabled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_aggr_config_medium_time_enabled_setf(struct cl_chip *chip, u8 mediumtimeenabled)
{
	ASSERT_ERR_CHIP((((u32)mediumtimeenabled << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00000008)) | ((u32)mediumtimeenabled << 3));
}

static inline u8 mac_hw_aggr_config_failed_bw_signaling_dis_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_aggr_config_failed_bw_signaling_dis_setf(struct cl_chip *chip, u8 failedbwsignalingdis)
{
	ASSERT_ERR_CHIP((((u32)failedbwsignalingdis << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00000004)) | ((u32)failedbwsignalingdis << 2));
}

static inline u8 mac_hw_aggr_config_cl_2400_macphyifmode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_aggr_config_cl_2400_macphyifmode_setf(struct cl_chip *chip, u8 cl2400macphyifmode)
{
	ASSERT_ERR_CHIP((((u32)cl2400macphyifmode << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00000002)) | ((u32)cl2400macphyifmode << 1));
}

static inline u8 mac_hw_aggr_config_cl_2400_rcmode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_aggr_config_cl_2400_rcmode_setf(struct cl_chip *chip, u8 cl2400rcmode)
{
	ASSERT_ERR_CHIP((((u32)cl2400rcmode << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_AGGR_CONFIG_ADDR, (cl_reg_read(chip, MAC_HW_AGGR_CONFIG_ADDR) & ~((u32)0x00000001)) | ((u32)cl2400rcmode << 0));
}

/**
 * @brief TX_PROT_POWER_LEVEL register definition
 *  Tx Protection power level settings register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:24 TX_PROT_POWER_LEVEL_3     0x0F
 *    23:16 TX_PROT_POWER_LEVEL_2     0x0F
 *    15:08 TX_PROT_POWER_LEVEL_1     0x0F
 *    07:00 TX_PROT_POWER_LEVEL_0     0x0F
 * </pre>
 */
#define MAC_HW_TX_PROT_POWER_LEVEL_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080C0)
#define MAC_HW_TX_PROT_POWER_LEVEL_OFFSET      0x000080C0
#define MAC_HW_TX_PROT_POWER_LEVEL_INDEX       0x00002030
#define MAC_HW_TX_PROT_POWER_LEVEL_RESET       0x0F0F0F0F

static inline u32 mac_hw_tx_prot_power_level_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);
}

static inline void mac_hw_tx_prot_power_level_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_3_MASK    ((u32)0xFF000000)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_3_LSB    24
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_3_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_2_MASK    ((u32)0x00FF0000)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_2_LSB    16
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_2_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_1_MASK    ((u32)0x0000FF00)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_1_LSB    8
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_1_WIDTH    ((u32)0x00000008)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_0_MASK    ((u32)0x000000FF)
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_0_LSB    0
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_0_WIDTH    ((u32)0x00000008)

#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_3_RST    0x0F
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_2_RST    0x0F
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_1_RST    0x0F
#define MAC_HW_TX_PROT_POWER_LEVEL_TX_PROT_POWER_LEVEL_0_RST    0x0F

static inline void mac_hw_tx_prot_power_level_pack(struct cl_chip *chip, u8 tx_prot_power_level_3, u8 tx_prot_power_level_2, u8 tx_prot_power_level_1, u8 tx_prot_power_level_0)
{
	ASSERT_ERR_CHIP((((u32)tx_prot_power_level_3 << 24) & ~((u32)0xFF000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_prot_power_level_2 << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_prot_power_level_1 << 8) & ~((u32)0x0000FF00)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_prot_power_level_0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, ((u32)tx_prot_power_level_3 << 24) | ((u32)tx_prot_power_level_2 << 16) | ((u32)tx_prot_power_level_1 << 8) | ((u32)tx_prot_power_level_0 << 0));
}

static inline void mac_hw_tx_prot_power_level_unpack(struct cl_chip *chip, u8 *tx_prot_power_level_3, u8 *tx_prot_power_level_2, u8 *tx_prot_power_level_1, u8 *tx_prot_power_level_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);

	*tx_prot_power_level_3 = (local_val & ((u32)0xFF000000)) >> 24;
	*tx_prot_power_level_2 = (local_val & ((u32)0x00FF0000)) >> 16;
	*tx_prot_power_level_1 = (local_val & ((u32)0x0000FF00)) >> 8;
	*tx_prot_power_level_0 = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_tx_prot_power_level_tx_prot_power_level_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0xFF000000)) >> 24);
}

static inline void mac_hw_tx_prot_power_level_tx_prot_power_level_3_setf(struct cl_chip *chip, u8 txprotpowerlevel3)
{
	ASSERT_ERR_CHIP((((u32)txprotpowerlevel3 << 24) & ~((u32)0xFF000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR) & ~((u32)0xFF000000)) | ((u32)txprotpowerlevel3 << 24));
}

static inline u8 mac_hw_tx_prot_power_level_tx_prot_power_level_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_tx_prot_power_level_tx_prot_power_level_2_setf(struct cl_chip *chip, u8 txprotpowerlevel2)
{
	ASSERT_ERR_CHIP((((u32)txprotpowerlevel2 << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR) & ~((u32)0x00FF0000)) | ((u32)txprotpowerlevel2 << 16));
}

static inline u8 mac_hw_tx_prot_power_level_tx_prot_power_level_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x0000FF00)) >> 8);
}

static inline void mac_hw_tx_prot_power_level_tx_prot_power_level_1_setf(struct cl_chip *chip, u8 txprotpowerlevel1)
{
	ASSERT_ERR_CHIP((((u32)txprotpowerlevel1 << 8) & ~((u32)0x0000FF00)) == 0);
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR) & ~((u32)0x0000FF00)) | ((u32)txprotpowerlevel1 << 8));
}

static inline u8 mac_hw_tx_prot_power_level_tx_prot_power_level_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_tx_prot_power_level_tx_prot_power_level_0_setf(struct cl_chip *chip, u8 txprotpowerlevel0)
{
	ASSERT_ERR_CHIP((((u32)txprotpowerlevel0 << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR, (cl_reg_read(chip, MAC_HW_TX_PROT_POWER_LEVEL_ADDR) & ~((u32)0x000000FF)) | ((u32)txprotpowerlevel0 << 0));
}

/**
 * @brief TIME_ON_AIR_PARAM_1 register definition
 *  This register contains parameters used for computing time taken for packet on air. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 PPDU_STBC                 0x0
 *    29:28 PPDU_NUM_EXTN_SS          0x0
 *    27    PPDU_SHORT_GI             0
 *    26:24 PPDU_PRE_TYPE             0x0
 *    23:22 PPDU_BW                   0x0
 *    19:00 PPDU_LENGTH               0x0
 * </pre>
 */
#define MAC_HW_TIME_ON_AIR_PARAM_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080D0)
#define MAC_HW_TIME_ON_AIR_PARAM_1_OFFSET      0x000080D0
#define MAC_HW_TIME_ON_AIR_PARAM_1_INDEX       0x00002034
#define MAC_HW_TIME_ON_AIR_PARAM_1_RESET       0x00000000

static inline u32 mac_hw_time_on_air_param_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);
}

static inline void mac_hw_time_on_air_param_1_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_STBC_MASK    ((u32)0xC0000000)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_STBC_LSB    30
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_STBC_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_NUM_EXTN_SS_MASK    ((u32)0x30000000)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_NUM_EXTN_SS_LSB    28
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_NUM_EXTN_SS_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_SHORT_GI_BIT    ((u32)0x08000000)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_SHORT_GI_POS    27
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_PRE_TYPE_MASK    ((u32)0x07000000)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_PRE_TYPE_LSB    24
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_PRE_TYPE_WIDTH    ((u32)0x00000003)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_BW_MASK    ((u32)0x00C00000)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_BW_LSB    22
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_BW_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_LENGTH_MASK    ((u32)0x000FFFFF)
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_LENGTH_LSB    0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_LENGTH_WIDTH    ((u32)0x00000014)

#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_STBC_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_NUM_EXTN_SS_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_SHORT_GI_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_PRE_TYPE_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_BW_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_1_PPDU_LENGTH_RST    0x0

static inline void mac_hw_time_on_air_param_1_pack(struct cl_chip *chip, u8 ppdu_stbc, u8 ppdu_num_extn_ss, u8 ppdu_short_gi, u8 ppdu_pre_type, u8 ppdu_bw, u32 ppdu_length)
{
	ASSERT_ERR_CHIP((((u32)ppdu_stbc << 30) & ~((u32)0xC0000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_num_extn_ss << 28) & ~((u32)0x30000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_short_gi << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_pre_type << 24) & ~((u32)0x07000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_bw << 22) & ~((u32)0x00C00000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_length << 0) & ~((u32)0x000FFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, ((u32)ppdu_stbc << 30) | ((u32)ppdu_num_extn_ss << 28) | ((u32)ppdu_short_gi << 27) | ((u32)ppdu_pre_type << 24) | ((u32)ppdu_bw << 22) | ((u32)ppdu_length << 0));
}

static inline void mac_hw_time_on_air_param_1_unpack(struct cl_chip *chip, u8 *ppdu_stbc, u8 *ppdu_num_extn_ss, u8 *ppdu_short_gi, u8 *ppdu_pre_type, u8 *ppdu_bw, u32 *ppdu_length)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	*ppdu_stbc = (local_val & ((u32)0xC0000000)) >> 30;
	*ppdu_num_extn_ss = (local_val & ((u32)0x30000000)) >> 28;
	*ppdu_short_gi = (local_val & ((u32)0x08000000)) >> 27;
	*ppdu_pre_type = (local_val & ((u32)0x07000000)) >> 24;
	*ppdu_bw = (local_val & ((u32)0x00C00000)) >> 22;
	*ppdu_length = (local_val & ((u32)0x000FFFFF)) >> 0;
}

static inline u8 mac_hw_time_on_air_param_1_ppdu_stbc_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u8)((local_val & ((u32)0xC0000000)) >> 30);
}

static inline void mac_hw_time_on_air_param_1_ppdu_stbc_setf(struct cl_chip *chip, u8 ppdustbc)
{
	ASSERT_ERR_CHIP((((u32)ppdustbc << 30) & ~((u32)0xC0000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0xC0000000)) | ((u32)ppdustbc << 30));
}

static inline u8 mac_hw_time_on_air_param_1_ppdu_num_extn_ss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u8)((local_val & ((u32)0x30000000)) >> 28);
}

static inline void mac_hw_time_on_air_param_1_ppdu_num_extn_ss_setf(struct cl_chip *chip, u8 ppdunumextnss)
{
	ASSERT_ERR_CHIP((((u32)ppdunumextnss << 28) & ~((u32)0x30000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0x30000000)) | ((u32)ppdunumextnss << 28));
}

static inline u8 mac_hw_time_on_air_param_1_ppdu_short_gi_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_time_on_air_param_1_ppdu_short_gi_setf(struct cl_chip *chip, u8 ppdushortgi)
{
	ASSERT_ERR_CHIP((((u32)ppdushortgi << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0x08000000)) | ((u32)ppdushortgi << 27));
}

static inline u8 mac_hw_time_on_air_param_1_ppdu_pre_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u8)((local_val & ((u32)0x07000000)) >> 24);
}

static inline void mac_hw_time_on_air_param_1_ppdu_pre_type_setf(struct cl_chip *chip, u8 ppdupretype)
{
	ASSERT_ERR_CHIP((((u32)ppdupretype << 24) & ~((u32)0x07000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0x07000000)) | ((u32)ppdupretype << 24));
}

static inline u8 mac_hw_time_on_air_param_1_ppdu_bw_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u8)((local_val & ((u32)0x00C00000)) >> 22);
}

static inline void mac_hw_time_on_air_param_1_ppdu_bw_setf(struct cl_chip *chip, u8 ppdubw)
{
	ASSERT_ERR_CHIP((((u32)ppdubw << 22) & ~((u32)0x00C00000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0x00C00000)) | ((u32)ppdubw << 22));
}

static inline u32 mac_hw_time_on_air_param_1_ppdu_length_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR);

	return (u32)((local_val & ((u32)0x000FFFFF)) >> 0);
}

static inline void mac_hw_time_on_air_param_1_ppdu_length_setf(struct cl_chip *chip, u32 ppdulength)
{
	ASSERT_ERR_CHIP((((u32)ppdulength << 0) & ~((u32)0x000FFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_1_ADDR) & ~((u32)0x000FFFFF)) | ((u32)ppdulength << 0));
}

/**
 * @brief TIME_ON_AIR_PARAM_2 register definition
 *  This register contains parameters used for computing time taken for packet on air. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    13:12 PPDU_LTF_TYPE             0x0
 *    11:10 PPDU_PE_DURATION          0x0
 *    09:08 PPDU_GI_TYPE              0x0
 *    07    PPDU_DCM                  0
 *    06:00 PPDU_MCS_INDEX            0x0
 * </pre>
 */
#define MAC_HW_TIME_ON_AIR_PARAM_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080D4)
#define MAC_HW_TIME_ON_AIR_PARAM_2_OFFSET      0x000080D4
#define MAC_HW_TIME_ON_AIR_PARAM_2_INDEX       0x00002035
#define MAC_HW_TIME_ON_AIR_PARAM_2_RESET       0x00000000

static inline u32 mac_hw_time_on_air_param_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);
}

static inline void mac_hw_time_on_air_param_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_LTF_TYPE_MASK    ((u32)0x00003000)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_LTF_TYPE_LSB    12
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_LTF_TYPE_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_PE_DURATION_MASK    ((u32)0x00000C00)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_PE_DURATION_LSB    10
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_PE_DURATION_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_GI_TYPE_MASK    ((u32)0x00000300)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_GI_TYPE_LSB    8
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_GI_TYPE_WIDTH    ((u32)0x00000002)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_DCM_BIT    ((u32)0x00000080)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_DCM_POS    7
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_MCS_INDEX_MASK    ((u32)0x0000007F)
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_MCS_INDEX_LSB    0
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_MCS_INDEX_WIDTH    ((u32)0x00000007)

#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_LTF_TYPE_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_PE_DURATION_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_GI_TYPE_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_DCM_RST    0x0
#define MAC_HW_TIME_ON_AIR_PARAM_2_PPDU_MCS_INDEX_RST    0x0

static inline void mac_hw_time_on_air_param_2_pack(struct cl_chip *chip, u8 ppdu_ltf_type, u8 ppdu_pe_duration, u8 ppdu_gi_type, u8 ppdu_dcm, u8 ppdu_mcs_index)
{
	ASSERT_ERR_CHIP((((u32)ppdu_ltf_type << 12) & ~((u32)0x00003000)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_pe_duration << 10) & ~((u32)0x00000C00)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_gi_type << 8) & ~((u32)0x00000300)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_dcm << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ppdu_mcs_index << 0) & ~((u32)0x0000007F)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, ((u32)ppdu_ltf_type << 12) | ((u32)ppdu_pe_duration << 10) | ((u32)ppdu_gi_type << 8) | ((u32)ppdu_dcm << 7) | ((u32)ppdu_mcs_index << 0));
}

static inline void mac_hw_time_on_air_param_2_unpack(struct cl_chip *chip, u8 *ppdu_ltf_type, u8 *ppdu_pe_duration, u8 *ppdu_gi_type, u8 *ppdu_dcm, u8 *ppdu_mcs_index)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	*ppdu_ltf_type = (local_val & ((u32)0x00003000)) >> 12;
	*ppdu_pe_duration = (local_val & ((u32)0x00000C00)) >> 10;
	*ppdu_gi_type = (local_val & ((u32)0x00000300)) >> 8;
	*ppdu_dcm = (local_val & ((u32)0x00000080)) >> 7;
	*ppdu_mcs_index = (local_val & ((u32)0x0000007F)) >> 0;
}

static inline u8 mac_hw_time_on_air_param_2_ppdu_ltf_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	return (u8)((local_val & ((u32)0x00003000)) >> 12);
}

static inline void mac_hw_time_on_air_param_2_ppdu_ltf_type_setf(struct cl_chip *chip, u8 ppdultftype)
{
	ASSERT_ERR_CHIP((((u32)ppdultftype << 12) & ~((u32)0x00003000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR) & ~((u32)0x00003000)) | ((u32)ppdultftype << 12));
}

static inline u8 mac_hw_time_on_air_param_2_ppdu_pe_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	return (u8)((local_val & ((u32)0x00000C00)) >> 10);
}

static inline void mac_hw_time_on_air_param_2_ppdu_pe_duration_setf(struct cl_chip *chip, u8 ppdupeduration)
{
	ASSERT_ERR_CHIP((((u32)ppdupeduration << 10) & ~((u32)0x00000C00)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR) & ~((u32)0x00000C00)) | ((u32)ppdupeduration << 10));
}

static inline u8 mac_hw_time_on_air_param_2_ppdu_gi_type_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	return (u8)((local_val & ((u32)0x00000300)) >> 8);
}

static inline void mac_hw_time_on_air_param_2_ppdu_gi_type_setf(struct cl_chip *chip, u8 ppdugitype)
{
	ASSERT_ERR_CHIP((((u32)ppdugitype << 8) & ~((u32)0x00000300)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR) & ~((u32)0x00000300)) | ((u32)ppdugitype << 8));
}

static inline u8 mac_hw_time_on_air_param_2_ppdu_dcm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_time_on_air_param_2_ppdu_dcm_setf(struct cl_chip *chip, u8 ppdudcm)
{
	ASSERT_ERR_CHIP((((u32)ppdudcm << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR) & ~((u32)0x00000080)) | ((u32)ppdudcm << 7));
}

static inline u8 mac_hw_time_on_air_param_2_ppdu_mcs_index_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR);

	return (u8)((local_val & ((u32)0x0000007F)) >> 0);
}

static inline void mac_hw_time_on_air_param_2_ppdu_mcs_index_setf(struct cl_chip *chip, u8 ppdumcsindex)
{
	ASSERT_ERR_CHIP((((u32)ppdumcsindex << 0) & ~((u32)0x0000007F)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_PARAM_2_ADDR) & ~((u32)0x0000007F)) | ((u32)ppdumcsindex << 0));
}

/**
 * @brief TIME_ON_AIR_VALUE register definition
 *  This register contains time taken for packet on air. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    COMPUTE_DURATION          0
 *    30    TIME_ON_AIR_VALID         0
 *    15:00 TIME_ON_AIR               0x0
 * </pre>
 */
#define MAC_HW_TIME_ON_AIR_VALUE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080D8)
#define MAC_HW_TIME_ON_AIR_VALUE_OFFSET      0x000080D8
#define MAC_HW_TIME_ON_AIR_VALUE_INDEX       0x00002036
#define MAC_HW_TIME_ON_AIR_VALUE_RESET       0x00000000

static inline u32 mac_hw_time_on_air_value_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR);
}

static inline void mac_hw_time_on_air_value_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIME_ON_AIR_VALUE_COMPUTE_DURATION_BIT    ((u32)0x80000000)
#define MAC_HW_TIME_ON_AIR_VALUE_COMPUTE_DURATION_POS    31
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_VALID_BIT    ((u32)0x40000000)
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_VALID_POS    30
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_MASK    ((u32)0x0000FFFF)
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_LSB    0
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_WIDTH    ((u32)0x00000010)

#define MAC_HW_TIME_ON_AIR_VALUE_COMPUTE_DURATION_RST    0x0
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_VALID_RST    0x0
#define MAC_HW_TIME_ON_AIR_VALUE_TIME_ON_AIR_RST    0x0

static inline void mac_hw_time_on_air_value_pack(struct cl_chip *chip, u8 compute_duration, u8 time_on_air_valid, u16 time_on_air)
{
	ASSERT_ERR_CHIP((((u32)compute_duration << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)time_on_air_valid << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)time_on_air << 0) & ~((u32)0x0000FFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR, ((u32)compute_duration << 31) | ((u32)time_on_air_valid << 30) | ((u32)time_on_air << 0));
}

static inline void mac_hw_time_on_air_value_unpack(struct cl_chip *chip, u8 *compute_duration, u8 *time_on_air_valid, u16 *time_on_air)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR);

	*compute_duration = (local_val & ((u32)0x80000000)) >> 31;
	*time_on_air_valid = (local_val & ((u32)0x40000000)) >> 30;
	*time_on_air = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u8 mac_hw_time_on_air_value_compute_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_time_on_air_value_compute_duration_setf(struct cl_chip *chip, u8 computeduration)
{
	ASSERT_ERR_CHIP((((u32)computeduration << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR, (cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR) & ~((u32)0x80000000)) | ((u32)computeduration << 31));
}

static inline u8 mac_hw_time_on_air_value_time_on_air_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u16 mac_hw_time_on_air_value_time_on_air_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIME_ON_AIR_VALUE_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief ERROR_INT_RAW_STATUS register definition
 *  Indicates ERROR events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080E0)
#define MAC_HW_ERROR_INT_RAW_STATUS_OFFSET      0x000080E0
#define MAC_HW_ERROR_INT_RAW_STATUS_INDEX       0x00002038
#define MAC_HW_ERROR_INT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_error_int_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_RAW_STATUS_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_RAW_STATUS_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_RAW_STATUS_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_RAW_STATUS_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_RAW_STATUS_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_RAW_STATUS_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_RAW_STATUS_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_RAW_STATUS_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_RAW_STATUS_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_raw_status_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_raw_status_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_error_int_raw_status_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_error_int_raw_status_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_error_int_raw_status_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_error_int_raw_status_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_error_int_raw_status_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_error_int_raw_status_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_error_int_raw_status_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_error_int_raw_status_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_error_int_raw_status_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_error_int_raw_status_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_error_int_raw_status_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_error_int_raw_status_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_error_int_raw_status_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_error_int_raw_status_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_error_int_raw_status_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_error_int_raw_status_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_error_int_raw_status_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_error_int_raw_status_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_error_int_raw_status_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_error_int_raw_status_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_error_int_raw_status_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

/**
 * @brief ERROR_INT_EVENT_EN_SMAC register definition
 *  ERROR interrupt events enable SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080E4)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OFFSET      0x000080E4
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_INDEX       0x00002039
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_error_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_SMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_en_smac_pack(struct cl_chip *chip, u8 htp_tx_failed_dma_state, u8 htp_tx_failed_cs, u8 rx_payload_dma_dead, u8 rx_header_dma_dead, u8 rx_header_dma_dead2, u8 phy_err, u8 mac_phyif_under_run, u8 unexpected_tx_end, u8 rx_payload_dma_dead2, u8 htp_tx_dma_dead, u8 bcn_tx_dma_dead, u8 ac_3_tx_dma_dead, u8 ac_2_tx_dma_dead, u8 ac_1_tx_dma_dead, u8 ac_0_tx_dma_dead, u8 pt_error, u8 olbc_dsss, u8 olbc_ofdm, u8 rx_fifo_over_flow, u8 rx_dma_empty, u8 mac_phyif_overflow, u8 rx_dma_discard)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_dma_state << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_cs << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead2 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_err << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_under_run << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)unexpected_tx_end << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead2 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_dma_dead << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_dma_dead << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_dma_dead << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_dma_dead << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_dma_dead << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_dma_dead << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_error << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_dsss << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_ofdm << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_over_flow << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_empty << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_overflow << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_discard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, ((u32)htp_tx_failed_dma_state << 27) | ((u32)htp_tx_failed_cs << 26) | ((u32)rx_payload_dma_dead << 25) | ((u32)rx_header_dma_dead << 24) | ((u32)rx_header_dma_dead2 << 23) | ((u32)phy_err << 22) | ((u32)mac_phyif_under_run << 21) | ((u32)unexpected_tx_end << 20) | ((u32)rx_payload_dma_dead2 << 19) | ((u32)htp_tx_dma_dead << 18) | ((u32)bcn_tx_dma_dead << 17) | ((u32)ac_3_tx_dma_dead << 16) | ((u32)ac_2_tx_dma_dead << 15) | ((u32)ac_1_tx_dma_dead << 14) | ((u32)ac_0_tx_dma_dead << 13) | ((u32)pt_error << 12) | ((u32)olbc_dsss << 10) | ((u32)olbc_ofdm << 9) | ((u32)rx_fifo_over_flow << 8) | ((u32)rx_dma_empty << 7) | ((u32)mac_phyif_overflow << 6) | ((u32)rx_dma_discard << 5));
}

static inline void mac_hw_error_int_event_en_smac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_en_smac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_error_int_event_en_smac_htp_tx_failed_dma_state_setf(struct cl_chip *chip, u8 htptxfaileddmastate)
{
	ASSERT_ERR_CHIP((((u32)htptxfaileddmastate << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x08000000)) | ((u32)htptxfaileddmastate << 27));
}

static inline u8 mac_hw_error_int_event_en_smac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_error_int_event_en_smac_htp_tx_failed_cs_setf(struct cl_chip *chip, u8 htptxfailedcs)
{
	ASSERT_ERR_CHIP((((u32)htptxfailedcs << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x04000000)) | ((u32)htptxfailedcs << 26));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_error_int_event_en_smac_rx_payload_dma_dead_setf(struct cl_chip *chip, u8 rxpayloaddmadead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloaddmadead << 25));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_error_int_event_en_smac_rx_header_dma_dead_setf(struct cl_chip *chip, u8 rxheaderdmadead)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x01000000)) | ((u32)rxheaderdmadead << 24));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_error_int_event_en_smac_rx_header_dma_dead_2_setf(struct cl_chip *chip, u8 rxheaderdmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead2 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00800000)) | ((u32)rxheaderdmadead2 << 23));
}

static inline u8 mac_hw_error_int_event_en_smac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_error_int_event_en_smac_phy_err_setf(struct cl_chip *chip, u8 phyerr)
{
	ASSERT_ERR_CHIP((((u32)phyerr << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00400000)) | ((u32)phyerr << 22));
}

static inline u8 mac_hw_error_int_event_en_smac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_error_int_event_en_smac_mac_phyif_under_run_setf(struct cl_chip *chip, u8 macphyifunderrun)
{
	ASSERT_ERR_CHIP((((u32)macphyifunderrun << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00200000)) | ((u32)macphyifunderrun << 21));
}

static inline u8 mac_hw_error_int_event_en_smac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_error_int_event_en_smac_unexpected_tx_end_setf(struct cl_chip *chip, u8 unexpectedtxend)
{
	ASSERT_ERR_CHIP((((u32)unexpectedtxend << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00100000)) | ((u32)unexpectedtxend << 20));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_error_int_event_en_smac_rx_payload_dma_dead_2_setf(struct cl_chip *chip, u8 rxpayloaddmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead2 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00080000)) | ((u32)rxpayloaddmadead2 << 19));
}

static inline u8 mac_hw_error_int_event_en_smac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_error_int_event_en_smac_htp_tx_dma_dead_setf(struct cl_chip *chip, u8 htptxdmadead)
{
	ASSERT_ERR_CHIP((((u32)htptxdmadead << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00040000)) | ((u32)htptxdmadead << 18));
}

static inline u8 mac_hw_error_int_event_en_smac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_error_int_event_en_smac_bcn_tx_dma_dead_setf(struct cl_chip *chip, u8 bcntxdmadead)
{
	ASSERT_ERR_CHIP((((u32)bcntxdmadead << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00020000)) | ((u32)bcntxdmadead << 17));
}

static inline u8 mac_hw_error_int_event_en_smac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_error_int_event_en_smac_ac_3_tx_dma_dead_setf(struct cl_chip *chip, u8 ac3txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac3txdmadead << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00010000)) | ((u32)ac3txdmadead << 16));
}

static inline u8 mac_hw_error_int_event_en_smac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_error_int_event_en_smac_ac_2_tx_dma_dead_setf(struct cl_chip *chip, u8 ac2txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac2txdmadead << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00008000)) | ((u32)ac2txdmadead << 15));
}

static inline u8 mac_hw_error_int_event_en_smac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_error_int_event_en_smac_ac_1_tx_dma_dead_setf(struct cl_chip *chip, u8 ac1txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac1txdmadead << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00004000)) | ((u32)ac1txdmadead << 14));
}

static inline u8 mac_hw_error_int_event_en_smac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_error_int_event_en_smac_ac_0_tx_dma_dead_setf(struct cl_chip *chip, u8 ac0txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac0txdmadead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac0txdmadead << 13));
}

static inline u8 mac_hw_error_int_event_en_smac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_error_int_event_en_smac_pt_error_setf(struct cl_chip *chip, u8 pterror)
{
	ASSERT_ERR_CHIP((((u32)pterror << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00001000)) | ((u32)pterror << 12));
}

static inline u8 mac_hw_error_int_event_en_smac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_error_int_event_en_smac_olbc_dsss_setf(struct cl_chip *chip, u8 olbcdsss)
{
	ASSERT_ERR_CHIP((((u32)olbcdsss << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000400)) | ((u32)olbcdsss << 10));
}

static inline u8 mac_hw_error_int_event_en_smac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_error_int_event_en_smac_olbc_ofdm_setf(struct cl_chip *chip, u8 olbcofdm)
{
	ASSERT_ERR_CHIP((((u32)olbcofdm << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000200)) | ((u32)olbcofdm << 9));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_error_int_event_en_smac_rx_fifo_over_flow_setf(struct cl_chip *chip, u8 rxfifooverflow)
{
	ASSERT_ERR_CHIP((((u32)rxfifooverflow << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rxfifooverflow << 8));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_error_int_event_en_smac_rx_dma_empty_setf(struct cl_chip *chip, u8 rxdmaempty)
{
	ASSERT_ERR_CHIP((((u32)rxdmaempty << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000080)) | ((u32)rxdmaempty << 7));
}

static inline u8 mac_hw_error_int_event_en_smac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_error_int_event_en_smac_mac_phyif_overflow_setf(struct cl_chip *chip, u8 macphyifoverflow)
{
	ASSERT_ERR_CHIP((((u32)macphyifoverflow << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000040)) | ((u32)macphyifoverflow << 6));
}

static inline u8 mac_hw_error_int_event_en_smac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_error_int_event_en_smac_rx_dma_discard_setf(struct cl_chip *chip, u8 rxdmadiscard)
{
	ASSERT_ERR_CHIP((((u32)rxdmadiscard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxdmadiscard << 5));
}

/**
 * @brief ERROR_INT_EVENT_STATUS_UMAC register definition
 *  ERROR interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080E8)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OFFSET      0x000080E8
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_INDEX       0x0000203A
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_status_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_status_umac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_status_umac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_error_int_event_status_umac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_error_int_event_status_umac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_error_int_event_status_umac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_error_int_event_status_umac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_error_int_event_status_umac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_error_int_event_status_umac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_error_int_event_status_umac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_error_int_event_status_umac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_error_int_event_status_umac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_error_int_event_status_umac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_error_int_event_status_umac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_error_int_event_status_umac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_error_int_event_status_umac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_error_int_event_status_umac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_error_int_event_status_umac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

/**
 * @brief ERROR_INT_EVENT_STATUS_SMAC register definition
 *  ERROR interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080EC)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OFFSET      0x000080EC
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_INDEX       0x0000203B
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_status_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_status_smac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_status_smac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_error_int_event_status_smac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_error_int_event_status_smac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_error_int_event_status_smac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_error_int_event_status_smac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_error_int_event_status_smac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_error_int_event_status_smac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_error_int_event_status_smac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_error_int_event_status_smac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_error_int_event_status_smac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_error_int_event_status_smac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_error_int_event_status_smac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_error_int_event_status_smac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_error_int_event_status_smac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_error_int_event_status_smac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_error_int_event_status_smac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

/**
 * @brief ERROR_INT_EVENT_FORCE register definition
 *  ERROR interrupt events force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080F0)
#define MAC_HW_ERROR_INT_EVENT_FORCE_OFFSET      0x000080F0
#define MAC_HW_ERROR_INT_EVENT_FORCE_INDEX       0x0000203C
#define MAC_HW_ERROR_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_error_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_error_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_FORCE_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_FORCE_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_FORCE_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_FORCE_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_FORCE_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_FORCE_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_force_pack(struct cl_chip *chip, u8 htp_tx_failed_dma_state, u8 htp_tx_failed_cs, u8 rx_payload_dma_dead, u8 rx_header_dma_dead, u8 rx_header_dma_dead2, u8 phy_err, u8 mac_phyif_under_run, u8 unexpected_tx_end, u8 rx_payload_dma_dead2, u8 htp_tx_dma_dead, u8 bcn_tx_dma_dead, u8 ac_3_tx_dma_dead, u8 ac_2_tx_dma_dead, u8 ac_1_tx_dma_dead, u8 ac_0_tx_dma_dead, u8 pt_error, u8 olbc_dsss, u8 olbc_ofdm, u8 rx_fifo_over_flow, u8 rx_dma_empty, u8 mac_phyif_overflow, u8 rx_dma_discard)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_dma_state << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_cs << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead2 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_err << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_under_run << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)unexpected_tx_end << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead2 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_dma_dead << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_dma_dead << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_dma_dead << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_dma_dead << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_dma_dead << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_dma_dead << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_error << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_dsss << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_ofdm << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_over_flow << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_empty << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_overflow << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_discard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, ((u32)htp_tx_failed_dma_state << 27) | ((u32)htp_tx_failed_cs << 26) | ((u32)rx_payload_dma_dead << 25) | ((u32)rx_header_dma_dead << 24) | ((u32)rx_header_dma_dead2 << 23) | ((u32)phy_err << 22) | ((u32)mac_phyif_under_run << 21) | ((u32)unexpected_tx_end << 20) | ((u32)rx_payload_dma_dead2 << 19) | ((u32)htp_tx_dma_dead << 18) | ((u32)bcn_tx_dma_dead << 17) | ((u32)ac_3_tx_dma_dead << 16) | ((u32)ac_2_tx_dma_dead << 15) | ((u32)ac_1_tx_dma_dead << 14) | ((u32)ac_0_tx_dma_dead << 13) | ((u32)pt_error << 12) | ((u32)olbc_dsss << 10) | ((u32)olbc_ofdm << 9) | ((u32)rx_fifo_over_flow << 8) | ((u32)rx_dma_empty << 7) | ((u32)mac_phyif_overflow << 6) | ((u32)rx_dma_discard << 5));
}

static inline void mac_hw_error_int_event_force_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_force_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_error_int_event_force_htp_tx_failed_dma_state_setf(struct cl_chip *chip, u8 htptxfaileddmastate)
{
	ASSERT_ERR_CHIP((((u32)htptxfaileddmastate << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x08000000)) | ((u32)htptxfaileddmastate << 27));
}

static inline u8 mac_hw_error_int_event_force_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_error_int_event_force_htp_tx_failed_cs_setf(struct cl_chip *chip, u8 htptxfailedcs)
{
	ASSERT_ERR_CHIP((((u32)htptxfailedcs << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x04000000)) | ((u32)htptxfailedcs << 26));
}

static inline u8 mac_hw_error_int_event_force_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_error_int_event_force_rx_payload_dma_dead_setf(struct cl_chip *chip, u8 rxpayloaddmadead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloaddmadead << 25));
}

static inline u8 mac_hw_error_int_event_force_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_error_int_event_force_rx_header_dma_dead_setf(struct cl_chip *chip, u8 rxheaderdmadead)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x01000000)) | ((u32)rxheaderdmadead << 24));
}

static inline u8 mac_hw_error_int_event_force_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_error_int_event_force_rx_header_dma_dead_2_setf(struct cl_chip *chip, u8 rxheaderdmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead2 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00800000)) | ((u32)rxheaderdmadead2 << 23));
}

static inline u8 mac_hw_error_int_event_force_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_error_int_event_force_phy_err_setf(struct cl_chip *chip, u8 phyerr)
{
	ASSERT_ERR_CHIP((((u32)phyerr << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00400000)) | ((u32)phyerr << 22));
}

static inline u8 mac_hw_error_int_event_force_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_error_int_event_force_mac_phyif_under_run_setf(struct cl_chip *chip, u8 macphyifunderrun)
{
	ASSERT_ERR_CHIP((((u32)macphyifunderrun << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00200000)) | ((u32)macphyifunderrun << 21));
}

static inline u8 mac_hw_error_int_event_force_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_error_int_event_force_unexpected_tx_end_setf(struct cl_chip *chip, u8 unexpectedtxend)
{
	ASSERT_ERR_CHIP((((u32)unexpectedtxend << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00100000)) | ((u32)unexpectedtxend << 20));
}

static inline u8 mac_hw_error_int_event_force_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_error_int_event_force_rx_payload_dma_dead_2_setf(struct cl_chip *chip, u8 rxpayloaddmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead2 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00080000)) | ((u32)rxpayloaddmadead2 << 19));
}

static inline u8 mac_hw_error_int_event_force_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_error_int_event_force_htp_tx_dma_dead_setf(struct cl_chip *chip, u8 htptxdmadead)
{
	ASSERT_ERR_CHIP((((u32)htptxdmadead << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00040000)) | ((u32)htptxdmadead << 18));
}

static inline u8 mac_hw_error_int_event_force_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_error_int_event_force_bcn_tx_dma_dead_setf(struct cl_chip *chip, u8 bcntxdmadead)
{
	ASSERT_ERR_CHIP((((u32)bcntxdmadead << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00020000)) | ((u32)bcntxdmadead << 17));
}

static inline u8 mac_hw_error_int_event_force_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_error_int_event_force_ac_3_tx_dma_dead_setf(struct cl_chip *chip, u8 ac3txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac3txdmadead << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00010000)) | ((u32)ac3txdmadead << 16));
}

static inline u8 mac_hw_error_int_event_force_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_error_int_event_force_ac_2_tx_dma_dead_setf(struct cl_chip *chip, u8 ac2txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac2txdmadead << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00008000)) | ((u32)ac2txdmadead << 15));
}

static inline u8 mac_hw_error_int_event_force_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_error_int_event_force_ac_1_tx_dma_dead_setf(struct cl_chip *chip, u8 ac1txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac1txdmadead << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00004000)) | ((u32)ac1txdmadead << 14));
}

static inline u8 mac_hw_error_int_event_force_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_error_int_event_force_ac_0_tx_dma_dead_setf(struct cl_chip *chip, u8 ac0txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac0txdmadead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00002000)) | ((u32)ac0txdmadead << 13));
}

static inline u8 mac_hw_error_int_event_force_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_error_int_event_force_pt_error_setf(struct cl_chip *chip, u8 pterror)
{
	ASSERT_ERR_CHIP((((u32)pterror << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00001000)) | ((u32)pterror << 12));
}

static inline u8 mac_hw_error_int_event_force_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_error_int_event_force_olbc_dsss_setf(struct cl_chip *chip, u8 olbcdsss)
{
	ASSERT_ERR_CHIP((((u32)olbcdsss << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000400)) | ((u32)olbcdsss << 10));
}

static inline u8 mac_hw_error_int_event_force_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_error_int_event_force_olbc_ofdm_setf(struct cl_chip *chip, u8 olbcofdm)
{
	ASSERT_ERR_CHIP((((u32)olbcofdm << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000200)) | ((u32)olbcofdm << 9));
}

static inline u8 mac_hw_error_int_event_force_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_error_int_event_force_rx_fifo_over_flow_setf(struct cl_chip *chip, u8 rxfifooverflow)
{
	ASSERT_ERR_CHIP((((u32)rxfifooverflow << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000100)) | ((u32)rxfifooverflow << 8));
}

static inline u8 mac_hw_error_int_event_force_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_error_int_event_force_rx_dma_empty_setf(struct cl_chip *chip, u8 rxdmaempty)
{
	ASSERT_ERR_CHIP((((u32)rxdmaempty << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000080)) | ((u32)rxdmaempty << 7));
}

static inline u8 mac_hw_error_int_event_force_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_error_int_event_force_mac_phyif_overflow_setf(struct cl_chip *chip, u8 macphyifoverflow)
{
	ASSERT_ERR_CHIP((((u32)macphyifoverflow << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000040)) | ((u32)macphyifoverflow << 6));
}

static inline u8 mac_hw_error_int_event_force_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_error_int_event_force_rx_dma_discard_setf(struct cl_chip *chip, u8 rxdmadiscard)
{
	ASSERT_ERR_CHIP((((u32)rxdmadiscard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000020)) | ((u32)rxdmadiscard << 5));
}

/**
 * @brief ERROR_INT_MAC_SOURCE_UMAC register definition
 *  Indicates UMAC ERROR interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080F4)
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_OFFSET      0x000080F4
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_INDEX       0x0000203D
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_error_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief ERROR_INT_MAC_SOURCE_SMAC register definition
 *  Indicates SMAC ERROR interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080F8)
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_OFFSET      0x000080F8
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_INDEX       0x0000203E
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_error_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief GEN_INT_EVENT_RAW_STATUS register definition
 *  Indicates general events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000080FC)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_OFFSET      0x000080FC
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_INDEX       0x0000203F
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_RAW_STATUS_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_raw_status_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_raw_status_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_gen_int_event_raw_status_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_gen_int_event_raw_status_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_gen_int_event_raw_status_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_gen_int_event_raw_status_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_gen_int_event_raw_status_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_gen_int_event_raw_status_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_gen_int_event_raw_status_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_gen_int_event_raw_status_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief GEN_INT_EVENT_EN_SMAC register definition
 *  GENERAL interrupt events enable SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008100)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_OFFSET      0x00008100
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_INDEX       0x00002040
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_gen_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_EN_SMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_SMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_en_smac_pack(struct cl_chip *chip, u8 ul_bss_color_collision, u8 dl_bss_color_collision, u8 abs_timers_9, u8 abs_timers_8, u8 abs_timers_7, u8 abs_timers_6, u8 abs_timers_5, u8 abs_timers_4, u8 abs_timers_3, u8 abs_timers_2, u8 abs_timers_1, u8 abs_timers_0, u8 imp_sec_dtim, u8 imp_pri_dtim, u8 tim_set, u8 idle_interrupt, u8 imp_sec_tbtt, u8 imp_pri_tbtt)
{
	ASSERT_ERR_CHIP((((u32)ul_bss_color_collision << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dl_bss_color_collision << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_9 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_8 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_7 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_6 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_5 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_4 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_3 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_1 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_0 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_dtim << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_dtim << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_set << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)idle_interrupt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_tbtt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_tbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, ((u32)ul_bss_color_collision << 31) | ((u32)dl_bss_color_collision << 30) | ((u32)abs_timers_9 << 29) | ((u32)abs_timers_8 << 28) | ((u32)abs_timers_7 << 27) | ((u32)abs_timers_6 << 26) | ((u32)abs_timers_5 << 25) | ((u32)abs_timers_4 << 24) | ((u32)abs_timers_3 << 23) | ((u32)abs_timers_2 << 22) | ((u32)abs_timers_1 << 21) | ((u32)abs_timers_0 << 20) | ((u32)imp_sec_dtim << 19) | ((u32)imp_pri_dtim << 18) | ((u32)tim_set << 11) | ((u32)idle_interrupt << 2) | ((u32)imp_sec_tbtt << 1) | ((u32)imp_pri_tbtt << 0));
}

static inline void mac_hw_gen_int_event_en_smac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_en_smac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_gen_int_event_en_smac_ul_bss_color_collision_setf(struct cl_chip *chip, u8 ulbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)ulbsscolorcollision << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x80000000)) | ((u32)ulbsscolorcollision << 31));
}

static inline u8 mac_hw_gen_int_event_en_smac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_gen_int_event_en_smac_dl_bss_color_collision_setf(struct cl_chip *chip, u8 dlbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)dlbsscolorcollision << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x40000000)) | ((u32)dlbsscolorcollision << 30));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_9_setf(struct cl_chip *chip, u8 abstimers9)
{
	ASSERT_ERR_CHIP((((u32)abstimers9 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x20000000)) | ((u32)abstimers9 << 29));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_8_setf(struct cl_chip *chip, u8 abstimers8)
{
	ASSERT_ERR_CHIP((((u32)abstimers8 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x10000000)) | ((u32)abstimers8 << 28));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_7_setf(struct cl_chip *chip, u8 abstimers7)
{
	ASSERT_ERR_CHIP((((u32)abstimers7 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x08000000)) | ((u32)abstimers7 << 27));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_6_setf(struct cl_chip *chip, u8 abstimers6)
{
	ASSERT_ERR_CHIP((((u32)abstimers6 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x04000000)) | ((u32)abstimers6 << 26));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_5_setf(struct cl_chip *chip, u8 abstimers5)
{
	ASSERT_ERR_CHIP((((u32)abstimers5 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x02000000)) | ((u32)abstimers5 << 25));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_4_setf(struct cl_chip *chip, u8 abstimers4)
{
	ASSERT_ERR_CHIP((((u32)abstimers4 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x01000000)) | ((u32)abstimers4 << 24));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_3_setf(struct cl_chip *chip, u8 abstimers3)
{
	ASSERT_ERR_CHIP((((u32)abstimers3 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00800000)) | ((u32)abstimers3 << 23));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_2_setf(struct cl_chip *chip, u8 abstimers2)
{
	ASSERT_ERR_CHIP((((u32)abstimers2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00400000)) | ((u32)abstimers2 << 22));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_1_setf(struct cl_chip *chip, u8 abstimers1)
{
	ASSERT_ERR_CHIP((((u32)abstimers1 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00200000)) | ((u32)abstimers1 << 21));
}

static inline u8 mac_hw_gen_int_event_en_smac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_gen_int_event_en_smac_abs_timers_0_setf(struct cl_chip *chip, u8 abstimers0)
{
	ASSERT_ERR_CHIP((((u32)abstimers0 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00100000)) | ((u32)abstimers0 << 20));
}

static inline u8 mac_hw_gen_int_event_en_smac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_gen_int_event_en_smac_imp_sec_dtim_setf(struct cl_chip *chip, u8 impsecdtim)
{
	ASSERT_ERR_CHIP((((u32)impsecdtim << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00080000)) | ((u32)impsecdtim << 19));
}

static inline u8 mac_hw_gen_int_event_en_smac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_gen_int_event_en_smac_imp_pri_dtim_setf(struct cl_chip *chip, u8 imppridtim)
{
	ASSERT_ERR_CHIP((((u32)imppridtim << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00040000)) | ((u32)imppridtim << 18));
}

static inline u8 mac_hw_gen_int_event_en_smac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_gen_int_event_en_smac_tim_set_setf(struct cl_chip *chip, u8 timset)
{
	ASSERT_ERR_CHIP((((u32)timset << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000800)) | ((u32)timset << 11));
}

static inline u8 mac_hw_gen_int_event_en_smac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_gen_int_event_en_smac_idle_interrupt_setf(struct cl_chip *chip, u8 idleinterrupt)
{
	ASSERT_ERR_CHIP((((u32)idleinterrupt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000004)) | ((u32)idleinterrupt << 2));
}

static inline u8 mac_hw_gen_int_event_en_smac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_gen_int_event_en_smac_imp_sec_tbtt_setf(struct cl_chip *chip, u8 impsectbtt)
{
	ASSERT_ERR_CHIP((((u32)impsectbtt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000002)) | ((u32)impsectbtt << 1));
}

static inline u8 mac_hw_gen_int_event_en_smac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_gen_int_event_en_smac_imp_pri_tbtt_setf(struct cl_chip *chip, u8 imppritbtt)
{
	ASSERT_ERR_CHIP((((u32)imppritbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000001)) | ((u32)imppritbtt << 0));
}

/**
 * @brief GEN_INT_EVENT_STATUS_UMAC register definition
 *  GENERAL interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008104)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_OFFSET      0x00008104
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_INDEX       0x00002041
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_status_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_UMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_status_umac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_status_umac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_gen_int_event_status_umac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_gen_int_event_status_umac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_gen_int_event_status_umac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_gen_int_event_status_umac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_gen_int_event_status_umac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_gen_int_event_status_umac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_gen_int_event_status_umac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_gen_int_event_status_umac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief GEN_INT_EVENT_STATUS_SMAC register definition
 *  GENERAL interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008108)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_OFFSET      0x00008108
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_INDEX       0x00002042
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_status_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_SMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_status_smac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_status_smac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_gen_int_event_status_smac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_gen_int_event_status_smac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_gen_int_event_status_smac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_gen_int_event_status_smac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_gen_int_event_status_smac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_gen_int_event_status_smac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_gen_int_event_status_smac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_gen_int_event_status_smac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief GEN_INT_EVENT_FORCE register definition
 *  GENERAL interrupt events force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000810C)
#define MAC_HW_GEN_INT_EVENT_FORCE_OFFSET      0x0000810C
#define MAC_HW_GEN_INT_EVENT_FORCE_INDEX       0x00002043
#define MAC_HW_GEN_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_gen_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_FORCE_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_FORCE_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_FORCE_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_FORCE_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_FORCE_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_FORCE_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_FORCE_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_FORCE_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_force_pack(struct cl_chip *chip, u8 ul_bss_color_collision, u8 dl_bss_color_collision, u8 abs_timers_9, u8 abs_timers_8, u8 abs_timers_7, u8 abs_timers_6, u8 abs_timers_5, u8 abs_timers_4, u8 abs_timers_3, u8 abs_timers_2, u8 abs_timers_1, u8 abs_timers_0, u8 imp_sec_dtim, u8 imp_pri_dtim, u8 tim_set, u8 idle_interrupt, u8 imp_sec_tbtt, u8 imp_pri_tbtt)
{
	ASSERT_ERR_CHIP((((u32)ul_bss_color_collision << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dl_bss_color_collision << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_9 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_8 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_7 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_6 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_5 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_4 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_3 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_1 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_0 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_dtim << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_dtim << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_set << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)idle_interrupt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_tbtt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_tbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, ((u32)ul_bss_color_collision << 31) | ((u32)dl_bss_color_collision << 30) | ((u32)abs_timers_9 << 29) | ((u32)abs_timers_8 << 28) | ((u32)abs_timers_7 << 27) | ((u32)abs_timers_6 << 26) | ((u32)abs_timers_5 << 25) | ((u32)abs_timers_4 << 24) | ((u32)abs_timers_3 << 23) | ((u32)abs_timers_2 << 22) | ((u32)abs_timers_1 << 21) | ((u32)abs_timers_0 << 20) | ((u32)imp_sec_dtim << 19) | ((u32)imp_pri_dtim << 18) | ((u32)tim_set << 11) | ((u32)idle_interrupt << 2) | ((u32)imp_sec_tbtt << 1) | ((u32)imp_pri_tbtt << 0));
}

static inline void mac_hw_gen_int_event_force_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_force_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_gen_int_event_force_ul_bss_color_collision_setf(struct cl_chip *chip, u8 ulbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)ulbsscolorcollision << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x80000000)) | ((u32)ulbsscolorcollision << 31));
}

static inline u8 mac_hw_gen_int_event_force_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_gen_int_event_force_dl_bss_color_collision_setf(struct cl_chip *chip, u8 dlbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)dlbsscolorcollision << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x40000000)) | ((u32)dlbsscolorcollision << 30));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_gen_int_event_force_abs_timers_9_setf(struct cl_chip *chip, u8 abstimers9)
{
	ASSERT_ERR_CHIP((((u32)abstimers9 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x20000000)) | ((u32)abstimers9 << 29));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_gen_int_event_force_abs_timers_8_setf(struct cl_chip *chip, u8 abstimers8)
{
	ASSERT_ERR_CHIP((((u32)abstimers8 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x10000000)) | ((u32)abstimers8 << 28));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_gen_int_event_force_abs_timers_7_setf(struct cl_chip *chip, u8 abstimers7)
{
	ASSERT_ERR_CHIP((((u32)abstimers7 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x08000000)) | ((u32)abstimers7 << 27));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_gen_int_event_force_abs_timers_6_setf(struct cl_chip *chip, u8 abstimers6)
{
	ASSERT_ERR_CHIP((((u32)abstimers6 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x04000000)) | ((u32)abstimers6 << 26));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_gen_int_event_force_abs_timers_5_setf(struct cl_chip *chip, u8 abstimers5)
{
	ASSERT_ERR_CHIP((((u32)abstimers5 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x02000000)) | ((u32)abstimers5 << 25));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_gen_int_event_force_abs_timers_4_setf(struct cl_chip *chip, u8 abstimers4)
{
	ASSERT_ERR_CHIP((((u32)abstimers4 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x01000000)) | ((u32)abstimers4 << 24));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_gen_int_event_force_abs_timers_3_setf(struct cl_chip *chip, u8 abstimers3)
{
	ASSERT_ERR_CHIP((((u32)abstimers3 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00800000)) | ((u32)abstimers3 << 23));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_gen_int_event_force_abs_timers_2_setf(struct cl_chip *chip, u8 abstimers2)
{
	ASSERT_ERR_CHIP((((u32)abstimers2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00400000)) | ((u32)abstimers2 << 22));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_gen_int_event_force_abs_timers_1_setf(struct cl_chip *chip, u8 abstimers1)
{
	ASSERT_ERR_CHIP((((u32)abstimers1 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00200000)) | ((u32)abstimers1 << 21));
}

static inline u8 mac_hw_gen_int_event_force_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_gen_int_event_force_abs_timers_0_setf(struct cl_chip *chip, u8 abstimers0)
{
	ASSERT_ERR_CHIP((((u32)abstimers0 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00100000)) | ((u32)abstimers0 << 20));
}

static inline u8 mac_hw_gen_int_event_force_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_gen_int_event_force_imp_sec_dtim_setf(struct cl_chip *chip, u8 impsecdtim)
{
	ASSERT_ERR_CHIP((((u32)impsecdtim << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00080000)) | ((u32)impsecdtim << 19));
}

static inline u8 mac_hw_gen_int_event_force_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_gen_int_event_force_imp_pri_dtim_setf(struct cl_chip *chip, u8 imppridtim)
{
	ASSERT_ERR_CHIP((((u32)imppridtim << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00040000)) | ((u32)imppridtim << 18));
}

static inline u8 mac_hw_gen_int_event_force_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_gen_int_event_force_tim_set_setf(struct cl_chip *chip, u8 timset)
{
	ASSERT_ERR_CHIP((((u32)timset << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000800)) | ((u32)timset << 11));
}

static inline u8 mac_hw_gen_int_event_force_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_gen_int_event_force_idle_interrupt_setf(struct cl_chip *chip, u8 idleinterrupt)
{
	ASSERT_ERR_CHIP((((u32)idleinterrupt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000004)) | ((u32)idleinterrupt << 2));
}

static inline u8 mac_hw_gen_int_event_force_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_gen_int_event_force_imp_sec_tbtt_setf(struct cl_chip *chip, u8 impsectbtt)
{
	ASSERT_ERR_CHIP((((u32)impsectbtt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000002)) | ((u32)impsectbtt << 1));
}

static inline u8 mac_hw_gen_int_event_force_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_gen_int_event_force_imp_pri_tbtt_setf(struct cl_chip *chip, u8 imppritbtt)
{
	ASSERT_ERR_CHIP((((u32)imppritbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000001)) | ((u32)imppritbtt << 0));
}

/**
 * @brief GEN_INT_MAC_SOURCE_UMAC register definition
 *  Indicates UMAC GENERAL interrupt MAC source  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008110)
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_OFFSET      0x00008110
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_INDEX       0x00002044
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_GEN_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_gen_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief GEN_INT_MAC_SOURCE_SMAC register definition
 *  Indicates SMAC GENERAL interrupt MAC source  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008114)
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_OFFSET      0x00008114
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_INDEX       0x00002045
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_GEN_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_gen_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief HIGH_PRI_INT_EVENT_RAW_STATUS register definition
 *  Indicates HIGH PRIORITY events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008118)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_OFFSET      0x00008118
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_INDEX       0x00002046
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_raw_status_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_raw_status_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_high_pri_int_event_raw_status_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief HIGH_PRI_INT_EVENT_EN_SMAC register definition
 *  HIGH PRIORITY interrupt events enable SMAC  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000811C)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_OFFSET      0x0000811C
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_INDEX       0x00002047
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_high_pri_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_en_smac_pack(struct cl_chip *chip, u8 tx_htp_ampdu_und, u8 tx_ac3_ampdu_und, u8 tx_ac2_ampdu_und, u8 tx_ac1_ampdu_und, u8 tx_ac0_ampdu_und, u8 sw_rts_success, u8 ac3_tx_bw_decision, u8 ac2_tx_bw_decision, u8 ac1_tx_bw_decision, u8 ac0_tx_bw_decision, u8 htp_tx_bw_decision, u8 bfr_resp_cancelled, u8 end_of_ppdu, u8 need_response, u8 rd_prot_trigger, u8 hcca_prot_trigger, u8 ac_3_prot_trigger, u8 ac_2_prot_trigger, u8 ac_1_prot_trigger, u8 ac_0_prot_trigger)
{
	ASSERT_ERR_CHIP((((u32)tx_htp_ampdu_und << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac3_ampdu_und << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac2_ampdu_und << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac1_ampdu_und << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac0_ampdu_und << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_rts_success << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac3_tx_bw_decision << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac2_tx_bw_decision << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac1_tx_bw_decision << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ac0_tx_bw_decision << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_bw_decision << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_resp_cancelled << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)end_of_ppdu << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)need_response << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_prot_trigger << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_prot_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_prot_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_prot_trigger << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_prot_trigger << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_prot_trigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, ((u32)tx_htp_ampdu_und << 30) | ((u32)tx_ac3_ampdu_und << 29) | ((u32)tx_ac2_ampdu_und << 28) | ((u32)tx_ac1_ampdu_und << 27) | ((u32)tx_ac0_ampdu_und << 26) | ((u32)sw_rts_success << 14) | ((u32)ac3_tx_bw_decision << 13) | ((u32)ac2_tx_bw_decision << 12) | ((u32)ac1_tx_bw_decision << 11) | ((u32)ac0_tx_bw_decision << 10) | ((u32)htp_tx_bw_decision << 9) | ((u32)bfr_resp_cancelled << 8) | ((u32)end_of_ppdu << 7) | ((u32)need_response << 6) | ((u32)rd_prot_trigger << 5) | ((u32)hcca_prot_trigger << 4) | ((u32)ac_3_prot_trigger << 3) | ((u32)ac_2_prot_trigger << 2) | ((u32)ac_1_prot_trigger << 1) | ((u32)ac_0_prot_trigger << 0));
}

static inline void mac_hw_high_pri_int_event_en_smac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_en_smac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_high_pri_int_event_en_smac_tx_htp_ampdu_und_setf(struct cl_chip *chip, u8 txhtpampduund)
{
	ASSERT_ERR_CHIP((((u32)txhtpampduund << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x40000000)) | ((u32)txhtpampduund << 30));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_high_pri_int_event_en_smac_tx_ac_3_ampdu_und_setf(struct cl_chip *chip, u8 txac3ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac3ampduund << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x20000000)) | ((u32)txac3ampduund << 29));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_high_pri_int_event_en_smac_tx_ac_2_ampdu_und_setf(struct cl_chip *chip, u8 txac2ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac2ampduund << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x10000000)) | ((u32)txac2ampduund << 28));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_high_pri_int_event_en_smac_tx_ac_1_ampdu_und_setf(struct cl_chip *chip, u8 txac1ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac1ampduund << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x08000000)) | ((u32)txac1ampduund << 27));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_high_pri_int_event_en_smac_tx_ac_0_ampdu_und_setf(struct cl_chip *chip, u8 txac0ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac0ampduund << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x04000000)) | ((u32)txac0ampduund << 26));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_high_pri_int_event_en_smac_sw_rts_success_setf(struct cl_chip *chip, u8 swrtssuccess)
{
	ASSERT_ERR_CHIP((((u32)swrtssuccess << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00004000)) | ((u32)swrtssuccess << 14));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_3_tx_bw_decision_setf(struct cl_chip *chip, u8 ac3txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac3txbwdecision << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac3txbwdecision << 13));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_2_tx_bw_decision_setf(struct cl_chip *chip, u8 ac2txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac2txbwdecision << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00001000)) | ((u32)ac2txbwdecision << 12));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_1_tx_bw_decision_setf(struct cl_chip *chip, u8 ac1txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac1txbwdecision << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000800)) | ((u32)ac1txbwdecision << 11));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_0_tx_bw_decision_setf(struct cl_chip *chip, u8 ac0txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac0txbwdecision << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000400)) | ((u32)ac0txbwdecision << 10));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_high_pri_int_event_en_smac_htp_tx_bw_decision_setf(struct cl_chip *chip, u8 htptxbwdecision)
{
	ASSERT_ERR_CHIP((((u32)htptxbwdecision << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000200)) | ((u32)htptxbwdecision << 9));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_high_pri_int_event_en_smac_bfr_resp_cancelled_setf(struct cl_chip *chip, u8 bfrrespcancelled)
{
	ASSERT_ERR_CHIP((((u32)bfrrespcancelled << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000100)) | ((u32)bfrrespcancelled << 8));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_high_pri_int_event_en_smac_end_of_ppdu_setf(struct cl_chip *chip, u8 endofppdu)
{
	ASSERT_ERR_CHIP((((u32)endofppdu << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000080)) | ((u32)endofppdu << 7));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_high_pri_int_event_en_smac_need_response_setf(struct cl_chip *chip, u8 needresponse)
{
	ASSERT_ERR_CHIP((((u32)needresponse << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000040)) | ((u32)needresponse << 6));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_high_pri_int_event_en_smac_rd_prot_trigger_setf(struct cl_chip *chip, u8 rdprottrigger)
{
	ASSERT_ERR_CHIP((((u32)rdprottrigger << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rdprottrigger << 5));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_high_pri_int_event_en_smac_hcca_prot_trigger_setf(struct cl_chip *chip, u8 hccaprottrigger)
{
	ASSERT_ERR_CHIP((((u32)hccaprottrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000010)) | ((u32)hccaprottrigger << 4));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_3_prot_trigger_setf(struct cl_chip *chip, u8 ac3prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3prottrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000008)) | ((u32)ac3prottrigger << 3));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_2_prot_trigger_setf(struct cl_chip *chip, u8 ac2prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2prottrigger << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000004)) | ((u32)ac2prottrigger << 2));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_1_prot_trigger_setf(struct cl_chip *chip, u8 ac1prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1prottrigger << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000002)) | ((u32)ac1prottrigger << 1));
}

static inline u8 mac_hw_high_pri_int_event_en_smac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_high_pri_int_event_en_smac_ac_0_prot_trigger_setf(struct cl_chip *chip, u8 ac0prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0prottrigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000001)) | ((u32)ac0prottrigger << 0));
}

/**
 * @brief HIGH_PRI_INT_EVENT_STA_UMAC register definition
 *  HIGH PRIORITY interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008120)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_OFFSET      0x00008120
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_INDEX       0x00002048
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_sta_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_sta_umac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_high_pri_int_event_sta_umac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief HIGH_PRI_INT_EVENT_STA_SMAC register definition
 *  HIGH PRIORITY interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008124)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_OFFSET      0x00008124
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_INDEX       0x00002049
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_sta_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_sta_smac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_high_pri_int_event_sta_smac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief HIGH_PRI_INT_EVENT_FORCE register definition
 *  HIGH PRIORITY interrupt event force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008128)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_OFFSET      0x00008128
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_INDEX       0x0000204A
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_high_pri_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_FORCE_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_force_pack(struct cl_chip *chip, u8 tx_htp_ampdu_und, u8 tx_ac3_ampdu_und, u8 tx_ac2_ampdu_und, u8 tx_ac1_ampdu_und, u8 tx_ac0_ampdu_und, u8 sw_rts_success, u8 ac3_tx_bw_decision, u8 ac2_tx_bw_decision, u8 ac1_tx_bw_decision, u8 ac0_tx_bw_decision, u8 htp_tx_bw_decision, u8 bfr_resp_cancelled, u8 end_of_ppdu, u8 need_response, u8 rd_prot_trigger, u8 hcca_prot_trigger, u8 ac_3_prot_trigger, u8 ac_2_prot_trigger, u8 ac_1_prot_trigger, u8 ac_0_prot_trigger)
{
	ASSERT_ERR_CHIP((((u32)tx_htp_ampdu_und << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac3_ampdu_und << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac2_ampdu_und << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac1_ampdu_und << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac0_ampdu_und << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_rts_success << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac3_tx_bw_decision << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac2_tx_bw_decision << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac1_tx_bw_decision << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ac0_tx_bw_decision << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_bw_decision << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_resp_cancelled << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)end_of_ppdu << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)need_response << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_prot_trigger << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_prot_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_prot_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_prot_trigger << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_prot_trigger << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_prot_trigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, ((u32)tx_htp_ampdu_und << 30) | ((u32)tx_ac3_ampdu_und << 29) | ((u32)tx_ac2_ampdu_und << 28) | ((u32)tx_ac1_ampdu_und << 27) | ((u32)tx_ac0_ampdu_und << 26) | ((u32)sw_rts_success << 14) | ((u32)ac3_tx_bw_decision << 13) | ((u32)ac2_tx_bw_decision << 12) | ((u32)ac1_tx_bw_decision << 11) | ((u32)ac0_tx_bw_decision << 10) | ((u32)htp_tx_bw_decision << 9) | ((u32)bfr_resp_cancelled << 8) | ((u32)end_of_ppdu << 7) | ((u32)need_response << 6) | ((u32)rd_prot_trigger << 5) | ((u32)hcca_prot_trigger << 4) | ((u32)ac_3_prot_trigger << 3) | ((u32)ac_2_prot_trigger << 2) | ((u32)ac_1_prot_trigger << 1) | ((u32)ac_0_prot_trigger << 0));
}

static inline void mac_hw_high_pri_int_event_force_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_force_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_high_pri_int_event_force_tx_htp_ampdu_und_setf(struct cl_chip *chip, u8 txhtpampduund)
{
	ASSERT_ERR_CHIP((((u32)txhtpampduund << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x40000000)) | ((u32)txhtpampduund << 30));
}

static inline u8 mac_hw_high_pri_int_event_force_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_high_pri_int_event_force_tx_ac_3_ampdu_und_setf(struct cl_chip *chip, u8 txac3ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac3ampduund << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x20000000)) | ((u32)txac3ampduund << 29));
}

static inline u8 mac_hw_high_pri_int_event_force_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_high_pri_int_event_force_tx_ac_2_ampdu_und_setf(struct cl_chip *chip, u8 txac2ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac2ampduund << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x10000000)) | ((u32)txac2ampduund << 28));
}

static inline u8 mac_hw_high_pri_int_event_force_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_high_pri_int_event_force_tx_ac_1_ampdu_und_setf(struct cl_chip *chip, u8 txac1ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac1ampduund << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x08000000)) | ((u32)txac1ampduund << 27));
}

static inline u8 mac_hw_high_pri_int_event_force_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_high_pri_int_event_force_tx_ac_0_ampdu_und_setf(struct cl_chip *chip, u8 txac0ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac0ampduund << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x04000000)) | ((u32)txac0ampduund << 26));
}

static inline u8 mac_hw_high_pri_int_event_force_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_high_pri_int_event_force_sw_rts_success_setf(struct cl_chip *chip, u8 swrtssuccess)
{
	ASSERT_ERR_CHIP((((u32)swrtssuccess << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00004000)) | ((u32)swrtssuccess << 14));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_high_pri_int_event_force_ac_3_tx_bw_decision_setf(struct cl_chip *chip, u8 ac3txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac3txbwdecision << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00002000)) | ((u32)ac3txbwdecision << 13));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_high_pri_int_event_force_ac_2_tx_bw_decision_setf(struct cl_chip *chip, u8 ac2txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac2txbwdecision << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00001000)) | ((u32)ac2txbwdecision << 12));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_high_pri_int_event_force_ac_1_tx_bw_decision_setf(struct cl_chip *chip, u8 ac1txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac1txbwdecision << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000800)) | ((u32)ac1txbwdecision << 11));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_high_pri_int_event_force_ac_0_tx_bw_decision_setf(struct cl_chip *chip, u8 ac0txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac0txbwdecision << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000400)) | ((u32)ac0txbwdecision << 10));
}

static inline u8 mac_hw_high_pri_int_event_force_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_high_pri_int_event_force_htp_tx_bw_decision_setf(struct cl_chip *chip, u8 htptxbwdecision)
{
	ASSERT_ERR_CHIP((((u32)htptxbwdecision << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000200)) | ((u32)htptxbwdecision << 9));
}

static inline u8 mac_hw_high_pri_int_event_force_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_high_pri_int_event_force_bfr_resp_cancelled_setf(struct cl_chip *chip, u8 bfrrespcancelled)
{
	ASSERT_ERR_CHIP((((u32)bfrrespcancelled << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000100)) | ((u32)bfrrespcancelled << 8));
}

static inline u8 mac_hw_high_pri_int_event_force_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_high_pri_int_event_force_end_of_ppdu_setf(struct cl_chip *chip, u8 endofppdu)
{
	ASSERT_ERR_CHIP((((u32)endofppdu << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000080)) | ((u32)endofppdu << 7));
}

static inline u8 mac_hw_high_pri_int_event_force_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_high_pri_int_event_force_need_response_setf(struct cl_chip *chip, u8 needresponse)
{
	ASSERT_ERR_CHIP((((u32)needresponse << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000040)) | ((u32)needresponse << 6));
}

static inline u8 mac_hw_high_pri_int_event_force_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_high_pri_int_event_force_rd_prot_trigger_setf(struct cl_chip *chip, u8 rdprottrigger)
{
	ASSERT_ERR_CHIP((((u32)rdprottrigger << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000020)) | ((u32)rdprottrigger << 5));
}

static inline u8 mac_hw_high_pri_int_event_force_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_high_pri_int_event_force_hcca_prot_trigger_setf(struct cl_chip *chip, u8 hccaprottrigger)
{
	ASSERT_ERR_CHIP((((u32)hccaprottrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000010)) | ((u32)hccaprottrigger << 4));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_high_pri_int_event_force_ac_3_prot_trigger_setf(struct cl_chip *chip, u8 ac3prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3prottrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000008)) | ((u32)ac3prottrigger << 3));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_high_pri_int_event_force_ac_2_prot_trigger_setf(struct cl_chip *chip, u8 ac2prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2prottrigger << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000004)) | ((u32)ac2prottrigger << 2));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_high_pri_int_event_force_ac_1_prot_trigger_setf(struct cl_chip *chip, u8 ac1prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1prottrigger << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000002)) | ((u32)ac1prottrigger << 1));
}

static inline u8 mac_hw_high_pri_int_event_force_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_high_pri_int_event_force_ac_0_prot_trigger_setf(struct cl_chip *chip, u8 ac0prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0prottrigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000001)) | ((u32)ac0prottrigger << 0));
}

/**
 * @brief HIGH_PRI_INT_MAC_SOURCE_UMAC register definition
 *  Indicates the UMAC HIGH PRIORITY interrupt MAC sou register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000812C)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_OFFSET      0x0000812C
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_INDEX       0x0000204B
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_high_pri_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief HIGH_PRI_INT_MAC_SOURCE_SMAC register definition
 *  Indicates the SMAC HIGH PRIORITY interrupt MAC sou register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008130)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_OFFSET      0x00008130
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_INDEX       0x0000204C
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_high_pri_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_INT_EVENT_RAW_STATUS register definition
 *  Indicates RX events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008134)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_OFFSET      0x00008134
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_INDEX       0x0000204D
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_RAW_STATUS_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_RAW_STATUS_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_raw_status_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_raw_status_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_rx_int_event_raw_status_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_rx_int_event_raw_status_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_rx_int_event_raw_status_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_rx_int_event_raw_status_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_rx_int_event_raw_status_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_rx_int_event_raw_status_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief RX_INT_EVENT_EN_SMAC register definition
 *  RX interrupt events enable SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008138)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_OFFSET      0x00008138
#define MAC_HW_RX_INT_EVENT_EN_SMAC_INDEX       0x0000204E
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_rx_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_EN_SMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_EN_SMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_EN_SMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_SMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_en_smac_pack(struct cl_chip *chip, u8 eop_filtered, u8 counter_rx_trigger2, u8 phy_rx_start, u8 ba_rx_trigger2, u8 rx_trigger2, u8 counter_rx_trigger, u8 ba_rx_trigger, u8 rx_trigger, u8 rx_implicit_bf, u8 rx_class_rule5, u8 rx_class_rule4, u8 rx_class_rule3, u8 rx_class_rule2, u8 rx_class_rule1, u8 rx_class_rule0)
{
	ASSERT_ERR_CHIP((((u32)eop_filtered << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger2 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_rx_start << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger2 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_implicit_bf << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, ((u32)eop_filtered << 25) | ((u32)counter_rx_trigger2 << 24) | ((u32)phy_rx_start << 23) | ((u32)ba_rx_trigger2 << 22) | ((u32)rx_trigger2 << 20) | ((u32)counter_rx_trigger << 19) | ((u32)ba_rx_trigger << 18) | ((u32)rx_trigger << 16) | ((u32)rx_implicit_bf << 8) | ((u32)rx_class_rule5 << 5) | ((u32)rx_class_rule4 << 4) | ((u32)rx_class_rule3 << 3) | ((u32)rx_class_rule2 << 2) | ((u32)rx_class_rule1 << 1) | ((u32)rx_class_rule0 << 0));
}

static inline void mac_hw_rx_int_event_en_smac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_en_smac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_rx_int_event_en_smac_eop_filtered_setf(struct cl_chip *chip, u8 eopfiltered)
{
	ASSERT_ERR_CHIP((((u32)eopfiltered << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x02000000)) | ((u32)eopfiltered << 25));
}

static inline u8 mac_hw_rx_int_event_en_smac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_rx_int_event_en_smac_counter_rx_trigger_2_setf(struct cl_chip *chip, u8 counterrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger2 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x01000000)) | ((u32)counterrxtrigger2 << 24));
}

static inline u8 mac_hw_rx_int_event_en_smac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_int_event_en_smac_phy_rx_start_setf(struct cl_chip *chip, u8 phyrxstart)
{
	ASSERT_ERR_CHIP((((u32)phyrxstart << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00800000)) | ((u32)phyrxstart << 23));
}

static inline u8 mac_hw_rx_int_event_en_smac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_int_event_en_smac_ba_rx_trigger_2_setf(struct cl_chip *chip, u8 barxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00400000)) | ((u32)barxtrigger2 << 22));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_int_event_en_smac_rx_trigger_2_setf(struct cl_chip *chip, u8 rxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger2 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00100000)) | ((u32)rxtrigger2 << 20));
}

static inline u8 mac_hw_rx_int_event_en_smac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_int_event_en_smac_counter_rx_trigger_setf(struct cl_chip *chip, u8 counterrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00080000)) | ((u32)counterrxtrigger << 19));
}

static inline u8 mac_hw_rx_int_event_en_smac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_int_event_en_smac_ba_rx_trigger_setf(struct cl_chip *chip, u8 barxtrigger)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00040000)) | ((u32)barxtrigger << 18));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_int_event_en_smac_rx_trigger_setf(struct cl_chip *chip, u8 rxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00010000)) | ((u32)rxtrigger << 16));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_int_event_en_smac_rx_implicit_bf_setf(struct cl_chip *chip, u8 rximplicitbf)
{
	ASSERT_ERR_CHIP((((u32)rximplicitbf << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rximplicitbf << 8));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_5_setf(struct cl_chip *chip, u8 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxclassrule5 << 5));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_4_setf(struct cl_chip *chip, u8 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rxclassrule4 << 4));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_3_setf(struct cl_chip *chip, u8 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000008)) | ((u32)rxclassrule3 << 3));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_2_setf(struct cl_chip *chip, u8 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000004)) | ((u32)rxclassrule2 << 2));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_1_setf(struct cl_chip *chip, u8 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000002)) | ((u32)rxclassrule1 << 1));
}

static inline u8 mac_hw_rx_int_event_en_smac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_int_event_en_smac_rx_class_rule_0_setf(struct cl_chip *chip, u8 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000001)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief RX_INT_EVENT_STATUS_UMAC register definition
 *  RX interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000813C)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_OFFSET      0x0000813C
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_INDEX       0x0000204F
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_status_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_UMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_status_umac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_status_umac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_rx_int_event_status_umac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_rx_int_event_status_umac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_rx_int_event_status_umac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_rx_int_event_status_umac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_rx_int_event_status_umac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_rx_int_event_status_umac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief RX_INT_EVENT_STATUS_SMAC register definition
 *  RX interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008140)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_OFFSET      0x00008140
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_INDEX       0x00002050
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_status_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_SMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_status_smac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_status_smac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_rx_int_event_status_smac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_rx_int_event_status_smac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_rx_int_event_status_smac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_rx_int_event_status_smac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_rx_int_event_status_smac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_rx_int_event_status_smac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief RX_INT_EVENT_FORCE register definition
 *  RX interrupt events force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008144)
#define MAC_HW_RX_INT_EVENT_FORCE_OFFSET      0x00008144
#define MAC_HW_RX_INT_EVENT_FORCE_INDEX       0x00002051
#define MAC_HW_RX_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_rx_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_FORCE_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_FORCE_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_FORCE_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_FORCE_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_FORCE_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_FORCE_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_FORCE_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_force_pack(struct cl_chip *chip, u8 eop_filtered, u8 counter_rx_trigger2, u8 phy_rx_start, u8 ba_rx_trigger2, u8 rx_trigger2, u8 counter_rx_trigger, u8 ba_rx_trigger, u8 rx_trigger, u8 rx_implicit_bf, u8 rx_class_rule5, u8 rx_class_rule4, u8 rx_class_rule3, u8 rx_class_rule2, u8 rx_class_rule1, u8 rx_class_rule0)
{
	ASSERT_ERR_CHIP((((u32)eop_filtered << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger2 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_rx_start << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger2 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_implicit_bf << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, ((u32)eop_filtered << 25) | ((u32)counter_rx_trigger2 << 24) | ((u32)phy_rx_start << 23) | ((u32)ba_rx_trigger2 << 22) | ((u32)rx_trigger2 << 20) | ((u32)counter_rx_trigger << 19) | ((u32)ba_rx_trigger << 18) | ((u32)rx_trigger << 16) | ((u32)rx_implicit_bf << 8) | ((u32)rx_class_rule5 << 5) | ((u32)rx_class_rule4 << 4) | ((u32)rx_class_rule3 << 3) | ((u32)rx_class_rule2 << 2) | ((u32)rx_class_rule1 << 1) | ((u32)rx_class_rule0 << 0));
}

static inline void mac_hw_rx_int_event_force_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_force_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_rx_int_event_force_eop_filtered_setf(struct cl_chip *chip, u8 eopfiltered)
{
	ASSERT_ERR_CHIP((((u32)eopfiltered << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x02000000)) | ((u32)eopfiltered << 25));
}

static inline u8 mac_hw_rx_int_event_force_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_rx_int_event_force_counter_rx_trigger_2_setf(struct cl_chip *chip, u8 counterrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger2 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x01000000)) | ((u32)counterrxtrigger2 << 24));
}

static inline u8 mac_hw_rx_int_event_force_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_int_event_force_phy_rx_start_setf(struct cl_chip *chip, u8 phyrxstart)
{
	ASSERT_ERR_CHIP((((u32)phyrxstart << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00800000)) | ((u32)phyrxstart << 23));
}

static inline u8 mac_hw_rx_int_event_force_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_int_event_force_ba_rx_trigger_2_setf(struct cl_chip *chip, u8 barxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00400000)) | ((u32)barxtrigger2 << 22));
}

static inline u8 mac_hw_rx_int_event_force_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_int_event_force_rx_trigger_2_setf(struct cl_chip *chip, u8 rxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger2 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00100000)) | ((u32)rxtrigger2 << 20));
}

static inline u8 mac_hw_rx_int_event_force_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_int_event_force_counter_rx_trigger_setf(struct cl_chip *chip, u8 counterrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00080000)) | ((u32)counterrxtrigger << 19));
}

static inline u8 mac_hw_rx_int_event_force_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_int_event_force_ba_rx_trigger_setf(struct cl_chip *chip, u8 barxtrigger)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00040000)) | ((u32)barxtrigger << 18));
}

static inline u8 mac_hw_rx_int_event_force_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_int_event_force_rx_trigger_setf(struct cl_chip *chip, u8 rxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00010000)) | ((u32)rxtrigger << 16));
}

static inline u8 mac_hw_rx_int_event_force_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_int_event_force_rx_implicit_bf_setf(struct cl_chip *chip, u8 rximplicitbf)
{
	ASSERT_ERR_CHIP((((u32)rximplicitbf << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000100)) | ((u32)rximplicitbf << 8));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_5_setf(struct cl_chip *chip, u8 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000020)) | ((u32)rxclassrule5 << 5));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_4_setf(struct cl_chip *chip, u8 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000010)) | ((u32)rxclassrule4 << 4));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_3_setf(struct cl_chip *chip, u8 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000008)) | ((u32)rxclassrule3 << 3));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_2_setf(struct cl_chip *chip, u8 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000004)) | ((u32)rxclassrule2 << 2));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_1_setf(struct cl_chip *chip, u8 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000002)) | ((u32)rxclassrule1 << 1));
}

static inline u8 mac_hw_rx_int_event_force_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_int_event_force_rx_class_rule_0_setf(struct cl_chip *chip, u8 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000001)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief RX_INT_MAC_SOURCE_UMAC register definition
 *  Indicates the UMAC RX interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008148)
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_OFFSET      0x00008148
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_INDEX       0x00002052
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_rx_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief RX_INT_MAC_SOURCE_SMAC register definition
 *  Indicates the SMAC RX interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000814C)
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_OFFSET      0x0000814C
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_INDEX       0x00002053
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_RX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_rx_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TX_INT_EVENT_RAW_STATUS register definition
 *  Indicates TX events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    13    TXM_TX_TRIGGER            0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008150)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_OFFSET      0x00008150
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_INDEX       0x00002054
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXM_TX_TRIGGER_BIT    ((u32)0x00002000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXM_TX_TRIGGER_POS    13
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXM_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_RAW_STATUS_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_raw_status_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *txm_tx_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*txm_tx_trigger = (local_val & ((u32)0x00002000)) >> 13;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_raw_status_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_tx_int_event_raw_status_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_tx_int_event_raw_status_txm_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_tx_int_event_raw_status_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_tx_int_event_raw_status_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_tx_int_event_raw_status_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_tx_int_event_raw_status_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_tx_int_event_raw_status_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_tx_int_event_raw_status_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_tx_int_event_raw_status_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

/**
 * @brief TX_INT_EVENT_EN_SMAC register definition
 *  TX interrupt events enable SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008154)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_OFFSET      0x00008154
#define MAC_HW_TX_INT_EVENT_EN_SMAC_INDEX       0x00002055
#define MAC_HW_TX_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_tx_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_EN_SMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_SMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_en_smac_pack(struct cl_chip *chip, u8 htp_tx_buf_trigger, u8 bcn_tx_buf_trigger, u8 ac_3_tx_buf_trigger, u8 ac_2_tx_buf_trigger, u8 ac_1_tx_buf_trigger, u8 ac_0_tx_buf_trigger, u8 htp_tx_trigger, u8 hcca_tx_trigger, u8 bcn_tx_trigger, u8 ac_3_tx_trigger, u8 ac_2_tx_trigger, u8 ac_1_tx_trigger, u8 ac_0_tx_trigger, u8 txop_complete, u8 rd_tx_trigger, u8 tx_abort)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_buf_trigger << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_buf_trigger << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_buf_trigger << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_buf_trigger << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_buf_trigger << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_buf_trigger << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_trigger << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_tx_trigger << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_trigger << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_trigger << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_trigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_trigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_trigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_complete << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_tx_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_abort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, ((u32)htp_tx_buf_trigger << 29) | ((u32)bcn_tx_buf_trigger << 28) | ((u32)ac_3_tx_buf_trigger << 27) | ((u32)ac_2_tx_buf_trigger << 26) | ((u32)ac_1_tx_buf_trigger << 25) | ((u32)ac_0_tx_buf_trigger << 24) | ((u32)htp_tx_trigger << 12) | ((u32)hcca_tx_trigger << 11) | ((u32)bcn_tx_trigger << 10) | ((u32)ac_3_tx_trigger << 9) | ((u32)ac_2_tx_trigger << 8) | ((u32)ac_1_tx_trigger << 7) | ((u32)ac_0_tx_trigger << 6) | ((u32)txop_complete << 5) | ((u32)rd_tx_trigger << 4) | ((u32)tx_abort << 3));
}

static inline void mac_hw_tx_int_event_en_smac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_en_smac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_tx_int_event_en_smac_htp_tx_buf_trigger_setf(struct cl_chip *chip, u8 htptxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxbuftrigger << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x20000000)) | ((u32)htptxbuftrigger << 29));
}

static inline u8 mac_hw_tx_int_event_en_smac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_tx_int_event_en_smac_bcn_tx_buf_trigger_setf(struct cl_chip *chip, u8 bcntxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxbuftrigger << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x10000000)) | ((u32)bcntxbuftrigger << 28));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_tx_int_event_en_smac_ac_3_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac3txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txbuftrigger << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x08000000)) | ((u32)ac3txbuftrigger << 27));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_tx_int_event_en_smac_ac_2_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac2txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txbuftrigger << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x04000000)) | ((u32)ac2txbuftrigger << 26));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_tx_int_event_en_smac_ac_1_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac1txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txbuftrigger << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x02000000)) | ((u32)ac1txbuftrigger << 25));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_tx_int_event_en_smac_ac_0_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac0txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txbuftrigger << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x01000000)) | ((u32)ac0txbuftrigger << 24));
}

static inline u8 mac_hw_tx_int_event_en_smac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_tx_int_event_en_smac_htp_tx_trigger_setf(struct cl_chip *chip, u8 htptxtrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxtrigger << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00001000)) | ((u32)htptxtrigger << 12));
}

static inline u8 mac_hw_tx_int_event_en_smac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_tx_int_event_en_smac_hcca_tx_trigger_setf(struct cl_chip *chip, u8 hccatxtrigger)
{
	ASSERT_ERR_CHIP((((u32)hccatxtrigger << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000800)) | ((u32)hccatxtrigger << 11));
}

static inline u8 mac_hw_tx_int_event_en_smac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_tx_int_event_en_smac_bcn_tx_trigger_setf(struct cl_chip *chip, u8 bcntxtrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxtrigger << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000400)) | ((u32)bcntxtrigger << 10));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_tx_int_event_en_smac_ac_3_tx_trigger_setf(struct cl_chip *chip, u8 ac3txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txtrigger << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000200)) | ((u32)ac3txtrigger << 9));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_tx_int_event_en_smac_ac_2_tx_trigger_setf(struct cl_chip *chip, u8 ac2txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txtrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000100)) | ((u32)ac2txtrigger << 8));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_int_event_en_smac_ac_1_tx_trigger_setf(struct cl_chip *chip, u8 ac1txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txtrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000080)) | ((u32)ac1txtrigger << 7));
}

static inline u8 mac_hw_tx_int_event_en_smac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_tx_int_event_en_smac_ac_0_tx_trigger_setf(struct cl_chip *chip, u8 ac0txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txtrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000040)) | ((u32)ac0txtrigger << 6));
}

static inline u8 mac_hw_tx_int_event_en_smac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_tx_int_event_en_smac_txop_complete_setf(struct cl_chip *chip, u8 txopcomplete)
{
	ASSERT_ERR_CHIP((((u32)txopcomplete << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000020)) | ((u32)txopcomplete << 5));
}

static inline u8 mac_hw_tx_int_event_en_smac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_tx_int_event_en_smac_rd_tx_trigger_setf(struct cl_chip *chip, u8 rdtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rdtxtrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rdtxtrigger << 4));
}

static inline u8 mac_hw_tx_int_event_en_smac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_tx_int_event_en_smac_tx_abort_setf(struct cl_chip *chip, u8 txabort)
{
	ASSERT_ERR_CHIP((((u32)txabort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00000008)) | ((u32)txabort << 3));
}

/**
 * @brief TX_INT_EVENT_STATUS_UMAC register definition
 *  TX interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008158)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_OFFSET      0x00008158
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_INDEX       0x00002056
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_status_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_UMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_status_umac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_status_umac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_tx_int_event_status_umac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_tx_int_event_status_umac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_tx_int_event_status_umac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_tx_int_event_status_umac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_tx_int_event_status_umac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_tx_int_event_status_umac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_tx_int_event_status_umac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_tx_int_event_status_umac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

/**
 * @brief TX_INT_EVENT_STATUS_SMAC register definition
 *  TX interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000815C)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_OFFSET      0x0000815C
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_INDEX       0x00002057
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_status_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_SMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_status_smac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_status_smac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_tx_int_event_status_smac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_tx_int_event_status_smac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_tx_int_event_status_smac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_tx_int_event_status_smac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_tx_int_event_status_smac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_tx_int_event_status_smac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_tx_int_event_status_smac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_tx_int_event_status_smac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

/**
 * @brief TX_INT_EVENT_FORCE register definition
 *  TX interrupt events force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008160)
#define MAC_HW_TX_INT_EVENT_FORCE_OFFSET      0x00008160
#define MAC_HW_TX_INT_EVENT_FORCE_INDEX       0x00002058
#define MAC_HW_TX_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_tx_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_FORCE_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_FORCE_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_FORCE_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_FORCE_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_FORCE_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_FORCE_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_FORCE_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_FORCE_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_FORCE_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_force_pack(struct cl_chip *chip, u8 htp_tx_buf_trigger, u8 bcn_tx_buf_trigger, u8 ac_3_tx_buf_trigger, u8 ac_2_tx_buf_trigger, u8 ac_1_tx_buf_trigger, u8 ac_0_tx_buf_trigger, u8 htp_tx_trigger, u8 hcca_tx_trigger, u8 bcn_tx_trigger, u8 ac_3_tx_trigger, u8 ac_2_tx_trigger, u8 ac_1_tx_trigger, u8 ac_0_tx_trigger, u8 txop_complete, u8 rd_tx_trigger, u8 tx_abort)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_buf_trigger << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_buf_trigger << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_buf_trigger << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_buf_trigger << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_buf_trigger << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_buf_trigger << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_trigger << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_tx_trigger << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_trigger << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_trigger << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_trigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_trigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_trigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_complete << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_tx_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_abort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, ((u32)htp_tx_buf_trigger << 29) | ((u32)bcn_tx_buf_trigger << 28) | ((u32)ac_3_tx_buf_trigger << 27) | ((u32)ac_2_tx_buf_trigger << 26) | ((u32)ac_1_tx_buf_trigger << 25) | ((u32)ac_0_tx_buf_trigger << 24) | ((u32)htp_tx_trigger << 12) | ((u32)hcca_tx_trigger << 11) | ((u32)bcn_tx_trigger << 10) | ((u32)ac_3_tx_trigger << 9) | ((u32)ac_2_tx_trigger << 8) | ((u32)ac_1_tx_trigger << 7) | ((u32)ac_0_tx_trigger << 6) | ((u32)txop_complete << 5) | ((u32)rd_tx_trigger << 4) | ((u32)tx_abort << 3));
}

static inline void mac_hw_tx_int_event_force_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_force_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_tx_int_event_force_htp_tx_buf_trigger_setf(struct cl_chip *chip, u8 htptxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxbuftrigger << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x20000000)) | ((u32)htptxbuftrigger << 29));
}

static inline u8 mac_hw_tx_int_event_force_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_tx_int_event_force_bcn_tx_buf_trigger_setf(struct cl_chip *chip, u8 bcntxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxbuftrigger << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x10000000)) | ((u32)bcntxbuftrigger << 28));
}

static inline u8 mac_hw_tx_int_event_force_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_tx_int_event_force_ac_3_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac3txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txbuftrigger << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x08000000)) | ((u32)ac3txbuftrigger << 27));
}

static inline u8 mac_hw_tx_int_event_force_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_tx_int_event_force_ac_2_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac2txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txbuftrigger << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x04000000)) | ((u32)ac2txbuftrigger << 26));
}

static inline u8 mac_hw_tx_int_event_force_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_tx_int_event_force_ac_1_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac1txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txbuftrigger << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x02000000)) | ((u32)ac1txbuftrigger << 25));
}

static inline u8 mac_hw_tx_int_event_force_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_tx_int_event_force_ac_0_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac0txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txbuftrigger << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x01000000)) | ((u32)ac0txbuftrigger << 24));
}

static inline u8 mac_hw_tx_int_event_force_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_tx_int_event_force_htp_tx_trigger_setf(struct cl_chip *chip, u8 htptxtrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxtrigger << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00001000)) | ((u32)htptxtrigger << 12));
}

static inline u8 mac_hw_tx_int_event_force_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_tx_int_event_force_hcca_tx_trigger_setf(struct cl_chip *chip, u8 hccatxtrigger)
{
	ASSERT_ERR_CHIP((((u32)hccatxtrigger << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000800)) | ((u32)hccatxtrigger << 11));
}

static inline u8 mac_hw_tx_int_event_force_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_tx_int_event_force_bcn_tx_trigger_setf(struct cl_chip *chip, u8 bcntxtrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxtrigger << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000400)) | ((u32)bcntxtrigger << 10));
}

static inline u8 mac_hw_tx_int_event_force_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_tx_int_event_force_ac_3_tx_trigger_setf(struct cl_chip *chip, u8 ac3txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txtrigger << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000200)) | ((u32)ac3txtrigger << 9));
}

static inline u8 mac_hw_tx_int_event_force_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_tx_int_event_force_ac_2_tx_trigger_setf(struct cl_chip *chip, u8 ac2txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txtrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000100)) | ((u32)ac2txtrigger << 8));
}

static inline u8 mac_hw_tx_int_event_force_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_int_event_force_ac_1_tx_trigger_setf(struct cl_chip *chip, u8 ac1txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txtrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000080)) | ((u32)ac1txtrigger << 7));
}

static inline u8 mac_hw_tx_int_event_force_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_tx_int_event_force_ac_0_tx_trigger_setf(struct cl_chip *chip, u8 ac0txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txtrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000040)) | ((u32)ac0txtrigger << 6));
}

static inline u8 mac_hw_tx_int_event_force_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_tx_int_event_force_txop_complete_setf(struct cl_chip *chip, u8 txopcomplete)
{
	ASSERT_ERR_CHIP((((u32)txopcomplete << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000020)) | ((u32)txopcomplete << 5));
}

static inline u8 mac_hw_tx_int_event_force_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_tx_int_event_force_rd_tx_trigger_setf(struct cl_chip *chip, u8 rdtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rdtxtrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000010)) | ((u32)rdtxtrigger << 4));
}

static inline u8 mac_hw_tx_int_event_force_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_tx_int_event_force_tx_abort_setf(struct cl_chip *chip, u8 txabort)
{
	ASSERT_ERR_CHIP((((u32)txabort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_FORCE_ADDR) & ~((u32)0x00000008)) | ((u32)txabort << 3));
}

/**
 * @brief TX_INT_MAC_SOURCE_UMAC register definition
 *  Indicates UMAC TX interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008164)
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_OFFSET      0x00008164
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_INDEX       0x00002059
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_tx_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TX_INT_MAC_SOURCE_SMAC register definition
 *  Indicates SMAC TX interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008168)
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_OFFSET      0x00008168
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_INDEX       0x0000205A
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_tx_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TX_HTP_HEAD_PTR register definition
 *  Head Pointer of the HTP DMA channel is programmed  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_HTP_HEAD_PTR           0x0
 * </pre>
 */
#define MAC_HW_TX_HTP_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000817C)
#define MAC_HW_TX_HTP_HEAD_PTR_OFFSET      0x0000817C
#define MAC_HW_TX_HTP_HEAD_PTR_INDEX       0x0000205F
#define MAC_HW_TX_HTP_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_htp_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_HTP_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_htp_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_HTP_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_HTP_HEAD_PTR_TX_HTP_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_HTP_HEAD_PTR_TX_HTP_HEAD_PTR_LSB    0
#define MAC_HW_TX_HTP_HEAD_PTR_TX_HTP_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_HTP_HEAD_PTR_TX_HTP_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_htp_head_ptr_tx_htp_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_HTP_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_htp_head_ptr_tx_htp_head_ptr_setf(struct cl_chip *chip, u32 txhtpheadptr)
{
	ASSERT_ERR_CHIP((((u32)txhtpheadptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_HTP_HEAD_PTR_ADDR, (u32)txhtpheadptr << 0);
}

/**
 * @brief DMA_CNTRL_SET register definition
 *  Contains control set bits for the DMA channels. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RX_PAYLOAD_NEW_HEAD2      0
 *    30    RX_HEADER_NEW_HEAD2       0
 *    29    RX_PAYLOAD_NEW_TAIL2      0
 *    28    RX_HEADER_NEW_TAIL2       0
 *    27    RX_PAYLOAD_NEW_HEAD       0
 *    26    RX_HEADER_NEW_HEAD        0
 *    25    RX_PAYLOAD_NEW_TAIL       0
 *    24    RX_HEADER_NEW_TAIL        0
 *    20    HALT_HTP_AFTER_TXOP       0
 *    19    HALT_AC_3_AFTER_TXOP      0
 *    18    HALT_AC_2_AFTER_TXOP      0
 *    17    HALT_AC_1_AFTER_TXOP      0
 *    16    HALT_AC_0_AFTER_TXOP      0
 *    15    HALT_BCN_AFTER_TXOP       0
 *    13    TX_HTP_NEW_HEAD           0
 *    12    TX_AC_3_NEW_HEAD          0
 *    11    TX_AC_2_NEW_HEAD          0
 *    10    TX_AC_1_NEW_HEAD          0
 *    09    TX_AC_0_NEW_HEAD          0
 *    08    TX_BCN_NEW_HEAD           0
 *    05    TX_HTP_NEW_TAIL           0
 *    04    TX_AC_3_NEW_TAIL          0
 *    03    TX_AC_2_NEW_TAIL          0
 *    02    TX_AC_1_NEW_TAIL          0
 *    01    TX_AC_0_NEW_TAIL          0
 *    00    TX_BCN_NEW_TAIL           0
 * </pre>
 */
#define MAC_HW_DMA_CNTRL_SET_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008180)
#define MAC_HW_DMA_CNTRL_SET_OFFSET      0x00008180
#define MAC_HW_DMA_CNTRL_SET_INDEX       0x00002060
#define MAC_HW_DMA_CNTRL_SET_RESET       0x00000000

static inline u32 mac_hw_dma_cntrl_set_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);
}

static inline void mac_hw_dma_cntrl_set_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_2_BIT    ((u32)0x80000000)
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_2_POS    31
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_2_BIT    ((u32)0x40000000)
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_2_POS    30
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_2_BIT    ((u32)0x20000000)
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_2_POS    29
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_2_BIT    ((u32)0x10000000)
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_2_POS    28
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_BIT    ((u32)0x08000000)
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_POS    27
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_BIT    ((u32)0x04000000)
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_POS    26
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_BIT    ((u32)0x02000000)
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_POS    25
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_BIT    ((u32)0x01000000)
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_POS    24
#define MAC_HW_DMA_CNTRL_SET_HALT_HTP_AFTER_TXOP_BIT    ((u32)0x00100000)
#define MAC_HW_DMA_CNTRL_SET_HALT_HTP_AFTER_TXOP_POS    20
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_3_AFTER_TXOP_BIT    ((u32)0x00080000)
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_3_AFTER_TXOP_POS    19
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_2_AFTER_TXOP_BIT    ((u32)0x00040000)
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_2_AFTER_TXOP_POS    18
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_1_AFTER_TXOP_BIT    ((u32)0x00020000)
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_1_AFTER_TXOP_POS    17
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_0_AFTER_TXOP_BIT    ((u32)0x00010000)
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_0_AFTER_TXOP_POS    16
#define MAC_HW_DMA_CNTRL_SET_HALT_BCN_AFTER_TXOP_BIT    ((u32)0x00008000)
#define MAC_HW_DMA_CNTRL_SET_HALT_BCN_AFTER_TXOP_POS    15
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_HEAD_BIT    ((u32)0x00002000)
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_HEAD_POS    13
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_HEAD_BIT    ((u32)0x00001000)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_HEAD_POS    12
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_HEAD_BIT    ((u32)0x00000800)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_HEAD_POS    11
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_HEAD_BIT    ((u32)0x00000400)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_HEAD_POS    10
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_HEAD_BIT    ((u32)0x00000200)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_HEAD_POS    9
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_HEAD_BIT    ((u32)0x00000100)
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_HEAD_POS    8
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_TAIL_BIT    ((u32)0x00000020)
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_TAIL_POS    5
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_TAIL_BIT    ((u32)0x00000010)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_TAIL_POS    4
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_TAIL_BIT    ((u32)0x00000008)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_TAIL_POS    3
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_TAIL_BIT    ((u32)0x00000004)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_TAIL_POS    2
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_TAIL_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_TAIL_POS    1
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_TAIL_BIT    ((u32)0x00000001)
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_TAIL_POS    0

#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_2_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_2_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_2_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_2_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_PAYLOAD_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_RX_HEADER_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_HTP_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_3_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_2_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_1_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_AC_0_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_HALT_BCN_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_HTP_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_3_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_2_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_1_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_AC_0_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_SET_TX_BCN_NEW_TAIL_RST    0x0

static inline void mac_hw_dma_cntrl_set_pack(struct cl_chip *chip, u8 rx_payload_new_head2, u8 rx_header_new_head2, u8 rx_payload_new_tail2, u8 rx_header_new_tail2, u8 rx_payload_new_head, u8 rx_header_new_head, u8 rx_payload_new_tail, u8 rx_header_new_tail, u8 halt_htp_after_txop, u8 halt_ac_3_after_txop, u8 halt_ac_2_after_txop, u8 halt_ac_1_after_txop, u8 halt_ac_0_after_txop, u8 halt_bcn_after_txop, u8 tx_htp_new_head, u8 tx_ac_3_new_head, u8 tx_ac_2_new_head, u8 tx_ac_1_new_head, u8 tx_ac_0_new_head, u8 tx_bcn_new_head, u8 tx_htp_new_tail, u8 tx_ac_3_new_tail, u8 tx_ac_2_new_tail, u8 tx_ac_1_new_tail, u8 tx_ac_0_new_tail, u8 tx_bcn_new_tail)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_new_head2 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_head2 << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_tail2 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_tail2 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_head << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_head << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_tail << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_tail << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_htp_after_txop << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_3_after_txop << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_2_after_txop << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_1_after_txop << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_0_after_txop << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_bcn_after_txop << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_htp_new_head << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_3_new_head << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_2_new_head << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_1_new_head << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_0_new_head << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_bcn_new_head << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_htp_new_tail << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_3_new_tail << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_2_new_tail << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_1_new_tail << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_0_new_tail << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_bcn_new_tail << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, ((u32)rx_payload_new_head2 << 31) | ((u32)rx_header_new_head2 << 30) | ((u32)rx_payload_new_tail2 << 29) | ((u32)rx_header_new_tail2 << 28) | ((u32)rx_payload_new_head << 27) | ((u32)rx_header_new_head << 26) | ((u32)rx_payload_new_tail << 25) | ((u32)rx_header_new_tail << 24) | ((u32)halt_htp_after_txop << 20) | ((u32)halt_ac_3_after_txop << 19) | ((u32)halt_ac_2_after_txop << 18) | ((u32)halt_ac_1_after_txop << 17) | ((u32)halt_ac_0_after_txop << 16) | ((u32)halt_bcn_after_txop << 15) | ((u32)tx_htp_new_head << 13) | ((u32)tx_ac_3_new_head << 12) | ((u32)tx_ac_2_new_head << 11) | ((u32)tx_ac_1_new_head << 10) | ((u32)tx_ac_0_new_head << 9) | ((u32)tx_bcn_new_head << 8) | ((u32)tx_htp_new_tail << 5) | ((u32)tx_ac_3_new_tail << 4) | ((u32)tx_ac_2_new_tail << 3) | ((u32)tx_ac_1_new_tail << 2) | ((u32)tx_ac_0_new_tail << 1) | ((u32)tx_bcn_new_tail << 0));
}

static inline void mac_hw_dma_cntrl_set_unpack(struct cl_chip *chip, u8 *rx_payload_new_head2, u8 *rx_header_new_head2, u8 *rx_payload_new_tail2, u8 *rx_header_new_tail2, u8 *rx_payload_new_head, u8 *rx_header_new_head, u8 *rx_payload_new_tail, u8 *rx_header_new_tail, u8 *halt_htp_after_txop, u8 *halt_ac_3_after_txop, u8 *halt_ac_2_after_txop, u8 *halt_ac_1_after_txop, u8 *halt_ac_0_after_txop, u8 *halt_bcn_after_txop, u8 *tx_htp_new_head, u8 *tx_ac_3_new_head, u8 *tx_ac_2_new_head, u8 *tx_ac_1_new_head, u8 *tx_ac_0_new_head, u8 *tx_bcn_new_head, u8 *tx_htp_new_tail, u8 *tx_ac_3_new_tail, u8 *tx_ac_2_new_tail, u8 *tx_ac_1_new_tail, u8 *tx_ac_0_new_tail, u8 *tx_bcn_new_tail)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	*rx_payload_new_head2 = (local_val & ((u32)0x80000000)) >> 31;
	*rx_header_new_head2 = (local_val & ((u32)0x40000000)) >> 30;
	*rx_payload_new_tail2 = (local_val & ((u32)0x20000000)) >> 29;
	*rx_header_new_tail2 = (local_val & ((u32)0x10000000)) >> 28;
	*rx_payload_new_head = (local_val & ((u32)0x08000000)) >> 27;
	*rx_header_new_head = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_new_tail = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_new_tail = (local_val & ((u32)0x01000000)) >> 24;
	*halt_htp_after_txop = (local_val & ((u32)0x00100000)) >> 20;
	*halt_ac_3_after_txop = (local_val & ((u32)0x00080000)) >> 19;
	*halt_ac_2_after_txop = (local_val & ((u32)0x00040000)) >> 18;
	*halt_ac_1_after_txop = (local_val & ((u32)0x00020000)) >> 17;
	*halt_ac_0_after_txop = (local_val & ((u32)0x00010000)) >> 16;
	*halt_bcn_after_txop = (local_val & ((u32)0x00008000)) >> 15;
	*tx_htp_new_head = (local_val & ((u32)0x00002000)) >> 13;
	*tx_ac_3_new_head = (local_val & ((u32)0x00001000)) >> 12;
	*tx_ac_2_new_head = (local_val & ((u32)0x00000800)) >> 11;
	*tx_ac_1_new_head = (local_val & ((u32)0x00000400)) >> 10;
	*tx_ac_0_new_head = (local_val & ((u32)0x00000200)) >> 9;
	*tx_bcn_new_head = (local_val & ((u32)0x00000100)) >> 8;
	*tx_htp_new_tail = (local_val & ((u32)0x00000020)) >> 5;
	*tx_ac_3_new_tail = (local_val & ((u32)0x00000010)) >> 4;
	*tx_ac_2_new_tail = (local_val & ((u32)0x00000008)) >> 3;
	*tx_ac_1_new_tail = (local_val & ((u32)0x00000004)) >> 2;
	*tx_ac_0_new_tail = (local_val & ((u32)0x00000002)) >> 1;
	*tx_bcn_new_tail = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_dma_cntrl_set_rx_payload_new_head_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_dma_cntrl_set_rx_payload_new_head_2_setf(struct cl_chip *chip, u8 rxpayloadnewhead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewhead2 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x80000000)) | ((u32)rxpayloadnewhead2 << 31));
}

static inline u8 mac_hw_dma_cntrl_set_rx_header_new_head_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_dma_cntrl_set_rx_header_new_head_2_setf(struct cl_chip *chip, u8 rxheadernewhead2)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewhead2 << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x40000000)) | ((u32)rxheadernewhead2 << 30));
}

static inline u8 mac_hw_dma_cntrl_set_rx_payload_new_tail_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_dma_cntrl_set_rx_payload_new_tail_2_setf(struct cl_chip *chip, u8 rxpayloadnewtail2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewtail2 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x20000000)) | ((u32)rxpayloadnewtail2 << 29));
}

static inline u8 mac_hw_dma_cntrl_set_rx_header_new_tail_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_dma_cntrl_set_rx_header_new_tail_2_setf(struct cl_chip *chip, u8 rxheadernewtail2)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewtail2 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x10000000)) | ((u32)rxheadernewtail2 << 28));
}

static inline u8 mac_hw_dma_cntrl_set_rx_payload_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_dma_cntrl_set_rx_payload_new_head_setf(struct cl_chip *chip, u8 rxpayloadnewhead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewhead << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x08000000)) | ((u32)rxpayloadnewhead << 27));
}

static inline u8 mac_hw_dma_cntrl_set_rx_header_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_dma_cntrl_set_rx_header_new_head_setf(struct cl_chip *chip, u8 rxheadernewhead)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewhead << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x04000000)) | ((u32)rxheadernewhead << 26));
}

static inline u8 mac_hw_dma_cntrl_set_rx_payload_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_dma_cntrl_set_rx_payload_new_tail_setf(struct cl_chip *chip, u8 rxpayloadnewtail)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewtail << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloadnewtail << 25));
}

static inline u8 mac_hw_dma_cntrl_set_rx_header_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_dma_cntrl_set_rx_header_new_tail_setf(struct cl_chip *chip, u8 rxheadernewtail)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewtail << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x01000000)) | ((u32)rxheadernewtail << 24));
}

static inline u8 mac_hw_dma_cntrl_set_halt_htp_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_dma_cntrl_set_halt_htp_after_txop_setf(struct cl_chip *chip, u8 halthtpaftertxop)
{
	ASSERT_ERR_CHIP((((u32)halthtpaftertxop << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00100000)) | ((u32)halthtpaftertxop << 20));
}

static inline u8 mac_hw_dma_cntrl_set_halt_ac_3_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_dma_cntrl_set_halt_ac_3_after_txop_setf(struct cl_chip *chip, u8 haltac3aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac3aftertxop << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00080000)) | ((u32)haltac3aftertxop << 19));
}

static inline u8 mac_hw_dma_cntrl_set_halt_ac_2_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_dma_cntrl_set_halt_ac_2_after_txop_setf(struct cl_chip *chip, u8 haltac2aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac2aftertxop << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00040000)) | ((u32)haltac2aftertxop << 18));
}

static inline u8 mac_hw_dma_cntrl_set_halt_ac_1_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_dma_cntrl_set_halt_ac_1_after_txop_setf(struct cl_chip *chip, u8 haltac1aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac1aftertxop << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00020000)) | ((u32)haltac1aftertxop << 17));
}

static inline u8 mac_hw_dma_cntrl_set_halt_ac_0_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_dma_cntrl_set_halt_ac_0_after_txop_setf(struct cl_chip *chip, u8 haltac0aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac0aftertxop << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00010000)) | ((u32)haltac0aftertxop << 16));
}

static inline u8 mac_hw_dma_cntrl_set_halt_bcn_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_dma_cntrl_set_halt_bcn_after_txop_setf(struct cl_chip *chip, u8 haltbcnaftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltbcnaftertxop << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00008000)) | ((u32)haltbcnaftertxop << 15));
}

static inline u8 mac_hw_dma_cntrl_set_tx_htp_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_dma_cntrl_set_tx_htp_new_head_setf(struct cl_chip *chip, u8 txhtpnewhead)
{
	ASSERT_ERR_CHIP((((u32)txhtpnewhead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00002000)) | ((u32)txhtpnewhead << 13));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_3_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_3_new_head_setf(struct cl_chip *chip, u8 txac3newhead)
{
	ASSERT_ERR_CHIP((((u32)txac3newhead << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00001000)) | ((u32)txac3newhead << 12));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_2_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_2_new_head_setf(struct cl_chip *chip, u8 txac2newhead)
{
	ASSERT_ERR_CHIP((((u32)txac2newhead << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000800)) | ((u32)txac2newhead << 11));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_1_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_1_new_head_setf(struct cl_chip *chip, u8 txac1newhead)
{
	ASSERT_ERR_CHIP((((u32)txac1newhead << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000400)) | ((u32)txac1newhead << 10));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_0_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_0_new_head_setf(struct cl_chip *chip, u8 txac0newhead)
{
	ASSERT_ERR_CHIP((((u32)txac0newhead << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000200)) | ((u32)txac0newhead << 9));
}

static inline u8 mac_hw_dma_cntrl_set_tx_bcn_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_dma_cntrl_set_tx_bcn_new_head_setf(struct cl_chip *chip, u8 txbcnnewhead)
{
	ASSERT_ERR_CHIP((((u32)txbcnnewhead << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000100)) | ((u32)txbcnnewhead << 8));
}

static inline u8 mac_hw_dma_cntrl_set_tx_htp_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_dma_cntrl_set_tx_htp_new_tail_setf(struct cl_chip *chip, u8 txhtpnewtail)
{
	ASSERT_ERR_CHIP((((u32)txhtpnewtail << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000020)) | ((u32)txhtpnewtail << 5));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_3_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_3_new_tail_setf(struct cl_chip *chip, u8 txac3newtail)
{
	ASSERT_ERR_CHIP((((u32)txac3newtail << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000010)) | ((u32)txac3newtail << 4));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_2_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_2_new_tail_setf(struct cl_chip *chip, u8 txac2newtail)
{
	ASSERT_ERR_CHIP((((u32)txac2newtail << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000008)) | ((u32)txac2newtail << 3));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_1_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_1_new_tail_setf(struct cl_chip *chip, u8 txac1newtail)
{
	ASSERT_ERR_CHIP((((u32)txac1newtail << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000004)) | ((u32)txac1newtail << 2));
}

static inline u8 mac_hw_dma_cntrl_set_tx_ac_0_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_dma_cntrl_set_tx_ac_0_new_tail_setf(struct cl_chip *chip, u8 txac0newtail)
{
	ASSERT_ERR_CHIP((((u32)txac0newtail << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000002)) | ((u32)txac0newtail << 1));
}

static inline u8 mac_hw_dma_cntrl_set_tx_bcn_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_dma_cntrl_set_tx_bcn_new_tail_setf(struct cl_chip *chip, u8 txbcnnewtail)
{
	ASSERT_ERR_CHIP((((u32)txbcnnewtail << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_SET_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_SET_ADDR) & ~((u32)0x00000001)) | ((u32)txbcnnewtail << 0));
}

/**
 * @brief DMA_CNTRL_CLEAR register definition
 *  Contains control clear bits for the DMA channels. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    RX_PAYLOAD_NEW_HEAD2      0
 *    30    RX_HEADER_NEW_HEAD2       0
 *    29    RX_PAYLOAD_NEW_TAIL2      0
 *    28    RX_HEADER_NEW_TAIL2       0
 *    27    RX_PAYLOAD_NEW_HEAD       0
 *    26    RX_HEADER_NEW_HEAD        0
 *    25    RX_PAYLOAD_NEW_TAIL       0
 *    24    RX_HEADER_NEW_TAIL        0
 *    20    HALT_HTP_AFTER_TXOP       0
 *    19    HALT_AC_3_AFTER_TXOP      0
 *    18    HALT_AC_2_AFTER_TXOP      0
 *    17    HALT_AC_1_AFTER_TXOP      0
 *    16    HALT_AC_0_AFTER_TXOP      0
 *    15    HALT_BCN_AFTER_TXOP       0
 *    13    TX_HTP_NEW_HEAD           0
 *    12    TX_AC_3_NEW_HEAD          0
 *    11    TX_AC_2_NEW_HEAD          0
 *    10    TX_AC_1_NEW_HEAD          0
 *    09    TX_AC_0_NEW_HEAD          0
 *    08    TX_BCN_NEW_HEAD           0
 *    05    TX_HTP_NEW_TAIL           0
 *    04    TX_AC_3_NEW_TAIL          0
 *    03    TX_AC_2_NEW_TAIL          0
 *    02    TX_AC_1_NEW_TAIL          0
 *    01    TX_AC_0_NEW_TAIL          0
 *    00    TX_BCN_NEW_TAIL           0
 * </pre>
 */
#define MAC_HW_DMA_CNTRL_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008184)
#define MAC_HW_DMA_CNTRL_CLEAR_OFFSET      0x00008184
#define MAC_HW_DMA_CNTRL_CLEAR_INDEX       0x00002061
#define MAC_HW_DMA_CNTRL_CLEAR_RESET       0x00000000

static inline u32 mac_hw_dma_cntrl_clear_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);
}

static inline void mac_hw_dma_cntrl_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_2_BIT    ((u32)0x80000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_2_POS    31
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_2_BIT    ((u32)0x40000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_2_POS    30
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_2_BIT    ((u32)0x20000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_2_POS    29
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_2_BIT    ((u32)0x10000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_2_POS    28
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_BIT    ((u32)0x08000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_POS    27
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_BIT    ((u32)0x04000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_POS    26
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_BIT    ((u32)0x02000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_POS    25
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_BIT    ((u32)0x01000000)
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_POS    24
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_HTP_AFTER_TXOP_BIT    ((u32)0x00100000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_HTP_AFTER_TXOP_POS    20
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_3_AFTER_TXOP_BIT    ((u32)0x00080000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_3_AFTER_TXOP_POS    19
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_2_AFTER_TXOP_BIT    ((u32)0x00040000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_2_AFTER_TXOP_POS    18
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_1_AFTER_TXOP_BIT    ((u32)0x00020000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_1_AFTER_TXOP_POS    17
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_0_AFTER_TXOP_BIT    ((u32)0x00010000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_0_AFTER_TXOP_POS    16
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_BCN_AFTER_TXOP_BIT    ((u32)0x00008000)
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_BCN_AFTER_TXOP_POS    15
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_HEAD_BIT    ((u32)0x00002000)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_HEAD_POS    13
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_HEAD_BIT    ((u32)0x00001000)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_HEAD_POS    12
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_HEAD_BIT    ((u32)0x00000800)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_HEAD_POS    11
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_HEAD_BIT    ((u32)0x00000400)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_HEAD_POS    10
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_HEAD_BIT    ((u32)0x00000200)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_HEAD_POS    9
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_HEAD_BIT    ((u32)0x00000100)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_HEAD_POS    8
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_TAIL_BIT    ((u32)0x00000020)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_TAIL_POS    5
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_TAIL_BIT    ((u32)0x00000010)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_TAIL_POS    4
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_TAIL_BIT    ((u32)0x00000008)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_TAIL_POS    3
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_TAIL_BIT    ((u32)0x00000004)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_TAIL_POS    2
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_TAIL_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_TAIL_POS    1
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_TAIL_BIT    ((u32)0x00000001)
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_TAIL_POS    0

#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_2_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_2_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_2_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_2_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_PAYLOAD_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_RX_HEADER_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_HTP_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_3_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_2_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_1_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_AC_0_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_HALT_BCN_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_HEAD_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_HTP_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_3_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_2_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_1_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_AC_0_NEW_TAIL_RST    0x0
#define MAC_HW_DMA_CNTRL_CLEAR_TX_BCN_NEW_TAIL_RST    0x0

static inline void mac_hw_dma_cntrl_clear_pack(struct cl_chip *chip, u8 rx_payload_new_head2, u8 rx_header_new_head2, u8 rx_payload_new_tail2, u8 rx_header_new_tail2, u8 rx_payload_new_head, u8 rx_header_new_head, u8 rx_payload_new_tail, u8 rx_header_new_tail, u8 halt_htp_after_txop, u8 halt_ac_3_after_txop, u8 halt_ac_2_after_txop, u8 halt_ac_1_after_txop, u8 halt_ac_0_after_txop, u8 halt_bcn_after_txop, u8 tx_htp_new_head, u8 tx_ac_3_new_head, u8 tx_ac_2_new_head, u8 tx_ac_1_new_head, u8 tx_ac_0_new_head, u8 tx_bcn_new_head, u8 tx_htp_new_tail, u8 tx_ac_3_new_tail, u8 tx_ac_2_new_tail, u8 tx_ac_1_new_tail, u8 tx_ac_0_new_tail, u8 tx_bcn_new_tail)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_new_head2 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_head2 << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_tail2 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_tail2 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_head << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_head << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_new_tail << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_new_tail << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_htp_after_txop << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_3_after_txop << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_2_after_txop << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_1_after_txop << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_ac_0_after_txop << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)halt_bcn_after_txop << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_htp_new_head << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_3_new_head << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_2_new_head << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_1_new_head << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_0_new_head << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_bcn_new_head << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_htp_new_tail << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_3_new_tail << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_2_new_tail << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_1_new_tail << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac_0_new_tail << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_bcn_new_tail << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, ((u32)rx_payload_new_head2 << 31) | ((u32)rx_header_new_head2 << 30) | ((u32)rx_payload_new_tail2 << 29) | ((u32)rx_header_new_tail2 << 28) | ((u32)rx_payload_new_head << 27) | ((u32)rx_header_new_head << 26) | ((u32)rx_payload_new_tail << 25) | ((u32)rx_header_new_tail << 24) | ((u32)halt_htp_after_txop << 20) | ((u32)halt_ac_3_after_txop << 19) | ((u32)halt_ac_2_after_txop << 18) | ((u32)halt_ac_1_after_txop << 17) | ((u32)halt_ac_0_after_txop << 16) | ((u32)halt_bcn_after_txop << 15) | ((u32)tx_htp_new_head << 13) | ((u32)tx_ac_3_new_head << 12) | ((u32)tx_ac_2_new_head << 11) | ((u32)tx_ac_1_new_head << 10) | ((u32)tx_ac_0_new_head << 9) | ((u32)tx_bcn_new_head << 8) | ((u32)tx_htp_new_tail << 5) | ((u32)tx_ac_3_new_tail << 4) | ((u32)tx_ac_2_new_tail << 3) | ((u32)tx_ac_1_new_tail << 2) | ((u32)tx_ac_0_new_tail << 1) | ((u32)tx_bcn_new_tail << 0));
}

static inline void mac_hw_dma_cntrl_clear_unpack(struct cl_chip *chip, u8 *rx_payload_new_head2, u8 *rx_header_new_head2, u8 *rx_payload_new_tail2, u8 *rx_header_new_tail2, u8 *rx_payload_new_head, u8 *rx_header_new_head, u8 *rx_payload_new_tail, u8 *rx_header_new_tail, u8 *halt_htp_after_txop, u8 *halt_ac_3_after_txop, u8 *halt_ac_2_after_txop, u8 *halt_ac_1_after_txop, u8 *halt_ac_0_after_txop, u8 *halt_bcn_after_txop, u8 *tx_htp_new_head, u8 *tx_ac_3_new_head, u8 *tx_ac_2_new_head, u8 *tx_ac_1_new_head, u8 *tx_ac_0_new_head, u8 *tx_bcn_new_head, u8 *tx_htp_new_tail, u8 *tx_ac_3_new_tail, u8 *tx_ac_2_new_tail, u8 *tx_ac_1_new_tail, u8 *tx_ac_0_new_tail, u8 *tx_bcn_new_tail)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	*rx_payload_new_head2 = (local_val & ((u32)0x80000000)) >> 31;
	*rx_header_new_head2 = (local_val & ((u32)0x40000000)) >> 30;
	*rx_payload_new_tail2 = (local_val & ((u32)0x20000000)) >> 29;
	*rx_header_new_tail2 = (local_val & ((u32)0x10000000)) >> 28;
	*rx_payload_new_head = (local_val & ((u32)0x08000000)) >> 27;
	*rx_header_new_head = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_new_tail = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_new_tail = (local_val & ((u32)0x01000000)) >> 24;
	*halt_htp_after_txop = (local_val & ((u32)0x00100000)) >> 20;
	*halt_ac_3_after_txop = (local_val & ((u32)0x00080000)) >> 19;
	*halt_ac_2_after_txop = (local_val & ((u32)0x00040000)) >> 18;
	*halt_ac_1_after_txop = (local_val & ((u32)0x00020000)) >> 17;
	*halt_ac_0_after_txop = (local_val & ((u32)0x00010000)) >> 16;
	*halt_bcn_after_txop = (local_val & ((u32)0x00008000)) >> 15;
	*tx_htp_new_head = (local_val & ((u32)0x00002000)) >> 13;
	*tx_ac_3_new_head = (local_val & ((u32)0x00001000)) >> 12;
	*tx_ac_2_new_head = (local_val & ((u32)0x00000800)) >> 11;
	*tx_ac_1_new_head = (local_val & ((u32)0x00000400)) >> 10;
	*tx_ac_0_new_head = (local_val & ((u32)0x00000200)) >> 9;
	*tx_bcn_new_head = (local_val & ((u32)0x00000100)) >> 8;
	*tx_htp_new_tail = (local_val & ((u32)0x00000020)) >> 5;
	*tx_ac_3_new_tail = (local_val & ((u32)0x00000010)) >> 4;
	*tx_ac_2_new_tail = (local_val & ((u32)0x00000008)) >> 3;
	*tx_ac_1_new_tail = (local_val & ((u32)0x00000004)) >> 2;
	*tx_ac_0_new_tail = (local_val & ((u32)0x00000002)) >> 1;
	*tx_bcn_new_tail = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_dma_cntrl_clear_rx_payload_new_head_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_dma_cntrl_clear_rx_payload_new_head_2_setf(struct cl_chip *chip, u8 rxpayloadnewhead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewhead2 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x80000000)) | ((u32)rxpayloadnewhead2 << 31));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_header_new_head_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_dma_cntrl_clear_rx_header_new_head_2_setf(struct cl_chip *chip, u8 rxheadernewhead2)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewhead2 << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x40000000)) | ((u32)rxheadernewhead2 << 30));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_payload_new_tail_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_dma_cntrl_clear_rx_payload_new_tail_2_setf(struct cl_chip *chip, u8 rxpayloadnewtail2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewtail2 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x20000000)) | ((u32)rxpayloadnewtail2 << 29));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_header_new_tail_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_dma_cntrl_clear_rx_header_new_tail_2_setf(struct cl_chip *chip, u8 rxheadernewtail2)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewtail2 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x10000000)) | ((u32)rxheadernewtail2 << 28));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_payload_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_dma_cntrl_clear_rx_payload_new_head_setf(struct cl_chip *chip, u8 rxpayloadnewhead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewhead << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x08000000)) | ((u32)rxpayloadnewhead << 27));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_header_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_dma_cntrl_clear_rx_header_new_head_setf(struct cl_chip *chip, u8 rxheadernewhead)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewhead << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x04000000)) | ((u32)rxheadernewhead << 26));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_payload_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_dma_cntrl_clear_rx_payload_new_tail_setf(struct cl_chip *chip, u8 rxpayloadnewtail)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadnewtail << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloadnewtail << 25));
}

static inline u8 mac_hw_dma_cntrl_clear_rx_header_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_dma_cntrl_clear_rx_header_new_tail_setf(struct cl_chip *chip, u8 rxheadernewtail)
{
	ASSERT_ERR_CHIP((((u32)rxheadernewtail << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x01000000)) | ((u32)rxheadernewtail << 24));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_htp_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_dma_cntrl_clear_halt_htp_after_txop_setf(struct cl_chip *chip, u8 halthtpaftertxop)
{
	ASSERT_ERR_CHIP((((u32)halthtpaftertxop << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00100000)) | ((u32)halthtpaftertxop << 20));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_ac_3_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_dma_cntrl_clear_halt_ac_3_after_txop_setf(struct cl_chip *chip, u8 haltac3aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac3aftertxop << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00080000)) | ((u32)haltac3aftertxop << 19));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_ac_2_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_dma_cntrl_clear_halt_ac_2_after_txop_setf(struct cl_chip *chip, u8 haltac2aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac2aftertxop << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00040000)) | ((u32)haltac2aftertxop << 18));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_ac_1_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_dma_cntrl_clear_halt_ac_1_after_txop_setf(struct cl_chip *chip, u8 haltac1aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac1aftertxop << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00020000)) | ((u32)haltac1aftertxop << 17));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_ac_0_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_dma_cntrl_clear_halt_ac_0_after_txop_setf(struct cl_chip *chip, u8 haltac0aftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltac0aftertxop << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00010000)) | ((u32)haltac0aftertxop << 16));
}

static inline u8 mac_hw_dma_cntrl_clear_halt_bcn_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_dma_cntrl_clear_halt_bcn_after_txop_setf(struct cl_chip *chip, u8 haltbcnaftertxop)
{
	ASSERT_ERR_CHIP((((u32)haltbcnaftertxop << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00008000)) | ((u32)haltbcnaftertxop << 15));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_htp_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_dma_cntrl_clear_tx_htp_new_head_setf(struct cl_chip *chip, u8 txhtpnewhead)
{
	ASSERT_ERR_CHIP((((u32)txhtpnewhead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00002000)) | ((u32)txhtpnewhead << 13));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_3_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_3_new_head_setf(struct cl_chip *chip, u8 txac3newhead)
{
	ASSERT_ERR_CHIP((((u32)txac3newhead << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00001000)) | ((u32)txac3newhead << 12));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_2_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_2_new_head_setf(struct cl_chip *chip, u8 txac2newhead)
{
	ASSERT_ERR_CHIP((((u32)txac2newhead << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000800)) | ((u32)txac2newhead << 11));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_1_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_1_new_head_setf(struct cl_chip *chip, u8 txac1newhead)
{
	ASSERT_ERR_CHIP((((u32)txac1newhead << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000400)) | ((u32)txac1newhead << 10));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_0_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_0_new_head_setf(struct cl_chip *chip, u8 txac0newhead)
{
	ASSERT_ERR_CHIP((((u32)txac0newhead << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000200)) | ((u32)txac0newhead << 9));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_bcn_new_head_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_dma_cntrl_clear_tx_bcn_new_head_setf(struct cl_chip *chip, u8 txbcnnewhead)
{
	ASSERT_ERR_CHIP((((u32)txbcnnewhead << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000100)) | ((u32)txbcnnewhead << 8));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_htp_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_dma_cntrl_clear_tx_htp_new_tail_setf(struct cl_chip *chip, u8 txhtpnewtail)
{
	ASSERT_ERR_CHIP((((u32)txhtpnewtail << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000020)) | ((u32)txhtpnewtail << 5));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_3_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_3_new_tail_setf(struct cl_chip *chip, u8 txac3newtail)
{
	ASSERT_ERR_CHIP((((u32)txac3newtail << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000010)) | ((u32)txac3newtail << 4));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_2_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_2_new_tail_setf(struct cl_chip *chip, u8 txac2newtail)
{
	ASSERT_ERR_CHIP((((u32)txac2newtail << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000008)) | ((u32)txac2newtail << 3));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_1_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_1_new_tail_setf(struct cl_chip *chip, u8 txac1newtail)
{
	ASSERT_ERR_CHIP((((u32)txac1newtail << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000004)) | ((u32)txac1newtail << 2));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_ac_0_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_dma_cntrl_clear_tx_ac_0_new_tail_setf(struct cl_chip *chip, u8 txac0newtail)
{
	ASSERT_ERR_CHIP((((u32)txac0newtail << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000002)) | ((u32)txac0newtail << 1));
}

static inline u8 mac_hw_dma_cntrl_clear_tx_bcn_new_tail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_dma_cntrl_clear_tx_bcn_new_tail_setf(struct cl_chip *chip, u8 txbcnnewtail)
{
	ASSERT_ERR_CHIP((((u32)txbcnnewtail << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_DMA_CNTRL_CLEAR_ADDR) & ~((u32)0x00000001)) | ((u32)txbcnnewtail << 0));
}

/**
 * @brief DMA_STATUS_1 register definition
 *  Indicates HW DMA status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:30 RX_PAYLOAD2_STATE         0x0
 *    29:28 RX_PAYLOAD_STATE          0x0
 *    27:26 RX_HEADER2_STATE          0x0
 *    25:24 RX_HEADER_STATE           0x0
 *    21:20 TX_HTP_STATE              0x0
 *    17:16 TX_AC_3_STATE             0x0
 *    13:12 TX_AC_2_STATE             0x0
 *    09:08 TX_AC_1_STATE             0x0
 *    05:04 TX_AC_0_STATE             0x0
 *    01:00 TX_BCN_STATE              0x0
 * </pre>
 */
#define MAC_HW_DMA_STATUS_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008188)
#define MAC_HW_DMA_STATUS_1_OFFSET      0x00008188
#define MAC_HW_DMA_STATUS_1_INDEX       0x00002062
#define MAC_HW_DMA_STATUS_1_RESET       0x00000000

static inline u32 mac_hw_dma_status_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);
}

/* Field definitions */
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_2_STATE_MASK    ((u32)0xC0000000)
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_2_STATE_LSB    30
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_2_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_STATE_MASK    ((u32)0x30000000)
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_STATE_LSB    28
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_RX_HEADER_2_STATE_MASK    ((u32)0x0C000000)
#define MAC_HW_DMA_STATUS_1_RX_HEADER_2_STATE_LSB    26
#define MAC_HW_DMA_STATUS_1_RX_HEADER_2_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_RX_HEADER_STATE_MASK    ((u32)0x03000000)
#define MAC_HW_DMA_STATUS_1_RX_HEADER_STATE_LSB    24
#define MAC_HW_DMA_STATUS_1_RX_HEADER_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_HTP_STATE_MASK    ((u32)0x00300000)
#define MAC_HW_DMA_STATUS_1_TX_HTP_STATE_LSB    20
#define MAC_HW_DMA_STATUS_1_TX_HTP_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_AC_3_STATE_MASK    ((u32)0x00030000)
#define MAC_HW_DMA_STATUS_1_TX_AC_3_STATE_LSB    16
#define MAC_HW_DMA_STATUS_1_TX_AC_3_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_AC_2_STATE_MASK    ((u32)0x00003000)
#define MAC_HW_DMA_STATUS_1_TX_AC_2_STATE_LSB    12
#define MAC_HW_DMA_STATUS_1_TX_AC_2_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_AC_1_STATE_MASK    ((u32)0x00000300)
#define MAC_HW_DMA_STATUS_1_TX_AC_1_STATE_LSB    8
#define MAC_HW_DMA_STATUS_1_TX_AC_1_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_AC_0_STATE_MASK    ((u32)0x00000030)
#define MAC_HW_DMA_STATUS_1_TX_AC_0_STATE_LSB    4
#define MAC_HW_DMA_STATUS_1_TX_AC_0_STATE_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_1_TX_BCN_STATE_MASK    ((u32)0x00000003)
#define MAC_HW_DMA_STATUS_1_TX_BCN_STATE_LSB    0
#define MAC_HW_DMA_STATUS_1_TX_BCN_STATE_WIDTH    ((u32)0x00000002)

#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_2_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_RX_PAYLOAD_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_RX_HEADER_2_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_RX_HEADER_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_HTP_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_AC_3_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_AC_2_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_AC_1_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_AC_0_STATE_RST    0x0
#define MAC_HW_DMA_STATUS_1_TX_BCN_STATE_RST    0x0

static inline void mac_hw_dma_status_1_unpack(struct cl_chip *chip, u8 *rx_payload2_state, u8 *rx_payload_state, u8 *rx_header2_state, u8 *rx_header_state, u8 *tx_htp_state, u8 *tx_ac_3_state, u8 *tx_ac_2_state, u8 *tx_ac_1_state, u8 *tx_ac_0_state, u8 *tx_bcn_state)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	*rx_payload2_state = (local_val & ((u32)0xC0000000)) >> 30;
	*rx_payload_state = (local_val & ((u32)0x30000000)) >> 28;
	*rx_header2_state = (local_val & ((u32)0x0C000000)) >> 26;
	*rx_header_state = (local_val & ((u32)0x03000000)) >> 24;
	*tx_htp_state = (local_val & ((u32)0x00300000)) >> 20;
	*tx_ac_3_state = (local_val & ((u32)0x00030000)) >> 16;
	*tx_ac_2_state = (local_val & ((u32)0x00003000)) >> 12;
	*tx_ac_1_state = (local_val & ((u32)0x00000300)) >> 8;
	*tx_ac_0_state = (local_val & ((u32)0x00000030)) >> 4;
	*tx_bcn_state = (local_val & ((u32)0x00000003)) >> 0;
}

static inline u8 mac_hw_dma_status_1_rx_payload_2_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0xC0000000)) >> 30);
}

static inline u8 mac_hw_dma_status_1_rx_payload_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x30000000)) >> 28);
}

static inline u8 mac_hw_dma_status_1_rx_header_2_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x0C000000)) >> 26);
}

static inline u8 mac_hw_dma_status_1_rx_header_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x03000000)) >> 24);
}

static inline u8 mac_hw_dma_status_1_tx_htp_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00300000)) >> 20);
}

static inline u8 mac_hw_dma_status_1_tx_ac_3_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline u8 mac_hw_dma_status_1_tx_ac_2_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00003000)) >> 12);
}

static inline u8 mac_hw_dma_status_1_tx_ac_1_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00000300)) >> 8);
}

static inline u8 mac_hw_dma_status_1_tx_ac_0_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline u8 mac_hw_dma_status_1_tx_bcn_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_1_ADDR);

	return (u8)((local_val & ((u32)0x00000003)) >> 0);
}

/**
 * @brief DMA_STATUS_2 register definition
 *  Indicates HW DMA status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    TX_AC_3_NEW_HEAD_ERR      0
 *    28    TX_AC_2_NEW_HEAD_ERR      0
 *    27    TX_AC_1_NEW_HEAD_ERR      0
 *    26    TX_AC_0_NEW_HEAD_ERR      0
 *    25    TX_BCN_NEW_HEAD_ERR       0
 *    24    TX_AC_3_BUS_ERR           0
 *    23    TX_AC_2_BUS_ERR           0
 *    22    TX_AC_1_BUS_ERR           0
 *    21    TX_AC_0_BUS_ERR           0
 *    20    TX_BCN_BUS_ERR            0
 *    19    TX_AC_3_PT_ADDRESS_ERR    0
 *    18    TX_AC_2_PT_ADDRESS_ERR    0
 *    17    TX_AC_1_PT_ADDRESS_ERR    0
 *    16    TX_AC_0_PT_ADDRESS_ERR    0
 *    15    TX_BCN_PT_ADDRESS_ERR     0
 *    14    TX_AC_3_NEXT_POINTER_ERR  0
 *    13    TX_AC_2_NEXT_POINTER_ERR  0
 *    12    TX_AC_1_NEXT_POINTER_ERR  0
 *    11    TX_AC_0_NEXT_POINTER_ERR  0
 *    10    TX_BCN_NEXT_POINTER_ERR   0
 *    09    TX_AC_3_U_PATTERN_ERR     0
 *    08    TX_AC_2_U_PATTERN_ERR     0
 *    07    TX_AC_1_U_PATTERN_ERR     0
 *    06    TX_AC_0_U_PATTERN_ERR     0
 *    05    TX_BCN_U_PATTERN_ERR      0
 *    04    TX_AC_3_LEN_MISMATCH      0
 *    03    TX_AC_2_LEN_MISMATCH      0
 *    02    TX_AC_1_LEN_MISMATCH      0
 *    01    TX_AC_0_LEN_MISMATCH      0
 *    00    TX_BCN_LEN_MISMATCH       0
 * </pre>
 */
#define MAC_HW_DMA_STATUS_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000818C)
#define MAC_HW_DMA_STATUS_2_OFFSET      0x0000818C
#define MAC_HW_DMA_STATUS_2_INDEX       0x00002063
#define MAC_HW_DMA_STATUS_2_RESET       0x00000000

static inline u32 mac_hw_dma_status_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);
}

/* Field definitions */
#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEW_HEAD_ERR_BIT    ((u32)0x20000000)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEW_HEAD_ERR_POS    29
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEW_HEAD_ERR_BIT    ((u32)0x10000000)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEW_HEAD_ERR_POS    28
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEW_HEAD_ERR_BIT    ((u32)0x08000000)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEW_HEAD_ERR_POS    27
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEW_HEAD_ERR_BIT    ((u32)0x04000000)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEW_HEAD_ERR_POS    26
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEW_HEAD_ERR_BIT    ((u32)0x02000000)
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEW_HEAD_ERR_POS    25
#define MAC_HW_DMA_STATUS_2_TX_AC_3_BUS_ERR_BIT    ((u32)0x01000000)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_BUS_ERR_POS    24
#define MAC_HW_DMA_STATUS_2_TX_AC_2_BUS_ERR_BIT    ((u32)0x00800000)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_BUS_ERR_POS    23
#define MAC_HW_DMA_STATUS_2_TX_AC_1_BUS_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_BUS_ERR_POS    22
#define MAC_HW_DMA_STATUS_2_TX_AC_0_BUS_ERR_BIT    ((u32)0x00200000)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_BUS_ERR_POS    21
#define MAC_HW_DMA_STATUS_2_TX_BCN_BUS_ERR_BIT    ((u32)0x00100000)
#define MAC_HW_DMA_STATUS_2_TX_BCN_BUS_ERR_POS    20
#define MAC_HW_DMA_STATUS_2_TX_AC_3_PT_ADDRESS_ERR_BIT    ((u32)0x00080000)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_PT_ADDRESS_ERR_POS    19
#define MAC_HW_DMA_STATUS_2_TX_AC_2_PT_ADDRESS_ERR_BIT    ((u32)0x00040000)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_PT_ADDRESS_ERR_POS    18
#define MAC_HW_DMA_STATUS_2_TX_AC_1_PT_ADDRESS_ERR_BIT    ((u32)0x00020000)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_PT_ADDRESS_ERR_POS    17
#define MAC_HW_DMA_STATUS_2_TX_AC_0_PT_ADDRESS_ERR_BIT    ((u32)0x00010000)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_PT_ADDRESS_ERR_POS    16
#define MAC_HW_DMA_STATUS_2_TX_BCN_PT_ADDRESS_ERR_BIT    ((u32)0x00008000)
#define MAC_HW_DMA_STATUS_2_TX_BCN_PT_ADDRESS_ERR_POS    15
#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEXT_POINTER_ERR_BIT    ((u32)0x00004000)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEXT_POINTER_ERR_POS    14
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEXT_POINTER_ERR_BIT    ((u32)0x00002000)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEXT_POINTER_ERR_POS    13
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEXT_POINTER_ERR_BIT    ((u32)0x00001000)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEXT_POINTER_ERR_POS    12
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEXT_POINTER_ERR_BIT    ((u32)0x00000800)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEXT_POINTER_ERR_POS    11
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEXT_POINTER_ERR_BIT    ((u32)0x00000400)
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEXT_POINTER_ERR_POS    10
#define MAC_HW_DMA_STATUS_2_TX_AC_3_U_PATTERN_ERR_BIT    ((u32)0x00000200)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_U_PATTERN_ERR_POS    9
#define MAC_HW_DMA_STATUS_2_TX_AC_2_U_PATTERN_ERR_BIT    ((u32)0x00000100)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_U_PATTERN_ERR_POS    8
#define MAC_HW_DMA_STATUS_2_TX_AC_1_U_PATTERN_ERR_BIT    ((u32)0x00000080)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_U_PATTERN_ERR_POS    7
#define MAC_HW_DMA_STATUS_2_TX_AC_0_U_PATTERN_ERR_BIT    ((u32)0x00000040)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_U_PATTERN_ERR_POS    6
#define MAC_HW_DMA_STATUS_2_TX_BCN_U_PATTERN_ERR_BIT    ((u32)0x00000020)
#define MAC_HW_DMA_STATUS_2_TX_BCN_U_PATTERN_ERR_POS    5
#define MAC_HW_DMA_STATUS_2_TX_AC_3_LEN_MISMATCH_BIT    ((u32)0x00000010)
#define MAC_HW_DMA_STATUS_2_TX_AC_3_LEN_MISMATCH_POS    4
#define MAC_HW_DMA_STATUS_2_TX_AC_2_LEN_MISMATCH_BIT    ((u32)0x00000008)
#define MAC_HW_DMA_STATUS_2_TX_AC_2_LEN_MISMATCH_POS    3
#define MAC_HW_DMA_STATUS_2_TX_AC_1_LEN_MISMATCH_BIT    ((u32)0x00000004)
#define MAC_HW_DMA_STATUS_2_TX_AC_1_LEN_MISMATCH_POS    2
#define MAC_HW_DMA_STATUS_2_TX_AC_0_LEN_MISMATCH_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_2_TX_AC_0_LEN_MISMATCH_POS    1
#define MAC_HW_DMA_STATUS_2_TX_BCN_LEN_MISMATCH_BIT    ((u32)0x00000001)
#define MAC_HW_DMA_STATUS_2_TX_BCN_LEN_MISMATCH_POS    0

#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_3_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_3_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_3_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_3_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_3_LEN_MISMATCH_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_2_LEN_MISMATCH_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_1_LEN_MISMATCH_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_AC_0_LEN_MISMATCH_RST    0x0
#define MAC_HW_DMA_STATUS_2_TX_BCN_LEN_MISMATCH_RST    0x0

static inline void mac_hw_dma_status_2_unpack(struct cl_chip *chip, u8 *tx_ac_3_new_head_err, u8 *tx_ac_2_new_head_err, u8 *tx_ac_1_new_head_err, u8 *tx_ac_0_new_head_err, u8 *tx_bcn_new_head_err, u8 *tx_ac_3_bus_err, u8 *tx_ac_2_bus_err, u8 *tx_ac_1_bus_err, u8 *tx_ac_0_bus_err, u8 *tx_bcn_bus_err, u8 *tx_ac_3_pt_address_err, u8 *tx_ac_2_pt_address_err, u8 *tx_ac_1_pt_address_err, u8 *tx_ac_0_pt_address_err, u8 *tx_bcn_pt_address_err, u8 *tx_ac_3_next_pointer_err, u8 *tx_ac_2_next_pointer_err, u8 *tx_ac_1_next_pointer_err, u8 *tx_ac_0_next_pointer_err, u8 *tx_bcn_next_pointer_err, u8 *tx_ac_3_u_pattern_err, u8 *tx_ac_2_u_pattern_err, u8 *tx_ac_1_u_pattern_err, u8 *tx_ac_0_u_pattern_err, u8 *tx_bcn_u_pattern_err, u8 *tx_ac_3_len_mismatch, u8 *tx_ac_2_len_mismatch, u8 *tx_ac_1_len_mismatch, u8 *tx_ac_0_len_mismatch, u8 *tx_bcn_len_mismatch)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	*tx_ac_3_new_head_err = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac_2_new_head_err = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac_1_new_head_err = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac_0_new_head_err = (local_val & ((u32)0x04000000)) >> 26;
	*tx_bcn_new_head_err = (local_val & ((u32)0x02000000)) >> 25;
	*tx_ac_3_bus_err = (local_val & ((u32)0x01000000)) >> 24;
	*tx_ac_2_bus_err = (local_val & ((u32)0x00800000)) >> 23;
	*tx_ac_1_bus_err = (local_val & ((u32)0x00400000)) >> 22;
	*tx_ac_0_bus_err = (local_val & ((u32)0x00200000)) >> 21;
	*tx_bcn_bus_err = (local_val & ((u32)0x00100000)) >> 20;
	*tx_ac_3_pt_address_err = (local_val & ((u32)0x00080000)) >> 19;
	*tx_ac_2_pt_address_err = (local_val & ((u32)0x00040000)) >> 18;
	*tx_ac_1_pt_address_err = (local_val & ((u32)0x00020000)) >> 17;
	*tx_ac_0_pt_address_err = (local_val & ((u32)0x00010000)) >> 16;
	*tx_bcn_pt_address_err = (local_val & ((u32)0x00008000)) >> 15;
	*tx_ac_3_next_pointer_err = (local_val & ((u32)0x00004000)) >> 14;
	*tx_ac_2_next_pointer_err = (local_val & ((u32)0x00002000)) >> 13;
	*tx_ac_1_next_pointer_err = (local_val & ((u32)0x00001000)) >> 12;
	*tx_ac_0_next_pointer_err = (local_val & ((u32)0x00000800)) >> 11;
	*tx_bcn_next_pointer_err = (local_val & ((u32)0x00000400)) >> 10;
	*tx_ac_3_u_pattern_err = (local_val & ((u32)0x00000200)) >> 9;
	*tx_ac_2_u_pattern_err = (local_val & ((u32)0x00000100)) >> 8;
	*tx_ac_1_u_pattern_err = (local_val & ((u32)0x00000080)) >> 7;
	*tx_ac_0_u_pattern_err = (local_val & ((u32)0x00000040)) >> 6;
	*tx_bcn_u_pattern_err = (local_val & ((u32)0x00000020)) >> 5;
	*tx_ac_3_len_mismatch = (local_val & ((u32)0x00000010)) >> 4;
	*tx_ac_2_len_mismatch = (local_val & ((u32)0x00000008)) >> 3;
	*tx_ac_1_len_mismatch = (local_val & ((u32)0x00000004)) >> 2;
	*tx_ac_0_len_mismatch = (local_val & ((u32)0x00000002)) >> 1;
	*tx_bcn_len_mismatch = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_dma_status_2_tx_ac_3_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_dma_status_2_tx_ac_2_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_dma_status_2_tx_ac_1_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_dma_status_2_tx_ac_0_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_dma_status_2_tx_bcn_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_2_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief DMA_STATUS_3 register definition
 *  Indicates HW DMA status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    TX_HTP_NEW_HEAD_ERR       0
 *    28    TX_HTP_BUS_ERR            0
 *    27    TX_HTP_PT_ADDRESS_ERR     0
 *    26    TX_HTP_NEXT_POINTER_ERR   0
 *    25    TX_HTP_U_PATTERN_ERR      0
 *    24    TX_HTP_LEN_MISMATCH       0
 *    15    RX_PAY_NEW_HEAD2_ERR      0
 *    14    RX_HDR_NEW_HEAD2_ERR      0
 *    13    RX_PAY_BUS_2_ERR          0
 *    12    RX_HDR_BUS_2_ERR          0
 *    11    RX_PAY_NEXT_POINTER2_ERR  0
 *    10    RX_HDR_NEXT_POINTER2_ERR  0
 *    09    RX_PAY_U_PATTERN2_ERR     0
 *    08    RX_HDR_U_PATTERN2_ERR     0
 *    07    RX_PAY_NEW_HEAD_ERR       0
 *    06    RX_HDR_NEW_HEAD_ERR       0
 *    05    RX_PAY_BUS_ERR            0
 *    04    RX_HDR_BUS_ERR            0
 *    03    RX_PAY_NEXT_POINTER_ERR   0
 *    02    RX_HDR_NEXT_POINTER_ERR   0
 *    01    RX_PAY_U_PATTERN_ERR      0
 *    00    RX_HDR_U_PATTERN_ERR      0
 * </pre>
 */
#define MAC_HW_DMA_STATUS_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008190)
#define MAC_HW_DMA_STATUS_3_OFFSET      0x00008190
#define MAC_HW_DMA_STATUS_3_INDEX       0x00002064
#define MAC_HW_DMA_STATUS_3_RESET       0x00000000

static inline u32 mac_hw_dma_status_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);
}

/* Field definitions */
#define MAC_HW_DMA_STATUS_3_TX_HTP_NEW_HEAD_ERR_BIT    ((u32)0x20000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_NEW_HEAD_ERR_POS    29
#define MAC_HW_DMA_STATUS_3_TX_HTP_BUS_ERR_BIT    ((u32)0x10000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_BUS_ERR_POS    28
#define MAC_HW_DMA_STATUS_3_TX_HTP_PT_ADDRESS_ERR_BIT    ((u32)0x08000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_PT_ADDRESS_ERR_POS    27
#define MAC_HW_DMA_STATUS_3_TX_HTP_NEXT_POINTER_ERR_BIT    ((u32)0x04000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_NEXT_POINTER_ERR_POS    26
#define MAC_HW_DMA_STATUS_3_TX_HTP_U_PATTERN_ERR_BIT    ((u32)0x02000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_U_PATTERN_ERR_POS    25
#define MAC_HW_DMA_STATUS_3_TX_HTP_LEN_MISMATCH_BIT    ((u32)0x01000000)
#define MAC_HW_DMA_STATUS_3_TX_HTP_LEN_MISMATCH_POS    24
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_2_ERR_BIT    ((u32)0x00008000)
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_2_ERR_POS    15
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_2_ERR_BIT    ((u32)0x00004000)
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_2_ERR_POS    14
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_2_ERR_BIT    ((u32)0x00002000)
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_2_ERR_POS    13
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_2_ERR_BIT    ((u32)0x00001000)
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_2_ERR_POS    12
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_2_ERR_BIT    ((u32)0x00000800)
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_2_ERR_POS    11
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_2_ERR_BIT    ((u32)0x00000400)
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_2_ERR_POS    10
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_2_ERR_BIT    ((u32)0x00000200)
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_2_ERR_POS    9
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_2_ERR_BIT    ((u32)0x00000100)
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_2_ERR_POS    8
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_ERR_BIT    ((u32)0x00000080)
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_ERR_POS    7
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_ERR_BIT    ((u32)0x00000040)
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_ERR_POS    6
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_ERR_BIT    ((u32)0x00000020)
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_ERR_POS    5
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_ERR_BIT    ((u32)0x00000010)
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_ERR_POS    4
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_ERR_BIT    ((u32)0x00000008)
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_ERR_POS    3
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_ERR_BIT    ((u32)0x00000004)
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_ERR_POS    2
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_ERR_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_ERR_POS    1
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_ERR_BIT    ((u32)0x00000001)
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_ERR_POS    0

#define MAC_HW_DMA_STATUS_3_TX_HTP_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_TX_HTP_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_TX_HTP_PT_ADDRESS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_TX_HTP_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_TX_HTP_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_TX_HTP_LEN_MISMATCH_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_2_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEW_HEAD_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_BUS_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_NEXT_POINTER_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_PAY_U_PATTERN_ERR_RST    0x0
#define MAC_HW_DMA_STATUS_3_RX_HDR_U_PATTERN_ERR_RST    0x0

static inline void mac_hw_dma_status_3_unpack(struct cl_chip *chip, u8 *tx_htp_new_head_err, u8 *tx_htp_bus_err, u8 *tx_htp_pt_address_err, u8 *tx_htp_next_pointer_err, u8 *tx_htp_u_pattern_err, u8 *tx_htp_len_mismatch, u8 *rx_pay_new_head2_err, u8 *rx_hdr_new_head2_err, u8 *rx_pay_bus_2_err, u8 *rx_hdr_bus_2_err, u8 *rx_pay_next_pointer2_err, u8 *rx_hdr_next_pointer2_err, u8 *rx_pay_u_pattern2_err, u8 *rx_hdr_u_pattern2_err, u8 *rx_pay_new_head_err, u8 *rx_hdr_new_head_err, u8 *rx_pay_bus_err, u8 *rx_hdr_bus_err, u8 *rx_pay_next_pointer_err, u8 *rx_hdr_next_pointer_err, u8 *rx_pay_u_pattern_err, u8 *rx_hdr_u_pattern_err)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	*tx_htp_new_head_err = (local_val & ((u32)0x20000000)) >> 29;
	*tx_htp_bus_err = (local_val & ((u32)0x10000000)) >> 28;
	*tx_htp_pt_address_err = (local_val & ((u32)0x08000000)) >> 27;
	*tx_htp_next_pointer_err = (local_val & ((u32)0x04000000)) >> 26;
	*tx_htp_u_pattern_err = (local_val & ((u32)0x02000000)) >> 25;
	*tx_htp_len_mismatch = (local_val & ((u32)0x01000000)) >> 24;
	*rx_pay_new_head2_err = (local_val & ((u32)0x00008000)) >> 15;
	*rx_hdr_new_head2_err = (local_val & ((u32)0x00004000)) >> 14;
	*rx_pay_bus_2_err = (local_val & ((u32)0x00002000)) >> 13;
	*rx_hdr_bus_2_err = (local_val & ((u32)0x00001000)) >> 12;
	*rx_pay_next_pointer2_err = (local_val & ((u32)0x00000800)) >> 11;
	*rx_hdr_next_pointer2_err = (local_val & ((u32)0x00000400)) >> 10;
	*rx_pay_u_pattern2_err = (local_val & ((u32)0x00000200)) >> 9;
	*rx_hdr_u_pattern2_err = (local_val & ((u32)0x00000100)) >> 8;
	*rx_pay_new_head_err = (local_val & ((u32)0x00000080)) >> 7;
	*rx_hdr_new_head_err = (local_val & ((u32)0x00000040)) >> 6;
	*rx_pay_bus_err = (local_val & ((u32)0x00000020)) >> 5;
	*rx_hdr_bus_err = (local_val & ((u32)0x00000010)) >> 4;
	*rx_pay_next_pointer_err = (local_val & ((u32)0x00000008)) >> 3;
	*rx_hdr_next_pointer_err = (local_val & ((u32)0x00000004)) >> 2;
	*rx_pay_u_pattern_err = (local_val & ((u32)0x00000002)) >> 1;
	*rx_hdr_u_pattern_err = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_dma_status_3_tx_htp_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_dma_status_3_tx_htp_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_dma_status_3_tx_htp_pt_address_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_dma_status_3_tx_htp_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_dma_status_3_tx_htp_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_dma_status_3_tx_htp_len_mismatch_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_dma_status_3_rx_pay_new_head_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_new_head_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_dma_status_3_rx_pay_bus_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_bus_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_dma_status_3_rx_pay_next_pointer_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_next_pointer_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_dma_status_3_rx_pay_u_pattern_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_u_pattern_2_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_dma_status_3_rx_pay_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_new_head_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_dma_status_3_rx_pay_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_bus_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_dma_status_3_rx_pay_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_next_pointer_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_dma_status_3_rx_pay_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_dma_status_3_rx_hdr_u_pattern_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_3_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief DMA_STATUS_4 register definition
 *  Indicates HW DMA status. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    20    TX_HTP_RESP_DISABLED      0
 *    19    TX_HTP_RX_NOT_IDLE        0
 *    18    TX_HTP_TRIGGER_FCS_FAIL   0
 *    17    TX_HTP_HALT_AFTER_TXOP    1
 *    16    TX_HTP_END_Q              0
 *    15    TX_HTP_STARTUP            1
 *    14    TX_AC_3_HALT_AFTER_TXOP   0
 *    13    TX_AC_2_HALT_AFTER_TXOP   0
 *    12    TX_AC_1_HALT_AFTER_TXOP   0
 *    11    TX_AC_0_HALT_AFTER_TXOP   0
 *    10    TX_BCN_HALT_AFTER_TXOP    0
 *    09    TX_AC_3_END_Q             0
 *    08    TX_AC_2_END_Q             0
 *    07    TX_AC_1_END_Q             0
 *    06    TX_AC_0_END_Q             0
 *    05    TX_BCN_END_Q              0
 *    04    TX_AC_3_STARTUP           1
 *    03    TX_AC_2_STARTUP           1
 *    02    TX_AC_1_STARTUP           1
 *    01    TX_AC_0_STARTUP           1
 *    00    TX_BCN_STARTUP            1
 * </pre>
 */
#define MAC_HW_DMA_STATUS_4_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008194)
#define MAC_HW_DMA_STATUS_4_OFFSET      0x00008194
#define MAC_HW_DMA_STATUS_4_INDEX       0x00002065
#define MAC_HW_DMA_STATUS_4_RESET       0x0002801F

static inline u32 mac_hw_dma_status_4_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);
}

/* Field definitions */
#define MAC_HW_DMA_STATUS_4_TX_HTP_RESP_DISABLED_BIT    ((u32)0x00100000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_RESP_DISABLED_POS    20
#define MAC_HW_DMA_STATUS_4_TX_HTP_RX_NOT_IDLE_BIT    ((u32)0x00080000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_RX_NOT_IDLE_POS    19
#define MAC_HW_DMA_STATUS_4_TX_HTP_TRIGGER_FCS_FAIL_BIT    ((u32)0x00040000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_TRIGGER_FCS_FAIL_POS    18
#define MAC_HW_DMA_STATUS_4_TX_HTP_HALT_AFTER_TXOP_BIT    ((u32)0x00020000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_HALT_AFTER_TXOP_POS    17
#define MAC_HW_DMA_STATUS_4_TX_HTP_END_Q_BIT    ((u32)0x00010000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_END_Q_POS    16
#define MAC_HW_DMA_STATUS_4_TX_HTP_STARTUP_BIT    ((u32)0x00008000)
#define MAC_HW_DMA_STATUS_4_TX_HTP_STARTUP_POS    15
#define MAC_HW_DMA_STATUS_4_TX_AC_3_HALT_AFTER_TXOP_BIT    ((u32)0x00004000)
#define MAC_HW_DMA_STATUS_4_TX_AC_3_HALT_AFTER_TXOP_POS    14
#define MAC_HW_DMA_STATUS_4_TX_AC_2_HALT_AFTER_TXOP_BIT    ((u32)0x00002000)
#define MAC_HW_DMA_STATUS_4_TX_AC_2_HALT_AFTER_TXOP_POS    13
#define MAC_HW_DMA_STATUS_4_TX_AC_1_HALT_AFTER_TXOP_BIT    ((u32)0x00001000)
#define MAC_HW_DMA_STATUS_4_TX_AC_1_HALT_AFTER_TXOP_POS    12
#define MAC_HW_DMA_STATUS_4_TX_AC_0_HALT_AFTER_TXOP_BIT    ((u32)0x00000800)
#define MAC_HW_DMA_STATUS_4_TX_AC_0_HALT_AFTER_TXOP_POS    11
#define MAC_HW_DMA_STATUS_4_TX_BCN_HALT_AFTER_TXOP_BIT    ((u32)0x00000400)
#define MAC_HW_DMA_STATUS_4_TX_BCN_HALT_AFTER_TXOP_POS    10
#define MAC_HW_DMA_STATUS_4_TX_AC_3_END_Q_BIT    ((u32)0x00000200)
#define MAC_HW_DMA_STATUS_4_TX_AC_3_END_Q_POS    9
#define MAC_HW_DMA_STATUS_4_TX_AC_2_END_Q_BIT    ((u32)0x00000100)
#define MAC_HW_DMA_STATUS_4_TX_AC_2_END_Q_POS    8
#define MAC_HW_DMA_STATUS_4_TX_AC_1_END_Q_BIT    ((u32)0x00000080)
#define MAC_HW_DMA_STATUS_4_TX_AC_1_END_Q_POS    7
#define MAC_HW_DMA_STATUS_4_TX_AC_0_END_Q_BIT    ((u32)0x00000040)
#define MAC_HW_DMA_STATUS_4_TX_AC_0_END_Q_POS    6
#define MAC_HW_DMA_STATUS_4_TX_BCN_END_Q_BIT    ((u32)0x00000020)
#define MAC_HW_DMA_STATUS_4_TX_BCN_END_Q_POS    5
#define MAC_HW_DMA_STATUS_4_TX_AC_3_STARTUP_BIT    ((u32)0x00000010)
#define MAC_HW_DMA_STATUS_4_TX_AC_3_STARTUP_POS    4
#define MAC_HW_DMA_STATUS_4_TX_AC_2_STARTUP_BIT    ((u32)0x00000008)
#define MAC_HW_DMA_STATUS_4_TX_AC_2_STARTUP_POS    3
#define MAC_HW_DMA_STATUS_4_TX_AC_1_STARTUP_BIT    ((u32)0x00000004)
#define MAC_HW_DMA_STATUS_4_TX_AC_1_STARTUP_POS    2
#define MAC_HW_DMA_STATUS_4_TX_AC_0_STARTUP_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_STATUS_4_TX_AC_0_STARTUP_POS    1
#define MAC_HW_DMA_STATUS_4_TX_BCN_STARTUP_BIT    ((u32)0x00000001)
#define MAC_HW_DMA_STATUS_4_TX_BCN_STARTUP_POS    0

#define MAC_HW_DMA_STATUS_4_TX_HTP_RESP_DISABLED_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_HTP_RX_NOT_IDLE_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_HTP_TRIGGER_FCS_FAIL_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_HTP_HALT_AFTER_TXOP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_HTP_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_HTP_STARTUP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_AC_3_HALT_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_2_HALT_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_1_HALT_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_0_HALT_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_BCN_HALT_AFTER_TXOP_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_3_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_2_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_1_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_0_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_BCN_END_Q_RST    0x0
#define MAC_HW_DMA_STATUS_4_TX_AC_3_STARTUP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_AC_2_STARTUP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_AC_1_STARTUP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_AC_0_STARTUP_RST    0x1
#define MAC_HW_DMA_STATUS_4_TX_BCN_STARTUP_RST    0x1

static inline void mac_hw_dma_status_4_unpack(struct cl_chip *chip, u8 *tx_htp_resp_disabled, u8 *tx_htp_rx_not_idle, u8 *tx_htp_trigger_fcs_fail, u8 *tx_htp_halt_after_txop, u8 *tx_htp_end_q, u8 *tx_htp_startup, u8 *tx_ac_3_halt_after_txop, u8 *tx_ac_2_halt_after_txop, u8 *tx_ac_1_halt_after_txop, u8 *tx_ac_0_halt_after_txop, u8 *tx_bcn_halt_after_txop, u8 *tx_ac_3_end_q, u8 *tx_ac_2_end_q, u8 *tx_ac_1_end_q, u8 *tx_ac_0_end_q, u8 *tx_bcn_end_q, u8 *tx_ac_3_startup, u8 *tx_ac_2_startup, u8 *tx_ac_1_startup, u8 *tx_ac_0_startup, u8 *tx_bcn_startup)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	*tx_htp_resp_disabled = (local_val & ((u32)0x00100000)) >> 20;
	*tx_htp_rx_not_idle = (local_val & ((u32)0x00080000)) >> 19;
	*tx_htp_trigger_fcs_fail = (local_val & ((u32)0x00040000)) >> 18;
	*tx_htp_halt_after_txop = (local_val & ((u32)0x00020000)) >> 17;
	*tx_htp_end_q = (local_val & ((u32)0x00010000)) >> 16;
	*tx_htp_startup = (local_val & ((u32)0x00008000)) >> 15;
	*tx_ac_3_halt_after_txop = (local_val & ((u32)0x00004000)) >> 14;
	*tx_ac_2_halt_after_txop = (local_val & ((u32)0x00002000)) >> 13;
	*tx_ac_1_halt_after_txop = (local_val & ((u32)0x00001000)) >> 12;
	*tx_ac_0_halt_after_txop = (local_val & ((u32)0x00000800)) >> 11;
	*tx_bcn_halt_after_txop = (local_val & ((u32)0x00000400)) >> 10;
	*tx_ac_3_end_q = (local_val & ((u32)0x00000200)) >> 9;
	*tx_ac_2_end_q = (local_val & ((u32)0x00000100)) >> 8;
	*tx_ac_1_end_q = (local_val & ((u32)0x00000080)) >> 7;
	*tx_ac_0_end_q = (local_val & ((u32)0x00000040)) >> 6;
	*tx_bcn_end_q = (local_val & ((u32)0x00000020)) >> 5;
	*tx_ac_3_startup = (local_val & ((u32)0x00000010)) >> 4;
	*tx_ac_2_startup = (local_val & ((u32)0x00000008)) >> 3;
	*tx_ac_1_startup = (local_val & ((u32)0x00000004)) >> 2;
	*tx_ac_0_startup = (local_val & ((u32)0x00000002)) >> 1;
	*tx_bcn_startup = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_dma_status_4_tx_htp_resp_disabled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_dma_status_4_tx_htp_rx_not_idle_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_dma_status_4_tx_htp_trigger_fcs_fail_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_dma_status_4_tx_htp_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_dma_status_4_tx_htp_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_dma_status_4_tx_htp_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_dma_status_4_tx_ac_3_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_dma_status_4_tx_ac_2_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_dma_status_4_tx_ac_1_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_dma_status_4_tx_ac_0_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_dma_status_4_tx_bcn_halt_after_txop_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_dma_status_4_tx_ac_3_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_dma_status_4_tx_ac_2_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_dma_status_4_tx_ac_1_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_dma_status_4_tx_ac_0_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_dma_status_4_tx_bcn_end_q_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_dma_status_4_tx_ac_3_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_dma_status_4_tx_ac_2_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_dma_status_4_tx_ac_1_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_dma_status_4_tx_ac_0_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_dma_status_4_tx_bcn_startup_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_STATUS_4_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief TX_BCN_HEAD_PTR register definition
 *  Head Pointer of the Beacon DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_BCN_HEAD_PTR           0x0
 * </pre>
 */
#define MAC_HW_TX_BCN_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008198)
#define MAC_HW_TX_BCN_HEAD_PTR_OFFSET      0x00008198
#define MAC_HW_TX_BCN_HEAD_PTR_INDEX       0x00002066
#define MAC_HW_TX_BCN_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_bcn_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_BCN_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_bcn_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_BCN_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_BCN_HEAD_PTR_TX_BCN_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_BCN_HEAD_PTR_TX_BCN_HEAD_PTR_LSB    0
#define MAC_HW_TX_BCN_HEAD_PTR_TX_BCN_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_BCN_HEAD_PTR_TX_BCN_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_bcn_head_ptr_tx_bcn_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_BCN_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_bcn_head_ptr_tx_bcn_head_ptr_setf(struct cl_chip *chip, u32 txbcnheadptr)
{
	ASSERT_ERR_CHIP((((u32)txbcnheadptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_BCN_HEAD_PTR_ADDR, (u32)txbcnheadptr << 0);
}

/**
 * @brief TX_AC_0_HEAD_PTR register definition
 *  Head Pointer of the AC_BK DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_AC_0_HEAD_PTR          0x0
 * </pre>
 */
#define MAC_HW_TX_AC_0_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000819C)
#define MAC_HW_TX_AC_0_HEAD_PTR_OFFSET      0x0000819C
#define MAC_HW_TX_AC_0_HEAD_PTR_INDEX       0x00002067
#define MAC_HW_TX_AC_0_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_ac_0_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_AC_0_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_ac_0_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_AC_0_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_AC_0_HEAD_PTR_TX_AC_0_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_AC_0_HEAD_PTR_TX_AC_0_HEAD_PTR_LSB    0
#define MAC_HW_TX_AC_0_HEAD_PTR_TX_AC_0_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_AC_0_HEAD_PTR_TX_AC_0_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_ac_0_head_ptr_tx_ac_0_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_AC_0_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_ac_0_head_ptr_tx_ac_0_head_ptr_setf(struct cl_chip *chip, u32 txac0headptr)
{
	ASSERT_ERR_CHIP((((u32)txac0headptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_AC_0_HEAD_PTR_ADDR, (u32)txac0headptr << 0);
}

/**
 * @brief TX_AC_1_HEAD_PTR register definition
 *  Head Pointer of the AC_BE DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_AC_1_HEAD_PTR          0x0
 * </pre>
 */
#define MAC_HW_TX_AC_1_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081A0)
#define MAC_HW_TX_AC_1_HEAD_PTR_OFFSET      0x000081A0
#define MAC_HW_TX_AC_1_HEAD_PTR_INDEX       0x00002068
#define MAC_HW_TX_AC_1_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_ac_1_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_AC_1_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_ac_1_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_AC_1_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_AC_1_HEAD_PTR_TX_AC_1_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_AC_1_HEAD_PTR_TX_AC_1_HEAD_PTR_LSB    0
#define MAC_HW_TX_AC_1_HEAD_PTR_TX_AC_1_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_AC_1_HEAD_PTR_TX_AC_1_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_ac_1_head_ptr_tx_ac_1_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_AC_1_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_ac_1_head_ptr_tx_ac_1_head_ptr_setf(struct cl_chip *chip, u32 txac1headptr)
{
	ASSERT_ERR_CHIP((((u32)txac1headptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_AC_1_HEAD_PTR_ADDR, (u32)txac1headptr << 0);
}

/**
 * @brief TX_AC_2_HEAD_PTR register definition
 *  Head Pointer of the AC_VI DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_AC_2_HEAD_PTR          0x0
 * </pre>
 */
#define MAC_HW_TX_AC_2_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081A4)
#define MAC_HW_TX_AC_2_HEAD_PTR_OFFSET      0x000081A4
#define MAC_HW_TX_AC_2_HEAD_PTR_INDEX       0x00002069
#define MAC_HW_TX_AC_2_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_ac_2_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_AC_2_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_ac_2_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_AC_2_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_AC_2_HEAD_PTR_TX_AC_2_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_AC_2_HEAD_PTR_TX_AC_2_HEAD_PTR_LSB    0
#define MAC_HW_TX_AC_2_HEAD_PTR_TX_AC_2_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_AC_2_HEAD_PTR_TX_AC_2_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_ac_2_head_ptr_tx_ac_2_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_AC_2_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_ac_2_head_ptr_tx_ac_2_head_ptr_setf(struct cl_chip *chip, u32 txac2headptr)
{
	ASSERT_ERR_CHIP((((u32)txac2headptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_AC_2_HEAD_PTR_ADDR, (u32)txac2headptr << 0);
}

/**
 * @brief TX_AC_3_HEAD_PTR register definition
 *  Head Pointer of the AC_VO DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_AC_3_HEAD_PTR          0x0
 * </pre>
 */
#define MAC_HW_TX_AC_3_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081A8)
#define MAC_HW_TX_AC_3_HEAD_PTR_OFFSET      0x000081A8
#define MAC_HW_TX_AC_3_HEAD_PTR_INDEX       0x0000206A
#define MAC_HW_TX_AC_3_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_tx_ac_3_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_AC_3_HEAD_PTR_ADDR);
}

static inline void mac_hw_tx_ac_3_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_AC_3_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_AC_3_HEAD_PTR_TX_AC_3_HEAD_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TX_AC_3_HEAD_PTR_TX_AC_3_HEAD_PTR_LSB    0
#define MAC_HW_TX_AC_3_HEAD_PTR_TX_AC_3_HEAD_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_TX_AC_3_HEAD_PTR_TX_AC_3_HEAD_PTR_RST    0x0

static inline u32 mac_hw_tx_ac_3_head_ptr_tx_ac_3_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_AC_3_HEAD_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_tx_ac_3_head_ptr_tx_ac_3_head_ptr_setf(struct cl_chip *chip, u32 txac3headptr)
{
	ASSERT_ERR_CHIP((((u32)txac3headptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_TX_AC_3_HEAD_PTR_ADDR, (u32)txac3headptr << 0);
}

/**
 * @brief TX_STRUCT_SIZES register definition
 *  Indicates size of DMA structures register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29:24 DMA_RBD_SIZE              0x5
 *    23:18 DMA_RHD_SIZE              0x11
 *    17:12 DMA_TBD_SIZE              0x4
 *    11:06 DMA_THD_SIZE              0x10
 *    05:00 PT_ENTRY_SIZE             0x9
 * </pre>
 */
#define MAC_HW_TX_STRUCT_SIZES_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081AC)
#define MAC_HW_TX_STRUCT_SIZES_OFFSET      0x000081AC
#define MAC_HW_TX_STRUCT_SIZES_INDEX       0x0000206B
#define MAC_HW_TX_STRUCT_SIZES_RESET       0x05444409

static inline u32 mac_hw_tx_struct_sizes_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);
}

static inline void mac_hw_tx_struct_sizes_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_STRUCT_SIZES_DMA_RBD_SIZE_MASK    ((u32)0x3F000000)
#define MAC_HW_TX_STRUCT_SIZES_DMA_RBD_SIZE_LSB    24
#define MAC_HW_TX_STRUCT_SIZES_DMA_RBD_SIZE_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_STRUCT_SIZES_DMA_RHD_SIZE_MASK    ((u32)0x00FC0000)
#define MAC_HW_TX_STRUCT_SIZES_DMA_RHD_SIZE_LSB    18
#define MAC_HW_TX_STRUCT_SIZES_DMA_RHD_SIZE_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_STRUCT_SIZES_DMA_TBD_SIZE_MASK    ((u32)0x0003F000)
#define MAC_HW_TX_STRUCT_SIZES_DMA_TBD_SIZE_LSB    12
#define MAC_HW_TX_STRUCT_SIZES_DMA_TBD_SIZE_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_STRUCT_SIZES_DMA_THD_SIZE_MASK    ((u32)0x00000FC0)
#define MAC_HW_TX_STRUCT_SIZES_DMA_THD_SIZE_LSB    6
#define MAC_HW_TX_STRUCT_SIZES_DMA_THD_SIZE_WIDTH    ((u32)0x00000006)
#define MAC_HW_TX_STRUCT_SIZES_PT_ENTRY_SIZE_MASK    ((u32)0x0000003F)
#define MAC_HW_TX_STRUCT_SIZES_PT_ENTRY_SIZE_LSB    0
#define MAC_HW_TX_STRUCT_SIZES_PT_ENTRY_SIZE_WIDTH    ((u32)0x00000006)

#define MAC_HW_TX_STRUCT_SIZES_DMA_RBD_SIZE_RST    0x5
#define MAC_HW_TX_STRUCT_SIZES_DMA_RHD_SIZE_RST    0x11
#define MAC_HW_TX_STRUCT_SIZES_DMA_TBD_SIZE_RST    0x4
#define MAC_HW_TX_STRUCT_SIZES_DMA_THD_SIZE_RST    0x10
#define MAC_HW_TX_STRUCT_SIZES_PT_ENTRY_SIZE_RST    0x9

static inline void mac_hw_tx_struct_sizes_pack(struct cl_chip *chip, u8 dma_rbd_size, u8 dma_rhd_size, u8 dma_tbd_size, u8 dma_thd_size, u8 pt_entry_size)
{
	ASSERT_ERR_CHIP((((u32)dma_rbd_size << 24) & ~((u32)0x3F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dma_rhd_size << 18) & ~((u32)0x00FC0000)) == 0);
	ASSERT_ERR_CHIP((((u32)dma_tbd_size << 12) & ~((u32)0x0003F000)) == 0);
	ASSERT_ERR_CHIP((((u32)dma_thd_size << 6) & ~((u32)0x00000FC0)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_entry_size << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, ((u32)dma_rbd_size << 24) | ((u32)dma_rhd_size << 18) | ((u32)dma_tbd_size << 12) | ((u32)dma_thd_size << 6) | ((u32)pt_entry_size << 0));
}

static inline void mac_hw_tx_struct_sizes_unpack(struct cl_chip *chip, u8 *dma_rbd_size, u8 *dma_rhd_size, u8 *dma_tbd_size, u8 *dma_thd_size, u8 *pt_entry_size)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	*dma_rbd_size = (local_val & ((u32)0x3F000000)) >> 24;
	*dma_rhd_size = (local_val & ((u32)0x00FC0000)) >> 18;
	*dma_tbd_size = (local_val & ((u32)0x0003F000)) >> 12;
	*dma_thd_size = (local_val & ((u32)0x00000FC0)) >> 6;
	*pt_entry_size = (local_val & ((u32)0x0000003F)) >> 0;
}

static inline u8 mac_hw_tx_struct_sizes_dma_rbd_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	return (u8)((local_val & ((u32)0x3F000000)) >> 24);
}

static inline void mac_hw_tx_struct_sizes_dma_rbd_size_setf(struct cl_chip *chip, u8 dmarbdsize)
{
	ASSERT_ERR_CHIP((((u32)dmarbdsize << 24) & ~((u32)0x3F000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, (cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR) & ~((u32)0x3F000000)) | ((u32)dmarbdsize << 24));
}

static inline u8 mac_hw_tx_struct_sizes_dma_rhd_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	return (u8)((local_val & ((u32)0x00FC0000)) >> 18);
}

static inline void mac_hw_tx_struct_sizes_dma_rhd_size_setf(struct cl_chip *chip, u8 dmarhdsize)
{
	ASSERT_ERR_CHIP((((u32)dmarhdsize << 18) & ~((u32)0x00FC0000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, (cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR) & ~((u32)0x00FC0000)) | ((u32)dmarhdsize << 18));
}

static inline u8 mac_hw_tx_struct_sizes_dma_tbd_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	return (u8)((local_val & ((u32)0x0003F000)) >> 12);
}

static inline void mac_hw_tx_struct_sizes_dma_tbd_size_setf(struct cl_chip *chip, u8 dmatbdsize)
{
	ASSERT_ERR_CHIP((((u32)dmatbdsize << 12) & ~((u32)0x0003F000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, (cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR) & ~((u32)0x0003F000)) | ((u32)dmatbdsize << 12));
}

static inline u8 mac_hw_tx_struct_sizes_dma_thd_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	return (u8)((local_val & ((u32)0x00000FC0)) >> 6);
}

static inline void mac_hw_tx_struct_sizes_dma_thd_size_setf(struct cl_chip *chip, u8 dmathdsize)
{
	ASSERT_ERR_CHIP((((u32)dmathdsize << 6) & ~((u32)0x00000FC0)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, (cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR) & ~((u32)0x00000FC0)) | ((u32)dmathdsize << 6));
}

static inline u8 mac_hw_tx_struct_sizes_pt_entry_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR);

	return (u8)((local_val & ((u32)0x0000003F)) >> 0);
}

static inline void mac_hw_tx_struct_sizes_pt_entry_size_setf(struct cl_chip *chip, u8 ptentrysize)
{
	ASSERT_ERR_CHIP((((u32)ptentrysize << 0) & ~((u32)0x0000003F)) == 0);
	cl_reg_write(chip, MAC_HW_TX_STRUCT_SIZES_ADDR, (cl_reg_read(chip, MAC_HW_TX_STRUCT_SIZES_ADDR) & ~((u32)0x0000003F)) | ((u32)ptentrysize << 0));
}

/**
 * @brief RX_HEADER_HEAD_2_PTR register definition
 *  Head Pointer of the Rec 2 Header DMA channel is  register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 RX_HEADER_HEAD_PTR        0x0
 *    00    RX_HEADER_HEAD_PTR_VALID  0
 * </pre>
 */
#define MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081B0)
#define MAC_HW_RX_HEADER_HEAD_2_PTR_OFFSET      0x000081B0
#define MAC_HW_RX_HEADER_HEAD_2_PTR_INDEX       0x0000206C
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RESET       0x00000000

static inline u32 mac_hw_rx_header_head_2_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR);
}

static inline void mac_hw_rx_header_head_2_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_MASK    ((u32)0xFFFFFFFC)
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_LSB    2
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_WIDTH    ((u32)0x0000001E)
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_VALID_BIT    ((u32)0x00000001)
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_VALID_POS    0

#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_RST    0x0
#define MAC_HW_RX_HEADER_HEAD_2_PTR_RX_HEADER_HEAD_PTR_VALID_RST    0x0

static inline void mac_hw_rx_header_head_2_ptr_pack(struct cl_chip *chip, u32 rx_header_head_ptr, u8 rx_header_head_ptr_valid)
{
	ASSERT_ERR_CHIP((((u32)rx_header_head_ptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_head_ptr_valid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR, ((u32)rx_header_head_ptr << 2) | ((u32)rx_header_head_ptr_valid << 0));
}

static inline void mac_hw_rx_header_head_2_ptr_unpack(struct cl_chip *chip, u32 *rx_header_head_ptr, u8 *rx_header_head_ptr_valid)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR);

	*rx_header_head_ptr = (local_val & ((u32)0xFFFFFFFC)) >> 2;
	*rx_header_head_ptr_valid = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u32 mac_hw_rx_header_head_2_ptr_rx_header_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFFFC)) >> 2);
}

static inline void mac_hw_rx_header_head_2_ptr_rx_header_head_ptr_setf(struct cl_chip *chip, u32 rxheaderheadptr)
{
	ASSERT_ERR_CHIP((((u32)rxheaderheadptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR) & ~((u32)0xFFFFFFFC)) | ((u32)rxheaderheadptr << 2));
}

static inline u8 mac_hw_rx_header_head_2_ptr_rx_header_head_ptr_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_header_head_2_ptr_rx_header_head_ptr_valid_setf(struct cl_chip *chip, u8 rxheaderheadptrvalid)
{
	ASSERT_ERR_CHIP((((u32)rxheaderheadptrvalid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_2_PTR_ADDR) & ~((u32)0x00000001)) | ((u32)rxheaderheadptrvalid << 0));
}

/**
 * @brief RX_PAYLOAD_HEAD_2_PTR register definition
 *  Head Pointer of the Rec 2 Payload DMA channel is register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 RX_PAYLOAD_HEAD2_PTR      0x0
 *    00    RX_PAYLOAD_HEAD2_PTR_VALID 0
 * </pre>
 */
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081B4)
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_OFFSET      0x000081B4
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_INDEX       0x0000206D
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RESET       0x00000000

static inline u32 mac_hw_rx_payload_head_2_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR);
}

static inline void mac_hw_rx_payload_head_2_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_MASK    ((u32)0xFFFFFFFC)
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_LSB    2
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_WIDTH    ((u32)0x0000001E)
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_VALID_BIT    ((u32)0x00000001)
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_VALID_POS    0

#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_RST    0x0
#define MAC_HW_RX_PAYLOAD_HEAD_2_PTR_RX_PAYLOAD_HEAD_2_PTR_VALID_RST    0x0

static inline void mac_hw_rx_payload_head_2_ptr_pack(struct cl_chip *chip, u32 rx_payload_head2_ptr, u8 rx_payload_head2_ptr_valid)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_head2_ptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_head2_ptr_valid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR, ((u32)rx_payload_head2_ptr << 2) | ((u32)rx_payload_head2_ptr_valid << 0));
}

static inline void mac_hw_rx_payload_head_2_ptr_unpack(struct cl_chip *chip, u32 *rx_payload_head2_ptr, u8 *rx_payload_head2_ptr_valid)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR);

	*rx_payload_head2_ptr = (local_val & ((u32)0xFFFFFFFC)) >> 2;
	*rx_payload_head2_ptr_valid = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u32 mac_hw_rx_payload_head_2_ptr_rx_payload_head_2_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFFFC)) >> 2);
}

static inline void mac_hw_rx_payload_head_2_ptr_rx_payload_head_2_ptr_setf(struct cl_chip *chip, u32 rxpayloadhead2ptr)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadhead2ptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR) & ~((u32)0xFFFFFFFC)) | ((u32)rxpayloadhead2ptr << 2));
}

static inline u8 mac_hw_rx_payload_head_2_ptr_rx_payload_head_2_ptr_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_payload_head_2_ptr_rx_payload_head_2_ptr_valid_setf(struct cl_chip *chip, u8 rxpayloadhead2ptrvalid)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadhead2ptrvalid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_2_PTR_ADDR) & ~((u32)0x00000001)) | ((u32)rxpayloadhead2ptrvalid << 0));
}

/**
 * @brief RX_HEADER_HEAD_PTR register definition
 *  Head Pointer of the Receive Header DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 RX_HEADER_HEAD_PTR        0x0
 *    00    RX_HEADER_HEAD_PTR_VALID  0
 * </pre>
 */
#define MAC_HW_RX_HEADER_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081B8)
#define MAC_HW_RX_HEADER_HEAD_PTR_OFFSET      0x000081B8
#define MAC_HW_RX_HEADER_HEAD_PTR_INDEX       0x0000206E
#define MAC_HW_RX_HEADER_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_rx_header_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR);
}

static inline void mac_hw_rx_header_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_MASK    ((u32)0xFFFFFFFC)
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_LSB    2
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_WIDTH    ((u32)0x0000001E)
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_VALID_BIT    ((u32)0x00000001)
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_VALID_POS    0

#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_RST    0x0
#define MAC_HW_RX_HEADER_HEAD_PTR_RX_HEADER_HEAD_PTR_VALID_RST    0x0

static inline void mac_hw_rx_header_head_ptr_pack(struct cl_chip *chip, u32 rx_header_head_ptr, u8 rx_header_head_ptr_valid)
{
	ASSERT_ERR_CHIP((((u32)rx_header_head_ptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_head_ptr_valid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR, ((u32)rx_header_head_ptr << 2) | ((u32)rx_header_head_ptr_valid << 0));
}

static inline void mac_hw_rx_header_head_ptr_unpack(struct cl_chip *chip, u32 *rx_header_head_ptr, u8 *rx_header_head_ptr_valid)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR);

	*rx_header_head_ptr = (local_val & ((u32)0xFFFFFFFC)) >> 2;
	*rx_header_head_ptr_valid = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u32 mac_hw_rx_header_head_ptr_rx_header_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFFFC)) >> 2);
}

static inline void mac_hw_rx_header_head_ptr_rx_header_head_ptr_setf(struct cl_chip *chip, u32 rxheaderheadptr)
{
	ASSERT_ERR_CHIP((((u32)rxheaderheadptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR) & ~((u32)0xFFFFFFFC)) | ((u32)rxheaderheadptr << 2));
}

static inline u8 mac_hw_rx_header_head_ptr_rx_header_head_ptr_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_header_head_ptr_rx_header_head_ptr_valid_setf(struct cl_chip *chip, u8 rxheaderheadptrvalid)
{
	ASSERT_ERR_CHIP((((u32)rxheaderheadptrvalid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_HEADER_HEAD_PTR_ADDR) & ~((u32)0x00000001)) | ((u32)rxheaderheadptrvalid << 0));
}

/**
 * @brief RX_PAYLOAD_HEAD_PTR register definition
 *  Head Pointer of the Receive Payload DMA channel is programmed here. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:02 RX_PAYLOAD_HEAD_PTR       0x0
 *    00    RX_PAYLOAD_HEAD_PTR_VALID 0
 * </pre>
 */
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081BC)
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_OFFSET      0x000081BC
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_INDEX       0x0000206F
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RESET       0x00000000

static inline u32 mac_hw_rx_payload_head_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR);
}

static inline void mac_hw_rx_payload_head_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_MASK    ((u32)0xFFFFFFFC)
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_LSB    2
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_WIDTH    ((u32)0x0000001E)
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_VALID_BIT    ((u32)0x00000001)
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_VALID_POS    0

#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_RST    0x0
#define MAC_HW_RX_PAYLOAD_HEAD_PTR_RX_PAYLOAD_HEAD_PTR_VALID_RST    0x0

static inline void mac_hw_rx_payload_head_ptr_pack(struct cl_chip *chip, u32 rx_payload_head_ptr, u8 rx_payload_head_ptr_valid)
{
	ASSERT_ERR_CHIP((((u32)rx_payload_head_ptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_head_ptr_valid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR, ((u32)rx_payload_head_ptr << 2) | ((u32)rx_payload_head_ptr_valid << 0));
}

static inline void mac_hw_rx_payload_head_ptr_unpack(struct cl_chip *chip, u32 *rx_payload_head_ptr, u8 *rx_payload_head_ptr_valid)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR);

	*rx_payload_head_ptr = (local_val & ((u32)0xFFFFFFFC)) >> 2;
	*rx_payload_head_ptr_valid = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u32 mac_hw_rx_payload_head_ptr_rx_payload_head_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFFFC)) >> 2);
}

static inline void mac_hw_rx_payload_head_ptr_rx_payload_head_ptr_setf(struct cl_chip *chip, u32 rxpayloadheadptr)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadheadptr << 2) & ~((u32)0xFFFFFFFC)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR) & ~((u32)0xFFFFFFFC)) | ((u32)rxpayloadheadptr << 2));
}

static inline u8 mac_hw_rx_payload_head_ptr_rx_payload_head_ptr_valid_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_payload_head_ptr_rx_payload_head_ptr_valid_setf(struct cl_chip *chip, u8 rxpayloadheadptrvalid)
{
	ASSERT_ERR_CHIP((((u32)rxpayloadheadptrvalid << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR, (cl_reg_read(chip, MAC_HW_RX_PAYLOAD_HEAD_PTR_ADDR) & ~((u32)0x00000001)) | ((u32)rxpayloadheadptrvalid << 0));
}

/**
 * @brief DMA_THRESHOLD register definition
 *  Contains FIFO threshold value for DMA triggering register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    23:16 RX_FIFO_THRESHOLD         0x10
 *    07:00 TX_FIFO_THRESHOLD         0x10
 * </pre>
 */
#define MAC_HW_DMA_THRESHOLD_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081C0)
#define MAC_HW_DMA_THRESHOLD_OFFSET      0x000081C0
#define MAC_HW_DMA_THRESHOLD_INDEX       0x00002070
#define MAC_HW_DMA_THRESHOLD_RESET       0x00100010

static inline u32 mac_hw_dma_threshold_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR);
}

static inline void mac_hw_dma_threshold_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_THRESHOLD_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_THRESHOLD_RX_FIFO_THRESHOLD_MASK    ((u32)0x00FF0000)
#define MAC_HW_DMA_THRESHOLD_RX_FIFO_THRESHOLD_LSB    16
#define MAC_HW_DMA_THRESHOLD_RX_FIFO_THRESHOLD_WIDTH    ((u32)0x00000008)
#define MAC_HW_DMA_THRESHOLD_TX_FIFO_THRESHOLD_MASK    ((u32)0x000000FF)
#define MAC_HW_DMA_THRESHOLD_TX_FIFO_THRESHOLD_LSB    0
#define MAC_HW_DMA_THRESHOLD_TX_FIFO_THRESHOLD_WIDTH    ((u32)0x00000008)

#define MAC_HW_DMA_THRESHOLD_RX_FIFO_THRESHOLD_RST    0x10
#define MAC_HW_DMA_THRESHOLD_TX_FIFO_THRESHOLD_RST    0x10

static inline void mac_hw_dma_threshold_pack(struct cl_chip *chip, u8 rx_fifo_threshold, u8 tx_fifo_threshold)
{
	ASSERT_ERR_CHIP((((u32)rx_fifo_threshold << 16) & ~((u32)0x00FF0000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_fifo_threshold << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_THRESHOLD_ADDR, ((u32)rx_fifo_threshold << 16) | ((u32)tx_fifo_threshold << 0));
}

static inline void mac_hw_dma_threshold_unpack(struct cl_chip *chip, u8 *rx_fifo_threshold, u8 *tx_fifo_threshold)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR);

	*rx_fifo_threshold = (local_val & ((u32)0x00FF0000)) >> 16;
	*tx_fifo_threshold = (local_val & ((u32)0x000000FF)) >> 0;
}

static inline u8 mac_hw_dma_threshold_rx_fifo_threshold_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR);

	return (u8)((local_val & ((u32)0x00FF0000)) >> 16);
}

static inline void mac_hw_dma_threshold_rx_fifo_threshold_setf(struct cl_chip *chip, u8 rxfifothreshold)
{
	ASSERT_ERR_CHIP((((u32)rxfifothreshold << 16) & ~((u32)0x00FF0000)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_THRESHOLD_ADDR, (cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR) & ~((u32)0x00FF0000)) | ((u32)rxfifothreshold << 16));
}

static inline u8 mac_hw_dma_threshold_tx_fifo_threshold_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR);

	return (u8)((local_val & ((u32)0x000000FF)) >> 0);
}

static inline void mac_hw_dma_threshold_tx_fifo_threshold_setf(struct cl_chip *chip, u8 txfifothreshold)
{
	ASSERT_ERR_CHIP((((u32)txfifothreshold << 0) & ~((u32)0x000000FF)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_THRESHOLD_ADDR, (cl_reg_read(chip, MAC_HW_DMA_THRESHOLD_ADDR) & ~((u32)0x000000FF)) | ((u32)txfifothreshold << 0));
}

/**
 * @brief CONT_DMA register definition
 *  Continue DMA Tx command register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    00    CONT_AFTER_NATT           0
 * </pre>
 */
#define MAC_HW_CONT_DMA_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081C4)
#define MAC_HW_CONT_DMA_OFFSET      0x000081C4
#define MAC_HW_CONT_DMA_INDEX       0x00002071
#define MAC_HW_CONT_DMA_RESET       0x00000000

static inline u32 mac_hw_cont_dma_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CONT_DMA_ADDR);
}

static inline void mac_hw_cont_dma_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CONT_DMA_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CONT_DMA_CONT_AFTER_NATT_BIT    ((u32)0x00000001)
#define MAC_HW_CONT_DMA_CONT_AFTER_NATT_POS    0

#define MAC_HW_CONT_DMA_CONT_AFTER_NATT_RST    0x0

static inline u8 mac_hw_cont_dma_cont_after_natt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CONT_DMA_ADDR);

	return (u8)(local_val >> 0);
}

static inline void mac_hw_cont_dma_cont_after_natt_setf(struct cl_chip *chip, u8 contafternatt)
{
	ASSERT_ERR_CHIP((((u32)contafternatt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_CONT_DMA_ADDR, (u32)contafternatt << 0);
}

/**
 * @brief RX_LIST_2_FRAME_TYPE register definition
 *  required frame types for LL2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    NDP                       0
 *    29:28 FRAME_TYPE_4              0x3
 *    27:24 SUB_FRAME_TYPE_4          0x0
 *    23:22 FRAME_TYPE_3              0x3
 *    21:18 SUB_FRAME_TYPE_3          0x0
 *    17:16 FRAME_TYPE_2              0x3
 *    15:12 SUB_FRAME_TYPE_2          0x0
 *    11:10 FRAME_TYPE_1              0x3
 *    09:06 SUB_FRAME_TYPE_1          0x0
 *    05:04 FRAME_TYPE_0              0x3
 *    03:00 SUB_FRAME_TYPE_0          0x0
 * </pre>
 */
#define MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081C8)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_OFFSET      0x000081C8
#define MAC_HW_RX_LIST_2_FRAME_TYPE_INDEX       0x00002072
#define MAC_HW_RX_LIST_2_FRAME_TYPE_RESET       0x30C30C30

static inline u32 mac_hw_rx_list_2_frame_type_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);
}

static inline void mac_hw_rx_list_2_frame_type_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_LIST_2_FRAME_TYPE_NDP_BIT    ((u32)0x40000000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_NDP_POS    30
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_4_MASK    ((u32)0x30000000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_4_LSB    28
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_4_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_4_MASK    ((u32)0x0F000000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_4_LSB    24
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_4_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_3_MASK    ((u32)0x00C00000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_3_LSB    22
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_3_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_3_MASK    ((u32)0x003C0000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_3_LSB    18
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_3_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_2_MASK    ((u32)0x00030000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_2_LSB    16
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_2_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_2_MASK    ((u32)0x0000F000)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_2_LSB    12
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_2_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_1_MASK    ((u32)0x00000C00)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_1_LSB    10
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_1_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_1_MASK    ((u32)0x000003C0)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_1_LSB    6
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_1_WIDTH    ((u32)0x00000004)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_0_MASK    ((u32)0x00000030)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_0_LSB    4
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_0_WIDTH    ((u32)0x00000002)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_0_MASK    ((u32)0x0000000F)
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_0_LSB    0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_0_WIDTH    ((u32)0x00000004)

#define MAC_HW_RX_LIST_2_FRAME_TYPE_NDP_RST    0x0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_4_RST    0x3
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_4_RST    0x0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_3_RST    0x3
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_3_RST    0x0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_2_RST    0x3
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_2_RST    0x0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_1_RST    0x3
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_1_RST    0x0
#define MAC_HW_RX_LIST_2_FRAME_TYPE_FRAME_TYPE_0_RST    0x3
#define MAC_HW_RX_LIST_2_FRAME_TYPE_SUB_FRAME_TYPE_0_RST    0x0

static inline void mac_hw_rx_list_2_frame_type_pack(struct cl_chip *chip, u8 ndp, u8 frame_type_4, u8 sub_frame_type_4, u8 frame_type_3, u8 sub_frame_type_3, u8 frame_type_2, u8 sub_frame_type_2, u8 frame_type_1, u8 sub_frame_type_1, u8 frame_type_0, u8 sub_frame_type_0)
{
	ASSERT_ERR_CHIP((((u32)ndp << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_type_4 << 28) & ~((u32)0x30000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sub_frame_type_4 << 24) & ~((u32)0x0F000000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_type_3 << 22) & ~((u32)0x00C00000)) == 0);
	ASSERT_ERR_CHIP((((u32)sub_frame_type_3 << 18) & ~((u32)0x003C0000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_type_2 << 16) & ~((u32)0x00030000)) == 0);
	ASSERT_ERR_CHIP((((u32)sub_frame_type_2 << 12) & ~((u32)0x0000F000)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_type_1 << 10) & ~((u32)0x00000C00)) == 0);
	ASSERT_ERR_CHIP((((u32)sub_frame_type_1 << 6) & ~((u32)0x000003C0)) == 0);
	ASSERT_ERR_CHIP((((u32)frame_type_0 << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)sub_frame_type_0 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, ((u32)ndp << 30) | ((u32)frame_type_4 << 28) | ((u32)sub_frame_type_4 << 24) | ((u32)frame_type_3 << 22) | ((u32)sub_frame_type_3 << 18) | ((u32)frame_type_2 << 16) | ((u32)sub_frame_type_2 << 12) | ((u32)frame_type_1 << 10) | ((u32)sub_frame_type_1 << 6) | ((u32)frame_type_0 << 4) | ((u32)sub_frame_type_0 << 0));
}

static inline void mac_hw_rx_list_2_frame_type_unpack(struct cl_chip *chip, u8 *ndp, u8 *frame_type_4, u8 *sub_frame_type_4, u8 *frame_type_3, u8 *sub_frame_type_3, u8 *frame_type_2, u8 *sub_frame_type_2, u8 *frame_type_1, u8 *sub_frame_type_1, u8 *frame_type_0, u8 *sub_frame_type_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	*ndp = (local_val & ((u32)0x40000000)) >> 30;
	*frame_type_4 = (local_val & ((u32)0x30000000)) >> 28;
	*sub_frame_type_4 = (local_val & ((u32)0x0F000000)) >> 24;
	*frame_type_3 = (local_val & ((u32)0x00C00000)) >> 22;
	*sub_frame_type_3 = (local_val & ((u32)0x003C0000)) >> 18;
	*frame_type_2 = (local_val & ((u32)0x00030000)) >> 16;
	*sub_frame_type_2 = (local_val & ((u32)0x0000F000)) >> 12;
	*frame_type_1 = (local_val & ((u32)0x00000C00)) >> 10;
	*sub_frame_type_1 = (local_val & ((u32)0x000003C0)) >> 6;
	*frame_type_0 = (local_val & ((u32)0x00000030)) >> 4;
	*sub_frame_type_0 = (local_val & ((u32)0x0000000F)) >> 0;
}

static inline u8 mac_hw_rx_list_2_frame_type_ndp_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_rx_list_2_frame_type_ndp_setf(struct cl_chip *chip, u8 ndp)
{
	ASSERT_ERR_CHIP((((u32)ndp << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x40000000)) | ((u32)ndp << 30));
}

static inline u8 mac_hw_rx_list_2_frame_type_frame_type_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x30000000)) >> 28);
}

static inline void mac_hw_rx_list_2_frame_type_frame_type_4_setf(struct cl_chip *chip, u8 frametype4)
{
	ASSERT_ERR_CHIP((((u32)frametype4 << 28) & ~((u32)0x30000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x30000000)) | ((u32)frametype4 << 28));
}

static inline u8 mac_hw_rx_list_2_frame_type_sub_frame_type_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x0F000000)) >> 24);
}

static inline void mac_hw_rx_list_2_frame_type_sub_frame_type_4_setf(struct cl_chip *chip, u8 subframetype4)
{
	ASSERT_ERR_CHIP((((u32)subframetype4 << 24) & ~((u32)0x0F000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x0F000000)) | ((u32)subframetype4 << 24));
}

static inline u8 mac_hw_rx_list_2_frame_type_frame_type_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x00C00000)) >> 22);
}

static inline void mac_hw_rx_list_2_frame_type_frame_type_3_setf(struct cl_chip *chip, u8 frametype3)
{
	ASSERT_ERR_CHIP((((u32)frametype3 << 22) & ~((u32)0x00C00000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x00C00000)) | ((u32)frametype3 << 22));
}

static inline u8 mac_hw_rx_list_2_frame_type_sub_frame_type_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x003C0000)) >> 18);
}

static inline void mac_hw_rx_list_2_frame_type_sub_frame_type_3_setf(struct cl_chip *chip, u8 subframetype3)
{
	ASSERT_ERR_CHIP((((u32)subframetype3 << 18) & ~((u32)0x003C0000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x003C0000)) | ((u32)subframetype3 << 18));
}

static inline u8 mac_hw_rx_list_2_frame_type_frame_type_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x00030000)) >> 16);
}

static inline void mac_hw_rx_list_2_frame_type_frame_type_2_setf(struct cl_chip *chip, u8 frametype2)
{
	ASSERT_ERR_CHIP((((u32)frametype2 << 16) & ~((u32)0x00030000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x00030000)) | ((u32)frametype2 << 16));
}

static inline u8 mac_hw_rx_list_2_frame_type_sub_frame_type_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x0000F000)) >> 12);
}

static inline void mac_hw_rx_list_2_frame_type_sub_frame_type_2_setf(struct cl_chip *chip, u8 subframetype2)
{
	ASSERT_ERR_CHIP((((u32)subframetype2 << 12) & ~((u32)0x0000F000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x0000F000)) | ((u32)subframetype2 << 12));
}

static inline u8 mac_hw_rx_list_2_frame_type_frame_type_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x00000C00)) >> 10);
}

static inline void mac_hw_rx_list_2_frame_type_frame_type_1_setf(struct cl_chip *chip, u8 frametype1)
{
	ASSERT_ERR_CHIP((((u32)frametype1 << 10) & ~((u32)0x00000C00)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x00000C00)) | ((u32)frametype1 << 10));
}

static inline u8 mac_hw_rx_list_2_frame_type_sub_frame_type_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x000003C0)) >> 6);
}

static inline void mac_hw_rx_list_2_frame_type_sub_frame_type_1_setf(struct cl_chip *chip, u8 subframetype1)
{
	ASSERT_ERR_CHIP((((u32)subframetype1 << 6) & ~((u32)0x000003C0)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x000003C0)) | ((u32)subframetype1 << 6));
}

static inline u8 mac_hw_rx_list_2_frame_type_frame_type_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_rx_list_2_frame_type_frame_type_0_setf(struct cl_chip *chip, u8 frametype0)
{
	ASSERT_ERR_CHIP((((u32)frametype0 << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x00000030)) | ((u32)frametype0 << 4));
}

static inline u8 mac_hw_rx_list_2_frame_type_sub_frame_type_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR);

	return (u8)((local_val & ((u32)0x0000000F)) >> 0);
}

static inline void mac_hw_rx_list_2_frame_type_sub_frame_type_0_setf(struct cl_chip *chip, u8 subframetype0)
{
	ASSERT_ERR_CHIP((((u32)subframetype0 << 0) & ~((u32)0x0000000F)) == 0);
	cl_reg_write(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR, (cl_reg_read(chip, MAC_HW_RX_LIST_2_FRAME_TYPE_ADDR) & ~((u32)0x0000000F)) | ((u32)subframetype0 << 0));
}

/**
 * @brief DMA_RX_CELENO_MODES register definition
 *  Define Rx behavior in new Celeno modes register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    07:06 RX_CYCLIC_BUFFER_SIZE_LL2 0x0
 *    05:04 RX_CYCLIC_BUFFER_SIZE_LL1 0x0
 *    01    RX_CYCLIC_BUFFER_MODE     0
 * </pre>
 */
#define MAC_HW_DMA_RX_CELENO_MODES_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081CC)
#define MAC_HW_DMA_RX_CELENO_MODES_OFFSET      0x000081CC
#define MAC_HW_DMA_RX_CELENO_MODES_INDEX       0x00002073
#define MAC_HW_DMA_RX_CELENO_MODES_RESET       0x00000000

static inline u32 mac_hw_dma_rx_celeno_modes_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR);
}

static inline void mac_hw_dma_rx_celeno_modes_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_2_MASK    ((u32)0x000000C0)
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_2_LSB    6
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_2_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_1_MASK    ((u32)0x00000030)
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_1_LSB    4
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_1_WIDTH    ((u32)0x00000002)
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_MODE_BIT    ((u32)0x00000002)
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_MODE_POS    1

#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_2_RST    0x0
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_SIZE_LL_1_RST    0x0
#define MAC_HW_DMA_RX_CELENO_MODES_RX_CYCLIC_BUFFER_MODE_RST    0x0

static inline void mac_hw_dma_rx_celeno_modes_pack(struct cl_chip *chip, u8 rx_cyclic_buffer_size_ll2, u8 rx_cyclic_buffer_size_ll1, u8 rx_cyclic_buffer_mode)
{
	ASSERT_ERR_CHIP((((u32)rx_cyclic_buffer_size_ll2 << 6) & ~((u32)0x000000C0)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_cyclic_buffer_size_ll1 << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_cyclic_buffer_mode << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR, ((u32)rx_cyclic_buffer_size_ll2 << 6) | ((u32)rx_cyclic_buffer_size_ll1 << 4) | ((u32)rx_cyclic_buffer_mode << 1));
}

static inline void mac_hw_dma_rx_celeno_modes_unpack(struct cl_chip *chip, u8 *rx_cyclic_buffer_size_ll2, u8 *rx_cyclic_buffer_size_ll1, u8 *rx_cyclic_buffer_mode)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR);

	*rx_cyclic_buffer_size_ll2 = (local_val & ((u32)0x000000C0)) >> 6;
	*rx_cyclic_buffer_size_ll1 = (local_val & ((u32)0x00000030)) >> 4;
	*rx_cyclic_buffer_mode = (local_val & ((u32)0x00000002)) >> 1;
}

static inline u8 mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_size_ll_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR);

	return (u8)((local_val & ((u32)0x000000C0)) >> 6);
}

static inline void mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_size_ll_2_setf(struct cl_chip *chip, u8 rxcyclicbuffersizell2)
{
	ASSERT_ERR_CHIP((((u32)rxcyclicbuffersizell2 << 6) & ~((u32)0x000000C0)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR, (cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR) & ~((u32)0x000000C0)) | ((u32)rxcyclicbuffersizell2 << 6));
}

static inline u8 mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_size_ll_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_size_ll_1_setf(struct cl_chip *chip, u8 rxcyclicbuffersizell1)
{
	ASSERT_ERR_CHIP((((u32)rxcyclicbuffersizell1 << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR, (cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR) & ~((u32)0x00000030)) | ((u32)rxcyclicbuffersizell1 << 4));
}

static inline u8 mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_mode_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_dma_rx_celeno_modes_rx_cyclic_buffer_mode_setf(struct cl_chip *chip, u8 rxcyclicbuffermode)
{
	ASSERT_ERR_CHIP((((u32)rxcyclicbuffermode << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR, (cl_reg_read(chip, MAC_HW_DMA_RX_CELENO_MODES_ADDR) & ~((u32)0x00000002)) | ((u32)rxcyclicbuffermode << 1));
}

/**
 * @brief DMA_FW_PLD_START_PTR register definition
 *  DMA Payload FW start pointer and HW write pointer register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:05 DMA_FW_PLD_START_PTR      0x0
 * </pre>
 */
#define MAC_HW_DMA_FW_PLD_START_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081D0)
#define MAC_HW_DMA_FW_PLD_START_PTR_OFFSET      0x000081D0
#define MAC_HW_DMA_FW_PLD_START_PTR_INDEX       0x00002074
#define MAC_HW_DMA_FW_PLD_START_PTR_RESET       0x00000000

static inline u32 mac_hw_dma_fw_pld_start_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_FW_PLD_START_PTR_ADDR);
}

static inline void mac_hw_dma_fw_pld_start_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_FW_PLD_START_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_FW_PLD_START_PTR_DMA_FW_PLD_START_PTR_MASK    ((u32)0xFFFFFFE0)
#define MAC_HW_DMA_FW_PLD_START_PTR_DMA_FW_PLD_START_PTR_LSB    5
#define MAC_HW_DMA_FW_PLD_START_PTR_DMA_FW_PLD_START_PTR_WIDTH    ((u32)0x0000001B)

#define MAC_HW_DMA_FW_PLD_START_PTR_DMA_FW_PLD_START_PTR_RST    0x0

static inline u32 mac_hw_dma_fw_pld_start_ptr_dma_fw_pld_start_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_FW_PLD_START_PTR_ADDR);

	return (u32)(local_val >> 5);
}

static inline void mac_hw_dma_fw_pld_start_ptr_dma_fw_pld_start_ptr_setf(struct cl_chip *chip, u32 dmafwpldstartptr)
{
	ASSERT_ERR_CHIP((((u32)dmafwpldstartptr << 5) & ~((u32)0xFFFFFFE0)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_FW_PLD_START_PTR_ADDR, (u32)dmafwpldstartptr << 5);
}

/**
 * @brief DMA_FW_PLD_START_PTR_2 register definition
 *  DMA Payload FW start pointer2 and HW write pointer register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:05 DMA_FW_PLD_START_PTR2     0x0
 * </pre>
 */
#define MAC_HW_DMA_FW_PLD_START_PTR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081D4)
#define MAC_HW_DMA_FW_PLD_START_PTR_2_OFFSET      0x000081D4
#define MAC_HW_DMA_FW_PLD_START_PTR_2_INDEX       0x00002075
#define MAC_HW_DMA_FW_PLD_START_PTR_2_RESET       0x00000000

static inline u32 mac_hw_dma_fw_pld_start_ptr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_FW_PLD_START_PTR_2_ADDR);
}

static inline void mac_hw_dma_fw_pld_start_ptr_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_DMA_FW_PLD_START_PTR_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_DMA_FW_PLD_START_PTR_2_DMA_FW_PLD_START_PTR_2_MASK    ((u32)0xFFFFFFE0)
#define MAC_HW_DMA_FW_PLD_START_PTR_2_DMA_FW_PLD_START_PTR_2_LSB    5
#define MAC_HW_DMA_FW_PLD_START_PTR_2_DMA_FW_PLD_START_PTR_2_WIDTH    ((u32)0x0000001B)

#define MAC_HW_DMA_FW_PLD_START_PTR_2_DMA_FW_PLD_START_PTR_2_RST    0x0

static inline u32 mac_hw_dma_fw_pld_start_ptr_2_dma_fw_pld_start_ptr_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_FW_PLD_START_PTR_2_ADDR);

	return (u32)(local_val >> 5);
}

static inline void mac_hw_dma_fw_pld_start_ptr_2_dma_fw_pld_start_ptr_2_setf(struct cl_chip *chip, u32 dmafwpldstartptr2)
{
	ASSERT_ERR_CHIP((((u32)dmafwpldstartptr2 << 5) & ~((u32)0xFFFFFFE0)) == 0);
	cl_reg_write(chip, MAC_HW_DMA_FW_PLD_START_PTR_2_ADDR, (u32)dmafwpldstartptr2 << 5);
}

/**
 * @brief CYCLIC_BUFFER_READ_PTR register definition
 *  Cyclic Buffer FW read pointer for LL1 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 FW_CYCLIC_BUFFER_READ_PTR 0x0
 * </pre>
 */
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081D8)
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_OFFSET      0x000081D8
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_INDEX       0x00002076
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_RESET       0x00000000

static inline u32 mac_hw_cyclic_buffer_read_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_ADDR);
}

static inline void mac_hw_cyclic_buffer_read_ptr_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_FW_CYCLIC_BUFFER_READ_PTR_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_FW_CYCLIC_BUFFER_READ_PTR_LSB    0
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_FW_CYCLIC_BUFFER_READ_PTR_WIDTH    ((u32)0x00000020)

#define MAC_HW_CYCLIC_BUFFER_READ_PTR_FW_CYCLIC_BUFFER_READ_PTR_RST    0x0

static inline u32 mac_hw_cyclic_buffer_read_ptr_fw_cyclic_buffer_read_ptr_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_cyclic_buffer_read_ptr_fw_cyclic_buffer_read_ptr_setf(struct cl_chip *chip, u32 fwcyclicbufferreadptr)
{
	ASSERT_ERR_CHIP((((u32)fwcyclicbufferreadptr << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_ADDR, (u32)fwcyclicbufferreadptr << 0);
}

/**
 * @brief CYCLIC_BUFFER_READ_PTR_2 register definition
 *  Cyclic Buffer FW read pointer for LL2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 FW_CYCLIC_BUFFER_READ_PTR2 0x0
 * </pre>
 */
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x000081DC)
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_OFFSET      0x000081DC
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_INDEX       0x00002077
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_RESET       0x00000000

static inline u32 mac_hw_cyclic_buffer_read_ptr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_2_ADDR);
}

static inline void mac_hw_cyclic_buffer_read_ptr_2_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_2_ADDR, value);
}

/* Field definitions */
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_FW_CYCLIC_BUFFER_READ_PTR_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_FW_CYCLIC_BUFFER_READ_PTR_2_LSB    0
#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_FW_CYCLIC_BUFFER_READ_PTR_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_CYCLIC_BUFFER_READ_PTR_2_FW_CYCLIC_BUFFER_READ_PTR_2_RST    0x0

static inline u32 mac_hw_cyclic_buffer_read_ptr_2_fw_cyclic_buffer_read_ptr_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_2_ADDR);

	return (u32)(local_val >> 0);
}

static inline void mac_hw_cyclic_buffer_read_ptr_2_fw_cyclic_buffer_read_ptr_2_setf(struct cl_chip *chip, u32 fwcyclicbufferreadptr2)
{
	ASSERT_ERR_CHIP((((u32)fwcyclicbufferreadptr2 << 0) & ~((u32)0xFFFFFFFF)) == 0);
	cl_reg_write(chip, MAC_HW_CYCLIC_BUFFER_READ_PTR_2_ADDR, (u32)fwcyclicbufferreadptr2 << 0);
}

/**
 * @brief AMSDU_HISTOGRAM_1 register definition
 *  AMSDU histogram register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:16 AMSDU_3_COUNT             0x0
 *    11:00 AMSDU_2_COUNT             0x0
 * </pre>
 */
#define MAC_HW_AMSDU_HISTOGRAM_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008200)
#define MAC_HW_AMSDU_HISTOGRAM_1_OFFSET      0x00008200
#define MAC_HW_AMSDU_HISTOGRAM_1_INDEX       0x00002080
#define MAC_HW_AMSDU_HISTOGRAM_1_RESET       0x00000000

static inline u32 mac_hw_amsdu_histogram_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_1_ADDR);
}

/* Field definitions */
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_3_COUNT_MASK    ((u32)0x0FFF0000)
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_3_COUNT_LSB    16
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_3_COUNT_WIDTH    ((u32)0x0000000C)
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_2_COUNT_MASK    ((u32)0x00000FFF)
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_2_COUNT_LSB    0
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_2_COUNT_WIDTH    ((u32)0x0000000C)

#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_3_COUNT_RST    0x0
#define MAC_HW_AMSDU_HISTOGRAM_1_AMSDU_2_COUNT_RST    0x0

static inline void mac_hw_amsdu_histogram_1_unpack(struct cl_chip *chip, u16 *amsdu_3_count, u16 *amsdu_2_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_1_ADDR);

	*amsdu_3_count = (local_val & ((u32)0x0FFF0000)) >> 16;
	*amsdu_2_count = (local_val & ((u32)0x00000FFF)) >> 0;
}

static inline u16 mac_hw_amsdu_histogram_1_amsdu_3_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_1_ADDR);

	return (u16)((local_val & ((u32)0x0FFF0000)) >> 16);
}

static inline u16 mac_hw_amsdu_histogram_1_amsdu_2_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_1_ADDR);

	return (u16)((local_val & ((u32)0x00000FFF)) >> 0);
}

/**
 * @brief AMSDU_HISTOGRAM_2 register definition
 *  AMSDU histogram register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27:16 AMSDU_5_COUNT             0x0
 *    11:00 AMSDU_4_COUNT             0x0
 * </pre>
 */
#define MAC_HW_AMSDU_HISTOGRAM_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008204)
#define MAC_HW_AMSDU_HISTOGRAM_2_OFFSET      0x00008204
#define MAC_HW_AMSDU_HISTOGRAM_2_INDEX       0x00002081
#define MAC_HW_AMSDU_HISTOGRAM_2_RESET       0x00000000

static inline u32 mac_hw_amsdu_histogram_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_2_ADDR);
}

/* Field definitions */
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_5_COUNT_MASK    ((u32)0x0FFF0000)
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_5_COUNT_LSB    16
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_5_COUNT_WIDTH    ((u32)0x0000000C)
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_4_COUNT_MASK    ((u32)0x00000FFF)
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_4_COUNT_LSB    0
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_4_COUNT_WIDTH    ((u32)0x0000000C)

#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_5_COUNT_RST    0x0
#define MAC_HW_AMSDU_HISTOGRAM_2_AMSDU_4_COUNT_RST    0x0

static inline void mac_hw_amsdu_histogram_2_unpack(struct cl_chip *chip, u16 *amsdu_5_count, u16 *amsdu_4_count)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_2_ADDR);

	*amsdu_5_count = (local_val & ((u32)0x0FFF0000)) >> 16;
	*amsdu_4_count = (local_val & ((u32)0x00000FFF)) >> 0;
}

static inline u16 mac_hw_amsdu_histogram_2_amsdu_5_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_2_ADDR);

	return (u16)((local_val & ((u32)0x0FFF0000)) >> 16);
}

static inline u16 mac_hw_amsdu_histogram_2_amsdu_4_count_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_AMSDU_HISTOGRAM_2_ADDR);

	return (u16)((local_val & ((u32)0x00000FFF)) >> 0);
}

/**
 * @brief EDCA_AC_HAS_DATA_SET register definition
 *  Indicates whether an AC queue in SW has data register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    03    AC_3_HAS_DATA             0
 *    02    AC_2_HAS_DATA             0
 *    01    AC_1_HAS_DATA             0
 *    00    AC_0_HAS_DATA             0
 * </pre>
 */
#define MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008210)
#define MAC_HW_EDCA_AC_HAS_DATA_SET_OFFSET      0x00008210
#define MAC_HW_EDCA_AC_HAS_DATA_SET_INDEX       0x00002084
#define MAC_HW_EDCA_AC_HAS_DATA_SET_RESET       0x00000000

static inline void mac_hw_edca_ac_has_data_set_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_3_HAS_DATA_BIT    ((u32)0x00000008)
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_3_HAS_DATA_POS    3
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_2_HAS_DATA_BIT    ((u32)0x00000004)
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_2_HAS_DATA_POS    2
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_1_HAS_DATA_BIT    ((u32)0x00000002)
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_1_HAS_DATA_POS    1
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_0_HAS_DATA_BIT    ((u32)0x00000001)
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_0_HAS_DATA_POS    0

#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_3_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_2_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_1_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_SET_AC_0_HAS_DATA_RST    0x0

static inline void mac_hw_edca_ac_has_data_set_pack(struct cl_chip *chip, u8 ac_3_has_data, u8 ac_2_has_data, u8 ac_1_has_data, u8 ac_0_has_data)
{
	ASSERT_ERR_CHIP((((u32)ac_3_has_data << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_has_data << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_has_data << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_has_data << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, ((u32)ac_3_has_data << 3) | ((u32)ac_2_has_data << 2) | ((u32)ac_1_has_data << 1) | ((u32)ac_0_has_data << 0));
}

static inline void mac_hw_edca_ac_has_data_set_ac_3_has_data_setf(struct cl_chip *chip, u8 ac3hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac3hasdata << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR) & ~((u32)0x00000008)) | ((u32)ac3hasdata << 3));
}

static inline void mac_hw_edca_ac_has_data_set_ac_2_has_data_setf(struct cl_chip *chip, u8 ac2hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac2hasdata << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR) & ~((u32)0x00000004)) | ((u32)ac2hasdata << 2));
}

static inline void mac_hw_edca_ac_has_data_set_ac_1_has_data_setf(struct cl_chip *chip, u8 ac1hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac1hasdata << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR) & ~((u32)0x00000002)) | ((u32)ac1hasdata << 1));
}

static inline void mac_hw_edca_ac_has_data_set_ac_0_has_data_setf(struct cl_chip *chip, u8 ac0hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac0hasdata << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_SET_ADDR) & ~((u32)0x00000001)) | ((u32)ac0hasdata << 0));
}

/**
 * @brief EDCA_AC_HAS_DATA_CLEAR register definition
 *  Indicates whether an AC queue in SW has data register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    03    AC_3_HAS_DATA             0
 *    02    AC_2_HAS_DATA             0
 *    01    AC_1_HAS_DATA             0
 *    00    AC_0_HAS_DATA             0
 * </pre>
 */
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008214)
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_OFFSET      0x00008214
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_INDEX       0x00002085
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_RESET       0x00000000

static inline void mac_hw_edca_ac_has_data_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_3_HAS_DATA_BIT    ((u32)0x00000008)
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_3_HAS_DATA_POS    3
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_2_HAS_DATA_BIT    ((u32)0x00000004)
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_2_HAS_DATA_POS    2
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_1_HAS_DATA_BIT    ((u32)0x00000002)
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_1_HAS_DATA_POS    1
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_0_HAS_DATA_BIT    ((u32)0x00000001)
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_0_HAS_DATA_POS    0

#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_3_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_2_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_1_HAS_DATA_RST    0x0
#define MAC_HW_EDCA_AC_HAS_DATA_CLEAR_AC_0_HAS_DATA_RST    0x0

static inline void mac_hw_edca_ac_has_data_clear_pack(struct cl_chip *chip, u8 ac_3_has_data, u8 ac_2_has_data, u8 ac_1_has_data, u8 ac_0_has_data)
{
	ASSERT_ERR_CHIP((((u32)ac_3_has_data << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_has_data << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_has_data << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_has_data << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, ((u32)ac_3_has_data << 3) | ((u32)ac_2_has_data << 2) | ((u32)ac_1_has_data << 1) | ((u32)ac_0_has_data << 0));
}

static inline void mac_hw_edca_ac_has_data_clear_ac_3_has_data_setf(struct cl_chip *chip, u8 ac3hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac3hasdata << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR) & ~((u32)0x00000008)) | ((u32)ac3hasdata << 3));
}

static inline void mac_hw_edca_ac_has_data_clear_ac_2_has_data_setf(struct cl_chip *chip, u8 ac2hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac2hasdata << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR) & ~((u32)0x00000004)) | ((u32)ac2hasdata << 2));
}

static inline void mac_hw_edca_ac_has_data_clear_ac_1_has_data_setf(struct cl_chip *chip, u8 ac1hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac1hasdata << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR) & ~((u32)0x00000002)) | ((u32)ac1hasdata << 1));
}

static inline void mac_hw_edca_ac_has_data_clear_ac_0_has_data_setf(struct cl_chip *chip, u8 ac0hasdata)
{
	ASSERT_ERR_CHIP((((u32)ac0hasdata << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_EDCA_AC_HAS_DATA_CLEAR_ADDR) & ~((u32)0x00000001)) | ((u32)ac0hasdata << 0));
}

/**
 * @brief MOT_1 register definition
 *  Provides the value of the TXOP for EDCA, HCCA and RD. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 AC_1_MOT                  0x0
 *    15:00 AC_0_MOT                  0x0
 * </pre>
 */
#define MAC_HW_MOT_1_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008228)
#define MAC_HW_MOT_1_OFFSET      0x00008228
#define MAC_HW_MOT_1_INDEX       0x0000208A
#define MAC_HW_MOT_1_RESET       0x00000000

static inline u32 mac_hw_mot_1_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MOT_1_ADDR);
}

/* Field definitions */
#define MAC_HW_MOT_1_AC_1_MOT_MASK          ((u32)0xFFFF0000)
#define MAC_HW_MOT_1_AC_1_MOT_LSB           16
#define MAC_HW_MOT_1_AC_1_MOT_WIDTH         ((u32)0x00000010)
#define MAC_HW_MOT_1_AC_0_MOT_MASK          ((u32)0x0000FFFF)
#define MAC_HW_MOT_1_AC_0_MOT_LSB           0
#define MAC_HW_MOT_1_AC_0_MOT_WIDTH         ((u32)0x00000010)

#define MAC_HW_MOT_1_AC_1_MOT_RST           0x0
#define MAC_HW_MOT_1_AC_0_MOT_RST           0x0

static inline void mac_hw_mot_1_unpack(struct cl_chip *chip, u16 *ac_1_mot, u16 *ac_0_mot)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_1_ADDR);

	*ac_1_mot = (local_val & ((u32)0xFFFF0000)) >> 16;
	*ac_0_mot = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_mot_1_ac_1_mot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_1_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_mot_1_ac_0_mot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_1_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief MOT_2 register definition
 *  Provides the value of the TXOP for EDCA, HCCA and RD. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 AC_3_MOT                  0x2F
 *    15:00 AC_2_MOT                  0x5E
 * </pre>
 */
#define MAC_HW_MOT_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000822C)
#define MAC_HW_MOT_2_OFFSET      0x0000822C
#define MAC_HW_MOT_2_INDEX       0x0000208B
#define MAC_HW_MOT_2_RESET       0x002F005E

static inline u32 mac_hw_mot_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MOT_2_ADDR);
}

/* Field definitions */
#define MAC_HW_MOT_2_AC_3_MOT_MASK          ((u32)0xFFFF0000)
#define MAC_HW_MOT_2_AC_3_MOT_LSB           16
#define MAC_HW_MOT_2_AC_3_MOT_WIDTH         ((u32)0x00000010)
#define MAC_HW_MOT_2_AC_2_MOT_MASK          ((u32)0x0000FFFF)
#define MAC_HW_MOT_2_AC_2_MOT_LSB           0
#define MAC_HW_MOT_2_AC_2_MOT_WIDTH         ((u32)0x00000010)

#define MAC_HW_MOT_2_AC_3_MOT_RST           0x2F
#define MAC_HW_MOT_2_AC_2_MOT_RST           0x5E

static inline void mac_hw_mot_2_unpack(struct cl_chip *chip, u16 *ac_3_mot, u16 *ac_2_mot)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_2_ADDR);

	*ac_3_mot = (local_val & ((u32)0xFFFF0000)) >> 16;
	*ac_2_mot = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_mot_2_ac_3_mot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_2_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_mot_2_ac_2_mot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_2_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief MOT_3 register definition
 *  Provides the value of the TXOP for EDCA, HCCA and RD. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:16 MISC_MOT                  0x0
 *    15:00 HCCA_QAPMOT               0x0
 * </pre>
 */
#define MAC_HW_MOT_3_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008230)
#define MAC_HW_MOT_3_OFFSET      0x00008230
#define MAC_HW_MOT_3_INDEX       0x0000208C
#define MAC_HW_MOT_3_RESET       0x00000000

static inline u32 mac_hw_mot_3_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MOT_3_ADDR);
}

/* Field definitions */
#define MAC_HW_MOT_3_MISC_MOT_MASK          ((u32)0xFFFF0000)
#define MAC_HW_MOT_3_MISC_MOT_LSB           16
#define MAC_HW_MOT_3_MISC_MOT_WIDTH         ((u32)0x00000010)
#define MAC_HW_MOT_3_HCCA_QAPMOT_MASK       ((u32)0x0000FFFF)
#define MAC_HW_MOT_3_HCCA_QAPMOT_LSB        0
#define MAC_HW_MOT_3_HCCA_QAPMOT_WIDTH      ((u32)0x00000010)

#define MAC_HW_MOT_3_MISC_MOT_RST           0x0
#define MAC_HW_MOT_3_HCCA_QAPMOT_RST        0x0

static inline void mac_hw_mot_3_unpack(struct cl_chip *chip, u16 *misc_mot, u16 *hcca_qapmot)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_3_ADDR);

	*misc_mot = (local_val & ((u32)0xFFFF0000)) >> 16;
	*hcca_qapmot = (local_val & ((u32)0x0000FFFF)) >> 0;
}

static inline u16 mac_hw_mot_3_misc_mot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_3_ADDR);

	return (u16)((local_val & ((u32)0xFFFF0000)) >> 16);
}

static inline u16 mac_hw_mot_3_hcca_qapmot_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MOT_3_ADDR);

	return (u16)((local_val & ((u32)0x0000FFFF)) >> 0);
}

/**
 * @brief TIMER_INT_EVENT_RAW_STATUS register definition
 *  Indicates TIMER interrupt events raw status register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008240)
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_OFFSET      0x00008240
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_INDEX       0x00002090
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_raw_status_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_RAW_STATUS_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_raw_status_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_raw_status_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_timer_int_event_raw_status_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_timer_int_event_raw_status_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_RAW_STATUS_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

/**
 * @brief TIMER_INT_EVENT_EN_SMAC register definition
 *  TIMER interrupt events enable SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008244)
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_OFFSET      0x00008244
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_INDEX       0x00002091
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_en_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR);
}

static inline void mac_hw_timer_int_event_en_smac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_SMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_en_smac_pack(struct cl_chip *chip, u8 timer_rx_trigger2, u8 timer_rx_trigger, u8 timer_tx_trigger)
{
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger2 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_tx_trigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR, ((u32)timer_rx_trigger2 << 21) | ((u32)timer_rx_trigger << 17) | ((u32)timer_tx_trigger << 14));
}

static inline void mac_hw_timer_int_event_en_smac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_en_smac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_timer_int_event_en_smac_timer_rx_trigger_2_setf(struct cl_chip *chip, u8 timerrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger2 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00200000)) | ((u32)timerrxtrigger2 << 21));
}

static inline u8 mac_hw_timer_int_event_en_smac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_timer_int_event_en_smac_timer_rx_trigger_setf(struct cl_chip *chip, u8 timerrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00020000)) | ((u32)timerrxtrigger << 17));
}

static inline u8 mac_hw_timer_int_event_en_smac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_timer_int_event_en_smac_timer_tx_trigger_setf(struct cl_chip *chip, u8 timertxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timertxtrigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_SMAC_ADDR) & ~((u32)0x00004000)) | ((u32)timertxtrigger << 14));
}

/**
 * @brief TIMER_INT_EVENT_STATUS_UMAC register definition
 *  TIMER interrupt events status UMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008248)
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_OFFSET      0x00008248
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_INDEX       0x00002092
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_status_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_status_umac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_status_umac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_timer_int_event_status_umac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_timer_int_event_status_umac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

/**
 * @brief TIMER_INT_EVENT_STATUS_SMAC register definition
 *  TIMER interrupt events status SMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000824C)
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_OFFSET      0x0000824C
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_INDEX       0x00002093
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_status_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_status_smac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_status_smac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_timer_int_event_status_smac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_timer_int_event_status_smac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_SMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

/**
 * @brief TIMER_INT_EVENT_FORCE register definition
 *  TIMER interrupt events force register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_FORCE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008250)
#define MAC_HW_TIMER_INT_EVENT_FORCE_OFFSET      0x00008250
#define MAC_HW_TIMER_INT_EVENT_FORCE_INDEX       0x00002094
#define MAC_HW_TIMER_INT_EVENT_FORCE_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_force_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR);
}

static inline void mac_hw_timer_int_event_force_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_FORCE_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_force_pack(struct cl_chip *chip, u8 timer_rx_trigger2, u8 timer_rx_trigger, u8 timer_tx_trigger)
{
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger2 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_tx_trigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR, ((u32)timer_rx_trigger2 << 21) | ((u32)timer_rx_trigger << 17) | ((u32)timer_tx_trigger << 14));
}

static inline void mac_hw_timer_int_event_force_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_force_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_timer_int_event_force_timer_rx_trigger_2_setf(struct cl_chip *chip, u8 timerrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger2 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR) & ~((u32)0x00200000)) | ((u32)timerrxtrigger2 << 21));
}

static inline u8 mac_hw_timer_int_event_force_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_timer_int_event_force_timer_rx_trigger_setf(struct cl_chip *chip, u8 timerrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR) & ~((u32)0x00020000)) | ((u32)timerrxtrigger << 17));
}

static inline u8 mac_hw_timer_int_event_force_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_timer_int_event_force_timer_tx_trigger_setf(struct cl_chip *chip, u8 timertxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timertxtrigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_FORCE_ADDR) & ~((u32)0x00004000)) | ((u32)timertxtrigger << 14));
}

/**
 * @brief TIMER_INT_MAC_SOURCE_UMAC register definition
 *  Indicates UMAC TIMER interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008254)
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_OFFSET      0x00008254
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_INDEX       0x00002095
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_mac_source_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_timer_int_mac_source_umac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_UMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief TIMER_INT_MAC_SOURCE_SMAC register definition
 *  Indicates SMAC TIMER interrupt MAC source register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 INT_SOURCE_BIT_MAP        0x0
 * </pre>
 */
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008258)
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_OFFSET      0x00008258
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_INDEX       0x00002096
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_mac_source_smac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_LSB    0
#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_WIDTH    ((u32)0x00000020)

#define MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_INT_SOURCE_BIT_MAP_RST    0x0

static inline u32 mac_hw_timer_int_mac_source_smac_int_source_bit_map_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_MAC_SOURCE_SMAC_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_HTP_S_PTR register definition
 *  Current value of the HTP status pointer for deb register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 HTP_STATUS_POINTER        0x0
 * </pre>
 */
#define MAC_HW_DEBUG_HTP_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008520)
#define MAC_HW_DEBUG_HTP_S_PTR_OFFSET      0x00008520
#define MAC_HW_DEBUG_HTP_S_PTR_INDEX       0x00002148
#define MAC_HW_DEBUG_HTP_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_htp_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_HTP_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_HTP_S_PTR_HTP_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_HTP_S_PTR_HTP_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_HTP_S_PTR_HTP_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_HTP_S_PTR_HTP_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_htp_s_ptr_htp_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_HTP_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_BCN_S_PTR register definition
 *  Current value of the Beacon status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 BCN_STATUS_POINTER        0x0
 * </pre>
 */
#define MAC_HW_DEBUG_BCN_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008524)
#define MAC_HW_DEBUG_BCN_S_PTR_OFFSET      0x00008524
#define MAC_HW_DEBUG_BCN_S_PTR_INDEX       0x00002149
#define MAC_HW_DEBUG_BCN_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_bcn_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_BCN_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_BCN_S_PTR_BCN_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_BCN_S_PTR_BCN_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_BCN_S_PTR_BCN_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_BCN_S_PTR_BCN_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_bcn_s_ptr_bcn_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_BCN_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_AC_0_S_PTR register definition
 *  Current value of the AC_BK status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 AC_0_STATUS_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_AC_0_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008528)
#define MAC_HW_DEBUG_AC_0_S_PTR_OFFSET      0x00008528
#define MAC_HW_DEBUG_AC_0_S_PTR_INDEX       0x0000214A
#define MAC_HW_DEBUG_AC_0_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_ac_0_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_AC_0_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_AC_0_S_PTR_AC_0_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_AC_0_S_PTR_AC_0_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_AC_0_S_PTR_AC_0_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_AC_0_S_PTR_AC_0_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_ac_0_s_ptr_ac_0_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_AC_0_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_AC_1_S_PTR register definition
 *  Current value of the AC_BE status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 AC_1_STATUS_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_AC_1_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000852C)
#define MAC_HW_DEBUG_AC_1_S_PTR_OFFSET      0x0000852C
#define MAC_HW_DEBUG_AC_1_S_PTR_INDEX       0x0000214B
#define MAC_HW_DEBUG_AC_1_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_ac_1_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_AC_1_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_AC_1_S_PTR_AC_1_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_AC_1_S_PTR_AC_1_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_AC_1_S_PTR_AC_1_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_AC_1_S_PTR_AC_1_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_ac_1_s_ptr_ac_1_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_AC_1_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_AC_2_S_PTR register definition
 *  Current value of the AC_VI status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 AC_2_STATUS_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_AC_2_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008530)
#define MAC_HW_DEBUG_AC_2_S_PTR_OFFSET      0x00008530
#define MAC_HW_DEBUG_AC_2_S_PTR_INDEX       0x0000214C
#define MAC_HW_DEBUG_AC_2_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_ac_2_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_AC_2_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_AC_2_S_PTR_AC_2_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_AC_2_S_PTR_AC_2_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_AC_2_S_PTR_AC_2_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_AC_2_S_PTR_AC_2_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_ac_2_s_ptr_ac_2_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_AC_2_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_AC_3_S_PTR register definition
 *  Current value of the AC_VO status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 AC_3_STATUS_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_AC_3_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008534)
#define MAC_HW_DEBUG_AC_3_S_PTR_OFFSET      0x00008534
#define MAC_HW_DEBUG_AC_3_S_PTR_INDEX       0x0000214D
#define MAC_HW_DEBUG_AC_3_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_ac_3_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_AC_3_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_AC_3_S_PTR_AC_3_STATUS_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_AC_3_S_PTR_AC_3_STATUS_POINTER_LSB    0
#define MAC_HW_DEBUG_AC_3_S_PTR_AC_3_STATUS_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_AC_3_S_PTR_AC_3_STATUS_POINTER_RST    0x0

static inline u32 mac_hw_debug_ac_3_s_ptr_ac_3_status_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_AC_3_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_TX_C_PTR register definition
 *  Current value of the Transmit DMA current pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 TX_CURRENT_POINTER        0x0
 * </pre>
 */
#define MAC_HW_DEBUG_TX_C_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008540)
#define MAC_HW_DEBUG_TX_C_PTR_OFFSET      0x00008540
#define MAC_HW_DEBUG_TX_C_PTR_INDEX       0x00002150
#define MAC_HW_DEBUG_TX_C_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_tx_c_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_TX_C_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_TX_C_PTR_TX_CURRENT_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_TX_C_PTR_TX_CURRENT_POINTER_LSB    0
#define MAC_HW_DEBUG_TX_C_PTR_TX_CURRENT_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_TX_C_PTR_TX_CURRENT_POINTER_RST    0x0

static inline u32 mac_hw_debug_tx_c_ptr_tx_current_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_TX_C_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_RX_PAY_S_PTR register definition
 *  Current value of the Receive Payload DMA status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_PAY_STAT_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_PAY_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008544)
#define MAC_HW_DEBUG_RX_PAY_S_PTR_OFFSET      0x00008544
#define MAC_HW_DEBUG_RX_PAY_S_PTR_INDEX       0x00002151
#define MAC_HW_DEBUG_RX_PAY_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_rx_pay_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_PAY_S_PTR_RX_PAY_STAT_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_PAY_S_PTR_RX_PAY_STAT_POINTER_LSB    0
#define MAC_HW_DEBUG_RX_PAY_S_PTR_RX_PAY_STAT_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_PAY_S_PTR_RX_PAY_STAT_POINTER_RST    0x0

static inline u32 mac_hw_debug_rx_pay_s_ptr_rx_pay_stat_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_RX_HDR_S_PTR register definition
 *  Current value of the Receive Header DMA status pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_HDR_STAT_POINTER       0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_HDR_S_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008548)
#define MAC_HW_DEBUG_RX_HDR_S_PTR_OFFSET      0x00008548
#define MAC_HW_DEBUG_RX_HDR_S_PTR_INDEX       0x00002152
#define MAC_HW_DEBUG_RX_HDR_S_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_rx_hdr_s_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_HDR_S_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_HDR_S_PTR_RX_HDR_STAT_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_HDR_S_PTR_RX_HDR_STAT_POINTER_LSB    0
#define MAC_HW_DEBUG_RX_HDR_S_PTR_RX_HDR_STAT_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_HDR_S_PTR_RX_HDR_STAT_POINTER_RST    0x0

static inline u32 mac_hw_debug_rx_hdr_s_ptr_rx_hdr_stat_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_HDR_S_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_RX_PAY_C_PTR register definition
 *  Current value of the Receive Payload DMA current pointer for debug. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 RX_PAY_CURRENT_POINTER    0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_PAY_C_PTR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000854C)
#define MAC_HW_DEBUG_RX_PAY_C_PTR_OFFSET      0x0000854C
#define MAC_HW_DEBUG_RX_PAY_C_PTR_INDEX       0x00002153
#define MAC_HW_DEBUG_RX_PAY_C_PTR_RESET       0x00000000

static inline u32 mac_hw_debug_rx_pay_c_ptr_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_C_PTR_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_PAY_C_PTR_RX_PAY_CURRENT_POINTER_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_PAY_C_PTR_RX_PAY_CURRENT_POINTER_LSB    0
#define MAC_HW_DEBUG_RX_PAY_C_PTR_RX_PAY_CURRENT_POINTER_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_PAY_C_PTR_RX_PAY_CURRENT_POINTER_RST    0x0

static inline u32 mac_hw_debug_rx_pay_c_ptr_rx_pay_current_pointer_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_C_PTR_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief SW_PROFILING register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    SW_PROF_31                0
 *    30    SW_PROF_30                0
 *    29    SW_PROF_29                0
 *    28    SW_PROF_28                0
 *    27    SW_PROF_27                0
 *    26    SW_PROF_26                0
 *    25    SW_PROF_25                0
 *    24    SW_PROF_24                0
 *    23    SW_PROF_23                0
 *    22    SW_PROF_22                0
 *    21    SW_PROF_21                0
 *    20    SW_PROF_20                0
 *    19    SW_PROF_19                0
 *    18    SW_PROF_18                0
 *    17    SW_PROF_17                0
 *    16    SW_PROF_16                0
 *    15    SW_PROF_15                0
 *    14    SW_PROF_14                0
 *    13    SW_PROF_13                0
 *    12    SW_PROF_12                0
 *    11    SW_PROF_11                0
 *    10    SW_PROF_10                0
 *    09    SW_PROF_9                 0
 *    08    SW_PROF_8                 0
 *    07    SW_PROF_7                 0
 *    06    SW_PROF_6                 0
 *    05    SW_PROF_5                 0
 *    04    SW_PROF_4                 0
 *    03    SW_PROF_3                 0
 *    02    SW_PROF_2                 0
 *    01    SW_PROF_1                 0
 *    00    SW_PROF_0                 0
 * </pre>
 */
#define MAC_HW_SW_PROFILING_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008560)
#define MAC_HW_SW_PROFILING_OFFSET      0x00008560
#define MAC_HW_SW_PROFILING_INDEX       0x00002158
#define MAC_HW_SW_PROFILING_RESET       0x00000000

static inline u32 mac_hw_sw_profiling_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);
}

static inline void mac_hw_sw_profiling_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SW_PROFILING_SW_PROF_31_BIT    ((u32)0x80000000)
#define MAC_HW_SW_PROFILING_SW_PROF_31_POS    31
#define MAC_HW_SW_PROFILING_SW_PROF_30_BIT    ((u32)0x40000000)
#define MAC_HW_SW_PROFILING_SW_PROF_30_POS    30
#define MAC_HW_SW_PROFILING_SW_PROF_29_BIT    ((u32)0x20000000)
#define MAC_HW_SW_PROFILING_SW_PROF_29_POS    29
#define MAC_HW_SW_PROFILING_SW_PROF_28_BIT    ((u32)0x10000000)
#define MAC_HW_SW_PROFILING_SW_PROF_28_POS    28
#define MAC_HW_SW_PROFILING_SW_PROF_27_BIT    ((u32)0x08000000)
#define MAC_HW_SW_PROFILING_SW_PROF_27_POS    27
#define MAC_HW_SW_PROFILING_SW_PROF_26_BIT    ((u32)0x04000000)
#define MAC_HW_SW_PROFILING_SW_PROF_26_POS    26
#define MAC_HW_SW_PROFILING_SW_PROF_25_BIT    ((u32)0x02000000)
#define MAC_HW_SW_PROFILING_SW_PROF_25_POS    25
#define MAC_HW_SW_PROFILING_SW_PROF_24_BIT    ((u32)0x01000000)
#define MAC_HW_SW_PROFILING_SW_PROF_24_POS    24
#define MAC_HW_SW_PROFILING_SW_PROF_23_BIT    ((u32)0x00800000)
#define MAC_HW_SW_PROFILING_SW_PROF_23_POS    23
#define MAC_HW_SW_PROFILING_SW_PROF_22_BIT    ((u32)0x00400000)
#define MAC_HW_SW_PROFILING_SW_PROF_22_POS    22
#define MAC_HW_SW_PROFILING_SW_PROF_21_BIT    ((u32)0x00200000)
#define MAC_HW_SW_PROFILING_SW_PROF_21_POS    21
#define MAC_HW_SW_PROFILING_SW_PROF_20_BIT    ((u32)0x00100000)
#define MAC_HW_SW_PROFILING_SW_PROF_20_POS    20
#define MAC_HW_SW_PROFILING_SW_PROF_19_BIT    ((u32)0x00080000)
#define MAC_HW_SW_PROFILING_SW_PROF_19_POS    19
#define MAC_HW_SW_PROFILING_SW_PROF_18_BIT    ((u32)0x00040000)
#define MAC_HW_SW_PROFILING_SW_PROF_18_POS    18
#define MAC_HW_SW_PROFILING_SW_PROF_17_BIT    ((u32)0x00020000)
#define MAC_HW_SW_PROFILING_SW_PROF_17_POS    17
#define MAC_HW_SW_PROFILING_SW_PROF_16_BIT    ((u32)0x00010000)
#define MAC_HW_SW_PROFILING_SW_PROF_16_POS    16
#define MAC_HW_SW_PROFILING_SW_PROF_15_BIT    ((u32)0x00008000)
#define MAC_HW_SW_PROFILING_SW_PROF_15_POS    15
#define MAC_HW_SW_PROFILING_SW_PROF_14_BIT    ((u32)0x00004000)
#define MAC_HW_SW_PROFILING_SW_PROF_14_POS    14
#define MAC_HW_SW_PROFILING_SW_PROF_13_BIT    ((u32)0x00002000)
#define MAC_HW_SW_PROFILING_SW_PROF_13_POS    13
#define MAC_HW_SW_PROFILING_SW_PROF_12_BIT    ((u32)0x00001000)
#define MAC_HW_SW_PROFILING_SW_PROF_12_POS    12
#define MAC_HW_SW_PROFILING_SW_PROF_11_BIT    ((u32)0x00000800)
#define MAC_HW_SW_PROFILING_SW_PROF_11_POS    11
#define MAC_HW_SW_PROFILING_SW_PROF_10_BIT    ((u32)0x00000400)
#define MAC_HW_SW_PROFILING_SW_PROF_10_POS    10
#define MAC_HW_SW_PROFILING_SW_PROF_9_BIT    ((u32)0x00000200)
#define MAC_HW_SW_PROFILING_SW_PROF_9_POS    9
#define MAC_HW_SW_PROFILING_SW_PROF_8_BIT    ((u32)0x00000100)
#define MAC_HW_SW_PROFILING_SW_PROF_8_POS    8
#define MAC_HW_SW_PROFILING_SW_PROF_7_BIT    ((u32)0x00000080)
#define MAC_HW_SW_PROFILING_SW_PROF_7_POS    7
#define MAC_HW_SW_PROFILING_SW_PROF_6_BIT    ((u32)0x00000040)
#define MAC_HW_SW_PROFILING_SW_PROF_6_POS    6
#define MAC_HW_SW_PROFILING_SW_PROF_5_BIT    ((u32)0x00000020)
#define MAC_HW_SW_PROFILING_SW_PROF_5_POS    5
#define MAC_HW_SW_PROFILING_SW_PROF_4_BIT    ((u32)0x00000010)
#define MAC_HW_SW_PROFILING_SW_PROF_4_POS    4
#define MAC_HW_SW_PROFILING_SW_PROF_3_BIT    ((u32)0x00000008)
#define MAC_HW_SW_PROFILING_SW_PROF_3_POS    3
#define MAC_HW_SW_PROFILING_SW_PROF_2_BIT    ((u32)0x00000004)
#define MAC_HW_SW_PROFILING_SW_PROF_2_POS    2
#define MAC_HW_SW_PROFILING_SW_PROF_1_BIT    ((u32)0x00000002)
#define MAC_HW_SW_PROFILING_SW_PROF_1_POS    1
#define MAC_HW_SW_PROFILING_SW_PROF_0_BIT    ((u32)0x00000001)
#define MAC_HW_SW_PROFILING_SW_PROF_0_POS    0

#define MAC_HW_SW_PROFILING_SW_PROF_31_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_30_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_29_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_28_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_27_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_26_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_25_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_24_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_23_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_22_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_21_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_20_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_19_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_18_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_17_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_16_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_15_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_14_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_13_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_12_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_11_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_10_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_9_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_8_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_7_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_6_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_5_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_4_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_3_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_2_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_1_RST    0x0
#define MAC_HW_SW_PROFILING_SW_PROF_0_RST    0x0

static inline void mac_hw_sw_profiling_pack(struct cl_chip *chip, u8 sw_prof_31, u8 sw_prof_30, u8 sw_prof_29, u8 sw_prof_28, u8 sw_prof_27, u8 sw_prof_26, u8 sw_prof_25, u8 sw_prof_24, u8 sw_prof_23, u8 sw_prof_22, u8 sw_prof_21, u8 sw_prof_20, u8 sw_prof_19, u8 sw_prof_18, u8 sw_prof_17, u8 sw_prof_16, u8 sw_prof_15, u8 sw_prof_14, u8 sw_prof_13, u8 sw_prof_12, u8 sw_prof_11, u8 sw_prof_10, u8 sw_prof_9, u8 sw_prof_8, u8 sw_prof_7, u8 sw_prof_6, u8 sw_prof_5, u8 sw_prof_4, u8 sw_prof_3, u8 sw_prof_2, u8 sw_prof_1, u8 sw_prof_0)
{
	ASSERT_ERR_CHIP((((u32)sw_prof_31 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_30 << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_29 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_28 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_27 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_26 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_25 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_24 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_23 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_22 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_21 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_20 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_19 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_18 << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_17 << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_16 << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_15 << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_14 << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_13 << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_12 << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_11 << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_10 << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_9 << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_8 << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_7 << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_6 << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_prof_0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, ((u32)sw_prof_31 << 31) | ((u32)sw_prof_30 << 30) | ((u32)sw_prof_29 << 29) | ((u32)sw_prof_28 << 28) | ((u32)sw_prof_27 << 27) | ((u32)sw_prof_26 << 26) | ((u32)sw_prof_25 << 25) | ((u32)sw_prof_24 << 24) | ((u32)sw_prof_23 << 23) | ((u32)sw_prof_22 << 22) | ((u32)sw_prof_21 << 21) | ((u32)sw_prof_20 << 20) | ((u32)sw_prof_19 << 19) | ((u32)sw_prof_18 << 18) | ((u32)sw_prof_17 << 17) | ((u32)sw_prof_16 << 16) | ((u32)sw_prof_15 << 15) | ((u32)sw_prof_14 << 14) | ((u32)sw_prof_13 << 13) | ((u32)sw_prof_12 << 12) | ((u32)sw_prof_11 << 11) | ((u32)sw_prof_10 << 10) | ((u32)sw_prof_9 << 9) | ((u32)sw_prof_8 << 8) | ((u32)sw_prof_7 << 7) | ((u32)sw_prof_6 << 6) | ((u32)sw_prof_5 << 5) | ((u32)sw_prof_4 << 4) | ((u32)sw_prof_3 << 3) | ((u32)sw_prof_2 << 2) | ((u32)sw_prof_1 << 1) | ((u32)sw_prof_0 << 0));
}

static inline void mac_hw_sw_profiling_unpack(struct cl_chip *chip, u8 *sw_prof_31, u8 *sw_prof_30, u8 *sw_prof_29, u8 *sw_prof_28, u8 *sw_prof_27, u8 *sw_prof_26, u8 *sw_prof_25, u8 *sw_prof_24, u8 *sw_prof_23, u8 *sw_prof_22, u8 *sw_prof_21, u8 *sw_prof_20, u8 *sw_prof_19, u8 *sw_prof_18, u8 *sw_prof_17, u8 *sw_prof_16, u8 *sw_prof_15, u8 *sw_prof_14, u8 *sw_prof_13, u8 *sw_prof_12, u8 *sw_prof_11, u8 *sw_prof_10, u8 *sw_prof_9, u8 *sw_prof_8, u8 *sw_prof_7, u8 *sw_prof_6, u8 *sw_prof_5, u8 *sw_prof_4, u8 *sw_prof_3, u8 *sw_prof_2, u8 *sw_prof_1, u8 *sw_prof_0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	*sw_prof_31 = (local_val & ((u32)0x80000000)) >> 31;
	*sw_prof_30 = (local_val & ((u32)0x40000000)) >> 30;
	*sw_prof_29 = (local_val & ((u32)0x20000000)) >> 29;
	*sw_prof_28 = (local_val & ((u32)0x10000000)) >> 28;
	*sw_prof_27 = (local_val & ((u32)0x08000000)) >> 27;
	*sw_prof_26 = (local_val & ((u32)0x04000000)) >> 26;
	*sw_prof_25 = (local_val & ((u32)0x02000000)) >> 25;
	*sw_prof_24 = (local_val & ((u32)0x01000000)) >> 24;
	*sw_prof_23 = (local_val & ((u32)0x00800000)) >> 23;
	*sw_prof_22 = (local_val & ((u32)0x00400000)) >> 22;
	*sw_prof_21 = (local_val & ((u32)0x00200000)) >> 21;
	*sw_prof_20 = (local_val & ((u32)0x00100000)) >> 20;
	*sw_prof_19 = (local_val & ((u32)0x00080000)) >> 19;
	*sw_prof_18 = (local_val & ((u32)0x00040000)) >> 18;
	*sw_prof_17 = (local_val & ((u32)0x00020000)) >> 17;
	*sw_prof_16 = (local_val & ((u32)0x00010000)) >> 16;
	*sw_prof_15 = (local_val & ((u32)0x00008000)) >> 15;
	*sw_prof_14 = (local_val & ((u32)0x00004000)) >> 14;
	*sw_prof_13 = (local_val & ((u32)0x00002000)) >> 13;
	*sw_prof_12 = (local_val & ((u32)0x00001000)) >> 12;
	*sw_prof_11 = (local_val & ((u32)0x00000800)) >> 11;
	*sw_prof_10 = (local_val & ((u32)0x00000400)) >> 10;
	*sw_prof_9 = (local_val & ((u32)0x00000200)) >> 9;
	*sw_prof_8 = (local_val & ((u32)0x00000100)) >> 8;
	*sw_prof_7 = (local_val & ((u32)0x00000080)) >> 7;
	*sw_prof_6 = (local_val & ((u32)0x00000040)) >> 6;
	*sw_prof_5 = (local_val & ((u32)0x00000020)) >> 5;
	*sw_prof_4 = (local_val & ((u32)0x00000010)) >> 4;
	*sw_prof_3 = (local_val & ((u32)0x00000008)) >> 3;
	*sw_prof_2 = (local_val & ((u32)0x00000004)) >> 2;
	*sw_prof_1 = (local_val & ((u32)0x00000002)) >> 1;
	*sw_prof_0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_sw_profiling_sw_prof_31_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_sw_profiling_sw_prof_31_setf(struct cl_chip *chip, u8 swprof31)
{
	ASSERT_ERR_CHIP((((u32)swprof31 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x80000000)) | ((u32)swprof31 << 31));
}

static inline u8 mac_hw_sw_profiling_sw_prof_30_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_sw_profiling_sw_prof_30_setf(struct cl_chip *chip, u8 swprof30)
{
	ASSERT_ERR_CHIP((((u32)swprof30 << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x40000000)) | ((u32)swprof30 << 30));
}

static inline u8 mac_hw_sw_profiling_sw_prof_29_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_sw_profiling_sw_prof_29_setf(struct cl_chip *chip, u8 swprof29)
{
	ASSERT_ERR_CHIP((((u32)swprof29 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x20000000)) | ((u32)swprof29 << 29));
}

static inline u8 mac_hw_sw_profiling_sw_prof_28_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_sw_profiling_sw_prof_28_setf(struct cl_chip *chip, u8 swprof28)
{
	ASSERT_ERR_CHIP((((u32)swprof28 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x10000000)) | ((u32)swprof28 << 28));
}

static inline u8 mac_hw_sw_profiling_sw_prof_27_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_sw_profiling_sw_prof_27_setf(struct cl_chip *chip, u8 swprof27)
{
	ASSERT_ERR_CHIP((((u32)swprof27 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x08000000)) | ((u32)swprof27 << 27));
}

static inline u8 mac_hw_sw_profiling_sw_prof_26_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_sw_profiling_sw_prof_26_setf(struct cl_chip *chip, u8 swprof26)
{
	ASSERT_ERR_CHIP((((u32)swprof26 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x04000000)) | ((u32)swprof26 << 26));
}

static inline u8 mac_hw_sw_profiling_sw_prof_25_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_sw_profiling_sw_prof_25_setf(struct cl_chip *chip, u8 swprof25)
{
	ASSERT_ERR_CHIP((((u32)swprof25 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x02000000)) | ((u32)swprof25 << 25));
}

static inline u8 mac_hw_sw_profiling_sw_prof_24_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_sw_profiling_sw_prof_24_setf(struct cl_chip *chip, u8 swprof24)
{
	ASSERT_ERR_CHIP((((u32)swprof24 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x01000000)) | ((u32)swprof24 << 24));
}

static inline u8 mac_hw_sw_profiling_sw_prof_23_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_sw_profiling_sw_prof_23_setf(struct cl_chip *chip, u8 swprof23)
{
	ASSERT_ERR_CHIP((((u32)swprof23 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00800000)) | ((u32)swprof23 << 23));
}

static inline u8 mac_hw_sw_profiling_sw_prof_22_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_sw_profiling_sw_prof_22_setf(struct cl_chip *chip, u8 swprof22)
{
	ASSERT_ERR_CHIP((((u32)swprof22 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00400000)) | ((u32)swprof22 << 22));
}

static inline u8 mac_hw_sw_profiling_sw_prof_21_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_sw_profiling_sw_prof_21_setf(struct cl_chip *chip, u8 swprof21)
{
	ASSERT_ERR_CHIP((((u32)swprof21 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00200000)) | ((u32)swprof21 << 21));
}

static inline u8 mac_hw_sw_profiling_sw_prof_20_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_sw_profiling_sw_prof_20_setf(struct cl_chip *chip, u8 swprof20)
{
	ASSERT_ERR_CHIP((((u32)swprof20 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00100000)) | ((u32)swprof20 << 20));
}

static inline u8 mac_hw_sw_profiling_sw_prof_19_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_sw_profiling_sw_prof_19_setf(struct cl_chip *chip, u8 swprof19)
{
	ASSERT_ERR_CHIP((((u32)swprof19 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00080000)) | ((u32)swprof19 << 19));
}

static inline u8 mac_hw_sw_profiling_sw_prof_18_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_sw_profiling_sw_prof_18_setf(struct cl_chip *chip, u8 swprof18)
{
	ASSERT_ERR_CHIP((((u32)swprof18 << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00040000)) | ((u32)swprof18 << 18));
}

static inline u8 mac_hw_sw_profiling_sw_prof_17_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_sw_profiling_sw_prof_17_setf(struct cl_chip *chip, u8 swprof17)
{
	ASSERT_ERR_CHIP((((u32)swprof17 << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00020000)) | ((u32)swprof17 << 17));
}

static inline u8 mac_hw_sw_profiling_sw_prof_16_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_sw_profiling_sw_prof_16_setf(struct cl_chip *chip, u8 swprof16)
{
	ASSERT_ERR_CHIP((((u32)swprof16 << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00010000)) | ((u32)swprof16 << 16));
}

static inline u8 mac_hw_sw_profiling_sw_prof_15_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_sw_profiling_sw_prof_15_setf(struct cl_chip *chip, u8 swprof15)
{
	ASSERT_ERR_CHIP((((u32)swprof15 << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00008000)) | ((u32)swprof15 << 15));
}

static inline u8 mac_hw_sw_profiling_sw_prof_14_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_sw_profiling_sw_prof_14_setf(struct cl_chip *chip, u8 swprof14)
{
	ASSERT_ERR_CHIP((((u32)swprof14 << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00004000)) | ((u32)swprof14 << 14));
}

static inline u8 mac_hw_sw_profiling_sw_prof_13_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_sw_profiling_sw_prof_13_setf(struct cl_chip *chip, u8 swprof13)
{
	ASSERT_ERR_CHIP((((u32)swprof13 << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00002000)) | ((u32)swprof13 << 13));
}

static inline u8 mac_hw_sw_profiling_sw_prof_12_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_sw_profiling_sw_prof_12_setf(struct cl_chip *chip, u8 swprof12)
{
	ASSERT_ERR_CHIP((((u32)swprof12 << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00001000)) | ((u32)swprof12 << 12));
}

static inline u8 mac_hw_sw_profiling_sw_prof_11_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_sw_profiling_sw_prof_11_setf(struct cl_chip *chip, u8 swprof11)
{
	ASSERT_ERR_CHIP((((u32)swprof11 << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000800)) | ((u32)swprof11 << 11));
}

static inline u8 mac_hw_sw_profiling_sw_prof_10_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_sw_profiling_sw_prof_10_setf(struct cl_chip *chip, u8 swprof10)
{
	ASSERT_ERR_CHIP((((u32)swprof10 << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000400)) | ((u32)swprof10 << 10));
}

static inline u8 mac_hw_sw_profiling_sw_prof_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_sw_profiling_sw_prof_9_setf(struct cl_chip *chip, u8 swprof9)
{
	ASSERT_ERR_CHIP((((u32)swprof9 << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000200)) | ((u32)swprof9 << 9));
}

static inline u8 mac_hw_sw_profiling_sw_prof_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_sw_profiling_sw_prof_8_setf(struct cl_chip *chip, u8 swprof8)
{
	ASSERT_ERR_CHIP((((u32)swprof8 << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000100)) | ((u32)swprof8 << 8));
}

static inline u8 mac_hw_sw_profiling_sw_prof_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_sw_profiling_sw_prof_7_setf(struct cl_chip *chip, u8 swprof7)
{
	ASSERT_ERR_CHIP((((u32)swprof7 << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000080)) | ((u32)swprof7 << 7));
}

static inline u8 mac_hw_sw_profiling_sw_prof_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_sw_profiling_sw_prof_6_setf(struct cl_chip *chip, u8 swprof6)
{
	ASSERT_ERR_CHIP((((u32)swprof6 << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000040)) | ((u32)swprof6 << 6));
}

static inline u8 mac_hw_sw_profiling_sw_prof_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_sw_profiling_sw_prof_5_setf(struct cl_chip *chip, u8 swprof5)
{
	ASSERT_ERR_CHIP((((u32)swprof5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000020)) | ((u32)swprof5 << 5));
}

static inline u8 mac_hw_sw_profiling_sw_prof_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_sw_profiling_sw_prof_4_setf(struct cl_chip *chip, u8 swprof4)
{
	ASSERT_ERR_CHIP((((u32)swprof4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000010)) | ((u32)swprof4 << 4));
}

static inline u8 mac_hw_sw_profiling_sw_prof_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_sw_profiling_sw_prof_3_setf(struct cl_chip *chip, u8 swprof3)
{
	ASSERT_ERR_CHIP((((u32)swprof3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000008)) | ((u32)swprof3 << 3));
}

static inline u8 mac_hw_sw_profiling_sw_prof_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_sw_profiling_sw_prof_2_setf(struct cl_chip *chip, u8 swprof2)
{
	ASSERT_ERR_CHIP((((u32)swprof2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000004)) | ((u32)swprof2 << 2));
}

static inline u8 mac_hw_sw_profiling_sw_prof_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_sw_profiling_sw_prof_1_setf(struct cl_chip *chip, u8 swprof1)
{
	ASSERT_ERR_CHIP((((u32)swprof1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000002)) | ((u32)swprof1 << 1));
}

static inline u8 mac_hw_sw_profiling_sw_prof_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_sw_profiling_sw_prof_0_setf(struct cl_chip *chip, u8 swprof0)
{
	ASSERT_ERR_CHIP((((u32)swprof0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_PROFILING_ADDR) & ~((u32)0x00000001)) | ((u32)swprof0 << 0));
}

/**
 * @brief SW_SET_PROFILING register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    SW_SET_PROF_31            0
 *    30    SW_SET_PROF_30            0
 *    29    SW_SET_PROF_29            0
 *    28    SW_SET_PROF_28            0
 *    27    SW_SET_PROF_27            0
 *    26    SW_SET_PROF_26            0
 *    25    SW_SET_PROF_25            0
 *    24    SW_SET_PROF_24            0
 *    23    SW_SET_PROF_23            0
 *    22    SW_SET_PROF_22            0
 *    21    SW_SET_PROF_21            0
 *    20    SW_SET_PROF_20            0
 *    19    SW_SET_PROF_19            0
 *    18    SW_SET_PROF_18            0
 *    17    SW_SET_PROF_17            0
 *    16    SW_SET_PROF_16            0
 *    15    SW_SET_PROF_15            0
 *    14    SW_SET_PROF_14            0
 *    13    SW_SET_PROF_13            0
 *    12    SW_SET_PROF_12            0
 *    11    SW_SET_PROF_11            0
 *    10    SW_SET_PROF_10            0
 *    09    SW_SET_PROF_9             0
 *    08    SW_SET_PROF_8             0
 *    07    SW_SET_PROF_7             0
 *    06    SW_SET_PROF_6             0
 *    05    SW_SET_PROF_5             0
 *    04    SW_SET_PROF_4             0
 *    03    SW_SET_PROF_3             0
 *    02    SW_SET_PROF_2             0
 *    01    SW_SET_PROF_1             0
 *    00    SW_SET_PROF_0             0
 * </pre>
 */
#define MAC_HW_SW_SET_PROFILING_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008564)
#define MAC_HW_SW_SET_PROFILING_OFFSET      0x00008564
#define MAC_HW_SW_SET_PROFILING_INDEX       0x00002159
#define MAC_HW_SW_SET_PROFILING_RESET       0x00000000

static inline void mac_hw_sw_set_profiling_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_31_BIT    ((u32)0x80000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_31_POS    31
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_30_BIT    ((u32)0x40000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_30_POS    30
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_29_BIT    ((u32)0x20000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_29_POS    29
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_28_BIT    ((u32)0x10000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_28_POS    28
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_27_BIT    ((u32)0x08000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_27_POS    27
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_26_BIT    ((u32)0x04000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_26_POS    26
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_25_BIT    ((u32)0x02000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_25_POS    25
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_24_BIT    ((u32)0x01000000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_24_POS    24
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_23_BIT    ((u32)0x00800000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_23_POS    23
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_22_BIT    ((u32)0x00400000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_22_POS    22
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_21_BIT    ((u32)0x00200000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_21_POS    21
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_20_BIT    ((u32)0x00100000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_20_POS    20
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_19_BIT    ((u32)0x00080000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_19_POS    19
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_18_BIT    ((u32)0x00040000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_18_POS    18
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_17_BIT    ((u32)0x00020000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_17_POS    17
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_16_BIT    ((u32)0x00010000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_16_POS    16
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_15_BIT    ((u32)0x00008000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_15_POS    15
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_14_BIT    ((u32)0x00004000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_14_POS    14
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_13_BIT    ((u32)0x00002000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_13_POS    13
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_12_BIT    ((u32)0x00001000)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_12_POS    12
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_11_BIT    ((u32)0x00000800)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_11_POS    11
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_10_BIT    ((u32)0x00000400)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_10_POS    10
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_9_BIT    ((u32)0x00000200)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_9_POS    9
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_8_BIT    ((u32)0x00000100)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_8_POS    8
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_7_BIT    ((u32)0x00000080)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_7_POS    7
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_6_BIT    ((u32)0x00000040)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_6_POS    6
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_5_BIT    ((u32)0x00000020)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_5_POS    5
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_4_BIT    ((u32)0x00000010)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_4_POS    4
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_3_BIT    ((u32)0x00000008)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_3_POS    3
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_2_BIT    ((u32)0x00000004)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_2_POS    2
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_1_BIT    ((u32)0x00000002)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_1_POS    1
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_0_BIT    ((u32)0x00000001)
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_0_POS    0

#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_31_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_30_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_29_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_28_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_27_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_26_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_25_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_24_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_23_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_22_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_21_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_20_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_19_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_18_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_17_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_16_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_15_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_14_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_13_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_12_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_11_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_10_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_9_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_8_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_7_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_6_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_5_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_4_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_3_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_2_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_1_RST    0x0
#define MAC_HW_SW_SET_PROFILING_SW_SET_PROF_0_RST    0x0

static inline void mac_hw_sw_set_profiling_pack(struct cl_chip *chip, u8 sw_set_prof_31, u8 sw_set_prof_30, u8 sw_set_prof_29, u8 sw_set_prof_28, u8 sw_set_prof_27, u8 sw_set_prof_26, u8 sw_set_prof_25, u8 sw_set_prof_24, u8 sw_set_prof_23, u8 sw_set_prof_22, u8 sw_set_prof_21, u8 sw_set_prof_20, u8 sw_set_prof_19, u8 sw_set_prof_18, u8 sw_set_prof_17, u8 sw_set_prof_16, u8 sw_set_prof_15, u8 sw_set_prof_14, u8 sw_set_prof_13, u8 sw_set_prof_12, u8 sw_set_prof_11, u8 sw_set_prof_10, u8 sw_set_prof_9, u8 sw_set_prof_8, u8 sw_set_prof_7, u8 sw_set_prof_6, u8 sw_set_prof_5, u8 sw_set_prof_4, u8 sw_set_prof_3, u8 sw_set_prof_2, u8 sw_set_prof_1, u8 sw_set_prof_0)
{
	ASSERT_ERR_CHIP((((u32)sw_set_prof_31 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_30 << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_29 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_28 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_27 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_26 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_25 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_24 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_23 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_22 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_21 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_20 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_19 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_18 << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_17 << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_16 << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_15 << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_14 << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_13 << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_12 << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_11 << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_10 << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_9 << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_8 << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_7 << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_6 << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_set_prof_0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, ((u32)sw_set_prof_31 << 31) | ((u32)sw_set_prof_30 << 30) | ((u32)sw_set_prof_29 << 29) | ((u32)sw_set_prof_28 << 28) | ((u32)sw_set_prof_27 << 27) | ((u32)sw_set_prof_26 << 26) | ((u32)sw_set_prof_25 << 25) | ((u32)sw_set_prof_24 << 24) | ((u32)sw_set_prof_23 << 23) | ((u32)sw_set_prof_22 << 22) | ((u32)sw_set_prof_21 << 21) | ((u32)sw_set_prof_20 << 20) | ((u32)sw_set_prof_19 << 19) | ((u32)sw_set_prof_18 << 18) | ((u32)sw_set_prof_17 << 17) | ((u32)sw_set_prof_16 << 16) | ((u32)sw_set_prof_15 << 15) | ((u32)sw_set_prof_14 << 14) | ((u32)sw_set_prof_13 << 13) | ((u32)sw_set_prof_12 << 12) | ((u32)sw_set_prof_11 << 11) | ((u32)sw_set_prof_10 << 10) | ((u32)sw_set_prof_9 << 9) | ((u32)sw_set_prof_8 << 8) | ((u32)sw_set_prof_7 << 7) | ((u32)sw_set_prof_6 << 6) | ((u32)sw_set_prof_5 << 5) | ((u32)sw_set_prof_4 << 4) | ((u32)sw_set_prof_3 << 3) | ((u32)sw_set_prof_2 << 2) | ((u32)sw_set_prof_1 << 1) | ((u32)sw_set_prof_0 << 0));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_31_setf(struct cl_chip *chip, u8 swsetprof31)
{
	ASSERT_ERR_CHIP((((u32)swsetprof31 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x80000000)) | ((u32)swsetprof31 << 31));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_30_setf(struct cl_chip *chip, u8 swsetprof30)
{
	ASSERT_ERR_CHIP((((u32)swsetprof30 << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x40000000)) | ((u32)swsetprof30 << 30));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_29_setf(struct cl_chip *chip, u8 swsetprof29)
{
	ASSERT_ERR_CHIP((((u32)swsetprof29 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x20000000)) | ((u32)swsetprof29 << 29));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_28_setf(struct cl_chip *chip, u8 swsetprof28)
{
	ASSERT_ERR_CHIP((((u32)swsetprof28 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x10000000)) | ((u32)swsetprof28 << 28));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_27_setf(struct cl_chip *chip, u8 swsetprof27)
{
	ASSERT_ERR_CHIP((((u32)swsetprof27 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x08000000)) | ((u32)swsetprof27 << 27));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_26_setf(struct cl_chip *chip, u8 swsetprof26)
{
	ASSERT_ERR_CHIP((((u32)swsetprof26 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x04000000)) | ((u32)swsetprof26 << 26));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_25_setf(struct cl_chip *chip, u8 swsetprof25)
{
	ASSERT_ERR_CHIP((((u32)swsetprof25 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x02000000)) | ((u32)swsetprof25 << 25));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_24_setf(struct cl_chip *chip, u8 swsetprof24)
{
	ASSERT_ERR_CHIP((((u32)swsetprof24 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x01000000)) | ((u32)swsetprof24 << 24));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_23_setf(struct cl_chip *chip, u8 swsetprof23)
{
	ASSERT_ERR_CHIP((((u32)swsetprof23 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00800000)) | ((u32)swsetprof23 << 23));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_22_setf(struct cl_chip *chip, u8 swsetprof22)
{
	ASSERT_ERR_CHIP((((u32)swsetprof22 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00400000)) | ((u32)swsetprof22 << 22));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_21_setf(struct cl_chip *chip, u8 swsetprof21)
{
	ASSERT_ERR_CHIP((((u32)swsetprof21 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00200000)) | ((u32)swsetprof21 << 21));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_20_setf(struct cl_chip *chip, u8 swsetprof20)
{
	ASSERT_ERR_CHIP((((u32)swsetprof20 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00100000)) | ((u32)swsetprof20 << 20));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_19_setf(struct cl_chip *chip, u8 swsetprof19)
{
	ASSERT_ERR_CHIP((((u32)swsetprof19 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00080000)) | ((u32)swsetprof19 << 19));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_18_setf(struct cl_chip *chip, u8 swsetprof18)
{
	ASSERT_ERR_CHIP((((u32)swsetprof18 << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00040000)) | ((u32)swsetprof18 << 18));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_17_setf(struct cl_chip *chip, u8 swsetprof17)
{
	ASSERT_ERR_CHIP((((u32)swsetprof17 << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00020000)) | ((u32)swsetprof17 << 17));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_16_setf(struct cl_chip *chip, u8 swsetprof16)
{
	ASSERT_ERR_CHIP((((u32)swsetprof16 << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00010000)) | ((u32)swsetprof16 << 16));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_15_setf(struct cl_chip *chip, u8 swsetprof15)
{
	ASSERT_ERR_CHIP((((u32)swsetprof15 << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00008000)) | ((u32)swsetprof15 << 15));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_14_setf(struct cl_chip *chip, u8 swsetprof14)
{
	ASSERT_ERR_CHIP((((u32)swsetprof14 << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00004000)) | ((u32)swsetprof14 << 14));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_13_setf(struct cl_chip *chip, u8 swsetprof13)
{
	ASSERT_ERR_CHIP((((u32)swsetprof13 << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00002000)) | ((u32)swsetprof13 << 13));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_12_setf(struct cl_chip *chip, u8 swsetprof12)
{
	ASSERT_ERR_CHIP((((u32)swsetprof12 << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00001000)) | ((u32)swsetprof12 << 12));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_11_setf(struct cl_chip *chip, u8 swsetprof11)
{
	ASSERT_ERR_CHIP((((u32)swsetprof11 << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000800)) | ((u32)swsetprof11 << 11));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_10_setf(struct cl_chip *chip, u8 swsetprof10)
{
	ASSERT_ERR_CHIP((((u32)swsetprof10 << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000400)) | ((u32)swsetprof10 << 10));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_9_setf(struct cl_chip *chip, u8 swsetprof9)
{
	ASSERT_ERR_CHIP((((u32)swsetprof9 << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000200)) | ((u32)swsetprof9 << 9));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_8_setf(struct cl_chip *chip, u8 swsetprof8)
{
	ASSERT_ERR_CHIP((((u32)swsetprof8 << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000100)) | ((u32)swsetprof8 << 8));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_7_setf(struct cl_chip *chip, u8 swsetprof7)
{
	ASSERT_ERR_CHIP((((u32)swsetprof7 << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000080)) | ((u32)swsetprof7 << 7));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_6_setf(struct cl_chip *chip, u8 swsetprof6)
{
	ASSERT_ERR_CHIP((((u32)swsetprof6 << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000040)) | ((u32)swsetprof6 << 6));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_5_setf(struct cl_chip *chip, u8 swsetprof5)
{
	ASSERT_ERR_CHIP((((u32)swsetprof5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000020)) | ((u32)swsetprof5 << 5));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_4_setf(struct cl_chip *chip, u8 swsetprof4)
{
	ASSERT_ERR_CHIP((((u32)swsetprof4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000010)) | ((u32)swsetprof4 << 4));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_3_setf(struct cl_chip *chip, u8 swsetprof3)
{
	ASSERT_ERR_CHIP((((u32)swsetprof3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000008)) | ((u32)swsetprof3 << 3));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_2_setf(struct cl_chip *chip, u8 swsetprof2)
{
	ASSERT_ERR_CHIP((((u32)swsetprof2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000004)) | ((u32)swsetprof2 << 2));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_1_setf(struct cl_chip *chip, u8 swsetprof1)
{
	ASSERT_ERR_CHIP((((u32)swsetprof1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000002)) | ((u32)swsetprof1 << 1));
}

static inline void mac_hw_sw_set_profiling_sw_set_prof_0_setf(struct cl_chip *chip, u8 swsetprof0)
{
	ASSERT_ERR_CHIP((((u32)swsetprof0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_SET_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_SET_PROFILING_ADDR) & ~((u32)0x00000001)) | ((u32)swsetprof0 << 0));
}

/**
 * @brief SW_CLEAR_PROFILING register definition
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    SW_CLEAR_PROF_31          0
 *    30    SW_CLEAR_PROF_30          0
 *    29    SW_CLEAR_PROF_29          0
 *    28    SW_CLEAR_PROF_28          0
 *    27    SW_CLEAR_PROF_27          0
 *    26    SW_CLEAR_PROF_26          0
 *    25    SW_CLEAR_PROF_25          0
 *    24    SW_CLEAR_PROF_24          0
 *    23    SW_CLEAR_PROF_23          0
 *    22    SW_CLEAR_PROF_22          0
 *    21    SW_CLEAR_PROF_21          0
 *    20    SW_CLEAR_PROF_20          0
 *    19    SW_CLEAR_PROF_19          0
 *    18    SW_CLEAR_PROF_18          0
 *    17    SW_CLEAR_PROF_17          0
 *    16    SW_CLEAR_PROF_16          0
 *    15    SW_CLEAR_PROF_15          0
 *    14    SW_CLEAR_PROF_14          0
 *    13    SW_CLEAR_PROF_13          0
 *    12    SW_CLEAR_PROF_12          0
 *    11    SW_CLEAR_PROF_11          0
 *    10    SW_CLEAR_PROF_10          0
 *    09    SW_CLEAR_PROF_9           0
 *    08    SW_CLEAR_PROF_8           0
 *    07    SW_CLEAR_PROF_7           0
 *    06    SW_CLEAR_PROF_6           0
 *    05    SW_CLEAR_PROF_5           0
 *    04    SW_CLEAR_PROF_4           0
 *    03    SW_CLEAR_PROF_3           0
 *    02    SW_CLEAR_PROF_2           0
 *    01    SW_CLEAR_PROF_1           0
 *    00    SW_CLEAR_PROF_0           0
 * </pre>
 */
#define MAC_HW_SW_CLEAR_PROFILING_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008568)
#define MAC_HW_SW_CLEAR_PROFILING_OFFSET      0x00008568
#define MAC_HW_SW_CLEAR_PROFILING_INDEX       0x0000215A
#define MAC_HW_SW_CLEAR_PROFILING_RESET       0x00000000

static inline void mac_hw_sw_clear_profiling_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, value);
}

/* Field definitions */
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_31_BIT    ((u32)0x80000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_31_POS    31
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_30_BIT    ((u32)0x40000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_30_POS    30
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_29_BIT    ((u32)0x20000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_29_POS    29
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_28_BIT    ((u32)0x10000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_28_POS    28
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_27_BIT    ((u32)0x08000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_27_POS    27
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_26_BIT    ((u32)0x04000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_26_POS    26
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_25_BIT    ((u32)0x02000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_25_POS    25
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_24_BIT    ((u32)0x01000000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_24_POS    24
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_23_BIT    ((u32)0x00800000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_23_POS    23
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_22_BIT    ((u32)0x00400000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_22_POS    22
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_21_BIT    ((u32)0x00200000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_21_POS    21
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_20_BIT    ((u32)0x00100000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_20_POS    20
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_19_BIT    ((u32)0x00080000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_19_POS    19
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_18_BIT    ((u32)0x00040000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_18_POS    18
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_17_BIT    ((u32)0x00020000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_17_POS    17
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_16_BIT    ((u32)0x00010000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_16_POS    16
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_15_BIT    ((u32)0x00008000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_15_POS    15
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_14_BIT    ((u32)0x00004000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_14_POS    14
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_13_BIT    ((u32)0x00002000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_13_POS    13
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_12_BIT    ((u32)0x00001000)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_12_POS    12
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_11_BIT    ((u32)0x00000800)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_11_POS    11
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_10_BIT    ((u32)0x00000400)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_10_POS    10
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_9_BIT    ((u32)0x00000200)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_9_POS    9
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_8_BIT    ((u32)0x00000100)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_8_POS    8
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_7_BIT    ((u32)0x00000080)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_7_POS    7
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_6_BIT    ((u32)0x00000040)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_6_POS    6
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_5_BIT    ((u32)0x00000020)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_5_POS    5
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_4_BIT    ((u32)0x00000010)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_4_POS    4
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_3_BIT    ((u32)0x00000008)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_3_POS    3
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_2_BIT    ((u32)0x00000004)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_2_POS    2
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_1_BIT    ((u32)0x00000002)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_1_POS    1
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_0_BIT    ((u32)0x00000001)
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_0_POS    0

#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_31_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_30_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_29_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_28_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_27_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_26_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_25_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_24_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_23_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_22_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_21_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_20_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_19_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_18_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_17_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_16_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_15_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_14_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_13_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_12_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_11_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_10_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_9_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_8_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_7_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_6_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_5_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_4_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_3_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_2_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_1_RST    0x0
#define MAC_HW_SW_CLEAR_PROFILING_SW_CLEAR_PROF_0_RST    0x0

static inline void mac_hw_sw_clear_profiling_pack(struct cl_chip *chip, u8 sw_clear_prof_31, u8 sw_clear_prof_30, u8 sw_clear_prof_29, u8 sw_clear_prof_28, u8 sw_clear_prof_27, u8 sw_clear_prof_26, u8 sw_clear_prof_25, u8 sw_clear_prof_24, u8 sw_clear_prof_23, u8 sw_clear_prof_22, u8 sw_clear_prof_21, u8 sw_clear_prof_20, u8 sw_clear_prof_19, u8 sw_clear_prof_18, u8 sw_clear_prof_17, u8 sw_clear_prof_16, u8 sw_clear_prof_15, u8 sw_clear_prof_14, u8 sw_clear_prof_13, u8 sw_clear_prof_12, u8 sw_clear_prof_11, u8 sw_clear_prof_10, u8 sw_clear_prof_9, u8 sw_clear_prof_8, u8 sw_clear_prof_7, u8 sw_clear_prof_6, u8 sw_clear_prof_5, u8 sw_clear_prof_4, u8 sw_clear_prof_3, u8 sw_clear_prof_2, u8 sw_clear_prof_1, u8 sw_clear_prof_0)
{
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_31 << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_30 << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_29 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_28 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_27 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_26 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_25 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_24 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_23 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_22 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_21 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_20 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_19 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_18 << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_17 << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_16 << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_15 << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_14 << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_13 << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_12 << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_11 << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_10 << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_9 << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_8 << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_7 << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_6 << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_clear_prof_0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, ((u32)sw_clear_prof_31 << 31) | ((u32)sw_clear_prof_30 << 30) | ((u32)sw_clear_prof_29 << 29) | ((u32)sw_clear_prof_28 << 28) | ((u32)sw_clear_prof_27 << 27) | ((u32)sw_clear_prof_26 << 26) | ((u32)sw_clear_prof_25 << 25) | ((u32)sw_clear_prof_24 << 24) | ((u32)sw_clear_prof_23 << 23) | ((u32)sw_clear_prof_22 << 22) | ((u32)sw_clear_prof_21 << 21) | ((u32)sw_clear_prof_20 << 20) | ((u32)sw_clear_prof_19 << 19) | ((u32)sw_clear_prof_18 << 18) | ((u32)sw_clear_prof_17 << 17) | ((u32)sw_clear_prof_16 << 16) | ((u32)sw_clear_prof_15 << 15) | ((u32)sw_clear_prof_14 << 14) | ((u32)sw_clear_prof_13 << 13) | ((u32)sw_clear_prof_12 << 12) | ((u32)sw_clear_prof_11 << 11) | ((u32)sw_clear_prof_10 << 10) | ((u32)sw_clear_prof_9 << 9) | ((u32)sw_clear_prof_8 << 8) | ((u32)sw_clear_prof_7 << 7) | ((u32)sw_clear_prof_6 << 6) | ((u32)sw_clear_prof_5 << 5) | ((u32)sw_clear_prof_4 << 4) | ((u32)sw_clear_prof_3 << 3) | ((u32)sw_clear_prof_2 << 2) | ((u32)sw_clear_prof_1 << 1) | ((u32)sw_clear_prof_0 << 0));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_31_setf(struct cl_chip *chip, u8 swclearprof31)
{
	ASSERT_ERR_CHIP((((u32)swclearprof31 << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x80000000)) | ((u32)swclearprof31 << 31));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_30_setf(struct cl_chip *chip, u8 swclearprof30)
{
	ASSERT_ERR_CHIP((((u32)swclearprof30 << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x40000000)) | ((u32)swclearprof30 << 30));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_29_setf(struct cl_chip *chip, u8 swclearprof29)
{
	ASSERT_ERR_CHIP((((u32)swclearprof29 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x20000000)) | ((u32)swclearprof29 << 29));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_28_setf(struct cl_chip *chip, u8 swclearprof28)
{
	ASSERT_ERR_CHIP((((u32)swclearprof28 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x10000000)) | ((u32)swclearprof28 << 28));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_27_setf(struct cl_chip *chip, u8 swclearprof27)
{
	ASSERT_ERR_CHIP((((u32)swclearprof27 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x08000000)) | ((u32)swclearprof27 << 27));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_26_setf(struct cl_chip *chip, u8 swclearprof26)
{
	ASSERT_ERR_CHIP((((u32)swclearprof26 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x04000000)) | ((u32)swclearprof26 << 26));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_25_setf(struct cl_chip *chip, u8 swclearprof25)
{
	ASSERT_ERR_CHIP((((u32)swclearprof25 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x02000000)) | ((u32)swclearprof25 << 25));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_24_setf(struct cl_chip *chip, u8 swclearprof24)
{
	ASSERT_ERR_CHIP((((u32)swclearprof24 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x01000000)) | ((u32)swclearprof24 << 24));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_23_setf(struct cl_chip *chip, u8 swclearprof23)
{
	ASSERT_ERR_CHIP((((u32)swclearprof23 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00800000)) | ((u32)swclearprof23 << 23));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_22_setf(struct cl_chip *chip, u8 swclearprof22)
{
	ASSERT_ERR_CHIP((((u32)swclearprof22 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00400000)) | ((u32)swclearprof22 << 22));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_21_setf(struct cl_chip *chip, u8 swclearprof21)
{
	ASSERT_ERR_CHIP((((u32)swclearprof21 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00200000)) | ((u32)swclearprof21 << 21));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_20_setf(struct cl_chip *chip, u8 swclearprof20)
{
	ASSERT_ERR_CHIP((((u32)swclearprof20 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00100000)) | ((u32)swclearprof20 << 20));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_19_setf(struct cl_chip *chip, u8 swclearprof19)
{
	ASSERT_ERR_CHIP((((u32)swclearprof19 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00080000)) | ((u32)swclearprof19 << 19));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_18_setf(struct cl_chip *chip, u8 swclearprof18)
{
	ASSERT_ERR_CHIP((((u32)swclearprof18 << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00040000)) | ((u32)swclearprof18 << 18));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_17_setf(struct cl_chip *chip, u8 swclearprof17)
{
	ASSERT_ERR_CHIP((((u32)swclearprof17 << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00020000)) | ((u32)swclearprof17 << 17));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_16_setf(struct cl_chip *chip, u8 swclearprof16)
{
	ASSERT_ERR_CHIP((((u32)swclearprof16 << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00010000)) | ((u32)swclearprof16 << 16));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_15_setf(struct cl_chip *chip, u8 swclearprof15)
{
	ASSERT_ERR_CHIP((((u32)swclearprof15 << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00008000)) | ((u32)swclearprof15 << 15));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_14_setf(struct cl_chip *chip, u8 swclearprof14)
{
	ASSERT_ERR_CHIP((((u32)swclearprof14 << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00004000)) | ((u32)swclearprof14 << 14));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_13_setf(struct cl_chip *chip, u8 swclearprof13)
{
	ASSERT_ERR_CHIP((((u32)swclearprof13 << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00002000)) | ((u32)swclearprof13 << 13));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_12_setf(struct cl_chip *chip, u8 swclearprof12)
{
	ASSERT_ERR_CHIP((((u32)swclearprof12 << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00001000)) | ((u32)swclearprof12 << 12));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_11_setf(struct cl_chip *chip, u8 swclearprof11)
{
	ASSERT_ERR_CHIP((((u32)swclearprof11 << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000800)) | ((u32)swclearprof11 << 11));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_10_setf(struct cl_chip *chip, u8 swclearprof10)
{
	ASSERT_ERR_CHIP((((u32)swclearprof10 << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000400)) | ((u32)swclearprof10 << 10));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_9_setf(struct cl_chip *chip, u8 swclearprof9)
{
	ASSERT_ERR_CHIP((((u32)swclearprof9 << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000200)) | ((u32)swclearprof9 << 9));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_8_setf(struct cl_chip *chip, u8 swclearprof8)
{
	ASSERT_ERR_CHIP((((u32)swclearprof8 << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000100)) | ((u32)swclearprof8 << 8));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_7_setf(struct cl_chip *chip, u8 swclearprof7)
{
	ASSERT_ERR_CHIP((((u32)swclearprof7 << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000080)) | ((u32)swclearprof7 << 7));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_6_setf(struct cl_chip *chip, u8 swclearprof6)
{
	ASSERT_ERR_CHIP((((u32)swclearprof6 << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000040)) | ((u32)swclearprof6 << 6));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_5_setf(struct cl_chip *chip, u8 swclearprof5)
{
	ASSERT_ERR_CHIP((((u32)swclearprof5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000020)) | ((u32)swclearprof5 << 5));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_4_setf(struct cl_chip *chip, u8 swclearprof4)
{
	ASSERT_ERR_CHIP((((u32)swclearprof4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000010)) | ((u32)swclearprof4 << 4));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_3_setf(struct cl_chip *chip, u8 swclearprof3)
{
	ASSERT_ERR_CHIP((((u32)swclearprof3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000008)) | ((u32)swclearprof3 << 3));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_2_setf(struct cl_chip *chip, u8 swclearprof2)
{
	ASSERT_ERR_CHIP((((u32)swclearprof2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000004)) | ((u32)swclearprof2 << 2));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_1_setf(struct cl_chip *chip, u8 swclearprof1)
{
	ASSERT_ERR_CHIP((((u32)swclearprof1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000002)) | ((u32)swclearprof1 << 1));
}

static inline void mac_hw_sw_clear_profiling_sw_clear_prof_0_setf(struct cl_chip *chip, u8 swclearprof0)
{
	ASSERT_ERR_CHIP((((u32)swclearprof0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR, (cl_reg_read(chip, MAC_HW_SW_CLEAR_PROFILING_ADDR) & ~((u32)0x00000001)) | ((u32)swclearprof0 << 0));
}

/**
 * @brief DEBUG_RX_PAY_S_PTR_2 register definition
 *  Debug Rx Payload Status Pointer for LL2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 Rx_Pay_Stat_Pointer2      0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000856C)
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_OFFSET      0x0000856C
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_INDEX       0x0000215B
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_RESET       0x00000000

static inline u32 mac_hw_debug_rx_pay_s_ptr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_S_PTR_2_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_RX_PAY_STAT_POINTER_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_RX_PAY_STAT_POINTER_2_LSB    0
#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_RX_PAY_STAT_POINTER_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_PAY_S_PTR_2_RX_PAY_STAT_POINTER_2_RST    0x0

static inline u32 mac_hw_debug_rx_pay_s_ptr_2_rx_pay_stat_pointer_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_S_PTR_2_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_RX_HDR_S_PTR_2 register definition
 *  Debug Rx Header Status Pointer for LL2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 rx_Hdr_Stat_Pointer2      0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008570)
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_OFFSET      0x00008570
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_INDEX       0x0000215C
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_RESET       0x00000000

static inline u32 mac_hw_debug_rx_hdr_s_ptr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_HDR_S_PTR_2_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_RX_HDR_STAT_POINTER_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_RX_HDR_STAT_POINTER_2_LSB    0
#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_RX_HDR_STAT_POINTER_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_HDR_S_PTR_2_RX_HDR_STAT_POINTER_2_RST    0x0

static inline u32 mac_hw_debug_rx_hdr_s_ptr_2_rx_hdr_stat_pointer_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_HDR_S_PTR_2_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief DEBUG_RX_PAY_C_PTR_2 register definition
 *  Debug Rx Payload Current Pointer for LL2 register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 rx_Pay_Current_Pointer2   0x0
 * </pre>
 */
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008574)
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_OFFSET      0x00008574
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_INDEX       0x0000215D
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_RESET       0x00000000

static inline u32 mac_hw_debug_rx_pay_c_ptr_2_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_C_PTR_2_ADDR);
}

/* Field definitions */
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_RX_PAY_CURRENT_POINTER_2_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_RX_PAY_CURRENT_POINTER_2_LSB    0
#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_RX_PAY_CURRENT_POINTER_2_WIDTH    ((u32)0x00000020)

#define MAC_HW_DEBUG_RX_PAY_C_PTR_2_RX_PAY_CURRENT_POINTER_2_RST    0x0

static inline u32 mac_hw_debug_rx_pay_c_ptr_2_rx_pay_current_pointer_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DEBUG_RX_PAY_C_PTR_2_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief MAC_HW_SPARE_2_REG register definition
 *  spare register to be used for ECO fixes register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:08 SPARE_2                   0x0
 *    07    PLD_SPARE_ENABLE          0
 *    06    HDR_SPARE_ENABLE          0
 *    05:04 MY_MAX_PE_DURATION        0x0
 *    03    SPARE_1                   0
 *    02    SEC_TRIG_OLD_METHOD_EN    0
 *    01    MPIF_TX_FIFO_HALF_SIZE    0
 *    00    SPARE_BIT                 0
 * </pre>
 */
#define MAC_HW_MAC_HW_SPARE_2_REG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008604)
#define MAC_HW_MAC_HW_SPARE_2_REG_OFFSET      0x00008604
#define MAC_HW_MAC_HW_SPARE_2_REG_INDEX       0x00002181
#define MAC_HW_MAC_HW_SPARE_2_REG_RESET       0x00000000

static inline u32 mac_hw_mac_hw_spare_2_reg_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);
}

static inline void mac_hw_mac_hw_spare_2_reg_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, value);
}

/* Field definitions */
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_2_MASK    ((u32)0xFFFFFF00)
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_2_LSB    8
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_2_WIDTH    ((u32)0x00000018)
#define MAC_HW_MAC_HW_SPARE_2_REG_PLD_SPARE_ENABLE_BIT    ((u32)0x00000080)
#define MAC_HW_MAC_HW_SPARE_2_REG_PLD_SPARE_ENABLE_POS    7
#define MAC_HW_MAC_HW_SPARE_2_REG_HDR_SPARE_ENABLE_BIT    ((u32)0x00000040)
#define MAC_HW_MAC_HW_SPARE_2_REG_HDR_SPARE_ENABLE_POS    6
#define MAC_HW_MAC_HW_SPARE_2_REG_MY_MAX_PE_DURATION_MASK    ((u32)0x00000030)
#define MAC_HW_MAC_HW_SPARE_2_REG_MY_MAX_PE_DURATION_LSB    4
#define MAC_HW_MAC_HW_SPARE_2_REG_MY_MAX_PE_DURATION_WIDTH    ((u32)0x00000002)
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_1_BIT    ((u32)0x00000008)
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_1_POS    3
#define MAC_HW_MAC_HW_SPARE_2_REG_SEC_TRIG_OLD_METHOD_EN_BIT    ((u32)0x00000004)
#define MAC_HW_MAC_HW_SPARE_2_REG_SEC_TRIG_OLD_METHOD_EN_POS    2
#define MAC_HW_MAC_HW_SPARE_2_REG_MPIF_TX_FIFO_HALF_SIZE_BIT    ((u32)0x00000002)
#define MAC_HW_MAC_HW_SPARE_2_REG_MPIF_TX_FIFO_HALF_SIZE_POS    1
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_BIT_BIT    ((u32)0x00000001)
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_BIT_POS    0

#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_2_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_PLD_SPARE_ENABLE_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_HDR_SPARE_ENABLE_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_MY_MAX_PE_DURATION_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_1_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_SEC_TRIG_OLD_METHOD_EN_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_MPIF_TX_FIFO_HALF_SIZE_RST    0x0
#define MAC_HW_MAC_HW_SPARE_2_REG_SPARE_BIT_RST    0x0

static inline void mac_hw_mac_hw_spare_2_reg_pack(struct cl_chip *chip, u32 spare_2, u8 pld_spare_enable, u8 hdr_spare_enable, u8 my_max_pe_duration, u8 spare_1, u8 sec_trig_old_method_en, u8 mpif_tx_fifo_half_size, u8 spare_bit)
{
	ASSERT_ERR_CHIP((((u32)spare_2 << 8) & ~((u32)0xFFFFFF00)) == 0);
	ASSERT_ERR_CHIP((((u32)pld_spare_enable << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)hdr_spare_enable << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)my_max_pe_duration << 4) & ~((u32)0x00000030)) == 0);
	ASSERT_ERR_CHIP((((u32)spare_1 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)sec_trig_old_method_en << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)mpif_tx_fifo_half_size << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)spare_bit << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, ((u32)spare_2 << 8) | ((u32)pld_spare_enable << 7) | ((u32)hdr_spare_enable << 6) | ((u32)my_max_pe_duration << 4) | ((u32)spare_1 << 3) | ((u32)sec_trig_old_method_en << 2) | ((u32)mpif_tx_fifo_half_size << 1) | ((u32)spare_bit << 0));
}

static inline void mac_hw_mac_hw_spare_2_reg_unpack(struct cl_chip *chip, u32 *spare_2, u8 *pld_spare_enable, u8 *hdr_spare_enable, u8 *my_max_pe_duration, u8 *spare_1, u8 *sec_trig_old_method_en, u8 *mpif_tx_fifo_half_size, u8 *spare_bit)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	*spare_2 = (local_val & ((u32)0xFFFFFF00)) >> 8;
	*pld_spare_enable = (local_val & ((u32)0x00000080)) >> 7;
	*hdr_spare_enable = (local_val & ((u32)0x00000040)) >> 6;
	*my_max_pe_duration = (local_val & ((u32)0x00000030)) >> 4;
	*spare_1 = (local_val & ((u32)0x00000008)) >> 3;
	*sec_trig_old_method_en = (local_val & ((u32)0x00000004)) >> 2;
	*mpif_tx_fifo_half_size = (local_val & ((u32)0x00000002)) >> 1;
	*spare_bit = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u32 mac_hw_mac_hw_spare_2_reg_spare_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u32)((local_val & ((u32)0xFFFFFF00)) >> 8);
}

static inline void mac_hw_mac_hw_spare_2_reg_spare_2_setf(struct cl_chip *chip, u32 spare2)
{
	ASSERT_ERR_CHIP((((u32)spare2 << 8) & ~((u32)0xFFFFFF00)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0xFFFFFF00)) | ((u32)spare2 << 8));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_pld_spare_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_mac_hw_spare_2_reg_pld_spare_enable_setf(struct cl_chip *chip, u8 pldspareenable)
{
	ASSERT_ERR_CHIP((((u32)pldspareenable << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000080)) | ((u32)pldspareenable << 7));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_hdr_spare_enable_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_mac_hw_spare_2_reg_hdr_spare_enable_setf(struct cl_chip *chip, u8 hdrspareenable)
{
	ASSERT_ERR_CHIP((((u32)hdrspareenable << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000040)) | ((u32)hdrspareenable << 6));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_my_max_pe_duration_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000030)) >> 4);
}

static inline void mac_hw_mac_hw_spare_2_reg_my_max_pe_duration_setf(struct cl_chip *chip, u8 mymaxpeduration)
{
	ASSERT_ERR_CHIP((((u32)mymaxpeduration << 4) & ~((u32)0x00000030)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000030)) | ((u32)mymaxpeduration << 4));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_spare_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_mac_hw_spare_2_reg_spare_1_setf(struct cl_chip *chip, u8 spare1)
{
	ASSERT_ERR_CHIP((((u32)spare1 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000008)) | ((u32)spare1 << 3));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_sec_trig_old_method_en_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_mac_hw_spare_2_reg_sec_trig_old_method_en_setf(struct cl_chip *chip, u8 sectrigoldmethoden)
{
	ASSERT_ERR_CHIP((((u32)sectrigoldmethoden << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000004)) | ((u32)sectrigoldmethoden << 2));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_mpif_tx_fifo_half_size_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_mac_hw_spare_2_reg_mpif_tx_fifo_half_size_setf(struct cl_chip *chip, u8 mpiftxfifohalfsize)
{
	ASSERT_ERR_CHIP((((u32)mpiftxfifohalfsize << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000002)) | ((u32)mpiftxfifohalfsize << 1));
}

static inline u8 mac_hw_mac_hw_spare_2_reg_spare_bit_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_mac_hw_spare_2_reg_spare_bit_setf(struct cl_chip *chip, u8 sparebit)
{
	ASSERT_ERR_CHIP((((u32)sparebit << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR, (cl_reg_read(chip, MAC_HW_MAC_HW_SPARE_2_REG_ADDR) & ~((u32)0x00000001)) | ((u32)sparebit << 0));
}

/**
 * @brief DMA_HIF_ADDR_DEBUG register definition
 *  indicate the last address on AHB master port register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31:00 dma_HIFAddress            0x0
 * </pre>
 */
#define MAC_HW_DMA_HIF_ADDR_DEBUG_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008608)
#define MAC_HW_DMA_HIF_ADDR_DEBUG_OFFSET      0x00008608
#define MAC_HW_DMA_HIF_ADDR_DEBUG_INDEX       0x00002182
#define MAC_HW_DMA_HIF_ADDR_DEBUG_RESET       0x00000000

static inline u32 mac_hw_dma_hif_addr_debug_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_DMA_HIF_ADDR_DEBUG_ADDR);
}

/* Field definitions */
#define MAC_HW_DMA_HIF_ADDR_DEBUG_DMA_HIFADDRESS_MASK    ((u32)0xFFFFFFFF)
#define MAC_HW_DMA_HIF_ADDR_DEBUG_DMA_HIFADDRESS_LSB    0
#define MAC_HW_DMA_HIF_ADDR_DEBUG_DMA_HIFADDRESS_WIDTH    ((u32)0x00000020)

#define MAC_HW_DMA_HIF_ADDR_DEBUG_DMA_HIFADDRESS_RST    0x0

static inline u32 mac_hw_dma_hif_addr_debug_dma_hifaddress_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_DMA_HIF_ADDR_DEBUG_ADDR);

	return (u32)(local_val >> 0);
}

/**
 * @brief ERROR_INT_EVENT_STATUS_LMAC register definition
 *  Error interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008700)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OFFSET      0x00008700
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_INDEX       0x000021C0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_status_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_status_lmac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_status_lmac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_error_int_event_status_lmac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_error_int_event_status_lmac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_error_int_event_status_lmac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_error_int_event_status_lmac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_error_int_event_status_lmac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_error_int_event_status_lmac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_error_int_event_status_lmac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_error_int_event_status_lmac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline u8 mac_hw_error_int_event_status_lmac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_error_int_event_status_lmac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_error_int_event_status_lmac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_error_int_event_status_lmac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_error_int_event_status_lmac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_error_int_event_status_lmac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_error_int_event_status_lmac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

/**
 * @brief ERROR_INT_EVENT_CLEAR register definition
 *  Error interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008704)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OFFSET      0x00008704
#define MAC_HW_ERROR_INT_EVENT_CLEAR_INDEX       0x000021C1
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_error_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_CLEAR_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_CLEAR_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_CLEAR_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_clear_pack(struct cl_chip *chip, u8 htp_tx_failed_dma_state, u8 htp_tx_failed_cs, u8 rx_payload_dma_dead, u8 rx_header_dma_dead, u8 rx_header_dma_dead2, u8 phy_err, u8 mac_phyif_under_run, u8 unexpected_tx_end, u8 rx_payload_dma_dead2, u8 htp_tx_dma_dead, u8 bcn_tx_dma_dead, u8 ac_3_tx_dma_dead, u8 ac_2_tx_dma_dead, u8 ac_1_tx_dma_dead, u8 ac_0_tx_dma_dead, u8 pt_error, u8 olbc_dsss, u8 olbc_ofdm, u8 rx_fifo_over_flow, u8 rx_dma_empty, u8 mac_phyif_overflow, u8 rx_dma_discard)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_dma_state << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_cs << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead2 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_err << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_under_run << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)unexpected_tx_end << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead2 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_dma_dead << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_dma_dead << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_dma_dead << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_dma_dead << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_dma_dead << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_dma_dead << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_error << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_dsss << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_ofdm << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_over_flow << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_empty << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_overflow << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_discard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, ((u32)htp_tx_failed_dma_state << 27) | ((u32)htp_tx_failed_cs << 26) | ((u32)rx_payload_dma_dead << 25) | ((u32)rx_header_dma_dead << 24) | ((u32)rx_header_dma_dead2 << 23) | ((u32)phy_err << 22) | ((u32)mac_phyif_under_run << 21) | ((u32)unexpected_tx_end << 20) | ((u32)rx_payload_dma_dead2 << 19) | ((u32)htp_tx_dma_dead << 18) | ((u32)bcn_tx_dma_dead << 17) | ((u32)ac_3_tx_dma_dead << 16) | ((u32)ac_2_tx_dma_dead << 15) | ((u32)ac_1_tx_dma_dead << 14) | ((u32)ac_0_tx_dma_dead << 13) | ((u32)pt_error << 12) | ((u32)olbc_dsss << 10) | ((u32)olbc_ofdm << 9) | ((u32)rx_fifo_over_flow << 8) | ((u32)rx_dma_empty << 7) | ((u32)mac_phyif_overflow << 6) | ((u32)rx_dma_discard << 5));
}

static inline void mac_hw_error_int_event_clear_htp_tx_failed_dma_state_setf(struct cl_chip *chip, u8 htptxfaileddmastate)
{
	ASSERT_ERR_CHIP((((u32)htptxfaileddmastate << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x08000000)) | ((u32)htptxfaileddmastate << 27));
}

static inline void mac_hw_error_int_event_clear_htp_tx_failed_cs_setf(struct cl_chip *chip, u8 htptxfailedcs)
{
	ASSERT_ERR_CHIP((((u32)htptxfailedcs << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x04000000)) | ((u32)htptxfailedcs << 26));
}

static inline void mac_hw_error_int_event_clear_rx_payload_dma_dead_setf(struct cl_chip *chip, u8 rxpayloaddmadead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloaddmadead << 25));
}

static inline void mac_hw_error_int_event_clear_rx_header_dma_dead_setf(struct cl_chip *chip, u8 rxheaderdmadead)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x01000000)) | ((u32)rxheaderdmadead << 24));
}

static inline void mac_hw_error_int_event_clear_rx_header_dma_dead_2_setf(struct cl_chip *chip, u8 rxheaderdmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead2 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00800000)) | ((u32)rxheaderdmadead2 << 23));
}

static inline void mac_hw_error_int_event_clear_phy_err_setf(struct cl_chip *chip, u8 phyerr)
{
	ASSERT_ERR_CHIP((((u32)phyerr << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00400000)) | ((u32)phyerr << 22));
}

static inline void mac_hw_error_int_event_clear_mac_phyif_under_run_setf(struct cl_chip *chip, u8 macphyifunderrun)
{
	ASSERT_ERR_CHIP((((u32)macphyifunderrun << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00200000)) | ((u32)macphyifunderrun << 21));
}

static inline void mac_hw_error_int_event_clear_unexpected_tx_end_setf(struct cl_chip *chip, u8 unexpectedtxend)
{
	ASSERT_ERR_CHIP((((u32)unexpectedtxend << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00100000)) | ((u32)unexpectedtxend << 20));
}

static inline void mac_hw_error_int_event_clear_rx_payload_dma_dead_2_setf(struct cl_chip *chip, u8 rxpayloaddmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead2 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00080000)) | ((u32)rxpayloaddmadead2 << 19));
}

static inline void mac_hw_error_int_event_clear_htp_tx_dma_dead_setf(struct cl_chip *chip, u8 htptxdmadead)
{
	ASSERT_ERR_CHIP((((u32)htptxdmadead << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00040000)) | ((u32)htptxdmadead << 18));
}

static inline void mac_hw_error_int_event_clear_bcn_tx_dma_dead_setf(struct cl_chip *chip, u8 bcntxdmadead)
{
	ASSERT_ERR_CHIP((((u32)bcntxdmadead << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00020000)) | ((u32)bcntxdmadead << 17));
}

static inline void mac_hw_error_int_event_clear_ac_3_tx_dma_dead_setf(struct cl_chip *chip, u8 ac3txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac3txdmadead << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00010000)) | ((u32)ac3txdmadead << 16));
}

static inline void mac_hw_error_int_event_clear_ac_2_tx_dma_dead_setf(struct cl_chip *chip, u8 ac2txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac2txdmadead << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00008000)) | ((u32)ac2txdmadead << 15));
}

static inline void mac_hw_error_int_event_clear_ac_1_tx_dma_dead_setf(struct cl_chip *chip, u8 ac1txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac1txdmadead << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00004000)) | ((u32)ac1txdmadead << 14));
}

static inline void mac_hw_error_int_event_clear_ac_0_tx_dma_dead_setf(struct cl_chip *chip, u8 ac0txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac0txdmadead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00002000)) | ((u32)ac0txdmadead << 13));
}

static inline void mac_hw_error_int_event_clear_pt_error_setf(struct cl_chip *chip, u8 pterror)
{
	ASSERT_ERR_CHIP((((u32)pterror << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00001000)) | ((u32)pterror << 12));
}

static inline void mac_hw_error_int_event_clear_olbc_dsss_setf(struct cl_chip *chip, u8 olbcdsss)
{
	ASSERT_ERR_CHIP((((u32)olbcdsss << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000400)) | ((u32)olbcdsss << 10));
}

static inline void mac_hw_error_int_event_clear_olbc_ofdm_setf(struct cl_chip *chip, u8 olbcofdm)
{
	ASSERT_ERR_CHIP((((u32)olbcofdm << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000200)) | ((u32)olbcofdm << 9));
}

static inline void mac_hw_error_int_event_clear_rx_fifo_over_flow_setf(struct cl_chip *chip, u8 rxfifooverflow)
{
	ASSERT_ERR_CHIP((((u32)rxfifooverflow << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000100)) | ((u32)rxfifooverflow << 8));
}

static inline void mac_hw_error_int_event_clear_rx_dma_empty_setf(struct cl_chip *chip, u8 rxdmaempty)
{
	ASSERT_ERR_CHIP((((u32)rxdmaempty << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000080)) | ((u32)rxdmaempty << 7));
}

static inline void mac_hw_error_int_event_clear_mac_phyif_overflow_setf(struct cl_chip *chip, u8 macphyifoverflow)
{
	ASSERT_ERR_CHIP((((u32)macphyifoverflow << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000040)) | ((u32)macphyifoverflow << 6));
}

static inline void mac_hw_error_int_event_clear_rx_dma_discard_setf(struct cl_chip *chip, u8 rxdmadiscard)
{
	ASSERT_ERR_CHIP((((u32)rxdmadiscard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000020)) | ((u32)rxdmadiscard << 5));
}

/**
 * @brief ERROR_INT_EVENT_EN_LMAC register definition
 *  Error interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008708)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OFFSET      0x00008708
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_INDEX       0x000021C2
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_error_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_LMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_en_lmac_pack(struct cl_chip *chip, u8 htp_tx_failed_dma_state, u8 htp_tx_failed_cs, u8 rx_payload_dma_dead, u8 rx_header_dma_dead, u8 rx_header_dma_dead2, u8 phy_err, u8 mac_phyif_under_run, u8 unexpected_tx_end, u8 rx_payload_dma_dead2, u8 htp_tx_dma_dead, u8 bcn_tx_dma_dead, u8 ac_3_tx_dma_dead, u8 ac_2_tx_dma_dead, u8 ac_1_tx_dma_dead, u8 ac_0_tx_dma_dead, u8 pt_error, u8 olbc_dsss, u8 olbc_ofdm, u8 rx_fifo_over_flow, u8 rx_dma_empty, u8 mac_phyif_overflow, u8 rx_dma_discard)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_dma_state << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_cs << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead2 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_err << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_under_run << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)unexpected_tx_end << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead2 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_dma_dead << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_dma_dead << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_dma_dead << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_dma_dead << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_dma_dead << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_dma_dead << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_error << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_dsss << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_ofdm << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_over_flow << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_empty << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_overflow << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_discard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, ((u32)htp_tx_failed_dma_state << 27) | ((u32)htp_tx_failed_cs << 26) | ((u32)rx_payload_dma_dead << 25) | ((u32)rx_header_dma_dead << 24) | ((u32)rx_header_dma_dead2 << 23) | ((u32)phy_err << 22) | ((u32)mac_phyif_under_run << 21) | ((u32)unexpected_tx_end << 20) | ((u32)rx_payload_dma_dead2 << 19) | ((u32)htp_tx_dma_dead << 18) | ((u32)bcn_tx_dma_dead << 17) | ((u32)ac_3_tx_dma_dead << 16) | ((u32)ac_2_tx_dma_dead << 15) | ((u32)ac_1_tx_dma_dead << 14) | ((u32)ac_0_tx_dma_dead << 13) | ((u32)pt_error << 12) | ((u32)olbc_dsss << 10) | ((u32)olbc_ofdm << 9) | ((u32)rx_fifo_over_flow << 8) | ((u32)rx_dma_empty << 7) | ((u32)mac_phyif_overflow << 6) | ((u32)rx_dma_discard << 5));
}

static inline void mac_hw_error_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_en_lmac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_error_int_event_en_lmac_htp_tx_failed_dma_state_setf(struct cl_chip *chip, u8 htptxfaileddmastate)
{
	ASSERT_ERR_CHIP((((u32)htptxfaileddmastate << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x08000000)) | ((u32)htptxfaileddmastate << 27));
}

static inline u8 mac_hw_error_int_event_en_lmac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_error_int_event_en_lmac_htp_tx_failed_cs_setf(struct cl_chip *chip, u8 htptxfailedcs)
{
	ASSERT_ERR_CHIP((((u32)htptxfailedcs << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x04000000)) | ((u32)htptxfailedcs << 26));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_error_int_event_en_lmac_rx_payload_dma_dead_setf(struct cl_chip *chip, u8 rxpayloaddmadead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloaddmadead << 25));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_error_int_event_en_lmac_rx_header_dma_dead_setf(struct cl_chip *chip, u8 rxheaderdmadead)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x01000000)) | ((u32)rxheaderdmadead << 24));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_error_int_event_en_lmac_rx_header_dma_dead_2_setf(struct cl_chip *chip, u8 rxheaderdmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead2 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00800000)) | ((u32)rxheaderdmadead2 << 23));
}

static inline u8 mac_hw_error_int_event_en_lmac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_error_int_event_en_lmac_phy_err_setf(struct cl_chip *chip, u8 phyerr)
{
	ASSERT_ERR_CHIP((((u32)phyerr << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00400000)) | ((u32)phyerr << 22));
}

static inline u8 mac_hw_error_int_event_en_lmac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_error_int_event_en_lmac_mac_phyif_under_run_setf(struct cl_chip *chip, u8 macphyifunderrun)
{
	ASSERT_ERR_CHIP((((u32)macphyifunderrun << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00200000)) | ((u32)macphyifunderrun << 21));
}

static inline u8 mac_hw_error_int_event_en_lmac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_error_int_event_en_lmac_unexpected_tx_end_setf(struct cl_chip *chip, u8 unexpectedtxend)
{
	ASSERT_ERR_CHIP((((u32)unexpectedtxend << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00100000)) | ((u32)unexpectedtxend << 20));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_error_int_event_en_lmac_rx_payload_dma_dead_2_setf(struct cl_chip *chip, u8 rxpayloaddmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead2 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00080000)) | ((u32)rxpayloaddmadead2 << 19));
}

static inline u8 mac_hw_error_int_event_en_lmac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_error_int_event_en_lmac_htp_tx_dma_dead_setf(struct cl_chip *chip, u8 htptxdmadead)
{
	ASSERT_ERR_CHIP((((u32)htptxdmadead << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00040000)) | ((u32)htptxdmadead << 18));
}

static inline u8 mac_hw_error_int_event_en_lmac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_error_int_event_en_lmac_bcn_tx_dma_dead_setf(struct cl_chip *chip, u8 bcntxdmadead)
{
	ASSERT_ERR_CHIP((((u32)bcntxdmadead << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00020000)) | ((u32)bcntxdmadead << 17));
}

static inline u8 mac_hw_error_int_event_en_lmac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_error_int_event_en_lmac_ac_3_tx_dma_dead_setf(struct cl_chip *chip, u8 ac3txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac3txdmadead << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00010000)) | ((u32)ac3txdmadead << 16));
}

static inline u8 mac_hw_error_int_event_en_lmac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_error_int_event_en_lmac_ac_2_tx_dma_dead_setf(struct cl_chip *chip, u8 ac2txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac2txdmadead << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00008000)) | ((u32)ac2txdmadead << 15));
}

static inline u8 mac_hw_error_int_event_en_lmac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_error_int_event_en_lmac_ac_1_tx_dma_dead_setf(struct cl_chip *chip, u8 ac1txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac1txdmadead << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00004000)) | ((u32)ac1txdmadead << 14));
}

static inline u8 mac_hw_error_int_event_en_lmac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_error_int_event_en_lmac_ac_0_tx_dma_dead_setf(struct cl_chip *chip, u8 ac0txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac0txdmadead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac0txdmadead << 13));
}

static inline u8 mac_hw_error_int_event_en_lmac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_error_int_event_en_lmac_pt_error_setf(struct cl_chip *chip, u8 pterror)
{
	ASSERT_ERR_CHIP((((u32)pterror << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00001000)) | ((u32)pterror << 12));
}

static inline u8 mac_hw_error_int_event_en_lmac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_error_int_event_en_lmac_olbc_dsss_setf(struct cl_chip *chip, u8 olbcdsss)
{
	ASSERT_ERR_CHIP((((u32)olbcdsss << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000400)) | ((u32)olbcdsss << 10));
}

static inline u8 mac_hw_error_int_event_en_lmac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_error_int_event_en_lmac_olbc_ofdm_setf(struct cl_chip *chip, u8 olbcofdm)
{
	ASSERT_ERR_CHIP((((u32)olbcofdm << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000200)) | ((u32)olbcofdm << 9));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_error_int_event_en_lmac_rx_fifo_over_flow_setf(struct cl_chip *chip, u8 rxfifooverflow)
{
	ASSERT_ERR_CHIP((((u32)rxfifooverflow << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rxfifooverflow << 8));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_error_int_event_en_lmac_rx_dma_empty_setf(struct cl_chip *chip, u8 rxdmaempty)
{
	ASSERT_ERR_CHIP((((u32)rxdmaempty << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000080)) | ((u32)rxdmaempty << 7));
}

static inline u8 mac_hw_error_int_event_en_lmac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_error_int_event_en_lmac_mac_phyif_overflow_setf(struct cl_chip *chip, u8 macphyifoverflow)
{
	ASSERT_ERR_CHIP((((u32)macphyifoverflow << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000040)) | ((u32)macphyifoverflow << 6));
}

static inline u8 mac_hw_error_int_event_en_lmac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_error_int_event_en_lmac_rx_dma_discard_setf(struct cl_chip *chip, u8 rxdmadiscard)
{
	ASSERT_ERR_CHIP((((u32)rxdmadiscard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxdmadiscard << 5));
}

/**
 * @brief ERROR_INT_EVENT_EN_UMAC register definition
 *  Error interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    27    HTP_TX_FAILED_DMA_STATE   0
 *    26    HTP_TX_FAILED_CS          0
 *    25    RX_PAYLOAD_DMA_DEAD       0
 *    24    RX_HEADER_DMA_DEAD        0
 *    23    RX_HEADER_DMA_DEAD2       0
 *    22    PHY_ERR                   0
 *    21    MAC_PHYIF_UNDER_RUN       0
 *    20    UNEXPECTED_TX_END         0
 *    19    RX_PAYLOAD_DMA_DEAD2      0
 *    18    HTP_TX_DMA_DEAD           0
 *    17    BCN_TX_DMA_DEAD           0
 *    16    AC_3_TX_DMA_DEAD          0
 *    15    AC_2_TX_DMA_DEAD          0
 *    14    AC_1_TX_DMA_DEAD          0
 *    13    AC_0_TX_DMA_DEAD          0
 *    12    PT_ERROR                  0
 *    10    OLBC_DSSS                 0
 *    09    OLBC_OFDM                 0
 *    08    RX_FIFO_OVER_FLOW         0
 *    07    RX_DMA_EMPTY              0
 *    06    MAC_PHYIF_OVERFLOW        0
 *    05    RX_DMA_DISCARD            0
 * </pre>
 */
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000870C)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OFFSET      0x0000870C
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_INDEX       0x000021C3
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_error_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_error_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_DMA_STATE_BIT    ((u32)0x08000000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_DMA_STATE_POS    27
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_CS_BIT    ((u32)0x04000000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_CS_POS    26
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_BIT    ((u32)0x02000000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_POS    25
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_BIT    ((u32)0x01000000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_POS    24
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_2_BIT    ((u32)0x00800000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_2_POS    23
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PHY_ERR_BIT    ((u32)0x00400000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PHY_ERR_POS    22
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_UNDER_RUN_BIT    ((u32)0x00200000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_UNDER_RUN_POS    21
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_UNEXPECTED_TX_END_BIT    ((u32)0x00100000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_UNEXPECTED_TX_END_POS    20
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_2_BIT    ((u32)0x00080000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_2_POS    19
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_DMA_DEAD_BIT    ((u32)0x00040000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_DMA_DEAD_POS    18
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_BCN_TX_DMA_DEAD_BIT    ((u32)0x00020000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_BCN_TX_DMA_DEAD_POS    17
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_3_TX_DMA_DEAD_BIT    ((u32)0x00010000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_3_TX_DMA_DEAD_POS    16
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_2_TX_DMA_DEAD_BIT    ((u32)0x00008000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_2_TX_DMA_DEAD_POS    15
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_1_TX_DMA_DEAD_BIT    ((u32)0x00004000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_1_TX_DMA_DEAD_POS    14
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_0_TX_DMA_DEAD_BIT    ((u32)0x00002000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_0_TX_DMA_DEAD_POS    13
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PT_ERROR_BIT    ((u32)0x00001000)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PT_ERROR_POS    12
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_DSSS_BIT    ((u32)0x00000400)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_DSSS_POS    10
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_OFDM_BIT    ((u32)0x00000200)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_OFDM_POS    9
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_FIFO_OVER_FLOW_BIT    ((u32)0x00000100)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_FIFO_OVER_FLOW_POS    8
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_EMPTY_BIT    ((u32)0x00000080)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_EMPTY_POS    7
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_OVERFLOW_BIT    ((u32)0x00000040)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_OVERFLOW_POS    6
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_DISCARD_BIT    ((u32)0x00000020)
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_DISCARD_POS    5

#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_DMA_STATE_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_FAILED_CS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_HEADER_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PHY_ERR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_UNDER_RUN_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_UNEXPECTED_TX_END_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_PAYLOAD_DMA_DEAD_2_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_HTP_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_BCN_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_3_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_2_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_1_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_AC_0_TX_DMA_DEAD_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_PT_ERROR_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_DSSS_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_OLBC_OFDM_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_FIFO_OVER_FLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_EMPTY_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_MAC_PHYIF_OVERFLOW_RST    0x0
#define MAC_HW_ERROR_INT_EVENT_EN_UMAC_RX_DMA_DISCARD_RST    0x0

static inline void mac_hw_error_int_event_en_umac_pack(struct cl_chip *chip, u8 htp_tx_failed_dma_state, u8 htp_tx_failed_cs, u8 rx_payload_dma_dead, u8 rx_header_dma_dead, u8 rx_header_dma_dead2, u8 phy_err, u8 mac_phyif_under_run, u8 unexpected_tx_end, u8 rx_payload_dma_dead2, u8 htp_tx_dma_dead, u8 bcn_tx_dma_dead, u8 ac_3_tx_dma_dead, u8 ac_2_tx_dma_dead, u8 ac_1_tx_dma_dead, u8 ac_0_tx_dma_dead, u8 pt_error, u8 olbc_dsss, u8 olbc_ofdm, u8 rx_fifo_over_flow, u8 rx_dma_empty, u8 mac_phyif_overflow, u8 rx_dma_discard)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_dma_state << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_failed_cs << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_header_dma_dead2 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_err << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_under_run << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)unexpected_tx_end << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_payload_dma_dead2 << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_dma_dead << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_dma_dead << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_dma_dead << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_dma_dead << 15) & ~((u32)0x00008000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_dma_dead << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_dma_dead << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)pt_error << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_dsss << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)olbc_ofdm << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_fifo_over_flow << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_empty << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)mac_phyif_overflow << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_dma_discard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, ((u32)htp_tx_failed_dma_state << 27) | ((u32)htp_tx_failed_cs << 26) | ((u32)rx_payload_dma_dead << 25) | ((u32)rx_header_dma_dead << 24) | ((u32)rx_header_dma_dead2 << 23) | ((u32)phy_err << 22) | ((u32)mac_phyif_under_run << 21) | ((u32)unexpected_tx_end << 20) | ((u32)rx_payload_dma_dead2 << 19) | ((u32)htp_tx_dma_dead << 18) | ((u32)bcn_tx_dma_dead << 17) | ((u32)ac_3_tx_dma_dead << 16) | ((u32)ac_2_tx_dma_dead << 15) | ((u32)ac_1_tx_dma_dead << 14) | ((u32)ac_0_tx_dma_dead << 13) | ((u32)pt_error << 12) | ((u32)olbc_dsss << 10) | ((u32)olbc_ofdm << 9) | ((u32)rx_fifo_over_flow << 8) | ((u32)rx_dma_empty << 7) | ((u32)mac_phyif_overflow << 6) | ((u32)rx_dma_discard << 5));
}

static inline void mac_hw_error_int_event_en_umac_unpack(struct cl_chip *chip, u8 *htp_tx_failed_dma_state, u8 *htp_tx_failed_cs, u8 *rx_payload_dma_dead, u8 *rx_header_dma_dead, u8 *rx_header_dma_dead2, u8 *phy_err, u8 *mac_phyif_under_run, u8 *unexpected_tx_end, u8 *rx_payload_dma_dead2, u8 *htp_tx_dma_dead, u8 *bcn_tx_dma_dead, u8 *ac_3_tx_dma_dead, u8 *ac_2_tx_dma_dead, u8 *ac_1_tx_dma_dead, u8 *ac_0_tx_dma_dead, u8 *pt_error, u8 *olbc_dsss, u8 *olbc_ofdm, u8 *rx_fifo_over_flow, u8 *rx_dma_empty, u8 *mac_phyif_overflow, u8 *rx_dma_discard)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	*htp_tx_failed_dma_state = (local_val & ((u32)0x08000000)) >> 27;
	*htp_tx_failed_cs = (local_val & ((u32)0x04000000)) >> 26;
	*rx_payload_dma_dead = (local_val & ((u32)0x02000000)) >> 25;
	*rx_header_dma_dead = (local_val & ((u32)0x01000000)) >> 24;
	*rx_header_dma_dead2 = (local_val & ((u32)0x00800000)) >> 23;
	*phy_err = (local_val & ((u32)0x00400000)) >> 22;
	*mac_phyif_under_run = (local_val & ((u32)0x00200000)) >> 21;
	*unexpected_tx_end = (local_val & ((u32)0x00100000)) >> 20;
	*rx_payload_dma_dead2 = (local_val & ((u32)0x00080000)) >> 19;
	*htp_tx_dma_dead = (local_val & ((u32)0x00040000)) >> 18;
	*bcn_tx_dma_dead = (local_val & ((u32)0x00020000)) >> 17;
	*ac_3_tx_dma_dead = (local_val & ((u32)0x00010000)) >> 16;
	*ac_2_tx_dma_dead = (local_val & ((u32)0x00008000)) >> 15;
	*ac_1_tx_dma_dead = (local_val & ((u32)0x00004000)) >> 14;
	*ac_0_tx_dma_dead = (local_val & ((u32)0x00002000)) >> 13;
	*pt_error = (local_val & ((u32)0x00001000)) >> 12;
	*olbc_dsss = (local_val & ((u32)0x00000400)) >> 10;
	*olbc_ofdm = (local_val & ((u32)0x00000200)) >> 9;
	*rx_fifo_over_flow = (local_val & ((u32)0x00000100)) >> 8;
	*rx_dma_empty = (local_val & ((u32)0x00000080)) >> 7;
	*mac_phyif_overflow = (local_val & ((u32)0x00000040)) >> 6;
	*rx_dma_discard = (local_val & ((u32)0x00000020)) >> 5;
}

static inline u8 mac_hw_error_int_event_en_umac_htp_tx_failed_dma_state_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_error_int_event_en_umac_htp_tx_failed_dma_state_setf(struct cl_chip *chip, u8 htptxfaileddmastate)
{
	ASSERT_ERR_CHIP((((u32)htptxfaileddmastate << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x08000000)) | ((u32)htptxfaileddmastate << 27));
}

static inline u8 mac_hw_error_int_event_en_umac_htp_tx_failed_cs_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_error_int_event_en_umac_htp_tx_failed_cs_setf(struct cl_chip *chip, u8 htptxfailedcs)
{
	ASSERT_ERR_CHIP((((u32)htptxfailedcs << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x04000000)) | ((u32)htptxfailedcs << 26));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_payload_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_error_int_event_en_umac_rx_payload_dma_dead_setf(struct cl_chip *chip, u8 rxpayloaddmadead)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x02000000)) | ((u32)rxpayloaddmadead << 25));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_header_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_error_int_event_en_umac_rx_header_dma_dead_setf(struct cl_chip *chip, u8 rxheaderdmadead)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x01000000)) | ((u32)rxheaderdmadead << 24));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_header_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_error_int_event_en_umac_rx_header_dma_dead_2_setf(struct cl_chip *chip, u8 rxheaderdmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxheaderdmadead2 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00800000)) | ((u32)rxheaderdmadead2 << 23));
}

static inline u8 mac_hw_error_int_event_en_umac_phy_err_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_error_int_event_en_umac_phy_err_setf(struct cl_chip *chip, u8 phyerr)
{
	ASSERT_ERR_CHIP((((u32)phyerr << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00400000)) | ((u32)phyerr << 22));
}

static inline u8 mac_hw_error_int_event_en_umac_mac_phyif_under_run_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_error_int_event_en_umac_mac_phyif_under_run_setf(struct cl_chip *chip, u8 macphyifunderrun)
{
	ASSERT_ERR_CHIP((((u32)macphyifunderrun << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00200000)) | ((u32)macphyifunderrun << 21));
}

static inline u8 mac_hw_error_int_event_en_umac_unexpected_tx_end_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_error_int_event_en_umac_unexpected_tx_end_setf(struct cl_chip *chip, u8 unexpectedtxend)
{
	ASSERT_ERR_CHIP((((u32)unexpectedtxend << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00100000)) | ((u32)unexpectedtxend << 20));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_payload_dma_dead_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_error_int_event_en_umac_rx_payload_dma_dead_2_setf(struct cl_chip *chip, u8 rxpayloaddmadead2)
{
	ASSERT_ERR_CHIP((((u32)rxpayloaddmadead2 << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00080000)) | ((u32)rxpayloaddmadead2 << 19));
}

static inline u8 mac_hw_error_int_event_en_umac_htp_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_error_int_event_en_umac_htp_tx_dma_dead_setf(struct cl_chip *chip, u8 htptxdmadead)
{
	ASSERT_ERR_CHIP((((u32)htptxdmadead << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00040000)) | ((u32)htptxdmadead << 18));
}

static inline u8 mac_hw_error_int_event_en_umac_bcn_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_error_int_event_en_umac_bcn_tx_dma_dead_setf(struct cl_chip *chip, u8 bcntxdmadead)
{
	ASSERT_ERR_CHIP((((u32)bcntxdmadead << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00020000)) | ((u32)bcntxdmadead << 17));
}

static inline u8 mac_hw_error_int_event_en_umac_ac_3_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_error_int_event_en_umac_ac_3_tx_dma_dead_setf(struct cl_chip *chip, u8 ac3txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac3txdmadead << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00010000)) | ((u32)ac3txdmadead << 16));
}

static inline u8 mac_hw_error_int_event_en_umac_ac_2_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00008000)) >> 15);
}

static inline void mac_hw_error_int_event_en_umac_ac_2_tx_dma_dead_setf(struct cl_chip *chip, u8 ac2txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac2txdmadead << 15) & ~((u32)0x00008000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00008000)) | ((u32)ac2txdmadead << 15));
}

static inline u8 mac_hw_error_int_event_en_umac_ac_1_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_error_int_event_en_umac_ac_1_tx_dma_dead_setf(struct cl_chip *chip, u8 ac1txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac1txdmadead << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00004000)) | ((u32)ac1txdmadead << 14));
}

static inline u8 mac_hw_error_int_event_en_umac_ac_0_tx_dma_dead_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_error_int_event_en_umac_ac_0_tx_dma_dead_setf(struct cl_chip *chip, u8 ac0txdmadead)
{
	ASSERT_ERR_CHIP((((u32)ac0txdmadead << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac0txdmadead << 13));
}

static inline u8 mac_hw_error_int_event_en_umac_pt_error_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_error_int_event_en_umac_pt_error_setf(struct cl_chip *chip, u8 pterror)
{
	ASSERT_ERR_CHIP((((u32)pterror << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00001000)) | ((u32)pterror << 12));
}

static inline u8 mac_hw_error_int_event_en_umac_olbc_dsss_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_error_int_event_en_umac_olbc_dsss_setf(struct cl_chip *chip, u8 olbcdsss)
{
	ASSERT_ERR_CHIP((((u32)olbcdsss << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000400)) | ((u32)olbcdsss << 10));
}

static inline u8 mac_hw_error_int_event_en_umac_olbc_ofdm_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_error_int_event_en_umac_olbc_ofdm_setf(struct cl_chip *chip, u8 olbcofdm)
{
	ASSERT_ERR_CHIP((((u32)olbcofdm << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000200)) | ((u32)olbcofdm << 9));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_fifo_over_flow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_error_int_event_en_umac_rx_fifo_over_flow_setf(struct cl_chip *chip, u8 rxfifooverflow)
{
	ASSERT_ERR_CHIP((((u32)rxfifooverflow << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rxfifooverflow << 8));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_dma_empty_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_error_int_event_en_umac_rx_dma_empty_setf(struct cl_chip *chip, u8 rxdmaempty)
{
	ASSERT_ERR_CHIP((((u32)rxdmaempty << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000080)) | ((u32)rxdmaempty << 7));
}

static inline u8 mac_hw_error_int_event_en_umac_mac_phyif_overflow_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_error_int_event_en_umac_mac_phyif_overflow_setf(struct cl_chip *chip, u8 macphyifoverflow)
{
	ASSERT_ERR_CHIP((((u32)macphyifoverflow << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000040)) | ((u32)macphyifoverflow << 6));
}

static inline u8 mac_hw_error_int_event_en_umac_rx_dma_discard_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_error_int_event_en_umac_rx_dma_discard_setf(struct cl_chip *chip, u8 rxdmadiscard)
{
	ASSERT_ERR_CHIP((((u32)rxdmadiscard << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_ERROR_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxdmadiscard << 5));
}

/**
 * @brief GEN_INT_EVENT_STATUS_LMAC register definition
 *  General interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008710)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_OFFSET      0x00008710
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_INDEX       0x000021C4
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_status_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_STATUS_LMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_status_lmac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_status_lmac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline u8 mac_hw_gen_int_event_status_lmac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_gen_int_event_status_lmac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_gen_int_event_status_lmac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_gen_int_event_status_lmac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_gen_int_event_status_lmac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_gen_int_event_status_lmac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_gen_int_event_status_lmac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_gen_int_event_status_lmac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief GEN_INT_EVENT_CLEAR register definition
 *  General interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008714)
#define MAC_HW_GEN_INT_EVENT_CLEAR_OFFSET      0x00008714
#define MAC_HW_GEN_INT_EVENT_CLEAR_INDEX       0x000021C5
#define MAC_HW_GEN_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_gen_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_CLEAR_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_CLEAR_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_CLEAR_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_CLEAR_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_CLEAR_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_CLEAR_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_CLEAR_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_CLEAR_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_clear_pack(struct cl_chip *chip, u8 ul_bss_color_collision, u8 dl_bss_color_collision, u8 abs_timers_9, u8 abs_timers_8, u8 abs_timers_7, u8 abs_timers_6, u8 abs_timers_5, u8 abs_timers_4, u8 abs_timers_3, u8 abs_timers_2, u8 abs_timers_1, u8 abs_timers_0, u8 imp_sec_dtim, u8 imp_pri_dtim, u8 tim_set, u8 idle_interrupt, u8 imp_sec_tbtt, u8 imp_pri_tbtt)
{
	ASSERT_ERR_CHIP((((u32)ul_bss_color_collision << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dl_bss_color_collision << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_9 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_8 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_7 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_6 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_5 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_4 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_3 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_1 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_0 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_dtim << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_dtim << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_set << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)idle_interrupt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_tbtt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_tbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, ((u32)ul_bss_color_collision << 31) | ((u32)dl_bss_color_collision << 30) | ((u32)abs_timers_9 << 29) | ((u32)abs_timers_8 << 28) | ((u32)abs_timers_7 << 27) | ((u32)abs_timers_6 << 26) | ((u32)abs_timers_5 << 25) | ((u32)abs_timers_4 << 24) | ((u32)abs_timers_3 << 23) | ((u32)abs_timers_2 << 22) | ((u32)abs_timers_1 << 21) | ((u32)abs_timers_0 << 20) | ((u32)imp_sec_dtim << 19) | ((u32)imp_pri_dtim << 18) | ((u32)tim_set << 11) | ((u32)idle_interrupt << 2) | ((u32)imp_sec_tbtt << 1) | ((u32)imp_pri_tbtt << 0));
}

static inline void mac_hw_gen_int_event_clear_ul_bss_color_collision_setf(struct cl_chip *chip, u8 ulbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)ulbsscolorcollision << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x80000000)) | ((u32)ulbsscolorcollision << 31));
}

static inline void mac_hw_gen_int_event_clear_dl_bss_color_collision_setf(struct cl_chip *chip, u8 dlbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)dlbsscolorcollision << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x40000000)) | ((u32)dlbsscolorcollision << 30));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_9_setf(struct cl_chip *chip, u8 abstimers9)
{
	ASSERT_ERR_CHIP((((u32)abstimers9 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x20000000)) | ((u32)abstimers9 << 29));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_8_setf(struct cl_chip *chip, u8 abstimers8)
{
	ASSERT_ERR_CHIP((((u32)abstimers8 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x10000000)) | ((u32)abstimers8 << 28));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_7_setf(struct cl_chip *chip, u8 abstimers7)
{
	ASSERT_ERR_CHIP((((u32)abstimers7 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x08000000)) | ((u32)abstimers7 << 27));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_6_setf(struct cl_chip *chip, u8 abstimers6)
{
	ASSERT_ERR_CHIP((((u32)abstimers6 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x04000000)) | ((u32)abstimers6 << 26));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_5_setf(struct cl_chip *chip, u8 abstimers5)
{
	ASSERT_ERR_CHIP((((u32)abstimers5 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x02000000)) | ((u32)abstimers5 << 25));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_4_setf(struct cl_chip *chip, u8 abstimers4)
{
	ASSERT_ERR_CHIP((((u32)abstimers4 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x01000000)) | ((u32)abstimers4 << 24));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_3_setf(struct cl_chip *chip, u8 abstimers3)
{
	ASSERT_ERR_CHIP((((u32)abstimers3 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00800000)) | ((u32)abstimers3 << 23));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_2_setf(struct cl_chip *chip, u8 abstimers2)
{
	ASSERT_ERR_CHIP((((u32)abstimers2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00400000)) | ((u32)abstimers2 << 22));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_1_setf(struct cl_chip *chip, u8 abstimers1)
{
	ASSERT_ERR_CHIP((((u32)abstimers1 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00200000)) | ((u32)abstimers1 << 21));
}

static inline void mac_hw_gen_int_event_clear_abs_timers_0_setf(struct cl_chip *chip, u8 abstimers0)
{
	ASSERT_ERR_CHIP((((u32)abstimers0 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00100000)) | ((u32)abstimers0 << 20));
}

static inline void mac_hw_gen_int_event_clear_imp_sec_dtim_setf(struct cl_chip *chip, u8 impsecdtim)
{
	ASSERT_ERR_CHIP((((u32)impsecdtim << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00080000)) | ((u32)impsecdtim << 19));
}

static inline void mac_hw_gen_int_event_clear_imp_pri_dtim_setf(struct cl_chip *chip, u8 imppridtim)
{
	ASSERT_ERR_CHIP((((u32)imppridtim << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00040000)) | ((u32)imppridtim << 18));
}

static inline void mac_hw_gen_int_event_clear_tim_set_setf(struct cl_chip *chip, u8 timset)
{
	ASSERT_ERR_CHIP((((u32)timset << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000800)) | ((u32)timset << 11));
}

static inline void mac_hw_gen_int_event_clear_idle_interrupt_setf(struct cl_chip *chip, u8 idleinterrupt)
{
	ASSERT_ERR_CHIP((((u32)idleinterrupt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000004)) | ((u32)idleinterrupt << 2));
}

static inline void mac_hw_gen_int_event_clear_imp_sec_tbtt_setf(struct cl_chip *chip, u8 impsectbtt)
{
	ASSERT_ERR_CHIP((((u32)impsectbtt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000002)) | ((u32)impsectbtt << 1));
}

static inline void mac_hw_gen_int_event_clear_imp_pri_tbtt_setf(struct cl_chip *chip, u8 imppritbtt)
{
	ASSERT_ERR_CHIP((((u32)imppritbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000001)) | ((u32)imppritbtt << 0));
}

/**
 * @brief GEN_INT_EVENT_EN_LMAC register definition
 *  General interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008718)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_OFFSET      0x00008718
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_INDEX       0x000021C6
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_gen_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_EN_LMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_LMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_en_lmac_pack(struct cl_chip *chip, u8 ul_bss_color_collision, u8 dl_bss_color_collision, u8 abs_timers_9, u8 abs_timers_8, u8 abs_timers_7, u8 abs_timers_6, u8 abs_timers_5, u8 abs_timers_4, u8 abs_timers_3, u8 abs_timers_2, u8 abs_timers_1, u8 abs_timers_0, u8 imp_sec_dtim, u8 imp_pri_dtim, u8 tim_set, u8 idle_interrupt, u8 imp_sec_tbtt, u8 imp_pri_tbtt)
{
	ASSERT_ERR_CHIP((((u32)ul_bss_color_collision << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dl_bss_color_collision << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_9 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_8 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_7 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_6 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_5 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_4 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_3 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_1 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_0 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_dtim << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_dtim << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_set << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)idle_interrupt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_tbtt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_tbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, ((u32)ul_bss_color_collision << 31) | ((u32)dl_bss_color_collision << 30) | ((u32)abs_timers_9 << 29) | ((u32)abs_timers_8 << 28) | ((u32)abs_timers_7 << 27) | ((u32)abs_timers_6 << 26) | ((u32)abs_timers_5 << 25) | ((u32)abs_timers_4 << 24) | ((u32)abs_timers_3 << 23) | ((u32)abs_timers_2 << 22) | ((u32)abs_timers_1 << 21) | ((u32)abs_timers_0 << 20) | ((u32)imp_sec_dtim << 19) | ((u32)imp_pri_dtim << 18) | ((u32)tim_set << 11) | ((u32)idle_interrupt << 2) | ((u32)imp_sec_tbtt << 1) | ((u32)imp_pri_tbtt << 0));
}

static inline void mac_hw_gen_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_en_lmac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_gen_int_event_en_lmac_ul_bss_color_collision_setf(struct cl_chip *chip, u8 ulbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)ulbsscolorcollision << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x80000000)) | ((u32)ulbsscolorcollision << 31));
}

static inline u8 mac_hw_gen_int_event_en_lmac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_gen_int_event_en_lmac_dl_bss_color_collision_setf(struct cl_chip *chip, u8 dlbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)dlbsscolorcollision << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x40000000)) | ((u32)dlbsscolorcollision << 30));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_9_setf(struct cl_chip *chip, u8 abstimers9)
{
	ASSERT_ERR_CHIP((((u32)abstimers9 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x20000000)) | ((u32)abstimers9 << 29));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_8_setf(struct cl_chip *chip, u8 abstimers8)
{
	ASSERT_ERR_CHIP((((u32)abstimers8 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x10000000)) | ((u32)abstimers8 << 28));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_7_setf(struct cl_chip *chip, u8 abstimers7)
{
	ASSERT_ERR_CHIP((((u32)abstimers7 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x08000000)) | ((u32)abstimers7 << 27));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_6_setf(struct cl_chip *chip, u8 abstimers6)
{
	ASSERT_ERR_CHIP((((u32)abstimers6 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x04000000)) | ((u32)abstimers6 << 26));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_5_setf(struct cl_chip *chip, u8 abstimers5)
{
	ASSERT_ERR_CHIP((((u32)abstimers5 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x02000000)) | ((u32)abstimers5 << 25));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_4_setf(struct cl_chip *chip, u8 abstimers4)
{
	ASSERT_ERR_CHIP((((u32)abstimers4 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x01000000)) | ((u32)abstimers4 << 24));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_3_setf(struct cl_chip *chip, u8 abstimers3)
{
	ASSERT_ERR_CHIP((((u32)abstimers3 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00800000)) | ((u32)abstimers3 << 23));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_2_setf(struct cl_chip *chip, u8 abstimers2)
{
	ASSERT_ERR_CHIP((((u32)abstimers2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00400000)) | ((u32)abstimers2 << 22));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_1_setf(struct cl_chip *chip, u8 abstimers1)
{
	ASSERT_ERR_CHIP((((u32)abstimers1 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00200000)) | ((u32)abstimers1 << 21));
}

static inline u8 mac_hw_gen_int_event_en_lmac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_gen_int_event_en_lmac_abs_timers_0_setf(struct cl_chip *chip, u8 abstimers0)
{
	ASSERT_ERR_CHIP((((u32)abstimers0 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00100000)) | ((u32)abstimers0 << 20));
}

static inline u8 mac_hw_gen_int_event_en_lmac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_gen_int_event_en_lmac_imp_sec_dtim_setf(struct cl_chip *chip, u8 impsecdtim)
{
	ASSERT_ERR_CHIP((((u32)impsecdtim << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00080000)) | ((u32)impsecdtim << 19));
}

static inline u8 mac_hw_gen_int_event_en_lmac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_gen_int_event_en_lmac_imp_pri_dtim_setf(struct cl_chip *chip, u8 imppridtim)
{
	ASSERT_ERR_CHIP((((u32)imppridtim << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00040000)) | ((u32)imppridtim << 18));
}

static inline u8 mac_hw_gen_int_event_en_lmac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_gen_int_event_en_lmac_tim_set_setf(struct cl_chip *chip, u8 timset)
{
	ASSERT_ERR_CHIP((((u32)timset << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000800)) | ((u32)timset << 11));
}

static inline u8 mac_hw_gen_int_event_en_lmac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_gen_int_event_en_lmac_idle_interrupt_setf(struct cl_chip *chip, u8 idleinterrupt)
{
	ASSERT_ERR_CHIP((((u32)idleinterrupt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000004)) | ((u32)idleinterrupt << 2));
}

static inline u8 mac_hw_gen_int_event_en_lmac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_gen_int_event_en_lmac_imp_sec_tbtt_setf(struct cl_chip *chip, u8 impsectbtt)
{
	ASSERT_ERR_CHIP((((u32)impsectbtt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000002)) | ((u32)impsectbtt << 1));
}

static inline u8 mac_hw_gen_int_event_en_lmac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_gen_int_event_en_lmac_imp_pri_tbtt_setf(struct cl_chip *chip, u8 imppritbtt)
{
	ASSERT_ERR_CHIP((((u32)imppritbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000001)) | ((u32)imppritbtt << 0));
}

/**
 * @brief GEN_INT_EVENT_EN_UMAC register definition
 *  General interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    31    UL_BSS_COLOR_COLLISION    0
 *    30    DL_BSS_COLOR_COLLISION    0
 *    29    ABS_TIMERS_9              0
 *    28    ABS_TIMERS_8              0
 *    27    ABS_TIMERS_7              0
 *    26    ABS_TIMERS_6              0
 *    25    ABS_TIMERS_5              0
 *    24    ABS_TIMERS_4              0
 *    23    ABS_TIMERS_3              0
 *    22    ABS_TIMERS_2              0
 *    21    ABS_TIMERS_1              0
 *    20    ABS_TIMERS_0              0
 *    19    IMP_SEC_DTIM              0
 *    18    IMP_PRI_DTIM              0
 *    11    TIM_SET                   0
 *    02    IDLE_INTERRUPT            0
 *    01    IMP_SEC_TBTT              0
 *    00    IMP_PRI_TBTT              0
 * </pre>
 */
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000871C)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_OFFSET      0x0000871C
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_INDEX       0x000021C7
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_gen_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_gen_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_UL_BSS_COLOR_COLLISION_BIT    ((u32)0x80000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_UL_BSS_COLOR_COLLISION_POS    31
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_DL_BSS_COLOR_COLLISION_BIT    ((u32)0x40000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_DL_BSS_COLOR_COLLISION_POS    30
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_9_BIT    ((u32)0x20000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_9_POS    29
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_8_BIT    ((u32)0x10000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_8_POS    28
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_7_BIT    ((u32)0x08000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_7_POS    27
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_6_BIT    ((u32)0x04000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_6_POS    26
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_5_BIT    ((u32)0x02000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_5_POS    25
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_4_BIT    ((u32)0x01000000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_4_POS    24
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_3_BIT    ((u32)0x00800000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_3_POS    23
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_2_BIT    ((u32)0x00400000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_2_POS    22
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_1_BIT    ((u32)0x00200000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_1_POS    21
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_0_BIT    ((u32)0x00100000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_0_POS    20
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_DTIM_BIT    ((u32)0x00080000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_DTIM_POS    19
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_DTIM_BIT    ((u32)0x00040000)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_DTIM_POS    18
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_TIM_SET_BIT    ((u32)0x00000800)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_TIM_SET_POS    11
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IDLE_INTERRUPT_BIT    ((u32)0x00000004)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IDLE_INTERRUPT_POS    2
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_TBTT_BIT    ((u32)0x00000002)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_TBTT_POS    1
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_TBTT_BIT    ((u32)0x00000001)
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_TBTT_POS    0

#define MAC_HW_GEN_INT_EVENT_EN_UMAC_UL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_DL_BSS_COLOR_COLLISION_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_9_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_8_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_7_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_6_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_5_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_4_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_3_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_2_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_1_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_ABS_TIMERS_0_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_DTIM_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_TIM_SET_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IDLE_INTERRUPT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_SEC_TBTT_RST    0x0
#define MAC_HW_GEN_INT_EVENT_EN_UMAC_IMP_PRI_TBTT_RST    0x0

static inline void mac_hw_gen_int_event_en_umac_pack(struct cl_chip *chip, u8 ul_bss_color_collision, u8 dl_bss_color_collision, u8 abs_timers_9, u8 abs_timers_8, u8 abs_timers_7, u8 abs_timers_6, u8 abs_timers_5, u8 abs_timers_4, u8 abs_timers_3, u8 abs_timers_2, u8 abs_timers_1, u8 abs_timers_0, u8 imp_sec_dtim, u8 imp_pri_dtim, u8 tim_set, u8 idle_interrupt, u8 imp_sec_tbtt, u8 imp_pri_tbtt)
{
	ASSERT_ERR_CHIP((((u32)ul_bss_color_collision << 31) & ~((u32)0x80000000)) == 0);
	ASSERT_ERR_CHIP((((u32)dl_bss_color_collision << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_9 << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_8 << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_7 << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_6 << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_5 << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_4 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_3 << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_1 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)abs_timers_0 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_dtim << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_dtim << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)tim_set << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)idle_interrupt << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_sec_tbtt << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)imp_pri_tbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, ((u32)ul_bss_color_collision << 31) | ((u32)dl_bss_color_collision << 30) | ((u32)abs_timers_9 << 29) | ((u32)abs_timers_8 << 28) | ((u32)abs_timers_7 << 27) | ((u32)abs_timers_6 << 26) | ((u32)abs_timers_5 << 25) | ((u32)abs_timers_4 << 24) | ((u32)abs_timers_3 << 23) | ((u32)abs_timers_2 << 22) | ((u32)abs_timers_1 << 21) | ((u32)abs_timers_0 << 20) | ((u32)imp_sec_dtim << 19) | ((u32)imp_pri_dtim << 18) | ((u32)tim_set << 11) | ((u32)idle_interrupt << 2) | ((u32)imp_sec_tbtt << 1) | ((u32)imp_pri_tbtt << 0));
}

static inline void mac_hw_gen_int_event_en_umac_unpack(struct cl_chip *chip, u8 *ul_bss_color_collision, u8 *dl_bss_color_collision, u8 *abs_timers_9, u8 *abs_timers_8, u8 *abs_timers_7, u8 *abs_timers_6, u8 *abs_timers_5, u8 *abs_timers_4, u8 *abs_timers_3, u8 *abs_timers_2, u8 *abs_timers_1, u8 *abs_timers_0, u8 *imp_sec_dtim, u8 *imp_pri_dtim, u8 *tim_set, u8 *idle_interrupt, u8 *imp_sec_tbtt, u8 *imp_pri_tbtt)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	*ul_bss_color_collision = (local_val & ((u32)0x80000000)) >> 31;
	*dl_bss_color_collision = (local_val & ((u32)0x40000000)) >> 30;
	*abs_timers_9 = (local_val & ((u32)0x20000000)) >> 29;
	*abs_timers_8 = (local_val & ((u32)0x10000000)) >> 28;
	*abs_timers_7 = (local_val & ((u32)0x08000000)) >> 27;
	*abs_timers_6 = (local_val & ((u32)0x04000000)) >> 26;
	*abs_timers_5 = (local_val & ((u32)0x02000000)) >> 25;
	*abs_timers_4 = (local_val & ((u32)0x01000000)) >> 24;
	*abs_timers_3 = (local_val & ((u32)0x00800000)) >> 23;
	*abs_timers_2 = (local_val & ((u32)0x00400000)) >> 22;
	*abs_timers_1 = (local_val & ((u32)0x00200000)) >> 21;
	*abs_timers_0 = (local_val & ((u32)0x00100000)) >> 20;
	*imp_sec_dtim = (local_val & ((u32)0x00080000)) >> 19;
	*imp_pri_dtim = (local_val & ((u32)0x00040000)) >> 18;
	*tim_set = (local_val & ((u32)0x00000800)) >> 11;
	*idle_interrupt = (local_val & ((u32)0x00000004)) >> 2;
	*imp_sec_tbtt = (local_val & ((u32)0x00000002)) >> 1;
	*imp_pri_tbtt = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_gen_int_event_en_umac_ul_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x80000000)) >> 31);
}

static inline void mac_hw_gen_int_event_en_umac_ul_bss_color_collision_setf(struct cl_chip *chip, u8 ulbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)ulbsscolorcollision << 31) & ~((u32)0x80000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x80000000)) | ((u32)ulbsscolorcollision << 31));
}

static inline u8 mac_hw_gen_int_event_en_umac_dl_bss_color_collision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_gen_int_event_en_umac_dl_bss_color_collision_setf(struct cl_chip *chip, u8 dlbsscolorcollision)
{
	ASSERT_ERR_CHIP((((u32)dlbsscolorcollision << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x40000000)) | ((u32)dlbsscolorcollision << 30));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_9_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_9_setf(struct cl_chip *chip, u8 abstimers9)
{
	ASSERT_ERR_CHIP((((u32)abstimers9 << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x20000000)) | ((u32)abstimers9 << 29));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_8_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_8_setf(struct cl_chip *chip, u8 abstimers8)
{
	ASSERT_ERR_CHIP((((u32)abstimers8 << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x10000000)) | ((u32)abstimers8 << 28));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_7_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_7_setf(struct cl_chip *chip, u8 abstimers7)
{
	ASSERT_ERR_CHIP((((u32)abstimers7 << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x08000000)) | ((u32)abstimers7 << 27));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_6_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_6_setf(struct cl_chip *chip, u8 abstimers6)
{
	ASSERT_ERR_CHIP((((u32)abstimers6 << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x04000000)) | ((u32)abstimers6 << 26));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_5_setf(struct cl_chip *chip, u8 abstimers5)
{
	ASSERT_ERR_CHIP((((u32)abstimers5 << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x02000000)) | ((u32)abstimers5 << 25));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_4_setf(struct cl_chip *chip, u8 abstimers4)
{
	ASSERT_ERR_CHIP((((u32)abstimers4 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x01000000)) | ((u32)abstimers4 << 24));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_3_setf(struct cl_chip *chip, u8 abstimers3)
{
	ASSERT_ERR_CHIP((((u32)abstimers3 << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00800000)) | ((u32)abstimers3 << 23));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_2_setf(struct cl_chip *chip, u8 abstimers2)
{
	ASSERT_ERR_CHIP((((u32)abstimers2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00400000)) | ((u32)abstimers2 << 22));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_1_setf(struct cl_chip *chip, u8 abstimers1)
{
	ASSERT_ERR_CHIP((((u32)abstimers1 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00200000)) | ((u32)abstimers1 << 21));
}

static inline u8 mac_hw_gen_int_event_en_umac_abs_timers_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_gen_int_event_en_umac_abs_timers_0_setf(struct cl_chip *chip, u8 abstimers0)
{
	ASSERT_ERR_CHIP((((u32)abstimers0 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00100000)) | ((u32)abstimers0 << 20));
}

static inline u8 mac_hw_gen_int_event_en_umac_imp_sec_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_gen_int_event_en_umac_imp_sec_dtim_setf(struct cl_chip *chip, u8 impsecdtim)
{
	ASSERT_ERR_CHIP((((u32)impsecdtim << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00080000)) | ((u32)impsecdtim << 19));
}

static inline u8 mac_hw_gen_int_event_en_umac_imp_pri_dtim_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_gen_int_event_en_umac_imp_pri_dtim_setf(struct cl_chip *chip, u8 imppridtim)
{
	ASSERT_ERR_CHIP((((u32)imppridtim << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00040000)) | ((u32)imppridtim << 18));
}

static inline u8 mac_hw_gen_int_event_en_umac_tim_set_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_gen_int_event_en_umac_tim_set_setf(struct cl_chip *chip, u8 timset)
{
	ASSERT_ERR_CHIP((((u32)timset << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000800)) | ((u32)timset << 11));
}

static inline u8 mac_hw_gen_int_event_en_umac_idle_interrupt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_gen_int_event_en_umac_idle_interrupt_setf(struct cl_chip *chip, u8 idleinterrupt)
{
	ASSERT_ERR_CHIP((((u32)idleinterrupt << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000004)) | ((u32)idleinterrupt << 2));
}

static inline u8 mac_hw_gen_int_event_en_umac_imp_sec_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_gen_int_event_en_umac_imp_sec_tbtt_setf(struct cl_chip *chip, u8 impsectbtt)
{
	ASSERT_ERR_CHIP((((u32)impsectbtt << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000002)) | ((u32)impsectbtt << 1));
}

static inline u8 mac_hw_gen_int_event_en_umac_imp_pri_tbtt_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_gen_int_event_en_umac_imp_pri_tbtt_setf(struct cl_chip *chip, u8 imppritbtt)
{
	ASSERT_ERR_CHIP((((u32)imppritbtt << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_GEN_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000001)) | ((u32)imppritbtt << 0));
}

/**
 * @brief HIGH_PRI_INT_EVENT_STA_LMAC register definition
 *  High pri interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008720)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_OFFSET      0x00008720
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_INDEX       0x000021C8
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_sta_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_sta_lmac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_high_pri_int_event_sta_lmac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_STA_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief HIGH_PRI_INT_EVENT_CLEAR register definition
 *  High priority interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008724)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_OFFSET      0x00008724
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_INDEX       0x000021C9
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_high_pri_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_clear_pack(struct cl_chip *chip, u8 tx_htp_ampdu_und, u8 tx_ac3_ampdu_und, u8 tx_ac2_ampdu_und, u8 tx_ac1_ampdu_und, u8 tx_ac0_ampdu_und, u8 sw_rts_success, u8 ac3_tx_bw_decision, u8 ac2_tx_bw_decision, u8 ac1_tx_bw_decision, u8 ac0_tx_bw_decision, u8 htp_tx_bw_decision, u8 bfr_resp_cancelled, u8 end_of_ppdu, u8 need_response, u8 rd_prot_trigger, u8 hcca_prot_trigger, u8 ac_3_prot_trigger, u8 ac_2_prot_trigger, u8 ac_1_prot_trigger, u8 ac_0_prot_trigger)
{
	ASSERT_ERR_CHIP((((u32)tx_htp_ampdu_und << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac3_ampdu_und << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac2_ampdu_und << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac1_ampdu_und << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac0_ampdu_und << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_rts_success << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac3_tx_bw_decision << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac2_tx_bw_decision << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac1_tx_bw_decision << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ac0_tx_bw_decision << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_bw_decision << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_resp_cancelled << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)end_of_ppdu << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)need_response << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_prot_trigger << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_prot_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_prot_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_prot_trigger << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_prot_trigger << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_prot_trigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, ((u32)tx_htp_ampdu_und << 30) | ((u32)tx_ac3_ampdu_und << 29) | ((u32)tx_ac2_ampdu_und << 28) | ((u32)tx_ac1_ampdu_und << 27) | ((u32)tx_ac0_ampdu_und << 26) | ((u32)sw_rts_success << 14) | ((u32)ac3_tx_bw_decision << 13) | ((u32)ac2_tx_bw_decision << 12) | ((u32)ac1_tx_bw_decision << 11) | ((u32)ac0_tx_bw_decision << 10) | ((u32)htp_tx_bw_decision << 9) | ((u32)bfr_resp_cancelled << 8) | ((u32)end_of_ppdu << 7) | ((u32)need_response << 6) | ((u32)rd_prot_trigger << 5) | ((u32)hcca_prot_trigger << 4) | ((u32)ac_3_prot_trigger << 3) | ((u32)ac_2_prot_trigger << 2) | ((u32)ac_1_prot_trigger << 1) | ((u32)ac_0_prot_trigger << 0));
}

static inline void mac_hw_high_pri_int_event_clear_tx_htp_ampdu_und_setf(struct cl_chip *chip, u8 txhtpampduund)
{
	ASSERT_ERR_CHIP((((u32)txhtpampduund << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x40000000)) | ((u32)txhtpampduund << 30));
}

static inline void mac_hw_high_pri_int_event_clear_tx_ac_3_ampdu_und_setf(struct cl_chip *chip, u8 txac3ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac3ampduund << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x20000000)) | ((u32)txac3ampduund << 29));
}

static inline void mac_hw_high_pri_int_event_clear_tx_ac_2_ampdu_und_setf(struct cl_chip *chip, u8 txac2ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac2ampduund << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x10000000)) | ((u32)txac2ampduund << 28));
}

static inline void mac_hw_high_pri_int_event_clear_tx_ac_1_ampdu_und_setf(struct cl_chip *chip, u8 txac1ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac1ampduund << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x08000000)) | ((u32)txac1ampduund << 27));
}

static inline void mac_hw_high_pri_int_event_clear_tx_ac_0_ampdu_und_setf(struct cl_chip *chip, u8 txac0ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac0ampduund << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x04000000)) | ((u32)txac0ampduund << 26));
}

static inline void mac_hw_high_pri_int_event_clear_sw_rts_success_setf(struct cl_chip *chip, u8 swrtssuccess)
{
	ASSERT_ERR_CHIP((((u32)swrtssuccess << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00004000)) | ((u32)swrtssuccess << 14));
}

static inline void mac_hw_high_pri_int_event_clear_ac_3_tx_bw_decision_setf(struct cl_chip *chip, u8 ac3txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac3txbwdecision << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00002000)) | ((u32)ac3txbwdecision << 13));
}

static inline void mac_hw_high_pri_int_event_clear_ac_2_tx_bw_decision_setf(struct cl_chip *chip, u8 ac2txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac2txbwdecision << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00001000)) | ((u32)ac2txbwdecision << 12));
}

static inline void mac_hw_high_pri_int_event_clear_ac_1_tx_bw_decision_setf(struct cl_chip *chip, u8 ac1txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac1txbwdecision << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000800)) | ((u32)ac1txbwdecision << 11));
}

static inline void mac_hw_high_pri_int_event_clear_ac_0_tx_bw_decision_setf(struct cl_chip *chip, u8 ac0txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac0txbwdecision << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000400)) | ((u32)ac0txbwdecision << 10));
}

static inline void mac_hw_high_pri_int_event_clear_htp_tx_bw_decision_setf(struct cl_chip *chip, u8 htptxbwdecision)
{
	ASSERT_ERR_CHIP((((u32)htptxbwdecision << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000200)) | ((u32)htptxbwdecision << 9));
}

static inline void mac_hw_high_pri_int_event_clear_bfr_resp_cancelled_setf(struct cl_chip *chip, u8 bfrrespcancelled)
{
	ASSERT_ERR_CHIP((((u32)bfrrespcancelled << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000100)) | ((u32)bfrrespcancelled << 8));
}

static inline void mac_hw_high_pri_int_event_clear_end_of_ppdu_setf(struct cl_chip *chip, u8 endofppdu)
{
	ASSERT_ERR_CHIP((((u32)endofppdu << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000080)) | ((u32)endofppdu << 7));
}

static inline void mac_hw_high_pri_int_event_clear_need_response_setf(struct cl_chip *chip, u8 needresponse)
{
	ASSERT_ERR_CHIP((((u32)needresponse << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000040)) | ((u32)needresponse << 6));
}

static inline void mac_hw_high_pri_int_event_clear_rd_prot_trigger_setf(struct cl_chip *chip, u8 rdprottrigger)
{
	ASSERT_ERR_CHIP((((u32)rdprottrigger << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000020)) | ((u32)rdprottrigger << 5));
}

static inline void mac_hw_high_pri_int_event_clear_hcca_prot_trigger_setf(struct cl_chip *chip, u8 hccaprottrigger)
{
	ASSERT_ERR_CHIP((((u32)hccaprottrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000010)) | ((u32)hccaprottrigger << 4));
}

static inline void mac_hw_high_pri_int_event_clear_ac_3_prot_trigger_setf(struct cl_chip *chip, u8 ac3prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3prottrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000008)) | ((u32)ac3prottrigger << 3));
}

static inline void mac_hw_high_pri_int_event_clear_ac_2_prot_trigger_setf(struct cl_chip *chip, u8 ac2prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2prottrigger << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000004)) | ((u32)ac2prottrigger << 2));
}

static inline void mac_hw_high_pri_int_event_clear_ac_1_prot_trigger_setf(struct cl_chip *chip, u8 ac1prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1prottrigger << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000002)) | ((u32)ac1prottrigger << 1));
}

static inline void mac_hw_high_pri_int_event_clear_ac_0_prot_trigger_setf(struct cl_chip *chip, u8 ac0prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0prottrigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000001)) | ((u32)ac0prottrigger << 0));
}

/**
 * @brief HIGH_PRI_INT_EVENT_EN_LMAC register definition
 *  High priority interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008728)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_OFFSET      0x00008728
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_INDEX       0x000021CA
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_high_pri_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_en_lmac_pack(struct cl_chip *chip, u8 tx_htp_ampdu_und, u8 tx_ac3_ampdu_und, u8 tx_ac2_ampdu_und, u8 tx_ac1_ampdu_und, u8 tx_ac0_ampdu_und, u8 sw_rts_success, u8 ac3_tx_bw_decision, u8 ac2_tx_bw_decision, u8 ac1_tx_bw_decision, u8 ac0_tx_bw_decision, u8 htp_tx_bw_decision, u8 bfr_resp_cancelled, u8 end_of_ppdu, u8 need_response, u8 rd_prot_trigger, u8 hcca_prot_trigger, u8 ac_3_prot_trigger, u8 ac_2_prot_trigger, u8 ac_1_prot_trigger, u8 ac_0_prot_trigger)
{
	ASSERT_ERR_CHIP((((u32)tx_htp_ampdu_und << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac3_ampdu_und << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac2_ampdu_und << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac1_ampdu_und << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac0_ampdu_und << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_rts_success << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac3_tx_bw_decision << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac2_tx_bw_decision << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac1_tx_bw_decision << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ac0_tx_bw_decision << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_bw_decision << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_resp_cancelled << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)end_of_ppdu << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)need_response << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_prot_trigger << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_prot_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_prot_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_prot_trigger << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_prot_trigger << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_prot_trigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, ((u32)tx_htp_ampdu_und << 30) | ((u32)tx_ac3_ampdu_und << 29) | ((u32)tx_ac2_ampdu_und << 28) | ((u32)tx_ac1_ampdu_und << 27) | ((u32)tx_ac0_ampdu_und << 26) | ((u32)sw_rts_success << 14) | ((u32)ac3_tx_bw_decision << 13) | ((u32)ac2_tx_bw_decision << 12) | ((u32)ac1_tx_bw_decision << 11) | ((u32)ac0_tx_bw_decision << 10) | ((u32)htp_tx_bw_decision << 9) | ((u32)bfr_resp_cancelled << 8) | ((u32)end_of_ppdu << 7) | ((u32)need_response << 6) | ((u32)rd_prot_trigger << 5) | ((u32)hcca_prot_trigger << 4) | ((u32)ac_3_prot_trigger << 3) | ((u32)ac_2_prot_trigger << 2) | ((u32)ac_1_prot_trigger << 1) | ((u32)ac_0_prot_trigger << 0));
}

static inline void mac_hw_high_pri_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_high_pri_int_event_en_lmac_tx_htp_ampdu_und_setf(struct cl_chip *chip, u8 txhtpampduund)
{
	ASSERT_ERR_CHIP((((u32)txhtpampduund << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x40000000)) | ((u32)txhtpampduund << 30));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_high_pri_int_event_en_lmac_tx_ac_3_ampdu_und_setf(struct cl_chip *chip, u8 txac3ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac3ampduund << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x20000000)) | ((u32)txac3ampduund << 29));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_high_pri_int_event_en_lmac_tx_ac_2_ampdu_und_setf(struct cl_chip *chip, u8 txac2ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac2ampduund << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x10000000)) | ((u32)txac2ampduund << 28));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_high_pri_int_event_en_lmac_tx_ac_1_ampdu_und_setf(struct cl_chip *chip, u8 txac1ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac1ampduund << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x08000000)) | ((u32)txac1ampduund << 27));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_high_pri_int_event_en_lmac_tx_ac_0_ampdu_und_setf(struct cl_chip *chip, u8 txac0ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac0ampduund << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x04000000)) | ((u32)txac0ampduund << 26));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_high_pri_int_event_en_lmac_sw_rts_success_setf(struct cl_chip *chip, u8 swrtssuccess)
{
	ASSERT_ERR_CHIP((((u32)swrtssuccess << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00004000)) | ((u32)swrtssuccess << 14));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_3_tx_bw_decision_setf(struct cl_chip *chip, u8 ac3txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac3txbwdecision << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac3txbwdecision << 13));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_2_tx_bw_decision_setf(struct cl_chip *chip, u8 ac2txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac2txbwdecision << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00001000)) | ((u32)ac2txbwdecision << 12));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_1_tx_bw_decision_setf(struct cl_chip *chip, u8 ac1txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac1txbwdecision << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000800)) | ((u32)ac1txbwdecision << 11));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_0_tx_bw_decision_setf(struct cl_chip *chip, u8 ac0txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac0txbwdecision << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000400)) | ((u32)ac0txbwdecision << 10));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_high_pri_int_event_en_lmac_htp_tx_bw_decision_setf(struct cl_chip *chip, u8 htptxbwdecision)
{
	ASSERT_ERR_CHIP((((u32)htptxbwdecision << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000200)) | ((u32)htptxbwdecision << 9));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_high_pri_int_event_en_lmac_bfr_resp_cancelled_setf(struct cl_chip *chip, u8 bfrrespcancelled)
{
	ASSERT_ERR_CHIP((((u32)bfrrespcancelled << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000100)) | ((u32)bfrrespcancelled << 8));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_high_pri_int_event_en_lmac_end_of_ppdu_setf(struct cl_chip *chip, u8 endofppdu)
{
	ASSERT_ERR_CHIP((((u32)endofppdu << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000080)) | ((u32)endofppdu << 7));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_high_pri_int_event_en_lmac_need_response_setf(struct cl_chip *chip, u8 needresponse)
{
	ASSERT_ERR_CHIP((((u32)needresponse << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000040)) | ((u32)needresponse << 6));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_high_pri_int_event_en_lmac_rd_prot_trigger_setf(struct cl_chip *chip, u8 rdprottrigger)
{
	ASSERT_ERR_CHIP((((u32)rdprottrigger << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rdprottrigger << 5));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_high_pri_int_event_en_lmac_hcca_prot_trigger_setf(struct cl_chip *chip, u8 hccaprottrigger)
{
	ASSERT_ERR_CHIP((((u32)hccaprottrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000010)) | ((u32)hccaprottrigger << 4));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_3_prot_trigger_setf(struct cl_chip *chip, u8 ac3prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3prottrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000008)) | ((u32)ac3prottrigger << 3));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_2_prot_trigger_setf(struct cl_chip *chip, u8 ac2prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2prottrigger << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000004)) | ((u32)ac2prottrigger << 2));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_1_prot_trigger_setf(struct cl_chip *chip, u8 ac1prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1prottrigger << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000002)) | ((u32)ac1prottrigger << 1));
}

static inline u8 mac_hw_high_pri_int_event_en_lmac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_high_pri_int_event_en_lmac_ac_0_prot_trigger_setf(struct cl_chip *chip, u8 ac0prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0prottrigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000001)) | ((u32)ac0prottrigger << 0));
}

/**
 * @brief HIGH_PRI_INT_EVENT_EN_UMAC register definition
 *  High priority interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    30    TX_HTP_AMPDU_UND          0
 *    29    TX_AC3_AMPDU_UND          0
 *    28    TX_AC2_AMPDU_UND          0
 *    27    TX_AC1_AMPDU_UND          0
 *    26    TX_AC0_AMPDU_UND          0
 *    14    SW_RTS_SUCCESS            0
 *    13    AC3_TX_BW_DECISION        0
 *    12    AC2_TX_BW_DECISION        0
 *    11    AC1_TX_BW_DECISION        0
 *    10    AC0_TX_BW_DECISION        0
 *    09    HTP_TX_BW_DECISION        0
 *    08    BFR_RESP_CANCELLED        0
 *    07    END_OF_PPDU               0
 *    06    NEED_RESPONSE             0
 *    05    RD_PROT_TRIGGER           0
 *    04    HCCA_PROT_TRIGGER         0
 *    03    AC_3_PROT_TRIGGER         0
 *    02    AC_2_PROT_TRIGGER         0
 *    01    AC_1_PROT_TRIGGER         0
 *    00    AC_0_PROT_TRIGGER         0
 * </pre>
 */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000872C)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_OFFSET      0x0000872C
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_INDEX       0x000021CB
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_high_pri_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_high_pri_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_HTP_AMPDU_UND_BIT    ((u32)0x40000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_HTP_AMPDU_UND_POS    30
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_3_AMPDU_UND_BIT    ((u32)0x20000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_3_AMPDU_UND_POS    29
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_2_AMPDU_UND_BIT    ((u32)0x10000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_2_AMPDU_UND_POS    28
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_1_AMPDU_UND_BIT    ((u32)0x08000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_1_AMPDU_UND_POS    27
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_0_AMPDU_UND_BIT    ((u32)0x04000000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_0_AMPDU_UND_POS    26
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_SW_RTS_SUCCESS_BIT    ((u32)0x00004000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_SW_RTS_SUCCESS_POS    14
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_TX_BW_DECISION_BIT    ((u32)0x00002000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_TX_BW_DECISION_POS    13
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_TX_BW_DECISION_BIT    ((u32)0x00001000)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_TX_BW_DECISION_POS    12
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_TX_BW_DECISION_BIT    ((u32)0x00000800)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_TX_BW_DECISION_POS    11
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_TX_BW_DECISION_BIT    ((u32)0x00000400)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_TX_BW_DECISION_POS    10
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HTP_TX_BW_DECISION_BIT    ((u32)0x00000200)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HTP_TX_BW_DECISION_POS    9
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_BFR_RESP_CANCELLED_BIT    ((u32)0x00000100)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_BFR_RESP_CANCELLED_POS    8
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_END_OF_PPDU_BIT    ((u32)0x00000080)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_END_OF_PPDU_POS    7
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_NEED_RESPONSE_BIT    ((u32)0x00000040)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_NEED_RESPONSE_POS    6
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_RD_PROT_TRIGGER_BIT    ((u32)0x00000020)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_RD_PROT_TRIGGER_POS    5
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HCCA_PROT_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HCCA_PROT_TRIGGER_POS    4
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_PROT_TRIGGER_BIT    ((u32)0x00000008)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_PROT_TRIGGER_POS    3
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_PROT_TRIGGER_BIT    ((u32)0x00000004)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_PROT_TRIGGER_POS    2
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_PROT_TRIGGER_BIT    ((u32)0x00000002)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_PROT_TRIGGER_POS    1
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_PROT_TRIGGER_BIT    ((u32)0x00000001)
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_PROT_TRIGGER_POS    0

#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_HTP_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_3_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_2_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_1_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_TX_AC_0_AMPDU_UND_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_SW_RTS_SUCCESS_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HTP_TX_BW_DECISION_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_BFR_RESP_CANCELLED_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_END_OF_PPDU_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_NEED_RESPONSE_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_RD_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_HCCA_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_3_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_2_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_1_PROT_TRIGGER_RST    0x0
#define MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_AC_0_PROT_TRIGGER_RST    0x0

static inline void mac_hw_high_pri_int_event_en_umac_pack(struct cl_chip *chip, u8 tx_htp_ampdu_und, u8 tx_ac3_ampdu_und, u8 tx_ac2_ampdu_und, u8 tx_ac1_ampdu_und, u8 tx_ac0_ampdu_und, u8 sw_rts_success, u8 ac3_tx_bw_decision, u8 ac2_tx_bw_decision, u8 ac1_tx_bw_decision, u8 ac0_tx_bw_decision, u8 htp_tx_bw_decision, u8 bfr_resp_cancelled, u8 end_of_ppdu, u8 need_response, u8 rd_prot_trigger, u8 hcca_prot_trigger, u8 ac_3_prot_trigger, u8 ac_2_prot_trigger, u8 ac_1_prot_trigger, u8 ac_0_prot_trigger)
{
	ASSERT_ERR_CHIP((((u32)tx_htp_ampdu_und << 30) & ~((u32)0x40000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac3_ampdu_und << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac2_ampdu_und << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac1_ampdu_und << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_ac0_ampdu_und << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)sw_rts_success << 14) & ~((u32)0x00004000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac3_tx_bw_decision << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac2_tx_bw_decision << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac1_tx_bw_decision << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)ac0_tx_bw_decision << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_bw_decision << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)bfr_resp_cancelled << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)end_of_ppdu << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)need_response << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_prot_trigger << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_prot_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_prot_trigger << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_prot_trigger << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_prot_trigger << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_prot_trigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, ((u32)tx_htp_ampdu_und << 30) | ((u32)tx_ac3_ampdu_und << 29) | ((u32)tx_ac2_ampdu_und << 28) | ((u32)tx_ac1_ampdu_und << 27) | ((u32)tx_ac0_ampdu_und << 26) | ((u32)sw_rts_success << 14) | ((u32)ac3_tx_bw_decision << 13) | ((u32)ac2_tx_bw_decision << 12) | ((u32)ac1_tx_bw_decision << 11) | ((u32)ac0_tx_bw_decision << 10) | ((u32)htp_tx_bw_decision << 9) | ((u32)bfr_resp_cancelled << 8) | ((u32)end_of_ppdu << 7) | ((u32)need_response << 6) | ((u32)rd_prot_trigger << 5) | ((u32)hcca_prot_trigger << 4) | ((u32)ac_3_prot_trigger << 3) | ((u32)ac_2_prot_trigger << 2) | ((u32)ac_1_prot_trigger << 1) | ((u32)ac_0_prot_trigger << 0));
}

static inline void mac_hw_high_pri_int_event_en_umac_unpack(struct cl_chip *chip, u8 *tx_htp_ampdu_und, u8 *tx_ac3_ampdu_und, u8 *tx_ac2_ampdu_und, u8 *tx_ac1_ampdu_und, u8 *tx_ac0_ampdu_und, u8 *sw_rts_success, u8 *ac3_tx_bw_decision, u8 *ac2_tx_bw_decision, u8 *ac1_tx_bw_decision, u8 *ac0_tx_bw_decision, u8 *htp_tx_bw_decision, u8 *bfr_resp_cancelled, u8 *end_of_ppdu, u8 *need_response, u8 *rd_prot_trigger, u8 *hcca_prot_trigger, u8 *ac_3_prot_trigger, u8 *ac_2_prot_trigger, u8 *ac_1_prot_trigger, u8 *ac_0_prot_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	*tx_htp_ampdu_und = (local_val & ((u32)0x40000000)) >> 30;
	*tx_ac3_ampdu_und = (local_val & ((u32)0x20000000)) >> 29;
	*tx_ac2_ampdu_und = (local_val & ((u32)0x10000000)) >> 28;
	*tx_ac1_ampdu_und = (local_val & ((u32)0x08000000)) >> 27;
	*tx_ac0_ampdu_und = (local_val & ((u32)0x04000000)) >> 26;
	*sw_rts_success = (local_val & ((u32)0x00004000)) >> 14;
	*ac3_tx_bw_decision = (local_val & ((u32)0x00002000)) >> 13;
	*ac2_tx_bw_decision = (local_val & ((u32)0x00001000)) >> 12;
	*ac1_tx_bw_decision = (local_val & ((u32)0x00000800)) >> 11;
	*ac0_tx_bw_decision = (local_val & ((u32)0x00000400)) >> 10;
	*htp_tx_bw_decision = (local_val & ((u32)0x00000200)) >> 9;
	*bfr_resp_cancelled = (local_val & ((u32)0x00000100)) >> 8;
	*end_of_ppdu = (local_val & ((u32)0x00000080)) >> 7;
	*need_response = (local_val & ((u32)0x00000040)) >> 6;
	*rd_prot_trigger = (local_val & ((u32)0x00000020)) >> 5;
	*hcca_prot_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*ac_3_prot_trigger = (local_val & ((u32)0x00000008)) >> 3;
	*ac_2_prot_trigger = (local_val & ((u32)0x00000004)) >> 2;
	*ac_1_prot_trigger = (local_val & ((u32)0x00000002)) >> 1;
	*ac_0_prot_trigger = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_high_pri_int_event_en_umac_tx_htp_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x40000000)) >> 30);
}

static inline void mac_hw_high_pri_int_event_en_umac_tx_htp_ampdu_und_setf(struct cl_chip *chip, u8 txhtpampduund)
{
	ASSERT_ERR_CHIP((((u32)txhtpampduund << 30) & ~((u32)0x40000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x40000000)) | ((u32)txhtpampduund << 30));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_tx_ac_3_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_high_pri_int_event_en_umac_tx_ac_3_ampdu_und_setf(struct cl_chip *chip, u8 txac3ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac3ampduund << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x20000000)) | ((u32)txac3ampduund << 29));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_tx_ac_2_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_high_pri_int_event_en_umac_tx_ac_2_ampdu_und_setf(struct cl_chip *chip, u8 txac2ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac2ampduund << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x10000000)) | ((u32)txac2ampduund << 28));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_tx_ac_1_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_high_pri_int_event_en_umac_tx_ac_1_ampdu_und_setf(struct cl_chip *chip, u8 txac1ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac1ampduund << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x08000000)) | ((u32)txac1ampduund << 27));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_tx_ac_0_ampdu_und_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_high_pri_int_event_en_umac_tx_ac_0_ampdu_und_setf(struct cl_chip *chip, u8 txac0ampduund)
{
	ASSERT_ERR_CHIP((((u32)txac0ampduund << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x04000000)) | ((u32)txac0ampduund << 26));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_sw_rts_success_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_high_pri_int_event_en_umac_sw_rts_success_setf(struct cl_chip *chip, u8 swrtssuccess)
{
	ASSERT_ERR_CHIP((((u32)swrtssuccess << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00004000)) | ((u32)swrtssuccess << 14));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_3_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00002000)) >> 13);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_3_tx_bw_decision_setf(struct cl_chip *chip, u8 ac3txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac3txbwdecision << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00002000)) | ((u32)ac3txbwdecision << 13));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_2_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_2_tx_bw_decision_setf(struct cl_chip *chip, u8 ac2txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac2txbwdecision << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00001000)) | ((u32)ac2txbwdecision << 12));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_1_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_1_tx_bw_decision_setf(struct cl_chip *chip, u8 ac1txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac1txbwdecision << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000800)) | ((u32)ac1txbwdecision << 11));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_0_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_0_tx_bw_decision_setf(struct cl_chip *chip, u8 ac0txbwdecision)
{
	ASSERT_ERR_CHIP((((u32)ac0txbwdecision << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000400)) | ((u32)ac0txbwdecision << 10));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_htp_tx_bw_decision_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_high_pri_int_event_en_umac_htp_tx_bw_decision_setf(struct cl_chip *chip, u8 htptxbwdecision)
{
	ASSERT_ERR_CHIP((((u32)htptxbwdecision << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000200)) | ((u32)htptxbwdecision << 9));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_bfr_resp_cancelled_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_high_pri_int_event_en_umac_bfr_resp_cancelled_setf(struct cl_chip *chip, u8 bfrrespcancelled)
{
	ASSERT_ERR_CHIP((((u32)bfrrespcancelled << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000100)) | ((u32)bfrrespcancelled << 8));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_end_of_ppdu_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_high_pri_int_event_en_umac_end_of_ppdu_setf(struct cl_chip *chip, u8 endofppdu)
{
	ASSERT_ERR_CHIP((((u32)endofppdu << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000080)) | ((u32)endofppdu << 7));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_need_response_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_high_pri_int_event_en_umac_need_response_setf(struct cl_chip *chip, u8 needresponse)
{
	ASSERT_ERR_CHIP((((u32)needresponse << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000040)) | ((u32)needresponse << 6));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_rd_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_high_pri_int_event_en_umac_rd_prot_trigger_setf(struct cl_chip *chip, u8 rdprottrigger)
{
	ASSERT_ERR_CHIP((((u32)rdprottrigger << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rdprottrigger << 5));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_hcca_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_high_pri_int_event_en_umac_hcca_prot_trigger_setf(struct cl_chip *chip, u8 hccaprottrigger)
{
	ASSERT_ERR_CHIP((((u32)hccaprottrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000010)) | ((u32)hccaprottrigger << 4));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_3_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_3_prot_trigger_setf(struct cl_chip *chip, u8 ac3prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3prottrigger << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000008)) | ((u32)ac3prottrigger << 3));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_2_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_2_prot_trigger_setf(struct cl_chip *chip, u8 ac2prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2prottrigger << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000004)) | ((u32)ac2prottrigger << 2));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_1_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_1_prot_trigger_setf(struct cl_chip *chip, u8 ac1prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1prottrigger << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000002)) | ((u32)ac1prottrigger << 1));
}

static inline u8 mac_hw_high_pri_int_event_en_umac_ac_0_prot_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_high_pri_int_event_en_umac_ac_0_prot_trigger_setf(struct cl_chip *chip, u8 ac0prottrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0prottrigger << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_HIGH_PRI_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000001)) | ((u32)ac0prottrigger << 0));
}

/**
 * @brief RX_INT_EVENT_STATUS_LMAC register definition
 *  Rx interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008730)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_OFFSET      0x00008730
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_INDEX       0x000021CC
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_status_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_STATUS_LMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_status_lmac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_status_lmac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_rx_int_event_status_lmac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_rx_int_event_status_lmac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline u8 mac_hw_rx_int_event_status_lmac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline u8 mac_hw_rx_int_event_status_lmac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline u8 mac_hw_rx_int_event_status_lmac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline u8 mac_hw_rx_int_event_status_lmac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

/**
 * @brief RX_INT_EVENT_CLEAR register definition
 *  Rx interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008734)
#define MAC_HW_RX_INT_EVENT_CLEAR_OFFSET      0x00008734
#define MAC_HW_RX_INT_EVENT_CLEAR_INDEX       0x000021CD
#define MAC_HW_RX_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_rx_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_CLEAR_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_CLEAR_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_CLEAR_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_CLEAR_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_CLEAR_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_CLEAR_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_clear_pack(struct cl_chip *chip, u8 eop_filtered, u8 counter_rx_trigger2, u8 phy_rx_start, u8 ba_rx_trigger2, u8 rx_trigger2, u8 counter_rx_trigger, u8 ba_rx_trigger, u8 rx_trigger, u8 rx_implicit_bf, u8 rx_class_rule5, u8 rx_class_rule4, u8 rx_class_rule3, u8 rx_class_rule2, u8 rx_class_rule1, u8 rx_class_rule0)
{
	ASSERT_ERR_CHIP((((u32)eop_filtered << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger2 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_rx_start << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger2 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_implicit_bf << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, ((u32)eop_filtered << 25) | ((u32)counter_rx_trigger2 << 24) | ((u32)phy_rx_start << 23) | ((u32)ba_rx_trigger2 << 22) | ((u32)rx_trigger2 << 20) | ((u32)counter_rx_trigger << 19) | ((u32)ba_rx_trigger << 18) | ((u32)rx_trigger << 16) | ((u32)rx_implicit_bf << 8) | ((u32)rx_class_rule5 << 5) | ((u32)rx_class_rule4 << 4) | ((u32)rx_class_rule3 << 3) | ((u32)rx_class_rule2 << 2) | ((u32)rx_class_rule1 << 1) | ((u32)rx_class_rule0 << 0));
}

static inline void mac_hw_rx_int_event_clear_eop_filtered_setf(struct cl_chip *chip, u8 eopfiltered)
{
	ASSERT_ERR_CHIP((((u32)eopfiltered << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x02000000)) | ((u32)eopfiltered << 25));
}

static inline void mac_hw_rx_int_event_clear_counter_rx_trigger_2_setf(struct cl_chip *chip, u8 counterrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger2 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x01000000)) | ((u32)counterrxtrigger2 << 24));
}

static inline void mac_hw_rx_int_event_clear_phy_rx_start_setf(struct cl_chip *chip, u8 phyrxstart)
{
	ASSERT_ERR_CHIP((((u32)phyrxstart << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00800000)) | ((u32)phyrxstart << 23));
}

static inline void mac_hw_rx_int_event_clear_ba_rx_trigger_2_setf(struct cl_chip *chip, u8 barxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00400000)) | ((u32)barxtrigger2 << 22));
}

static inline void mac_hw_rx_int_event_clear_rx_trigger_2_setf(struct cl_chip *chip, u8 rxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger2 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00100000)) | ((u32)rxtrigger2 << 20));
}

static inline void mac_hw_rx_int_event_clear_counter_rx_trigger_setf(struct cl_chip *chip, u8 counterrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00080000)) | ((u32)counterrxtrigger << 19));
}

static inline void mac_hw_rx_int_event_clear_ba_rx_trigger_setf(struct cl_chip *chip, u8 barxtrigger)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00040000)) | ((u32)barxtrigger << 18));
}

static inline void mac_hw_rx_int_event_clear_rx_trigger_setf(struct cl_chip *chip, u8 rxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00010000)) | ((u32)rxtrigger << 16));
}

static inline void mac_hw_rx_int_event_clear_rx_implicit_bf_setf(struct cl_chip *chip, u8 rximplicitbf)
{
	ASSERT_ERR_CHIP((((u32)rximplicitbf << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000100)) | ((u32)rximplicitbf << 8));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_5_setf(struct cl_chip *chip, u8 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000020)) | ((u32)rxclassrule5 << 5));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_4_setf(struct cl_chip *chip, u8 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000010)) | ((u32)rxclassrule4 << 4));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_3_setf(struct cl_chip *chip, u8 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000008)) | ((u32)rxclassrule3 << 3));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_2_setf(struct cl_chip *chip, u8 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000004)) | ((u32)rxclassrule2 << 2));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_1_setf(struct cl_chip *chip, u8 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000002)) | ((u32)rxclassrule1 << 1));
}

static inline void mac_hw_rx_int_event_clear_rx_class_rule_0_setf(struct cl_chip *chip, u8 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000001)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief RX_INT_EVENT_EN_LMAC register definition
 *  Rx interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008738)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_OFFSET      0x00008738
#define MAC_HW_RX_INT_EVENT_EN_LMAC_INDEX       0x000021CE
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_rx_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_EN_LMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_EN_LMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_EN_LMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_LMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_en_lmac_pack(struct cl_chip *chip, u8 eop_filtered, u8 counter_rx_trigger2, u8 phy_rx_start, u8 ba_rx_trigger2, u8 rx_trigger2, u8 counter_rx_trigger, u8 ba_rx_trigger, u8 rx_trigger, u8 rx_implicit_bf, u8 rx_class_rule5, u8 rx_class_rule4, u8 rx_class_rule3, u8 rx_class_rule2, u8 rx_class_rule1, u8 rx_class_rule0)
{
	ASSERT_ERR_CHIP((((u32)eop_filtered << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger2 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_rx_start << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger2 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_implicit_bf << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, ((u32)eop_filtered << 25) | ((u32)counter_rx_trigger2 << 24) | ((u32)phy_rx_start << 23) | ((u32)ba_rx_trigger2 << 22) | ((u32)rx_trigger2 << 20) | ((u32)counter_rx_trigger << 19) | ((u32)ba_rx_trigger << 18) | ((u32)rx_trigger << 16) | ((u32)rx_implicit_bf << 8) | ((u32)rx_class_rule5 << 5) | ((u32)rx_class_rule4 << 4) | ((u32)rx_class_rule3 << 3) | ((u32)rx_class_rule2 << 2) | ((u32)rx_class_rule1 << 1) | ((u32)rx_class_rule0 << 0));
}

static inline void mac_hw_rx_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_en_lmac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_rx_int_event_en_lmac_eop_filtered_setf(struct cl_chip *chip, u8 eopfiltered)
{
	ASSERT_ERR_CHIP((((u32)eopfiltered << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x02000000)) | ((u32)eopfiltered << 25));
}

static inline u8 mac_hw_rx_int_event_en_lmac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_rx_int_event_en_lmac_counter_rx_trigger_2_setf(struct cl_chip *chip, u8 counterrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger2 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x01000000)) | ((u32)counterrxtrigger2 << 24));
}

static inline u8 mac_hw_rx_int_event_en_lmac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_int_event_en_lmac_phy_rx_start_setf(struct cl_chip *chip, u8 phyrxstart)
{
	ASSERT_ERR_CHIP((((u32)phyrxstart << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00800000)) | ((u32)phyrxstart << 23));
}

static inline u8 mac_hw_rx_int_event_en_lmac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_int_event_en_lmac_ba_rx_trigger_2_setf(struct cl_chip *chip, u8 barxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00400000)) | ((u32)barxtrigger2 << 22));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_trigger_2_setf(struct cl_chip *chip, u8 rxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger2 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00100000)) | ((u32)rxtrigger2 << 20));
}

static inline u8 mac_hw_rx_int_event_en_lmac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_int_event_en_lmac_counter_rx_trigger_setf(struct cl_chip *chip, u8 counterrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00080000)) | ((u32)counterrxtrigger << 19));
}

static inline u8 mac_hw_rx_int_event_en_lmac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_int_event_en_lmac_ba_rx_trigger_setf(struct cl_chip *chip, u8 barxtrigger)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00040000)) | ((u32)barxtrigger << 18));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_trigger_setf(struct cl_chip *chip, u8 rxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00010000)) | ((u32)rxtrigger << 16));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_implicit_bf_setf(struct cl_chip *chip, u8 rximplicitbf)
{
	ASSERT_ERR_CHIP((((u32)rximplicitbf << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rximplicitbf << 8));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_5_setf(struct cl_chip *chip, u8 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxclassrule5 << 5));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_4_setf(struct cl_chip *chip, u8 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rxclassrule4 << 4));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_3_setf(struct cl_chip *chip, u8 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000008)) | ((u32)rxclassrule3 << 3));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_2_setf(struct cl_chip *chip, u8 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000004)) | ((u32)rxclassrule2 << 2));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_1_setf(struct cl_chip *chip, u8 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000002)) | ((u32)rxclassrule1 << 1));
}

static inline u8 mac_hw_rx_int_event_en_lmac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_int_event_en_lmac_rx_class_rule_0_setf(struct cl_chip *chip, u8 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000001)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief RX_INT_EVENT_EN_UMAC register definition
 *  Rx interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    25    EOP_FILTERED              0
 *    24    COUNTER_RX_TRIGGER2       0
 *    23    PHY_RX_START              0
 *    22    BA_RX_TRIGGER2            0
 *    20    RX_TRIGGER2               0
 *    19    COUNTER_RX_TRIGGER        0
 *    18    BA_RX_TRIGGER             0
 *    16    RX_TRIGGER                0
 *    08    RX_IMPLICIT_BF            0
 *    05    RX_CLASS_RULE5            0
 *    04    RX_CLASS_RULE4            0
 *    03    RX_CLASS_RULE3            0
 *    02    RX_CLASS_RULE2            0
 *    01    RX_CLASS_RULE1            0
 *    00    RX_CLASS_RULE0            0
 * </pre>
 */
#define MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000873C)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_OFFSET      0x0000873C
#define MAC_HW_RX_INT_EVENT_EN_UMAC_INDEX       0x000021CF
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_rx_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_rx_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_RX_INT_EVENT_EN_UMAC_EOP_FILTERED_BIT    ((u32)0x02000000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_EOP_FILTERED_POS    25
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_2_BIT    ((u32)0x01000000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_2_POS    24
#define MAC_HW_RX_INT_EVENT_EN_UMAC_PHY_RX_START_BIT    ((u32)0x00800000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_PHY_RX_START_POS    23
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_2_BIT    ((u32)0x00400000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_2_POS    22
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_2_BIT    ((u32)0x00100000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_2_POS    20
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_BIT    ((u32)0x00080000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_POS    19
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_BIT    ((u32)0x00040000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_POS    18
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_BIT    ((u32)0x00010000)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_POS    16
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_IMPLICIT_BF_BIT    ((u32)0x00000100)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_IMPLICIT_BF_POS    8
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_5_BIT    ((u32)0x00000020)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_5_POS    5
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_4_BIT    ((u32)0x00000010)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_4_POS    4
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_3_BIT    ((u32)0x00000008)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_3_POS    3
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_2_BIT    ((u32)0x00000004)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_2_POS    2
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_1_BIT    ((u32)0x00000002)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_1_POS    1
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_0_BIT    ((u32)0x00000001)
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_0_POS    0

#define MAC_HW_RX_INT_EVENT_EN_UMAC_EOP_FILTERED_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_PHY_RX_START_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_COUNTER_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_BA_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_TRIGGER_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_IMPLICIT_BF_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_5_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_4_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_3_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_2_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_1_RST    0x0
#define MAC_HW_RX_INT_EVENT_EN_UMAC_RX_CLASS_RULE_0_RST    0x0

static inline void mac_hw_rx_int_event_en_umac_pack(struct cl_chip *chip, u8 eop_filtered, u8 counter_rx_trigger2, u8 phy_rx_start, u8 ba_rx_trigger2, u8 rx_trigger2, u8 counter_rx_trigger, u8 ba_rx_trigger, u8 rx_trigger, u8 rx_implicit_bf, u8 rx_class_rule5, u8 rx_class_rule4, u8 rx_class_rule3, u8 rx_class_rule2, u8 rx_class_rule1, u8 rx_class_rule0)
{
	ASSERT_ERR_CHIP((((u32)eop_filtered << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger2 << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)phy_rx_start << 23) & ~((u32)0x00800000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger2 << 22) & ~((u32)0x00400000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger2 << 20) & ~((u32)0x00100000)) == 0);
	ASSERT_ERR_CHIP((((u32)counter_rx_trigger << 19) & ~((u32)0x00080000)) == 0);
	ASSERT_ERR_CHIP((((u32)ba_rx_trigger << 18) & ~((u32)0x00040000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_trigger << 16) & ~((u32)0x00010000)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_implicit_bf << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule5 << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule4 << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule3 << 3) & ~((u32)0x00000008)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule2 << 2) & ~((u32)0x00000004)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule1 << 1) & ~((u32)0x00000002)) == 0);
	ASSERT_ERR_CHIP((((u32)rx_class_rule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, ((u32)eop_filtered << 25) | ((u32)counter_rx_trigger2 << 24) | ((u32)phy_rx_start << 23) | ((u32)ba_rx_trigger2 << 22) | ((u32)rx_trigger2 << 20) | ((u32)counter_rx_trigger << 19) | ((u32)ba_rx_trigger << 18) | ((u32)rx_trigger << 16) | ((u32)rx_implicit_bf << 8) | ((u32)rx_class_rule5 << 5) | ((u32)rx_class_rule4 << 4) | ((u32)rx_class_rule3 << 3) | ((u32)rx_class_rule2 << 2) | ((u32)rx_class_rule1 << 1) | ((u32)rx_class_rule0 << 0));
}

static inline void mac_hw_rx_int_event_en_umac_unpack(struct cl_chip *chip, u8 *eop_filtered, u8 *counter_rx_trigger2, u8 *phy_rx_start, u8 *ba_rx_trigger2, u8 *rx_trigger2, u8 *counter_rx_trigger, u8 *ba_rx_trigger, u8 *rx_trigger, u8 *rx_implicit_bf, u8 *rx_class_rule5, u8 *rx_class_rule4, u8 *rx_class_rule3, u8 *rx_class_rule2, u8 *rx_class_rule1, u8 *rx_class_rule0)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	*eop_filtered = (local_val & ((u32)0x02000000)) >> 25;
	*counter_rx_trigger2 = (local_val & ((u32)0x01000000)) >> 24;
	*phy_rx_start = (local_val & ((u32)0x00800000)) >> 23;
	*ba_rx_trigger2 = (local_val & ((u32)0x00400000)) >> 22;
	*rx_trigger2 = (local_val & ((u32)0x00100000)) >> 20;
	*counter_rx_trigger = (local_val & ((u32)0x00080000)) >> 19;
	*ba_rx_trigger = (local_val & ((u32)0x00040000)) >> 18;
	*rx_trigger = (local_val & ((u32)0x00010000)) >> 16;
	*rx_implicit_bf = (local_val & ((u32)0x00000100)) >> 8;
	*rx_class_rule5 = (local_val & ((u32)0x00000020)) >> 5;
	*rx_class_rule4 = (local_val & ((u32)0x00000010)) >> 4;
	*rx_class_rule3 = (local_val & ((u32)0x00000008)) >> 3;
	*rx_class_rule2 = (local_val & ((u32)0x00000004)) >> 2;
	*rx_class_rule1 = (local_val & ((u32)0x00000002)) >> 1;
	*rx_class_rule0 = (local_val & ((u32)0x00000001)) >> 0;
}

static inline u8 mac_hw_rx_int_event_en_umac_eop_filtered_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_rx_int_event_en_umac_eop_filtered_setf(struct cl_chip *chip, u8 eopfiltered)
{
	ASSERT_ERR_CHIP((((u32)eopfiltered << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x02000000)) | ((u32)eopfiltered << 25));
}

static inline u8 mac_hw_rx_int_event_en_umac_counter_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_rx_int_event_en_umac_counter_rx_trigger_2_setf(struct cl_chip *chip, u8 counterrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger2 << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x01000000)) | ((u32)counterrxtrigger2 << 24));
}

static inline u8 mac_hw_rx_int_event_en_umac_phy_rx_start_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00800000)) >> 23);
}

static inline void mac_hw_rx_int_event_en_umac_phy_rx_start_setf(struct cl_chip *chip, u8 phyrxstart)
{
	ASSERT_ERR_CHIP((((u32)phyrxstart << 23) & ~((u32)0x00800000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00800000)) | ((u32)phyrxstart << 23));
}

static inline u8 mac_hw_rx_int_event_en_umac_ba_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00400000)) >> 22);
}

static inline void mac_hw_rx_int_event_en_umac_ba_rx_trigger_2_setf(struct cl_chip *chip, u8 barxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger2 << 22) & ~((u32)0x00400000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00400000)) | ((u32)barxtrigger2 << 22));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00100000)) >> 20);
}

static inline void mac_hw_rx_int_event_en_umac_rx_trigger_2_setf(struct cl_chip *chip, u8 rxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger2 << 20) & ~((u32)0x00100000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00100000)) | ((u32)rxtrigger2 << 20));
}

static inline u8 mac_hw_rx_int_event_en_umac_counter_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00080000)) >> 19);
}

static inline void mac_hw_rx_int_event_en_umac_counter_rx_trigger_setf(struct cl_chip *chip, u8 counterrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)counterrxtrigger << 19) & ~((u32)0x00080000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00080000)) | ((u32)counterrxtrigger << 19));
}

static inline u8 mac_hw_rx_int_event_en_umac_ba_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00040000)) >> 18);
}

static inline void mac_hw_rx_int_event_en_umac_ba_rx_trigger_setf(struct cl_chip *chip, u8 barxtrigger)
{
	ASSERT_ERR_CHIP((((u32)barxtrigger << 18) & ~((u32)0x00040000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00040000)) | ((u32)barxtrigger << 18));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00010000)) >> 16);
}

static inline void mac_hw_rx_int_event_en_umac_rx_trigger_setf(struct cl_chip *chip, u8 rxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rxtrigger << 16) & ~((u32)0x00010000)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00010000)) | ((u32)rxtrigger << 16));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_implicit_bf_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_rx_int_event_en_umac_rx_implicit_bf_setf(struct cl_chip *chip, u8 rximplicitbf)
{
	ASSERT_ERR_CHIP((((u32)rximplicitbf << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000100)) | ((u32)rximplicitbf << 8));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_5_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_5_setf(struct cl_chip *chip, u8 rxclassrule5)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule5 << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000020)) | ((u32)rxclassrule5 << 5));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_4_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_4_setf(struct cl_chip *chip, u8 rxclassrule4)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule4 << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rxclassrule4 << 4));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_3_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_3_setf(struct cl_chip *chip, u8 rxclassrule3)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule3 << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000008)) | ((u32)rxclassrule3 << 3));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000004)) >> 2);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_2_setf(struct cl_chip *chip, u8 rxclassrule2)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule2 << 2) & ~((u32)0x00000004)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000004)) | ((u32)rxclassrule2 << 2));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_1_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000002)) >> 1);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_1_setf(struct cl_chip *chip, u8 rxclassrule1)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule1 << 1) & ~((u32)0x00000002)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000002)) | ((u32)rxclassrule1 << 1));
}

static inline u8 mac_hw_rx_int_event_en_umac_rx_class_rule_0_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000001)) >> 0);
}

static inline void mac_hw_rx_int_event_en_umac_rx_class_rule_0_setf(struct cl_chip *chip, u8 rxclassrule0)
{
	ASSERT_ERR_CHIP((((u32)rxclassrule0 << 0) & ~((u32)0x00000001)) == 0);
	cl_reg_write(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_RX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000001)) | ((u32)rxclassrule0 << 0));
}

/**
 * @brief TIMER_INT_EVENT_STATUS_LMAC register definition
 *  Timer interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008740)
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_OFFSET      0x00008740
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_INDEX       0x000021D0
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_status_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_status_lmac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_status_lmac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline u8 mac_hw_timer_int_event_status_lmac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline u8 mac_hw_timer_int_event_status_lmac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

/**
 * @brief TIMER_INT_EVENT_CLEAR register definition
 *  Timer interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008744)
#define MAC_HW_TIMER_INT_EVENT_CLEAR_OFFSET      0x00008744
#define MAC_HW_TIMER_INT_EVENT_CLEAR_INDEX       0x000021D1
#define MAC_HW_TIMER_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_timer_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_CLEAR_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_clear_pack(struct cl_chip *chip, u8 timer_rx_trigger2, u8 timer_rx_trigger, u8 timer_tx_trigger)
{
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger2 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_tx_trigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR, ((u32)timer_rx_trigger2 << 21) | ((u32)timer_rx_trigger << 17) | ((u32)timer_tx_trigger << 14));
}

static inline void mac_hw_timer_int_event_clear_timer_rx_trigger_2_setf(struct cl_chip *chip, u8 timerrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger2 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00200000)) | ((u32)timerrxtrigger2 << 21));
}

static inline void mac_hw_timer_int_event_clear_timer_rx_trigger_setf(struct cl_chip *chip, u8 timerrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00020000)) | ((u32)timerrxtrigger << 17));
}

static inline void mac_hw_timer_int_event_clear_timer_tx_trigger_setf(struct cl_chip *chip, u8 timertxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timertxtrigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00004000)) | ((u32)timertxtrigger << 14));
}

/**
 * @brief TIMER_INT_EVENT_EN_LMAC register definition
 *  Timer interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008748)
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_OFFSET      0x00008748
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_INDEX       0x000021D2
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_timer_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_LMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_en_lmac_pack(struct cl_chip *chip, u8 timer_rx_trigger2, u8 timer_rx_trigger, u8 timer_tx_trigger)
{
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger2 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_tx_trigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR, ((u32)timer_rx_trigger2 << 21) | ((u32)timer_rx_trigger << 17) | ((u32)timer_tx_trigger << 14));
}

static inline void mac_hw_timer_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_en_lmac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_timer_int_event_en_lmac_timer_rx_trigger_2_setf(struct cl_chip *chip, u8 timerrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger2 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00200000)) | ((u32)timerrxtrigger2 << 21));
}

static inline u8 mac_hw_timer_int_event_en_lmac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_timer_int_event_en_lmac_timer_rx_trigger_setf(struct cl_chip *chip, u8 timerrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00020000)) | ((u32)timerrxtrigger << 17));
}

static inline u8 mac_hw_timer_int_event_en_lmac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_timer_int_event_en_lmac_timer_tx_trigger_setf(struct cl_chip *chip, u8 timertxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timertxtrigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00004000)) | ((u32)timertxtrigger << 14));
}

/**
 * @brief TIMER_INT_EVENT_EN_UMAC register definition
 *  Timer interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    21    TIMER_RX_TRIGGER2         0
 *    17    TIMER_RX_TRIGGER          0
 *    14    TIMER_TX_TRIGGER          0
 * </pre>
 */
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000874C)
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_OFFSET      0x0000874C
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_INDEX       0x000021D3
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_timer_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_timer_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_2_BIT    ((u32)0x00200000)
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_2_POS    21
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_BIT    ((u32)0x00020000)
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_POS    17
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_TX_TRIGGER_BIT    ((u32)0x00004000)
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_TX_TRIGGER_POS    14

#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_2_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_RX_TRIGGER_RST    0x0
#define MAC_HW_TIMER_INT_EVENT_EN_UMAC_TIMER_TX_TRIGGER_RST    0x0

static inline void mac_hw_timer_int_event_en_umac_pack(struct cl_chip *chip, u8 timer_rx_trigger2, u8 timer_rx_trigger, u8 timer_tx_trigger)
{
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger2 << 21) & ~((u32)0x00200000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_rx_trigger << 17) & ~((u32)0x00020000)) == 0);
	ASSERT_ERR_CHIP((((u32)timer_tx_trigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR, ((u32)timer_rx_trigger2 << 21) | ((u32)timer_rx_trigger << 17) | ((u32)timer_tx_trigger << 14));
}

static inline void mac_hw_timer_int_event_en_umac_unpack(struct cl_chip *chip, u8 *timer_rx_trigger2, u8 *timer_rx_trigger, u8 *timer_tx_trigger)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR);

	*timer_rx_trigger2 = (local_val & ((u32)0x00200000)) >> 21;
	*timer_rx_trigger = (local_val & ((u32)0x00020000)) >> 17;
	*timer_tx_trigger = (local_val & ((u32)0x00004000)) >> 14;
}

static inline u8 mac_hw_timer_int_event_en_umac_timer_rx_trigger_2_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00200000)) >> 21);
}

static inline void mac_hw_timer_int_event_en_umac_timer_rx_trigger_2_setf(struct cl_chip *chip, u8 timerrxtrigger2)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger2 << 21) & ~((u32)0x00200000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00200000)) | ((u32)timerrxtrigger2 << 21));
}

static inline u8 mac_hw_timer_int_event_en_umac_timer_rx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00020000)) >> 17);
}

static inline void mac_hw_timer_int_event_en_umac_timer_rx_trigger_setf(struct cl_chip *chip, u8 timerrxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timerrxtrigger << 17) & ~((u32)0x00020000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00020000)) | ((u32)timerrxtrigger << 17));
}

static inline u8 mac_hw_timer_int_event_en_umac_timer_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00004000)) >> 14);
}

static inline void mac_hw_timer_int_event_en_umac_timer_tx_trigger_setf(struct cl_chip *chip, u8 timertxtrigger)
{
	ASSERT_ERR_CHIP((((u32)timertxtrigger << 14) & ~((u32)0x00004000)) == 0);
	cl_reg_write(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TIMER_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00004000)) | ((u32)timertxtrigger << 14));
}

/**
 * @brief TX_INT_EVENT_STATUS_LMAC register definition
 *  Tx interrupts events status LMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008750)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_OFFSET      0x00008750
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_INDEX       0x000021D4
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_status_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_STATUS_LMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_status_lmac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_status_lmac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline u8 mac_hw_tx_int_event_status_lmac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline u8 mac_hw_tx_int_event_status_lmac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline u8 mac_hw_tx_int_event_status_lmac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline u8 mac_hw_tx_int_event_status_lmac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline u8 mac_hw_tx_int_event_status_lmac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline u8 mac_hw_tx_int_event_status_lmac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline u8 mac_hw_tx_int_event_status_lmac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline u8 mac_hw_tx_int_event_status_lmac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_STATUS_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

/**
 * @brief TX_INT_EVENT_CLEAR register definition
 *  Tx interrupts status clear register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    13    TXM_TX_TRIGGER            0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_CLEAR_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008754)
#define MAC_HW_TX_INT_EVENT_CLEAR_OFFSET      0x00008754
#define MAC_HW_TX_INT_EVENT_CLEAR_INDEX       0x000021D5
#define MAC_HW_TX_INT_EVENT_CLEAR_RESET       0x00000000

static inline void mac_hw_tx_int_event_clear_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_CLEAR_TXM_TX_TRIGGER_BIT    ((u32)0x00002000)
#define MAC_HW_TX_INT_EVENT_CLEAR_TXM_TX_TRIGGER_POS    13
#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_CLEAR_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_CLEAR_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_CLEAR_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_CLEAR_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_CLEAR_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_CLEAR_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_CLEAR_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_CLEAR_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_TXM_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_CLEAR_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_clear_pack(struct cl_chip *chip, u8 htp_tx_buf_trigger, u8 bcn_tx_buf_trigger, u8 ac_3_tx_buf_trigger, u8 ac_2_tx_buf_trigger, u8 ac_1_tx_buf_trigger, u8 ac_0_tx_buf_trigger, u8 txm_tx_trigger, u8 htp_tx_trigger, u8 hcca_tx_trigger, u8 bcn_tx_trigger, u8 ac_3_tx_trigger, u8 ac_2_tx_trigger, u8 ac_1_tx_trigger, u8 ac_0_tx_trigger, u8 txop_complete, u8 rd_tx_trigger, u8 tx_abort)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_buf_trigger << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_buf_trigger << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_buf_trigger << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_buf_trigger << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_buf_trigger << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_buf_trigger << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)txm_tx_trigger << 13) & ~((u32)0x00002000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_trigger << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_tx_trigger << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_trigger << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_trigger << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_trigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_trigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_trigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_complete << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_tx_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_abort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, ((u32)htp_tx_buf_trigger << 29) | ((u32)bcn_tx_buf_trigger << 28) | ((u32)ac_3_tx_buf_trigger << 27) | ((u32)ac_2_tx_buf_trigger << 26) | ((u32)ac_1_tx_buf_trigger << 25) | ((u32)ac_0_tx_buf_trigger << 24) | ((u32)txm_tx_trigger << 13) | ((u32)htp_tx_trigger << 12) | ((u32)hcca_tx_trigger << 11) | ((u32)bcn_tx_trigger << 10) | ((u32)ac_3_tx_trigger << 9) | ((u32)ac_2_tx_trigger << 8) | ((u32)ac_1_tx_trigger << 7) | ((u32)ac_0_tx_trigger << 6) | ((u32)txop_complete << 5) | ((u32)rd_tx_trigger << 4) | ((u32)tx_abort << 3));
}

static inline void mac_hw_tx_int_event_clear_htp_tx_buf_trigger_setf(struct cl_chip *chip, u8 htptxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxbuftrigger << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x20000000)) | ((u32)htptxbuftrigger << 29));
}

static inline void mac_hw_tx_int_event_clear_bcn_tx_buf_trigger_setf(struct cl_chip *chip, u8 bcntxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxbuftrigger << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x10000000)) | ((u32)bcntxbuftrigger << 28));
}

static inline void mac_hw_tx_int_event_clear_ac_3_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac3txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txbuftrigger << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x08000000)) | ((u32)ac3txbuftrigger << 27));
}

static inline void mac_hw_tx_int_event_clear_ac_2_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac2txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txbuftrigger << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x04000000)) | ((u32)ac2txbuftrigger << 26));
}

static inline void mac_hw_tx_int_event_clear_ac_1_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac1txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txbuftrigger << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x02000000)) | ((u32)ac1txbuftrigger << 25));
}

static inline void mac_hw_tx_int_event_clear_ac_0_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac0txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txbuftrigger << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x01000000)) | ((u32)ac0txbuftrigger << 24));
}

static inline void mac_hw_tx_int_event_clear_txm_tx_trigger_setf(struct cl_chip *chip, u8 txmtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)txmtxtrigger << 13) & ~((u32)0x00002000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00002000)) | ((u32)txmtxtrigger << 13));
}

static inline void mac_hw_tx_int_event_clear_htp_tx_trigger_setf(struct cl_chip *chip, u8 htptxtrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxtrigger << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00001000)) | ((u32)htptxtrigger << 12));
}

static inline void mac_hw_tx_int_event_clear_hcca_tx_trigger_setf(struct cl_chip *chip, u8 hccatxtrigger)
{
	ASSERT_ERR_CHIP((((u32)hccatxtrigger << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000800)) | ((u32)hccatxtrigger << 11));
}

static inline void mac_hw_tx_int_event_clear_bcn_tx_trigger_setf(struct cl_chip *chip, u8 bcntxtrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxtrigger << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000400)) | ((u32)bcntxtrigger << 10));
}

static inline void mac_hw_tx_int_event_clear_ac_3_tx_trigger_setf(struct cl_chip *chip, u8 ac3txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txtrigger << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000200)) | ((u32)ac3txtrigger << 9));
}

static inline void mac_hw_tx_int_event_clear_ac_2_tx_trigger_setf(struct cl_chip *chip, u8 ac2txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txtrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000100)) | ((u32)ac2txtrigger << 8));
}

static inline void mac_hw_tx_int_event_clear_ac_1_tx_trigger_setf(struct cl_chip *chip, u8 ac1txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txtrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000080)) | ((u32)ac1txtrigger << 7));
}

static inline void mac_hw_tx_int_event_clear_ac_0_tx_trigger_setf(struct cl_chip *chip, u8 ac0txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txtrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000040)) | ((u32)ac0txtrigger << 6));
}

static inline void mac_hw_tx_int_event_clear_txop_complete_setf(struct cl_chip *chip, u8 txopcomplete)
{
	ASSERT_ERR_CHIP((((u32)txopcomplete << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000020)) | ((u32)txopcomplete << 5));
}

static inline void mac_hw_tx_int_event_clear_rd_tx_trigger_setf(struct cl_chip *chip, u8 rdtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rdtxtrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000010)) | ((u32)rdtxtrigger << 4));
}

static inline void mac_hw_tx_int_event_clear_tx_abort_setf(struct cl_chip *chip, u8 txabort)
{
	ASSERT_ERR_CHIP((((u32)txabort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_CLEAR_ADDR) & ~((u32)0x00000008)) | ((u32)txabort << 3));
}

/**
 * @brief TX_INT_EVENT_EN_LMAC register definition
 *  Tx interrupts enable LMAC register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00008758)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_OFFSET      0x00008758
#define MAC_HW_TX_INT_EVENT_EN_LMAC_INDEX       0x000021D6
#define MAC_HW_TX_INT_EVENT_EN_LMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_en_lmac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);
}

static inline void mac_hw_tx_int_event_en_lmac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_EN_LMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_LMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_en_lmac_pack(struct cl_chip *chip, u8 htp_tx_buf_trigger, u8 bcn_tx_buf_trigger, u8 ac_3_tx_buf_trigger, u8 ac_2_tx_buf_trigger, u8 ac_1_tx_buf_trigger, u8 ac_0_tx_buf_trigger, u8 htp_tx_trigger, u8 hcca_tx_trigger, u8 bcn_tx_trigger, u8 ac_3_tx_trigger, u8 ac_2_tx_trigger, u8 ac_1_tx_trigger, u8 ac_0_tx_trigger, u8 txop_complete, u8 rd_tx_trigger, u8 tx_abort)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_buf_trigger << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_buf_trigger << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_buf_trigger << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_buf_trigger << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_buf_trigger << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_buf_trigger << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_trigger << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_tx_trigger << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_trigger << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_trigger << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_trigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_trigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_trigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_complete << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_tx_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_abort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, ((u32)htp_tx_buf_trigger << 29) | ((u32)bcn_tx_buf_trigger << 28) | ((u32)ac_3_tx_buf_trigger << 27) | ((u32)ac_2_tx_buf_trigger << 26) | ((u32)ac_1_tx_buf_trigger << 25) | ((u32)ac_0_tx_buf_trigger << 24) | ((u32)htp_tx_trigger << 12) | ((u32)hcca_tx_trigger << 11) | ((u32)bcn_tx_trigger << 10) | ((u32)ac_3_tx_trigger << 9) | ((u32)ac_2_tx_trigger << 8) | ((u32)ac_1_tx_trigger << 7) | ((u32)ac_0_tx_trigger << 6) | ((u32)txop_complete << 5) | ((u32)rd_tx_trigger << 4) | ((u32)tx_abort << 3));
}

static inline void mac_hw_tx_int_event_en_lmac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_en_lmac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_tx_int_event_en_lmac_htp_tx_buf_trigger_setf(struct cl_chip *chip, u8 htptxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxbuftrigger << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x20000000)) | ((u32)htptxbuftrigger << 29));
}

static inline u8 mac_hw_tx_int_event_en_lmac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_tx_int_event_en_lmac_bcn_tx_buf_trigger_setf(struct cl_chip *chip, u8 bcntxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxbuftrigger << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x10000000)) | ((u32)bcntxbuftrigger << 28));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_3_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac3txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txbuftrigger << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x08000000)) | ((u32)ac3txbuftrigger << 27));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_2_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac2txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txbuftrigger << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x04000000)) | ((u32)ac2txbuftrigger << 26));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_1_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac1txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txbuftrigger << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x02000000)) | ((u32)ac1txbuftrigger << 25));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_0_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac0txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txbuftrigger << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x01000000)) | ((u32)ac0txbuftrigger << 24));
}

static inline u8 mac_hw_tx_int_event_en_lmac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_tx_int_event_en_lmac_htp_tx_trigger_setf(struct cl_chip *chip, u8 htptxtrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxtrigger << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00001000)) | ((u32)htptxtrigger << 12));
}

static inline u8 mac_hw_tx_int_event_en_lmac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_tx_int_event_en_lmac_hcca_tx_trigger_setf(struct cl_chip *chip, u8 hccatxtrigger)
{
	ASSERT_ERR_CHIP((((u32)hccatxtrigger << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000800)) | ((u32)hccatxtrigger << 11));
}

static inline u8 mac_hw_tx_int_event_en_lmac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_tx_int_event_en_lmac_bcn_tx_trigger_setf(struct cl_chip *chip, u8 bcntxtrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxtrigger << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000400)) | ((u32)bcntxtrigger << 10));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_3_tx_trigger_setf(struct cl_chip *chip, u8 ac3txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txtrigger << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000200)) | ((u32)ac3txtrigger << 9));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_2_tx_trigger_setf(struct cl_chip *chip, u8 ac2txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txtrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000100)) | ((u32)ac2txtrigger << 8));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_1_tx_trigger_setf(struct cl_chip *chip, u8 ac1txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txtrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000080)) | ((u32)ac1txtrigger << 7));
}

static inline u8 mac_hw_tx_int_event_en_lmac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_tx_int_event_en_lmac_ac_0_tx_trigger_setf(struct cl_chip *chip, u8 ac0txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txtrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000040)) | ((u32)ac0txtrigger << 6));
}

static inline u8 mac_hw_tx_int_event_en_lmac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_tx_int_event_en_lmac_txop_complete_setf(struct cl_chip *chip, u8 txopcomplete)
{
	ASSERT_ERR_CHIP((((u32)txopcomplete << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000020)) | ((u32)txopcomplete << 5));
}

static inline u8 mac_hw_tx_int_event_en_lmac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_tx_int_event_en_lmac_rd_tx_trigger_setf(struct cl_chip *chip, u8 rdtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rdtxtrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rdtxtrigger << 4));
}

static inline u8 mac_hw_tx_int_event_en_lmac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_tx_int_event_en_lmac_tx_abort_setf(struct cl_chip *chip, u8 txabort)
{
	ASSERT_ERR_CHIP((((u32)txabort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_LMAC_ADDR) & ~((u32)0x00000008)) | ((u32)txabort << 3));
}

/**
 * @brief TX_INT_EVENT_EN_UMAC register definition
 *  Tx interrupts enable UMAC register. register description
 * <pre>
 *   Bits           Field Name   Reset Value
 *  -----   ------------------   -----------
 *    29    HTP_TX_BUF_TRIGGER        0
 *    28    BCN_TX_BUF_TRIGGER        0
 *    27    AC_3_TX_BUF_TRIGGER       0
 *    26    AC_2_TX_BUF_TRIGGER       0
 *    25    AC_1_TX_BUF_TRIGGER       0
 *    24    AC_0_TX_BUF_TRIGGER       0
 *    12    HTP_TX_TRIGGER            0
 *    11    HCCA_TX_TRIGGER           0
 *    10    BCN_TX_TRIGGER            0
 *    09    AC_3_TX_TRIGGER           0
 *    08    AC_2_TX_TRIGGER           0
 *    07    AC_1_TX_TRIGGER           0
 *    06    AC_0_TX_TRIGGER           0
 *    05    TXOP_COMPLETE             0
 *    04    RD_TX_TRIGGER             0
 *    03    TX_ABORT                  0
 * </pre>
 */
#define MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR        (REG_MAC_HW_BASE_ADDR + 0x0000875C)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_OFFSET      0x0000875C
#define MAC_HW_TX_INT_EVENT_EN_UMAC_INDEX       0x000021D7
#define MAC_HW_TX_INT_EVENT_EN_UMAC_RESET       0x00000000

static inline u32 mac_hw_tx_int_event_en_umac_get(struct cl_chip *chip)
{
	return cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);
}

static inline void mac_hw_tx_int_event_en_umac_set(struct cl_chip *chip, u32 value)
{
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, value);
}

/* Field definitions */
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_BUF_TRIGGER_BIT    ((u32)0x20000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_BUF_TRIGGER_POS    29
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_BUF_TRIGGER_BIT    ((u32)0x10000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_BUF_TRIGGER_POS    28
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_BUF_TRIGGER_BIT    ((u32)0x08000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_BUF_TRIGGER_POS    27
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_BUF_TRIGGER_BIT    ((u32)0x04000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_BUF_TRIGGER_POS    26
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_BUF_TRIGGER_BIT    ((u32)0x02000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_BUF_TRIGGER_POS    25
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_BUF_TRIGGER_BIT    ((u32)0x01000000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_BUF_TRIGGER_POS    24
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_TRIGGER_BIT    ((u32)0x00001000)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_TRIGGER_POS    12
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HCCA_TX_TRIGGER_BIT    ((u32)0x00000800)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HCCA_TX_TRIGGER_POS    11
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_TRIGGER_BIT    ((u32)0x00000400)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_TRIGGER_POS    10
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_TRIGGER_BIT    ((u32)0x00000200)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_TRIGGER_POS    9
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_TRIGGER_BIT    ((u32)0x00000100)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_TRIGGER_POS    8
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_TRIGGER_BIT    ((u32)0x00000080)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_TRIGGER_POS    7
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_TRIGGER_BIT    ((u32)0x00000040)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_TRIGGER_POS    6
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TXOP_COMPLETE_BIT    ((u32)0x00000020)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TXOP_COMPLETE_POS    5
#define MAC_HW_TX_INT_EVENT_EN_UMAC_RD_TX_TRIGGER_BIT    ((u32)0x00000010)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_RD_TX_TRIGGER_POS    4
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TX_ABORT_BIT    ((u32)0x00000008)
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TX_ABORT_POS    3

#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_BUF_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HTP_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_HCCA_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_BCN_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_3_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_2_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_1_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_AC_0_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TXOP_COMPLETE_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_RD_TX_TRIGGER_RST    0x0
#define MAC_HW_TX_INT_EVENT_EN_UMAC_TX_ABORT_RST    0x0

static inline void mac_hw_tx_int_event_en_umac_pack(struct cl_chip *chip, u8 htp_tx_buf_trigger, u8 bcn_tx_buf_trigger, u8 ac_3_tx_buf_trigger, u8 ac_2_tx_buf_trigger, u8 ac_1_tx_buf_trigger, u8 ac_0_tx_buf_trigger, u8 htp_tx_trigger, u8 hcca_tx_trigger, u8 bcn_tx_trigger, u8 ac_3_tx_trigger, u8 ac_2_tx_trigger, u8 ac_1_tx_trigger, u8 ac_0_tx_trigger, u8 txop_complete, u8 rd_tx_trigger, u8 tx_abort)
{
	ASSERT_ERR_CHIP((((u32)htp_tx_buf_trigger << 29) & ~((u32)0x20000000)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_buf_trigger << 28) & ~((u32)0x10000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_buf_trigger << 27) & ~((u32)0x08000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_buf_trigger << 26) & ~((u32)0x04000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_buf_trigger << 25) & ~((u32)0x02000000)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_buf_trigger << 24) & ~((u32)0x01000000)) == 0);
	ASSERT_ERR_CHIP((((u32)htp_tx_trigger << 12) & ~((u32)0x00001000)) == 0);
	ASSERT_ERR_CHIP((((u32)hcca_tx_trigger << 11) & ~((u32)0x00000800)) == 0);
	ASSERT_ERR_CHIP((((u32)bcn_tx_trigger << 10) & ~((u32)0x00000400)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_3_tx_trigger << 9) & ~((u32)0x00000200)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_2_tx_trigger << 8) & ~((u32)0x00000100)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_1_tx_trigger << 7) & ~((u32)0x00000080)) == 0);
	ASSERT_ERR_CHIP((((u32)ac_0_tx_trigger << 6) & ~((u32)0x00000040)) == 0);
	ASSERT_ERR_CHIP((((u32)txop_complete << 5) & ~((u32)0x00000020)) == 0);
	ASSERT_ERR_CHIP((((u32)rd_tx_trigger << 4) & ~((u32)0x00000010)) == 0);
	ASSERT_ERR_CHIP((((u32)tx_abort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, ((u32)htp_tx_buf_trigger << 29) | ((u32)bcn_tx_buf_trigger << 28) | ((u32)ac_3_tx_buf_trigger << 27) | ((u32)ac_2_tx_buf_trigger << 26) | ((u32)ac_1_tx_buf_trigger << 25) | ((u32)ac_0_tx_buf_trigger << 24) | ((u32)htp_tx_trigger << 12) | ((u32)hcca_tx_trigger << 11) | ((u32)bcn_tx_trigger << 10) | ((u32)ac_3_tx_trigger << 9) | ((u32)ac_2_tx_trigger << 8) | ((u32)ac_1_tx_trigger << 7) | ((u32)ac_0_tx_trigger << 6) | ((u32)txop_complete << 5) | ((u32)rd_tx_trigger << 4) | ((u32)tx_abort << 3));
}

static inline void mac_hw_tx_int_event_en_umac_unpack(struct cl_chip *chip, u8 *htp_tx_buf_trigger, u8 *bcn_tx_buf_trigger, u8 *ac_3_tx_buf_trigger, u8 *ac_2_tx_buf_trigger, u8 *ac_1_tx_buf_trigger, u8 *ac_0_tx_buf_trigger, u8 *htp_tx_trigger, u8 *hcca_tx_trigger, u8 *bcn_tx_trigger, u8 *ac_3_tx_trigger, u8 *ac_2_tx_trigger, u8 *ac_1_tx_trigger, u8 *ac_0_tx_trigger, u8 *txop_complete, u8 *rd_tx_trigger, u8 *tx_abort)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	*htp_tx_buf_trigger = (local_val & ((u32)0x20000000)) >> 29;
	*bcn_tx_buf_trigger = (local_val & ((u32)0x10000000)) >> 28;
	*ac_3_tx_buf_trigger = (local_val & ((u32)0x08000000)) >> 27;
	*ac_2_tx_buf_trigger = (local_val & ((u32)0x04000000)) >> 26;
	*ac_1_tx_buf_trigger = (local_val & ((u32)0x02000000)) >> 25;
	*ac_0_tx_buf_trigger = (local_val & ((u32)0x01000000)) >> 24;
	*htp_tx_trigger = (local_val & ((u32)0x00001000)) >> 12;
	*hcca_tx_trigger = (local_val & ((u32)0x00000800)) >> 11;
	*bcn_tx_trigger = (local_val & ((u32)0x00000400)) >> 10;
	*ac_3_tx_trigger = (local_val & ((u32)0x00000200)) >> 9;
	*ac_2_tx_trigger = (local_val & ((u32)0x00000100)) >> 8;
	*ac_1_tx_trigger = (local_val & ((u32)0x00000080)) >> 7;
	*ac_0_tx_trigger = (local_val & ((u32)0x00000040)) >> 6;
	*txop_complete = (local_val & ((u32)0x00000020)) >> 5;
	*rd_tx_trigger = (local_val & ((u32)0x00000010)) >> 4;
	*tx_abort = (local_val & ((u32)0x00000008)) >> 3;
}

static inline u8 mac_hw_tx_int_event_en_umac_htp_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x20000000)) >> 29);
}

static inline void mac_hw_tx_int_event_en_umac_htp_tx_buf_trigger_setf(struct cl_chip *chip, u8 htptxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxbuftrigger << 29) & ~((u32)0x20000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x20000000)) | ((u32)htptxbuftrigger << 29));
}

static inline u8 mac_hw_tx_int_event_en_umac_bcn_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x10000000)) >> 28);
}

static inline void mac_hw_tx_int_event_en_umac_bcn_tx_buf_trigger_setf(struct cl_chip *chip, u8 bcntxbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxbuftrigger << 28) & ~((u32)0x10000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x10000000)) | ((u32)bcntxbuftrigger << 28));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_3_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x08000000)) >> 27);
}

static inline void mac_hw_tx_int_event_en_umac_ac_3_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac3txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txbuftrigger << 27) & ~((u32)0x08000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x08000000)) | ((u32)ac3txbuftrigger << 27));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_2_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x04000000)) >> 26);
}

static inline void mac_hw_tx_int_event_en_umac_ac_2_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac2txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txbuftrigger << 26) & ~((u32)0x04000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x04000000)) | ((u32)ac2txbuftrigger << 26));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_1_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x02000000)) >> 25);
}

static inline void mac_hw_tx_int_event_en_umac_ac_1_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac1txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txbuftrigger << 25) & ~((u32)0x02000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x02000000)) | ((u32)ac1txbuftrigger << 25));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_0_tx_buf_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x01000000)) >> 24);
}

static inline void mac_hw_tx_int_event_en_umac_ac_0_tx_buf_trigger_setf(struct cl_chip *chip, u8 ac0txbuftrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txbuftrigger << 24) & ~((u32)0x01000000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x01000000)) | ((u32)ac0txbuftrigger << 24));
}

static inline u8 mac_hw_tx_int_event_en_umac_htp_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00001000)) >> 12);
}

static inline void mac_hw_tx_int_event_en_umac_htp_tx_trigger_setf(struct cl_chip *chip, u8 htptxtrigger)
{
	ASSERT_ERR_CHIP((((u32)htptxtrigger << 12) & ~((u32)0x00001000)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00001000)) | ((u32)htptxtrigger << 12));
}

static inline u8 mac_hw_tx_int_event_en_umac_hcca_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000800)) >> 11);
}

static inline void mac_hw_tx_int_event_en_umac_hcca_tx_trigger_setf(struct cl_chip *chip, u8 hccatxtrigger)
{
	ASSERT_ERR_CHIP((((u32)hccatxtrigger << 11) & ~((u32)0x00000800)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000800)) | ((u32)hccatxtrigger << 11));
}

static inline u8 mac_hw_tx_int_event_en_umac_bcn_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000400)) >> 10);
}

static inline void mac_hw_tx_int_event_en_umac_bcn_tx_trigger_setf(struct cl_chip *chip, u8 bcntxtrigger)
{
	ASSERT_ERR_CHIP((((u32)bcntxtrigger << 10) & ~((u32)0x00000400)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000400)) | ((u32)bcntxtrigger << 10));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_3_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000200)) >> 9);
}

static inline void mac_hw_tx_int_event_en_umac_ac_3_tx_trigger_setf(struct cl_chip *chip, u8 ac3txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac3txtrigger << 9) & ~((u32)0x00000200)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000200)) | ((u32)ac3txtrigger << 9));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_2_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000100)) >> 8);
}

static inline void mac_hw_tx_int_event_en_umac_ac_2_tx_trigger_setf(struct cl_chip *chip, u8 ac2txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac2txtrigger << 8) & ~((u32)0x00000100)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000100)) | ((u32)ac2txtrigger << 8));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_1_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000080)) >> 7);
}

static inline void mac_hw_tx_int_event_en_umac_ac_1_tx_trigger_setf(struct cl_chip *chip, u8 ac1txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac1txtrigger << 7) & ~((u32)0x00000080)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000080)) | ((u32)ac1txtrigger << 7));
}

static inline u8 mac_hw_tx_int_event_en_umac_ac_0_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000040)) >> 6);
}

static inline void mac_hw_tx_int_event_en_umac_ac_0_tx_trigger_setf(struct cl_chip *chip, u8 ac0txtrigger)
{
	ASSERT_ERR_CHIP((((u32)ac0txtrigger << 6) & ~((u32)0x00000040)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000040)) | ((u32)ac0txtrigger << 6));
}

static inline u8 mac_hw_tx_int_event_en_umac_txop_complete_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000020)) >> 5);
}

static inline void mac_hw_tx_int_event_en_umac_txop_complete_setf(struct cl_chip *chip, u8 txopcomplete)
{
	ASSERT_ERR_CHIP((((u32)txopcomplete << 5) & ~((u32)0x00000020)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000020)) | ((u32)txopcomplete << 5));
}

static inline u8 mac_hw_tx_int_event_en_umac_rd_tx_trigger_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000010)) >> 4);
}

static inline void mac_hw_tx_int_event_en_umac_rd_tx_trigger_setf(struct cl_chip *chip, u8 rdtxtrigger)
{
	ASSERT_ERR_CHIP((((u32)rdtxtrigger << 4) & ~((u32)0x00000010)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000010)) | ((u32)rdtxtrigger << 4));
}

static inline u8 mac_hw_tx_int_event_en_umac_tx_abort_getf(struct cl_chip *chip)
{
	u32 local_val = cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR);

	return (u8)((local_val & ((u32)0x00000008)) >> 3);
}

static inline void mac_hw_tx_int_event_en_umac_tx_abort_setf(struct cl_chip *chip, u8 txabort)
{
	ASSERT_ERR_CHIP((((u32)txabort << 3) & ~((u32)0x00000008)) == 0);
	cl_reg_write(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR, (cl_reg_read(chip, MAC_HW_TX_INT_EVENT_EN_UMAC_ADDR) & ~((u32)0x00000008)) | ((u32)txabort << 3));
}

/**
 * @brief MIB_TABLE register definition
 *  MIB table register description
 *  1024 memory size
 * </pre>
 */
#define MAC_HW_MIB_TABLE_ADDR        (REG_MAC_HW_BASE_ADDR + 0x00000800)
#define MAC_HW_MIB_TABLE_OFFSET      0x00000800
#define MAC_HW_MIB_TABLE_SIZE        0x00000400
#define MAC_HW_MIB_TABLE_END_ADDR    (MAC_HW_MIB_TABLE_ADDR  +  MAC_HW_MIB_TABLE_SIZE - 1)

#endif /* REG_MAC_HW_H_ */
